<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Momentonly</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-06-09T15:26:15.188Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Moment Only</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Spring3.1的缓存机制</title>
    <link href="http://yoursite.com/2020/06/10/Spring/Spring3.1%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/06/10/Spring/Spring3.1%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</id>
    <published>2020-06-10T13:20:59.000Z</published>
    <updated>2020-06-09T15:26:15.188Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring3-1的缓存机制"><a href="#Spring3-1的缓存机制" class="headerlink" title="Spring3.1的缓存机制"></a>Spring3.1的缓存机制</h1><h2 id="一"><a href="#一" class="headerlink" title="一"></a>一</h2><p>　 Spring 3.1 新增了一种全新的缓存机制，这种缓存机制与Spring容器无缝地整合在一起，可以对容器中的任意Bean或Bean的方法增加缓存。Spring的缓存机制非常灵活，它可以对容器中的任意Bean或的Bean的任意方法进行缓存，因此这种缓存机制可以在Java EE应用的任何层次上进行缓存。</p><p>提示 ： 与Hibernate SessionFactory级别的二级缓存相比，Spring 缓存的级别更高，SPring缓存可以在控制组件或业务逻辑组件级别进行缓存，这样应用完全无须重复调用底层的DAO组件的方法。</p><p>　　Spring 缓存同样不是一种具体的缓存实现方案，它底层同样需要依赖EhCache、Guava等具体的缓存实现。但这也正是Spring缓存机制的优势，应用程序只要面向Spring缓存API编程，应用底层的缓存实现可以在不同的缓存实现之间自由切换，应用程序无须任何改变，只要对配置文件略作修改即可。</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>Spring从3.1开始定义了org.springframework.cache.Cache和org.springframework.cache.CacheManager接口来统一不同的缓存技术；并支持使用JCache（JSR-107）注解简化我们开发；</p><ul><li><p>Cache接口为缓存的组件规范定义，包含缓存的各种操作集合；</p></li><li><p>Cache接口下Spring提供了各种xxxCache的实现；如RedisCache，EhCacheCache ,ConcurrentMapCache等；</p></li><li><p>每次调用需要缓存功能的方法时，Spring会检查检查指定参数的指定的目标方法是否已经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取。</p></li><li><p>使用Spring缓存抽象时我们需要关注以下两点；</p><p>1、确定方法需要被缓存以及他们的缓存策略</p><p>2、从缓存中读取之前缓存存储的数据</p><h2 id="：几个重要概念-amp-缓存注解"><a href="#：几个重要概念-amp-缓存注解" class="headerlink" title="：几个重要概念&amp;缓存注解"></a>：几个重要概念&amp;缓存注解</h2><p>| 名称           | 解释                                                         |<br>| ————– | ———————————————————— |<br>| Cache          | 缓存接口，定义缓存操作。实现有：RedisCache、EhCacheCache、ConcurrentMapCache等 |<br>| CacheManager   | 缓存管理器，管理各种缓存（cache）组件                        |<br>| @Cacheable     | 主要针对方法配置，能够根据方法的请求参数对其进行缓存         |<br>| @CacheEvict    | 清空缓存                                                     |<br>| @CachePut      | 保证方法被调用，又希望结果被缓存。 与@Cacheable区别在于是否每次都调用方法，常用于更新 |<br>| @EnableCaching | 开启基于注解的缓存                                           |<br>| keyGenerator   | 缓存数据时key生成策略                                        |<br>| serialize      | 缓存数据时value序列化策略                                    |<br>| @CacheConfig   | 统一配置本类的缓存注解的属性                                 |</p><p><strong>@Cacheable/@CachePut/@CacheEvict 主要的参数</strong></p><p>| 名称                           | 解释                                                         |<br>| —————————— | ———————————————————— |<br>| value                          | 缓存的名称，在 spring 配置文件中定义，必须指定至少一个 例如： @Cacheable(value=”mycache”) 或者 @Cacheable(value={”cache1”,”cache2”} |<br>| key                            | 缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写， 如果不指定，则缺省按照方法的所有参数进行组合 例如： @Cacheable(value=”testcache”,key=”#id”) |<br>| condition                      | 缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false， 只有为 true 才进行缓存/清除缓存 例如：@Cacheable(value=”testcache”,condition=”#userName.length()&gt;2”) |<br>| unless                         | 否定缓存。当条件结果为TRUE时，就不会缓存。 @Cacheable(value=”testcache”,unless=”#userName.length()&gt;2”) |<br>| allEntries (@CacheEvict )      | 是否清空所有缓存内容，缺省为 false，如果指定为 true， 则方法调用后将立即清空所有缓存 例如： @CachEvict(value=”testcache”,allEntries=true) |<br>| beforeInvocation (@CacheEvict) | 是否在方法执行前就清空，缺省为 false，如果指定为 true， 则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法 执行抛出异常，则不会清空缓存 例如： @CachEvict(value=”testcache”，beforeInvocation=true) |</p><h2 id="三：SpEL上下文数据"><a href="#三：SpEL上下文数据" class="headerlink" title="三：SpEL上下文数据"></a>三：SpEL上下文数据</h2><p>Spring Cache提供了一些供我们使用的SpEL上下文数据，下表直接摘自Spring官方文档：</p><p>| 名称          | 位置       | 描述                                                         | 示例                   |<br>| ————- | ———- | ———————————————————— | ———————- |<br>| methodName    | root对象   | 当前被调用的方法名                                           | <code>#root.methodname</code>     |<br>| method        | root对象   | 当前被调用的方法                                             | <code>#root.method.name</code>    |<br>| target        | root对象   | 当前被调用的目标对象实例                                     | <code>#root.target</code>         |<br>| targetClass   | root对象   | 当前被调用的目标对象的类                                     | <code>#root.targetClass</code>    |<br>| args          | root对象   | 当前被调用的方法的参数列表                                   | <code>#root.args[0]</code>        |<br>| caches        | root对象   | 当前方法调用使用的缓存列表                                   | <code>#root.caches[0].name</code> |<br>| Argument Name | 执行上下文 | 当前被调用的方法的参数，如findArtisan(Artisan artisan),可以通过#artsian.id获得参数 | <code>#artsian.id</code>          |<br>| result        | 执行上下文 | 方法执行后的返回值（仅当方法执行后的判断有效，如 unless cacheEvict的beforeInvocation=false） | <code>#result</code>              |</p><p><strong>注意：</strong></p><p>1.当我们要使用root对象的属性作为key时我们也可以将“#root”省略，因为Spring默认使用的就是root对象的属性。 如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@Cacheable(key = &quot;targetClass + methodName +#p0&quot;)</span><br></pre></td></tr></table></figure><p>2.使用方法参数时我们可以直接使用“#参数名”或者“#p参数index”。 如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Cacheable(value=&quot;users&quot;, key=&quot;#id&quot;)</span><br><span class="line">@Cacheable(value=&quot;users&quot;, key=&quot;#p0&quot;)</span><br></pre></td></tr></table></figure><p><strong>SpEL提供了多种运算符</strong></p><p>| <strong>类型</strong>   | <strong>运算符</strong>                                     |<br>| ———- | ———————————————- |<br>| 关系       | &lt;，&gt;，&lt;=，&gt;=，==，!=，lt，gt，le，ge，eq，ne   |<br>| 算术       | +，- ，* ，/，%，^                             |<br>| 逻辑       | &amp;&amp;，||，!，and，or，not，between，instanceof |<br>| 条件       | ?: (ternary)，?: (elvis)                       |<br>| 正则表达式 | matches                                        |<br>| 其他类型   | ?.，?[…]，![…]，^[…]，$[…]                     |</p></li></ul><p>参考：<a href="https://www.cnblogs.com/xiang--liu/p/9720344.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiang--liu/p/9720344.html</a></p><h1 id="Springboot自动配置缓存"><a href="#Springboot自动配置缓存" class="headerlink" title="Springboot自动配置缓存"></a>Springboot自动配置缓存</h1><p>详细原理：</p><p>1）、查看自动配置类：CacheAutoConfiguration</p><p>2）、断点跟踪可知默认配置了：</p><ul><li>org.springframework.boot.autoconfigure.cache.GenericCacheConfiguration</li><li>org.springframework.boot.autoconfigure.cache.JCacheCacheConfiguration</li><li>org.springframework.boot.autoconfigure.cache.EhCacheCacheConfiguration</li><li>org.springframework.boot.autoconfigure.cache.HazelcastCacheConfiguration</li><li>org.springframework.boot.autoconfigure.cache.InfinispanCacheConfiguration</li><li>org.springframework.boot.autoconfigure.cache.CouchbaseCacheConfiguration</li><li>org.springframework.boot.autoconfigure.cache.RedisCacheConfiguration</li><li>org.springframework.boot.autoconfigure.cache.CaffeineCacheConfiguration</li><li>org.springframework.boot.autoconfigure.cache.GuavaCacheConfiguration</li><li>org.springframework.boot.autoconfigure.cache.SimpleCacheConfiguration【默认】</li><li><p>org.springframework.boot.autoconfigure.cache.NoOpCacheConfiguration</p><p>默认SimpleCacheConfiguration生效</p></li></ul><p>3）、给容器中注册了一个CacheManager：ConcurrentMapCacheManager；</p><p>4）、获取和创建ConcurrentMapCache类型的缓存组件，他的作用将数据保存在ConcurrentMap中；</p><p>5）、 运行流程：</p><p>​        方法运行之前，先去查询Cache（缓存组件），按照cacheNames指定的名字获取，（CacheManager先获取相应的缓存），第一次获取缓存如果没有Cache组件会自动创建；</p><p>​       去Cache中查找缓存的内容，使用一个key，默认就是方法的参数，key是按照某种策略生成的，默认是使用keyGenerator生成的，默认使用SimpleKeyGenerator生成key，SimpleKeyGenerator生成key的默认策略：如果没有参数：key=new SimpleKey()；如果有一个参数：key=参数的值；如果有多个参数：key=new SimpleKey(params)；<br>​       没有查到缓存就调用目标方法，将目标方法返回的结果，放进缓存中，@Cacheable标注的方法执行之前先来检查缓存中有没有这个数据，默认按照参数的值作为key去查询缓存，如果没有就运行方法并将结果放入缓存，以后再来调用就可以直接使用缓存中的数据。</p><p>原文链接：<a href="https://blog.csdn.net/xm393392625/article/details/88625681" target="_blank" rel="noopener">https://blog.csdn.net/xm393392625/article/details/88625681</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring3-1的缓存机制&quot;&gt;&lt;a href=&quot;#Spring3-1的缓存机制&quot; class=&quot;headerlink&quot; title=&quot;Spring3.1的缓存机制&quot;&gt;&lt;/a&gt;Spring3.1的缓存机制&lt;/h1&gt;&lt;h2 id=&quot;一&quot;&gt;&lt;a href=&quot;#一&quot; c
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring4的泛型注入</title>
    <link href="http://yoursite.com/2020/06/09/Spring/Spring4%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%B3%A8%E5%85%A5/"/>
    <id>http://yoursite.com/2020/06/09/Spring/Spring4%E7%9A%84%E6%B3%9B%E5%9E%8B%E6%B3%A8%E5%85%A5/</id>
    <published>2020-06-09T12:50:59.000Z</published>
    <updated>2020-06-08T16:34:34.162Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring4的泛型注入测试"><a href="#spring4的泛型注入测试" class="headerlink" title="spring4的泛型注入测试"></a>spring4的泛型注入测试</h1><h2 id="1-创建两个实体User和Role"><a href="#1-创建两个实体User和Role" class="headerlink" title="1 创建两个实体User和Role"></a>1 创建两个实体User和Role</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">public class Role &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-baseDao抽取泛型基础curd"><a href="#2-baseDao抽取泛型基础curd" class="headerlink" title="2 baseDao抽取泛型基础curd"></a>2 baseDao抽取泛型基础curd</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class BaseDao&lt;T&gt; &#123;</span><br><span class="line">    public void save(T entity)&#123;</span><br><span class="line">        System.out.println(&quot;Save:&quot; + entity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-两个实现类UserDao-和-RoleDao"><a href="#3-两个实现类UserDao-和-RoleDao" class="headerlink" title="3 两个实现类UserDao 和 RoleDao"></a>3 两个实现类UserDao 和 RoleDao</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Repository</span><br><span class="line">public class RoleDao extends BaseDao&lt;Role&gt;&#123;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">@Repository</span><br><span class="line">public class UserDao extends BaseDao&lt;User&gt;&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-baseService"><a href="#4-baseService" class="headerlink" title="4 baseService"></a>4 baseService</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BaseService&lt;T&gt; &#123;</span><br><span class="line">    @Autowired</span><br><span class="line">    private BaseDao&lt;T&gt; dao;//这里会自动根据实际类型传入User或Role</span><br><span class="line">    </span><br><span class="line">    public void addNew(T entity)&#123;</span><br><span class="line">        System.out.println(&quot;addNew by &quot; + dao);</span><br><span class="line">        dao.save(entity);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-UserService-和RoleService"><a href="#5-UserService-和RoleService" class="headerlink" title="5 UserService 和RoleService"></a>5 UserService 和RoleService</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Service</span><br><span class="line">public class RoleService extends BaseService&lt;Role&gt;&#123;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">//若注解没有指定 bean 的 id, 则类名第一个字母小写即为 bean 的 id</span><br><span class="line">@Service</span><br><span class="line">public class UserService extends BaseService&lt;User&gt;&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-测试类"><a href="#6-测试类" class="headerlink" title="6 测试类"></a>6 测试类</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    </span><br><span class="line">    ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;beans-annotation.xml&quot;);</span><br><span class="line">    </span><br><span class="line">    UserService userService = (UserService) ctx.getBean(&quot;userService&quot;);</span><br><span class="line">    userService.addNew(new User());</span><br><span class="line">    </span><br><span class="line">    RoleService roleService = (RoleService) ctx.getBean(&quot;roleService&quot;);</span><br><span class="line">    roleService.addNew(new Role()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.cnblogs.com/linhp/p/5881778.html" target="_blank" rel="noopener">https://www.cnblogs.com/linhp/p/5881778.html</a></p><h1 id="spring注入泛型原理"><a href="#spring注入泛型原理" class="headerlink" title="spring注入泛型原理"></a>spring注入泛型原理</h1><h2 id="问"><a href="#问" class="headerlink" title="问"></a>问</h2><p>spring4的泛型依赖注入是什么原理？</p><p>Dao</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class BaseDao&lt;T&gt; &#123;</span><br><span class="line"></span><br><span class="line">    public void add()&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Repository</span><br><span class="line">public class EmpDao extends BaseDao&lt;Employee&gt;&#123; &#125;</span><br></pre></td></tr></table></figure><p>Service</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class BaseService&lt;T&gt; &#123;</span><br><span class="line">@Autowired</span><br><span class="line">protected BaseDao&lt;T&gt; baseDao;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class EmpService extends BaseService&lt;Employee&gt;&#123;</span><br><span class="line">    public void add()&#123;</span><br><span class="line">System.out.println(baseDao)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;spring-config6.xml&quot;);</span><br><span class="line">EmpService empService = ctx.getBean(EmpService.class);</span><br><span class="line">empService.add();</span><br><span class="line">//输出 dao.impl.EmpDao@214b199c</span><br></pre></td></tr></table></figure><p>获取EmpService spring自动匹配到了 EmpDao</p><p>但是！如果再添加一个 泛型 类型为Employee的bean，问题就来了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">@Repository</span><br><span class="line"> public class EmpDao2 extends BaseDao&lt;Employee&gt;&#123; &#125;</span><br></pre></td></tr></table></figure><p>添加第二个BaseDao的子类 泛型也为 Employee，再次测试出了如下异常:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expected single matching bean but found 2: empDao,empDao2</span><br></pre></td></tr></table></figure><p>可以肯定的一点是，Spring 是通过 泛型参数 来匹配EmpDao 与 EmpService的。但是sping是如何动态获取泛型类型的？泛型为何没有被擦除？</p><h2 id="答"><a href="#答" class="headerlink" title="答"></a>答</h2><p>如果用Pom等机制，可以把依赖的源代码下载下来，然后可以直接在 spring 的库中设置断点，来调试 spring 代码，如果足够耐心，逐行执行一次，就可以初见端倪了。</p><p>代码编写完了，command ＋ o 找到 DefaultListableBeanFactory，他在 spring bean 这个包中</p><p>定位到 findAutowireCandidates，可以在这里卡一个断点，然后debug运行你的程序。该方法负责找到匹配的 bean 注入到 service中。其中有如下代码负责过滤掉最开始找到的 candidates</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (String candidate : candidateNames) &#123;</span><br><span class="line">   <span class="keyword">if</span> (!isSelfReference(beanName, candidate) &amp;&amp; isAutowireCandidate(candidate, descriptor)) &#123;</span><br><span class="line">      addCandidateEntry(result, candidate, descriptor, requiredType);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中函数 isAutowireCandidate 往里面找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAutowireCandidate</span><span class="params">(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">super</span>.isAutowireCandidate(bdHolder, descriptor)) &#123;</span><br><span class="line"><span class="comment">// If explicitly false, do not proceed with any other checks...</span></span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> checkGenericTypeMatch(bdHolder, descriptor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看到这里有范型检查相关的内容，再往深入找，会看到这段代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (checkGenerics) &#123;</span><br><span class="line"><span class="comment">// Recursively check each generic</span></span><br><span class="line">ResolvableType[] ourGenerics = getGenerics();</span><br><span class="line">ResolvableType[] typeGenerics = other.as(ourResolved).getGenerics();</span><br><span class="line"><span class="keyword">if</span> (ourGenerics.length != typeGenerics.length) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (matchedBefore == <span class="keyword">null</span>) &#123;</span><br><span class="line">matchedBefore = <span class="keyword">new</span> IdentityHashMap&lt;&gt;(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">matchedBefore.put(<span class="keyword">this</span>.type, other.type);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ourGenerics.length; i++) &#123;</span><br><span class="line"><span class="keyword">if</span> (!ourGenerics[i].isAssignableFrom(typeGenerics[i], matchedBefore)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以 spring 其实是利用反射机制，获取类型的范型的，然后做了比较返回了合适的 bean 进行注入的。</p><p>参考：<a href="https://www.zhihu.com/question/268195272" target="_blank" rel="noopener">https://www.zhihu.com/question/268195272</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;spring4的泛型注入测试&quot;&gt;&lt;a href=&quot;#spring4的泛型注入测试&quot; class=&quot;headerlink&quot; title=&quot;spring4的泛型注入测试&quot;&gt;&lt;/a&gt;spring4的泛型注入测试&lt;/h1&gt;&lt;h2 id=&quot;1-创建两个实体User和Role
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>服务熔断与服务降级</title>
    <link href="http://yoursite.com/2020/06/08/SpringCloud/%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%E4%B8%8E%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7/"/>
    <id>http://yoursite.com/2020/06/08/SpringCloud/%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%E4%B8%8E%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7/</id>
    <published>2020-06-08T09:14:59.000Z</published>
    <updated>2020-06-08T09:26:33.783Z</updated>
    
    <content type="html"><![CDATA[<h1 id="服务熔断与服务降级"><a href="#服务熔断与服务降级" class="headerlink" title="服务熔断与服务降级"></a>服务熔断与服务降级</h1><h2 id="服务降级"><a href="#服务降级" class="headerlink" title="服务降级"></a>服务降级</h2><p>​        当请求超时，资源不足等情况发生时进行服务降级处理，不调用真是服务逻辑，而是使用快速失败fallback方式直接调用本地的一个方法返回托底数据，保证服务链条的完整，避免服务雪崩。</p><h2 id="服务熔断"><a href="#服务熔断" class="headerlink" title="服务熔断"></a>服务熔断</h2><p>​        一定时间内，异常请求比例(请求超时，网络故障，服务异常等)达到阈值时，启动熔断器，熔断器一旦启动，则会停止调用具体服务逻辑，而是通过fallcack快速返回托底数据，保证服务链的完整。</p><h3 id="开启熔断"><a href="#开启熔断" class="headerlink" title="开启熔断"></a>开启熔断</h3><p>​            在固定时间窗口内，接口调用超时比率达到一个阈值，会开启熔断。进入熔断状态后，后续对该服务接口的调用不再经过网络，直接执行本地的默认方法，达到服务降级的效果。</p><h3 id="熔断回复"><a href="#熔断回复" class="headerlink" title="熔断回复"></a>熔断回复</h3><p>​        熔断不可能是永久的。当经过了规定时间之后，服务将从熔断状态回复过来，再次接受调用方的远程调用。</p><h2 id="SpringCloud-Hystrix"><a href="#SpringCloud-Hystrix" class="headerlink" title="SpringCloud Hystrix"></a>SpringCloud Hystrix</h2><p>Spring Cloud Hystrix是基于Netflix的开源框架Hystrix实现，该框架实现了服务熔断、线程隔离等一系列服务保护功能。</p><p>对于熔断机制的实现，Hystrix设计了三种状态：</p><h3 id="熔断关闭状态（Closed）"><a href="#熔断关闭状态（Closed）" class="headerlink" title="熔断关闭状态（Closed）"></a>熔断关闭状态（Closed）</h3><p>服务没有故障时，熔断器所处的状态，对调用方的调用不做任何限制。</p><h3 id="熔断开启状态（Open）"><a href="#熔断开启状态（Open）" class="headerlink" title="熔断开启状态（Open）"></a>熔断开启状态（Open）</h3><p>在固定时间窗口内（Hystrix默认是10秒），接口调用出错比率达到一个阈值（Hystrix默认为50%），会进入熔断开启状态。进入熔断状态后，后续对该服务接口的调用不再经过网络，直接执行本地的fallback方法。</p><h3 id="半熔断状态（Half-Open）"><a href="#半熔断状态（Half-Open）" class="headerlink" title="半熔断状态（Half-Open）"></a>半熔断状态（Half-Open）</h3><p>在进入熔断开启状态一段时间之后（Hystrix默认是5秒），熔断器会进入半熔断状态。所谓半熔断就是尝试恢复服务调用，允许有限的流量调用该服务，并监控调用成功率。如果成功率达到预期，则说明服务已恢复，进入熔断关闭状态；如果成功率仍旧很低，则重新进入熔断关闭状态。</p><p>三个状态的转化关系</p><p>​                                                                            close</p><p>​            调用成功率达标，进入close状态                               调用失败率达到阈值，进入open状态</p><p>​    half-open                                             熔断一段时间    &lt;—                                                  open</p><p>​                                                        —&gt;    调用成功率不达标             </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;服务熔断与服务降级&quot;&gt;&lt;a href=&quot;#服务熔断与服务降级&quot; class=&quot;headerlink&quot; title=&quot;服务熔断与服务降级&quot;&gt;&lt;/a&gt;服务熔断与服务降级&lt;/h1&gt;&lt;h2 id=&quot;服务降级&quot;&gt;&lt;a href=&quot;#服务降级&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="SpringCloud" scheme="http://yoursite.com/categories/SpringCloud/"/>
    
    
      <category term="SpringCloud" scheme="http://yoursite.com/tags/SpringCloud/"/>
    
  </entry>
  
  <entry>
    <title>spring中的BeanPostProcessor接口</title>
    <link href="http://yoursite.com/2020/06/01/Spring/spring%E4%B8%AD%E7%9A%84BeanPostProcessor%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2020/06/01/Spring/spring%E4%B8%AD%E7%9A%84BeanPostProcessor%E6%8E%A5%E5%8F%A3/</id>
    <published>2020-06-01T07:50:59.000Z</published>
    <updated>2020-06-02T07:09:02.625Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring-bean的装载过程简略赏析"><a href="#spring-bean的装载过程简略赏析" class="headerlink" title="spring bean的装载过程简略赏析"></a>spring bean的装载过程简略赏析</h1><p><a href="https://www.cnblogs.com/foreveravalon/p/7152021.html" target="_blank" rel="noopener">https://www.cnblogs.com/foreveravalon/p/7152021.html</a></p><h1 id="spring中的BeanPostProcessor接口"><a href="#spring中的BeanPostProcessor接口" class="headerlink" title="spring中的BeanPostProcessor接口"></a>spring中的BeanPostProcessor接口</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;spring-bean的装载过程简略赏析&quot;&gt;&lt;a href=&quot;#spring-bean的装载过程简略赏析&quot; class=&quot;headerlink&quot; title=&quot;spring bean的装载过程简略赏析&quot;&gt;&lt;/a&gt;spring bean的装载过程简略赏析&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring加载classpath与classpath*的过程</title>
    <link href="http://yoursite.com/2020/05/27/Spring/Spring%E5%8A%A0%E8%BD%BDclasspath%E4%B8%8Eclasspath%E6%98%9F%E7%9A%84%E8%BF%87%E7%A8%8B/"/>
    <id>http://yoursite.com/2020/05/27/Spring/Spring%E5%8A%A0%E8%BD%BDclasspath%E4%B8%8Eclasspath%E6%98%9F%E7%9A%84%E8%BF%87%E7%A8%8B/</id>
    <published>2020-05-27T05:45:59.000Z</published>
    <updated>2020-05-27T14:42:20.764Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring加载classpath与classpath-的过程"><a href="#Spring加载classpath与classpath-的过程" class="headerlink" title="Spring加载classpath与classpath*的过程"></a>Spring加载classpath与classpath*的过程</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">1.无论是classpath还是classpath*都可以加载整个classpath下（包括jar包里面）的资源文件。</span><br><span class="line">2.classpath只会返回第一个匹配的资源，查找路径是优先在项目中存在资源文件，再查找jar包。</span><br><span class="line">3.文件名字包含通配符资源(如果spring-.xml，spring.xml)， 如果根目录为&quot;&quot;， classpath加载不到任何资源</span><br><span class="line">而classpath*则可以加载到classpath中可以匹配的目录中的资源，但是不能加载到jar包中的资源</span><br><span class="line">  第1，2点比较好表理解，大家可以自行测试，第三点表述有点绕，举个例，现在有资源文件结构如下：</span><br><span class="line">src/main/resources</span><br><span class="line">META-INF</span><br><span class="line">aaa</span><br><span class="line">notice.txt</span><br><span class="line">notice.txt</span><br><span class="line">notice.txt</span><br><span class="line"></span><br><span class="line">classpath:notice*.txt     加载不到资源    </span><br><span class="line">classpath*:notice*.txt     加载到resource根目录下notice.txt                       </span><br><span class="line">classpath:META-INF/notice*.txt   加载到META-INF下的一个资源（classpath是加载到匹配的第一个资源，就算删除classpath下的notice.txt，他仍然可以加载jar包中的notice.txt）                 </span><br><span class="line">classpath:META-*/notice*.txt      加载不到任何资源                             </span><br><span class="line">classpath*:META-INF/notice*.txt   加载到classpath以及所有jar包中META-INF目录下以notice开头的txt文件                                     </span><br><span class="line">classpath*:META-*/notice*.txt      只能加载到classpath下 META-INF目录的notice.txt</span><br></pre></td></tr></table></figure><p>有一些错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">classpath:META-INF/notice*.txt        可能什么也加载不到</span><br><span class="line"></span><br><span class="line">classpath*:META-*/notice*.txt        加载到classpath以及所有jar包中META-INF目录下以notice开头的txt文件</span><br></pre></td></tr></table></figure><p>​                 </p><p>原文链接：<a href="https://blog.csdn.net/n447194252/article/details/76664053" target="_blank" rel="noopener">https://blog.csdn.net/n447194252/article/details/76664053</a></p><h1 id="关于classpath与classpath-的一些测试"><a href="#关于classpath与classpath-的一些测试" class="headerlink" title="关于classpath与classpath*的一些测试"></a>关于classpath与classpath*的一些测试</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">测试结果：</span><br><span class="line">1、classpath在使用时，第一级路径无法使用通配符，如classpath:general*.properties或者classpath:general*/general*.properties是无法获取到的</span><br><span class="line">2、在我将general.properties拆成两个文件后，classpath同样可以获取两个文件，读取到全部内容，不知道是不是我测的方法有问题，这方面没感觉出来说是只能获取到第一个文件的限制</span><br><span class="line">3、classpath比classpath*快，明确位置比通配符快。</span><br></pre></td></tr></table></figure><p>对于2的说明：</p><p>应该是相同类路径下的相同名称的资源只能获取第一个，这个测试4中general.properties一个放在general下，一个放在general1下，虽然名称相同，但是不是同一路径了</p><p>原文链接：<a href="https://blog.csdn.net/n447194252/article/details/76664053" target="_blank" rel="noopener">https://blog.csdn.net/n447194252/article/details/76664053</a></p><h1 id="对于classpath与classpath-的一些理解"><a href="#对于classpath与classpath-的一些理解" class="headerlink" title="对于classpath与classpath*的一些理解"></a>对于classpath与classpath*的一些理解</h1><p>一般由PathMatchingResourcePatternResolver类的getResources解析</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new PathMatchingResourcePatternResolver().getResources(locationPattern);</span><br></pre></td></tr></table></figure><p>getResources()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Resource[] getResources(String locationPattern) throws IOException &#123;</span><br><span class="line">Assert.notNull(locationPattern, &quot;Location pattern must not be null&quot;);</span><br><span class="line">// classpath*:前缀</span><br><span class="line">if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123;</span><br><span class="line">// a class path resource (multiple resources for same name possible)</span><br><span class="line">if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123;</span><br><span class="line">// a class path resource pattern</span><br><span class="line">return findPathMatchingResources(locationPattern);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">// all class path resources with the given name</span><br><span class="line">return findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// classpath:前缀</span><br><span class="line">else &#123;</span><br><span class="line">// Generally only look for a pattern after a prefix here,</span><br><span class="line">// and on Tomcat only after the &quot;*/&quot; separator for its &quot;war:&quot; protocol.</span><br><span class="line">int prefixEnd = (locationPattern.startsWith(&quot;war:&quot;) ? locationPattern.indexOf(&quot;*/&quot;) + 1 :</span><br><span class="line">locationPattern.indexOf(&apos;:&apos;) + 1);</span><br><span class="line">if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123;</span><br><span class="line">// a file pattern</span><br><span class="line">return findPathMatchingResources(locationPattern);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">// a single resource with the given name</span><br><span class="line">return new Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>findPathMatchingResources()方法匹配模式路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">protected Resource[] findPathMatchingResources(String locationPattern) throws IOException &#123;</span><br><span class="line">String rootDirPath = determineRootDir(locationPattern);</span><br><span class="line">String subPattern = locationPattern.substring(rootDirPath.length());</span><br><span class="line">//根路径资源</span><br><span class="line">Resource[] rootDirResources = getResources(rootDirPath);</span><br><span class="line">Set&lt;Resource&gt; result = new LinkedHashSet&lt;&gt;(16);</span><br><span class="line">for (Resource rootDirResource : rootDirResources) &#123;</span><br><span class="line">rootDirResource = resolveRootDirResource(rootDirResource);</span><br><span class="line">URL rootDirUrl = rootDirResource.getURL();</span><br><span class="line">if (equinoxResolveMethod != null &amp;&amp; rootDirUrl.getProtocol().startsWith(&quot;bundle&quot;)) &#123;</span><br><span class="line">URL resolvedUrl = (URL) ReflectionUtils.invokeMethod(equinoxResolveMethod, null, rootDirUrl);</span><br><span class="line">if (resolvedUrl != null) &#123;</span><br><span class="line">rootDirUrl = resolvedUrl;</span><br><span class="line">&#125;</span><br><span class="line">rootDirResource = new UrlResource(rootDirUrl);</span><br><span class="line">&#125;</span><br><span class="line">if (rootDirUrl.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) &#123;</span><br><span class="line">result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirUrl, subPattern, getPathMatcher()));</span><br><span class="line">&#125;</span><br><span class="line">else if (ResourceUtils.isJarURL(rootDirUrl) || isJarResource(rootDirResource)) &#123;</span><br><span class="line">result.addAll(doFindPathMatchingJarResources(rootDirResource, rootDirUrl, subPattern));</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">if (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(&quot;Resolved location pattern [&quot; + locationPattern + &quot;] to resources &quot; + result);</span><br><span class="line">&#125;</span><br><span class="line">return result.toArray(new Resource[0]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结论1"><a href="#结论1" class="headerlink" title="结论1"></a>结论1</h2><p>classpath*:可以获取同一路径同一名字的多个资源</p><p>classpath:可以获取同一路径同一名字的一个资源</p><h2 id="结论2"><a href="#结论2" class="headerlink" title="结论2"></a>结论2</h2><p>当使用classpath:时，后面的路径不能紧接通配符路径</p><p>例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classpath:**/*.xml        classpath:spri*/*.xml</span><br></pre></td></tr></table></figure><p>spring的解析类在解析时会将路径其分成两部分（根路径+包含通配符路径）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classpath: 和 **/*.xml     classpath: 和 spri*/*.xml</span><br></pre></td></tr></table></figure><p>并且getResources()方法中的 </p><p>return new Resource[] {getResourceLoader().getResource(locationPattern)};</p><p>getResourceLoader().getResource(locationPattern)</p><p>进入DefaultResourceLoader类的getResource()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public Resource getResource(String location) &#123;</span><br><span class="line">Assert.notNull(location, &quot;Location must not be null&quot;);</span><br><span class="line"></span><br><span class="line">for (ProtocolResolver protocolResolver : getProtocolResolvers()) &#123;</span><br><span class="line">Resource resource = protocolResolver.resolve(location, this);</span><br><span class="line">if (resource != null) &#123;</span><br><span class="line">return resource;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (location.startsWith(&quot;/&quot;)) &#123;</span><br><span class="line">return getResourceByPath(location);</span><br><span class="line">&#125;</span><br><span class="line">// 截取了classpath:</span><br><span class="line">else if (location.startsWith(CLASSPATH_URL_PREFIX)) &#123;</span><br><span class="line">return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader());</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">try &#123;</span><br><span class="line">// Try to parse the location as a URL...</span><br><span class="line">URL url = new URL(location);</span><br><span class="line">return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url));</span><br><span class="line">&#125;</span><br><span class="line">catch (MalformedURLException ex) &#123;</span><br><span class="line">// No URL -&gt; resolve as resource path.</span><br><span class="line">return getResourceByPath(location);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>classpath:被截取，返回的根路径为””, 这样就获取不到任何资源</p><h2 id="结论3"><a href="#结论3" class="headerlink" title="结论3"></a>结论3</h2><h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>关于类路径下META-INF文件夹，使用前缀classpath:以及通配符获取不到资源</p><p>例如路径： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">classpath:META-INF/*.xml</span><br></pre></td></tr></table></figure><p>获取不到META-INF下的mapper.xml</p><p>解决：可以在META-INF中添加一个目录，例如classpath:META-INF/mapper/*.xml就可以了</p><p>调试分析：</p><p>findPathMatchingResources()方法中的有一句</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">URL rootDirUrl = rootDirResource.getURL();</span><br></pre></td></tr></table></figure><p>遇到rootDirResource是META-INF时，会获取一个根路径下的一个jar包路径</p><p>(file:/C:Program%20Files/Java/jdk1.8.0_161/jre/lib/ext/jfxrt.jar!/META-INF/)</p><p>在该jar路径下META-INF下查找mapper.xml当然查找不到</p><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>classpath:使用路径匹配，获取的资源只有一个。</p><p>getResources()方法中的classpath:分支获取根路径资源的方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return new Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;;</span><br></pre></td></tr></table></figure><p>可以看出，虽然new了一个数组Resource，但是实际数组中只有一个根路径资源，</p><p>因此，相同目录下使用classpath:与路径匹配获取的资源只有一个</p><p>并且findPathMatchingResources()方法中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for (Resource rootDirResource : rootDirResources) &#123;</span><br><span class="line">rootDirResource = resolveRootDirResource(rootDirResource);</span><br><span class="line">URL rootDirUrl = rootDirResource.getURL();</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>根据rootDirResource.getURL()获取一个URL路径</p><p>Resource实现类ClassPathResource中getURL()方法，</p><p>执行了return this.classLoader.getResource(this.path);返回了<strong><em>一个</em></strong>URL</p><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">    public void test5()&#123;</span><br><span class="line">        URL mapper = this.getClass().getClassLoader().getResource(&quot;META-INF/mappers/&quot;);</span><br><span class="line">        System.out.println(mapper.getPath());</span><br><span class="line">        URL metainf = this.getClass().getClassLoader().getResource(&quot;META-INF/&quot;);</span><br><span class="line">        System.out.println(metainf.getPath());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">file:/E:/maven/maven-repository/com/szxy/szxy-spring-boot-autoconfigure/1.0-SNAPSHOT/szxy-spring-boot-autoconfigure-1.0-SNAPSHOT.jar!/META-INF/mappers/</span><br><span class="line">file:/C:/Program%20Files/Java/jdk1.8.0_161/jre/lib/ext/jfxrt.jar!/META-INF/</span><br></pre></td></tr></table></figure><p>然而，这两个jar下虽然有对应的目录URL,但并不是我们想要匹配的jar,因此，匹配不到任何资源</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>​    1)使用classpath:获取资源，注意匹配目录不要与其他jar包中的重复，因为其根路径资源只加载</p><p>一个，如果通过根路径获取了另一个不含有资源的jar包(只是具有相同的类路径)，则无法获取资源。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例： classpath:META-INF/*.txt</span><br><span class="line">路径分割成根路径META-INF和模式路径*.txt</span><br><span class="line">许多jar包下都有META-INF目录，但是只会加载一个jar包去匹配资源而忽略其他jar包，因此可能导致需要的资源没有加载</span><br></pre></td></tr></table></figure><p>​    </p><p>2）获取单一资源，可以直接写完整的路径名进行匹配</p><p>3 ) classpath:如果具有相同路径相同名称的资源，则只加载一个</p><p>​            </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring加载classpath与classpath-的过程&quot;&gt;&lt;a href=&quot;#Spring加载classpath与classpath-的过程&quot; class=&quot;headerlink&quot; title=&quot;Spring加载classpath与classpath*的过
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>spring中一些使用分析链接</title>
    <link href="http://yoursite.com/2020/05/25/Spring/spring%E4%B8%AD%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90%E9%93%BE%E6%8E%A5/"/>
    <id>http://yoursite.com/2020/05/25/Spring/spring%E4%B8%AD%E4%B8%80%E4%BA%9B%E4%BD%BF%E7%94%A8%E5%88%86%E6%9E%90%E9%93%BE%E6%8E%A5/</id>
    <published>2020-05-25T10:07:59.000Z</published>
    <updated>2020-06-03T06:28:33.473Z</updated>
    
    <content type="html"><![CDATA[<h1 id="spring中一些使用分析链接"><a href="#spring中一些使用分析链接" class="headerlink" title="spring中一些使用分析链接"></a>spring中一些使用分析链接</h1><h2 id="Spring系列之FactoryBean（一）"><a href="#Spring系列之FactoryBean（一）" class="headerlink" title="Spring系列之FactoryBean（一）"></a>Spring系列之FactoryBean（一）</h2><p><a href="https://blog.csdn.net/zknxx/article/details/79572387" target="_blank" rel="noopener">https://blog.csdn.net/zknxx/article/details/79572387</a></p><h2 id="关于Spring加载classpath与classpath-的过程剖析"><a href="#关于Spring加载classpath与classpath-的过程剖析" class="headerlink" title="关于Spring加载classpath与classpath*的过程剖析"></a>关于Spring加载classpath与classpath*的过程剖析</h2><p><a href="https://blog.csdn.net/zl3450341/article/details/9306983#" target="_blank" rel="noopener">https://blog.csdn.net/zl3450341/article/details/9306983#</a></p><p><a href="https://www.cnblogs.com/EasonJim/p/6709314.html" target="_blank" rel="noopener">https://www.cnblogs.com/EasonJim/p/6709314.html</a></p><h1 id="spring常用的4种加载资源的前缀"><a href="#spring常用的4种加载资源的前缀" class="headerlink" title="spring常用的4种加载资源的前缀"></a>spring常用的4种加载资源的前缀</h1><p><a href="https://blog.csdn.net/hulei19900322/article/details/75200356" target="_blank" rel="noopener">https://blog.csdn.net/hulei19900322/article/details/75200356</a></p><h1 id="Spring开启Aop注解-EnableAspectJAutoProxy"><a href="#Spring开启Aop注解-EnableAspectJAutoProxy" class="headerlink" title="Spring开启Aop注解@EnableAspectJAutoProxy"></a>Spring开启Aop注解@EnableAspectJAutoProxy</h1><p><a href="https://blog.csdn.net/a3959678/article/details/100042832" target="_blank" rel="noopener">https://blog.csdn.net/a3959678/article/details/100042832</a></p><p><a href="https://www.iteye.com/blog/jag522-2115923" target="_blank" rel="noopener">https://www.iteye.com/blog/jag522-2115923</a></p><p><a href="https://www.cnblogs.com/foreveravalon/p/8653832.html" target="_blank" rel="noopener">https://www.cnblogs.com/foreveravalon/p/8653832.html</a></p><h2 id="完全读懂Spring框架之AOP实现原理"><a href="#完全读懂Spring框架之AOP实现原理" class="headerlink" title="完全读懂Spring框架之AOP实现原理"></a>完全读懂Spring框架之AOP实现原理</h2><p><a href="https://my.oschina.net/guangshan/blog/1797461" target="_blank" rel="noopener">https://my.oschina.net/guangshan/blog/1797461</a></p><h2 id="详解Spring中Bean的this调用导致AOP失效的原因"><a href="#详解Spring中Bean的this调用导致AOP失效的原因" class="headerlink" title="详解Spring中Bean的this调用导致AOP失效的原因"></a>详解Spring中Bean的this调用导致AOP失效的原因</h2><p><a href="https://my.oschina.net/guangshan/blog/1807721" target="_blank" rel="noopener">https://my.oschina.net/guangshan/blog/1807721</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;spring中一些使用分析链接&quot;&gt;&lt;a href=&quot;#spring中一些使用分析链接&quot; class=&quot;headerlink&quot; title=&quot;spring中一些使用分析链接&quot;&gt;&lt;/a&gt;spring中一些使用分析链接&lt;/h1&gt;&lt;h2 id=&quot;Spring系列之Fact
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>关于xml和注解</title>
    <link href="http://yoursite.com/2020/05/24/JavaSE/%E5%85%B3%E4%BA%8Exml%E5%92%8C%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/05/24/JavaSE/%E5%85%B3%E4%BA%8Exml%E5%92%8C%E6%B3%A8%E8%A7%A3/</id>
    <published>2020-05-24T15:09:08.000Z</published>
    <updated>2020-05-23T16:29:36.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于XML和注解"><a href="#关于XML和注解" class="headerlink" title="关于XML和注解"></a>关于XML和注解</h1><h2 id="回答1"><a href="#回答1" class="headerlink" title="回答1"></a>回答1</h2><p>​        最初引入配置文件的原因是为了降低耦合、方便修改等。在缺少元数据信息的过去，指定哪个类哪个方法用来做什么，或者指定ORM框架的实体映射等，只能通过人工手动编写。最初的Java可不像Ruby on Rails这种框架可以做到约定大于配置。如果把配置信息硬编码在代码里，那势必是每天都要大量改动代码，从而堆积大量样板代码，这些样板代码可读性很差，会和项目中很多的类发生耦合，而改动代码就要编译、重新封包部署，会非常影响工作效率。特别是如果将某个配置过的类删掉，那么如果不在配置代码里去掉对这个类的引用，那么必定编译无法通过。而配置文件的话，捕获一下ClassNotFound异常然后忽略这段配置就可以了。所以在过去，使用某种格式的配置文件，当然xml居多，来配置Java项目的各个组件是十分正常的。</p><p>​        不过配置文件也是存在弊端的，首先最大的问题就是配置文件是不参与编译的，这也意味着无法享受静态语言编译检查带来的好处。配置文件是否起作用，甚至格式是否正确，只能在将项目跑起来的时候，才能进行排除。如果是比较隐晦的错误，也会给开发人员带来很多困扰。再者，尽管XML等配置文件的可读性理论上是良好的，但如果其内容过于繁杂，甚至堆积成山，那么对于维护人员来说也是一件非常痛苦的事情。</p><p>不过事情在Java引入注解之后得到了很大的改变。注解是可以给类、接口、方法、成员变量、参数上附加元信息的新功能。有了它的标记，再也不用将一大堆类、方法创建完了还要在XML里罗列一遍，配置文件的体积得到了极大地瘦身。回到刚刚的问题，之所以最初不用Java代码作为配置文件，主要是因为这些代码需要经常性改动，会导致配置代码和项目产生耦合，且频繁编译，替换也不方便。但有了注解之后，直接扫描注解就能获得足够多的配置信息，样板代码消失了，配置文件本身其实很少会发生变化了，这样以来，用XML还是用Java代码做配置，其实问题都不大了。而且用代码的话，可以享受IDE的语法提示，确保不容易写错，对自己的配置到底会怎样被框架使用也会了解的更深刻一点，嗯，一点儿而已。</p><p>​        甚至，包括Servlet 3.0和Spring Framework都重新引入了基于代码配置的功能。没错儿，题主，现在的Java，不仅不是需要使用XML之类的配置文件，而是真的有很多框架是可以用Java代码做配置文件的。我现在开Spring项目，连web.xml和applicationContext.xml之类的配置文件都没有，统统是使用代码进行配置的。其他框架不敢保证，但是Servlet3.0和Spring的配置，都是可以在XML和Java代码两者之间随意转换的。不存在某种写法只能在特定的配置手段中使用的问题。</p><p>​        使用代码作为配置文件除了可以享受IDE语法高亮提示和静态编译除错的好处之外，还有一个好处是对于需要根据复杂情景灵活提供配置的时候，代码的灵活性是配置文件无法比拟的。比如使用随机数、使用if-else、调用远程服务器提供配置信息等，即使XML能配出来，也是相当麻烦，绝对比使用代码要多出很多行来的。</p><p>​        以上是Java项目配置文件发展的历史，以及各自的利弊及适用场景。其实无论XML也好，Java代码也好，在现在Java项目中都是OK的。不过如果需要更加灵活的配置，还是更加推荐使用Java代码的方式。现在这种方式也是愈发主流，甚至Gradle这种项目配置，都使用脚本语言了。当然，我的水平有限，也有可能个人理解中也有很多谬误，欢迎指正交流。</p><h2 id="回答2"><a href="#回答2" class="headerlink" title="回答2"></a>回答2</h2><p>最早最早的程序都是写死的，也就是说用语言本身来写“配置”。这是第一阶段。</p><p>但程序员们很快发现要改点什么就得重新编译程序，很不方便，于是把一些可可能会变的东西写到配置文件中，配置文件通常是文本文件，ini或者xml之类的。ini相对功能较简单，xml则比较复杂。这是第二阶段。</p><p>后来配置越来越多，配置文件变得复杂起来，为了让xml尽可能不写错（xml的错误不能在编译期检查出），还使用了dtd，schema等对xml进行验证。程序员们甚至想一切皆配置，所有程序按功能完全模块化，以后改什么动动配置即可，看起来很美好……这是第三阶段。</p><p>但配置的复杂也是个大问题，后来程序员们又发现，这么复杂的配置掌握起来其实也很困难，并不比写代码简单多少，错误还不能在编译期看出，且有些东西确实万年不变的，干嘛要配置呢？于是又返璞归真的开始宣传“零配置”，利用一些新的语言特性，如“注解”（annotation），将配置“写死”在程序中……这是第四阶段。</p><p>第五阶段，其实我瞎编的，就是配置文件还是要，只不过只保留了最必要的部分，大多“配置”都写死了。</p><p>来自：<a href="https://www.zhihu.com/question/271390057" target="_blank" rel="noopener">https://www.zhihu.com/question/271390057</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于XML和注解&quot;&gt;&lt;a href=&quot;#关于XML和注解&quot; class=&quot;headerlink&quot; title=&quot;关于XML和注解&quot;&gt;&lt;/a&gt;关于XML和注解&lt;/h1&gt;&lt;h2 id=&quot;回答1&quot;&gt;&lt;a href=&quot;#回答1&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/categories/JavaSE/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>springboot中yml属性的注入.md</title>
    <link href="http://yoursite.com/2020/05/24/SpringBoot/springboot%E4%B8%ADyml%E5%B1%9E%E6%80%A7%E7%9A%84%E6%B3%A8%E5%85%A5/"/>
    <id>http://yoursite.com/2020/05/24/SpringBoot/springboot%E4%B8%ADyml%E5%B1%9E%E6%80%A7%E7%9A%84%E6%B3%A8%E5%85%A5/</id>
    <published>2020-05-24T14:20:20.000Z</published>
    <updated>2020-05-25T05:24:07.482Z</updated>
    
    <content type="html"><![CDATA[<h1 id="springboot中yml文件"><a href="#springboot中yml文件" class="headerlink" title="springboot中yml文件"></a>springboot中yml文件</h1><h2 id="yml语法"><a href="#yml语法" class="headerlink" title="yml语法"></a>yml语法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">k:(空格)v :表示一对键值对(空格必须有);</span><br><span class="line">以空格的缩进来控制层级关系;只要是左对齐的一列数据，就是同一层级，几个空格不重要。</span><br><span class="line">属性和值是大小写敏感。</span><br><span class="line">字面量：普通值(数字、字符串、布尔)</span><br><span class="line">        字符串默认不用加上单引号或者双引号。</span><br><span class="line">        &quot;&quot;: 双引号，不会自动转义字符串里面的特殊字符串；特殊字符会作为本身想表示的意思。</span><br><span class="line">            name: &quot;zhangsan \n lisi&quot; -》输出：zhangsan 换行 lisi</span><br><span class="line">        &apos;&apos;: 单引号，会自动转义字符串里面的特殊字符串；下面的 \ 自动转义成了 \\</span><br><span class="line">            name: &quot;zhangsan \n lisi&quot; -》输出：zhangsan \n lisi</span><br><span class="line">对象(List、Map、键值对形式)</span><br><span class="line">k:v: 在下一行写对象的属性和值；注意缩进</span><br><span class="line">    对象还是 k: v 的方式</span><br><span class="line">    friends:</span><br><span class="line">        lastName: zhangsan</span><br><span class="line">        age: 20</span><br><span class="line">行内写法： friends: &#123;lastName: zhangsan, age: 18&#125;</span><br><span class="line">数组(List、Set)</span><br><span class="line">用 -值表示数组中的元素</span><br><span class="line">pets:</span><br><span class="line"> - cat</span><br><span class="line"> - dog</span><br><span class="line"> - pig</span><br><span class="line">行内写法: pets: [cat,dog,pig];</span><br></pre></td></tr></table></figure><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><h3 id="实体配置"><a href="#实体配置" class="headerlink" title="实体配置"></a>实体配置</h3><p>此处省略了get,set,toString方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(prefix = &quot;com.yml.test&quot;)</span><br><span class="line">public class Person &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Integer age;</span><br><span class="line">    private Boolean boss;</span><br><span class="line">    private Date birth;</span><br><span class="line">    private Map&lt;String, Object&gt; maps;</span><br><span class="line">    private List&lt;Object&gt; lists;</span><br><span class="line">    private Dog dog;</span><br><span class="line">    public static class Dog&#123;</span><br><span class="line">        private String name;</span><br><span class="line">        private Integer age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="测试yml配置"><a href="#测试yml配置" class="headerlink" title="测试yml配置"></a>测试yml配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">com:</span><br><span class="line">  yml:</span><br><span class="line">    test:</span><br><span class="line">      name: hello</span><br><span class="line">      age: 20</span><br><span class="line">      boss: true</span><br><span class="line">      birth: 1999/05/20</span><br><span class="line">      maps: &#123;hello: hello, world: world&#125;</span><br><span class="line">      lists:</span><br><span class="line">        - 11111</span><br><span class="line">        - 22222</span><br><span class="line">      dog:</span><br><span class="line">        name: tom</span><br><span class="line">        age: 2</span><br></pre></td></tr></table></figure><h3 id="开启配置"><a href="#开启配置" class="headerlink" title="开启配置"></a>开启配置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Configuration</span><br><span class="line">@EnableConfigurationProperties(&#123;Person.class&#125;)</span><br><span class="line">配置类&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="读取配置信息并打印"><a href="#读取配置信息并打印" class="headerlink" title="读取配置信息并打印"></a>读取配置信息并打印</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person&#123;name=&apos;hello&apos;, age=20, boss=true, birth=Thu May 20 00:00:00 CST 1999, maps=&#123;hello=hello, world=world&#125;, lists=[11111, 22222], dog=Dog&#123;name=&apos;tom&apos;, age=2&#125;&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;springboot中yml文件&quot;&gt;&lt;a href=&quot;#springboot中yml文件&quot; class=&quot;headerlink&quot; title=&quot;springboot中yml文件&quot;&gt;&lt;/a&gt;springboot中yml文件&lt;/h1&gt;&lt;h2 id=&quot;yml语法&quot;&gt;&lt;a
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot中的SCI接口</title>
    <link href="http://yoursite.com/2020/05/23/SpringBoot/SpringBoot%E4%B8%AD%E7%9A%84SCI%E6%8E%A5%E5%8F%A3/"/>
    <id>http://yoursite.com/2020/05/23/SpringBoot/SpringBoot%E4%B8%AD%E7%9A%84SCI%E6%8E%A5%E5%8F%A3/</id>
    <published>2020-05-23T11:12:59.000Z</published>
    <updated>2020-05-23T14:08:49.650Z</updated>
    
    <content type="html"><![CDATA[<h2 id="servlet3-0使用Java-SPI机制"><a href="#servlet3-0使用Java-SPI机制" class="headerlink" title="servlet3.0使用Java SPI机制"></a>servlet3.0使用Java SPI机制</h2><p>​    Servlet3.0环境下ServletContainerInitializer(简称SCI)接口的使用.</p><h3 id="SCI定义"><a href="#SCI定义" class="headerlink" title="SCI定义"></a>SCI定义</h3><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 完整命名: javax.servlet.ServletContainerInitializer</span><br><span class="line">public interface ServletContainerInitializer &#123;</span><br><span class="line">    public void onStartup(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx)</span><br><span class="line">        throws ServletException; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SCI概述"><a href="#SCI概述" class="headerlink" title="SCI概述"></a>SCI概述</h3><p>ServletContainerInitializer 是 Servlet 3.0 新增的一个接口，主要用于在容器启动阶段通过编程风格注册Filter, Servlet以及Listener，以取代通过web.xml配置注册。这样就利于开发内聚的web应用框架.<br>我们以SpringMVC举例, servlet3.0之前我们需要在web.xml中依据Spring的规范新建一堆配置。这样就相当于将框架和容器紧耦合了。而在3.x后注册的功能内聚到Spring里，Spring-web就变成一个纯粹的即插即用的组件，不用依据应用环境定义一套新的配置。</p><h3 id="SCI原理"><a href="#SCI原理" class="headerlink" title="SCI原理"></a>SCI原理</h3><p>1）ServletContainerInitializer接口的实现类通过java SPI声明自己是ServletContainerInitializer 的provider.</p><p>2）容器启动阶段依据java spi获取到所有ServletContainerInitializer的实现类，然后执行其onStartup方法.</p><p>3）另外在实现ServletContainerInitializer时还可以通过@HandlesTypes注解定义本实现类希望处理的类型，容器会    将当前应用中所有这一类型（继承或者实现）的类放在ServletContainerInitializer接口的集合参数c中传递进来。    如果不定义处理类型，或者应用中不存在相应的实现类，则集合参数c为空.</p><p>4）这一类实现了 SCI 的接口，如果做为独立的包发布，在打包时，会在JAR 文件的 META-INF/services/javax.servlet.ServletContainerInitializer 文件中进行注册。 容器在启动时，就会扫描所有带有这些注册信息的类(@HandlesTypes(WebApplicationInitializer.class)这里就是加载WebApplicationInitializer.class类)进行解析，启动时会调用其 onStartup方法——也就是说servlet容器负责加载这些指定类, 而ServletContainerInitializer的实现者(例如Spring-web中的SpringServletContainerInitializer对接口ServletContainerInitializer的实现中,是可以直接获取到这些类的)</p><h3 id="与类加载的区别"><a href="#与类加载的区别" class="headerlink" title="与类加载的区别"></a>与类加载的区别</h3><p>​    类加载是根据限定的名称去加载，并没有相关的标准去加载未知的内容.<br>​    而SCI(全称 ServletContainerInitializer)则是根据约定的标准，扫描META-INF中包含注册信息的 class 并在启动阶段调用其onStartup.</p><h3 id="SpringMVC中的应用"><a href="#SpringMVC中的应用" class="headerlink" title="SpringMVC中的应用"></a>SpringMVC中的应用</h3><p>通过查看ServletContainerInitializer继承层级, 可以发现spring-web中的SpringServletContainerInitializer正是实现了ServletContainerInitializer接口；</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">@HandlesTypes(WebApplicationInitializer.class)</span><br><span class="line">public class SpringServletContainerInitializer implements ServletContainerInitializer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onStartup(Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)</span><br><span class="line">            throws ServletException &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;WebApplicationInitializer&gt; initializers = new LinkedList&lt;WebApplicationInitializer&gt;();</span><br><span class="line"></span><br><span class="line">        // webAppInitializerClasses 就是servlet3.0规范中为我们收集的 WebApplicationInitializer 接口的实现类的class</span><br><span class="line">        // 从webAppInitializerClasses中筛选并实例化出合格的相应的类</span><br><span class="line">        if (webAppInitializerClasses != null) &#123;</span><br><span class="line">            for (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123;</span><br><span class="line">                // Be defensive: Some servlet containers provide us with invalid classes,</span><br><span class="line">                // no matter what @HandlesTypes says...</span><br><span class="line">                if (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;</span><br><span class="line">                        WebApplicationInitializer.class.isAssignableFrom(waiClass)) &#123;</span><br><span class="line">                    try &#123;</span><br><span class="line">                        initializers.add((WebApplicationInitializer) waiClass.newInstance());</span><br><span class="line">                    &#125;</span><br><span class="line">                    catch (Throwable ex) &#123;</span><br><span class="line">                        throw new ServletException(&quot;Failed to instantiate WebApplicationInitializer class&quot;, ex);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (initializers.isEmpty()) &#123;</span><br><span class="line">            servletContext.log(&quot;No Spring WebApplicationInitializer types detected on classpath&quot;);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 这行代码说明我们在实现WebApplicationInitializer可以通过继承Ordered, PriorityOrdered来自定义执行顺序</span><br><span class="line">        AnnotationAwareOrderComparator.sort(initializers);</span><br><span class="line">        servletContext.log(&quot;Spring WebApplicationInitializers detected on classpath: &quot; + initializers);</span><br><span class="line"></span><br><span class="line">        // 迭代每个initializer实现的方法</span><br><span class="line">        for (WebApplicationInitializer initializer : initializers) &#123;</span><br><span class="line">            initializer.onStartup(servletContext);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1）SpringServletContainerInitializer 由支持Servlet3.0+的Servlet容器实例化并调用.</p><p>2）Servlet容器还会查询classpath下SpringServletContainerInitializer类上修饰的@HandlesTypes注解所标注的    WebApplicationInitializer接口的实现类. 这一步也是容器帮我们完成的.</p><p>3）SpringServletContainerInitializer通过实现ServletContainerInitializer将自身并入到Servlet容器的生命周期中, 并通过自身定义的WebApplicationInitializer将依赖于Spring框架的系统初始化需求与Servlet容器解耦. 即依赖于spring的系统可以通过实现WebApplicationInitializer来实现自定义的初始化逻辑. 而不需要去实现ServletContainerInitializer</p><h3 id="Tomcat调用SCI的时机"><a href="#Tomcat调用SCI的时机" class="headerlink" title="Tomcat调用SCI的时机"></a>Tomcat调用SCI的时机</h3><p>​    现在还有一个疑问, 就是 ServletContainerInitializer 的调用时机?, 因为servlet容器除了会回调SCI之外, 还有回调诸如servlet, listener等. 搞清楚这些先后顺序可以帮助我们快速定位和理解某些奇怪的问题.</p><p>​    这里我们就以Tomcat举例, 以下逻辑总结于Tomcat7.x, 有兴趣的读者可以去StandardContext类中对startInternal的实现中(第5608行 —— 第5618行, 这也是Tomcat中唯一的调用ServletContainerInitializers接口的onStartup方法的位置)求证下:</p><p>1）解析web.xml<br>2）往ServletContext实例中注入 context-param  参数<br>3）回调Servlet3.0的ServletContainerInitializers接口实现类<br>4）触发 Listener 事件(beforeContextInitialized, afterContextInitialized); 这里只会触发 ServletContextListener 类型的</p><p>5）初始化 Filter, 调用其init方法</p><p>6）加载 启动时即加载的servlet</p><p>原文链接：<a href="https://blog.csdn.net/lqzkcx3/article/details/78507169" target="_blank" rel="noopener">https://blog.csdn.net/lqzkcx3/article/details/78507169</a></p><h2 id="springBoot打成war在外部容器的启动"><a href="#springBoot打成war在外部容器的启动" class="headerlink" title="springBoot打成war在外部容器的启动"></a>springBoot打成war在外部容器的启动</h2><p>Springboot在使用外部容器运行时</p><p>需要写一个初始化类继承SpringBootServletInitializer</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public class OasysServletInitializer extends SpringBootServletInitializer &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123;</span><br><span class="line">        return builder.sources(OasysApplication.class);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringBootServletInitializer实现了WebApplicationInitializer接口，而实现了WebApplicationInitializer的类会被servlet容器扫描，并且调用onStartup()方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public abstract class SpringBootServletInitializer implements WebApplicationInitializer &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Springboot提供的SCI接口"><a href="#Springboot提供的SCI接口" class="headerlink" title="Springboot提供的SCI接口"></a>Springboot提供的SCI接口</h2><h3 id="ServletContextInitializer接口"><a href="#ServletContextInitializer接口" class="headerlink" title="ServletContextInitializer接口"></a>ServletContextInitializer接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">package org.springframework.boot.web.servlet;</span><br><span class="line"></span><br><span class="line">import javax.servlet.ServletContainerInitializer;</span><br><span class="line">import javax.servlet.ServletContext;</span><br><span class="line">import javax.servlet.ServletException;</span><br><span class="line"></span><br><span class="line">import org.springframework.web.SpringServletContainerInitializer;</span><br><span class="line">import org.springframework.web.WebApplicationInitializer;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Interface used to configure a Servlet 3.0+ &#123;@link ServletContext context&#125;</span><br><span class="line"> * programmatically. Unlike &#123;@link WebApplicationInitializer&#125;, classes that implement this</span><br><span class="line"> * interface (and do not implement &#123;@link WebApplicationInitializer&#125;) will &lt;b&gt;not&lt;/b&gt; be</span><br><span class="line"> * detected by &#123;@link SpringServletContainerInitializer&#125; and hence will not be</span><br><span class="line"> * automatically bootstrapped by the Servlet container.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * This interface is designed to act in a similar way to</span><br><span class="line"> * &#123;@link ServletContainerInitializer&#125;, but have a lifecycle that&apos;s managed by Spring and</span><br><span class="line"> * not the Servlet container.</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * For configuration examples see &#123;@link WebApplicationInitializer&#125;.</span><br><span class="line"> *</span><br><span class="line"> * @author Phillip Webb</span><br><span class="line"> * @since 1.4.0</span><br><span class="line"> * @see WebApplicationInitializer</span><br><span class="line"> */</span><br><span class="line">@FunctionalInterface</span><br><span class="line">public interface ServletContextInitializer &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Configure the given &#123;@link ServletContext&#125; with any servlets, filters, listeners</span><br><span class="line"> * context-params and attributes necessary for initialization.</span><br><span class="line"> * @param servletContext the &#123;@code ServletContext&#125; to initialize</span><br><span class="line"> * @throws ServletException if any call against the given &#123;@code ServletContext&#125;</span><br><span class="line"> * throws a &#123;@code ServletException&#125;</span><br><span class="line"> */</span><br><span class="line">void onStartup(ServletContext servletContext) throws ServletException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释：</p><p>1）接口用于以编程方式配置Servlet 3.0+ {@link ServletContext context}。</p><p>2）实现这个接口(并且没有实现{@link WebApplicationInitializer})的类不会被{@link SpringServletContainerInitializer}检测到，因此不会被Servlet容器自动引导。</p><p>3）这个接口的作用类似于{@link ServletContainerInitializer}，但是它的生命周期是由Spring管理的，而不是由Servlet容器管理的。</p><h3 id="接口使用"><a href="#接口使用" class="headerlink" title="接口使用"></a>接口使用</h3><p>在springboot中注册一个servlet可以使用这种方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Bean</span><br><span class="line">public ServletRegistrationBean registrationBean() &#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ServletRegistrationBean    extends   DynamicRegistrationBean </p><p>DynamicRegistrationBean    extends   RegistrationBean </p><p>RegistrationBean implements ServletContextInitializer, Ordered</p><p>通过继承结构可以看出，是通过实现Springboot提供的SCI接口（调用该接口的onStartup()）来完成的。</p><h3 id="关于该接口的一些想法及猜测"><a href="#关于该接口的一些想法及猜测" class="headerlink" title="关于该接口的一些想法及猜测"></a>关于该接口的一些想法及猜测</h3><p>1)实现了该接口的类必须通过@Bean等方式注册进spring容器中，才能被springboot发现从而调用其onStartup()</p><p>2)servlet 3动态加载servlet的机制只能在上下文ServletContext加载时对Servlet，Filter,,Listener进行注册。</p><p>当springboot打包成war包放入外部容器中时，外部容器启动springboot项目入口是实现WebApplicationInitializer接口的SpringBootServletInitializer类，SpringBootServletInitializer实例执行onStartup方法的时候会通过createRootApplicationContext方法来执行run方法，接下来的过程就同以jar包形式启动的应用的run过程一样了，在内部会创建IOC容器并返回，只是以war包形式的应用在创建IOC容器过程中，不再创建Servlet容器了。</p><p>因此整个启动过程都是在ServletContext加载时进行的，使用Springboot提供的SCI接口注册Servlet的Bean也会被springboot发现从而被调用onStartup()方法完成servlet注册(且该Bean是由spring容器管理的，并不会被servlet容器发现)。</p><p>3） springboot的内置容器启动和外置容器启动</p><p>​    内置容器：</p><p>​            jar包:</p><p>​                执行SpringBootApplication的run方法,启动IOC容器,然后创建嵌入式Servlet容器</p><p>​    外置容器：</p><p>​    　war包:  </p><p>​            先是启动Servlet服务器,服务器启动Springboot应用(springBootServletInitizer),然后启动IOC容器</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;servlet3-0使用Java-SPI机制&quot;&gt;&lt;a href=&quot;#servlet3-0使用Java-SPI机制&quot; class=&quot;headerlink&quot; title=&quot;servlet3.0使用Java SPI机制&quot;&gt;&lt;/a&gt;servlet3.0使用Java SPI
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot数据库连接池.md</title>
    <link href="http://yoursite.com/2020/05/22/SpringBoot/SpringBoot%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/"/>
    <id>http://yoursite.com/2020/05/22/SpringBoot/SpringBoot%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%9E%E6%8E%A5%E6%B1%A0/</id>
    <published>2020-05-22T09:20:20.000Z</published>
    <updated>2020-05-24T14:35:38.771Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Springboot连接池"><a href="#Springboot连接池" class="headerlink" title="Springboot连接池"></a>Springboot连接池</h1><h2 id="springboot-2-0-默认连接池"><a href="#springboot-2-0-默认连接池" class="headerlink" title="springboot 2.0 默认连接池"></a>springboot 2.0 默认连接池</h2><p>​    springboot 2.0 使用Hikari连接池（号称java平台最快的，替换druid）</p><p>​    1.性能方面 hikari&gt;druid&gt;tomcat-jdbc&gt;dbcp&gt;c3p0 。hikari的高性能得益于最大限度的避免锁竞争。</p><p>​     2.druid功能最为全面，sql拦截等百功能，统计数据较为度全面，具有良好的扩展性。</p><h2 id="关于springboot连接池配置"><a href="#关于springboot连接池配置" class="headerlink" title="关于springboot连接池配置"></a>关于springboot连接池配置</h2><p>​        自动配置类</p><p>​        </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class DataSourceAutoConfiguration &#123;</span><br><span class="line">@Configuration(proxyBeanMethods = false)</span><br><span class="line">@Conditional(PooledDataSourceCondition.class)</span><br><span class="line">@ConditionalOnMissingBean(&#123; DataSource.class, XADataSource.class &#125;)</span><br><span class="line">@Import(&#123; DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class,</span><br><span class="line">DataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.Generic.class,</span><br><span class="line">DataSourceJmxConfiguration.class &#125;)</span><br><span class="line">protected static class PooledDataSourceConfiguration &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>连接池Bean的创建配置类中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line">abstract class DataSourceConfiguration &#123;</span><br><span class="line"></span><br><span class="line">@SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">protected static &lt;T&gt; T createDataSource(DataSourceProperties properties, Class&lt;? extends DataSource&gt; type) &#123;</span><br><span class="line">return (T) properties.initializeDataSourceBuilder().type(type).build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Tomcat Pool DataSource configuration.</span><br><span class="line"> */</span><br><span class="line">@Configuration(proxyBeanMethods = false)</span><br><span class="line">@ConditionalOnClass(org.apache.tomcat.jdbc.pool.DataSource.class)</span><br><span class="line">@ConditionalOnMissingBean(DataSource.class)</span><br><span class="line">@ConditionalOnProperty(name = &quot;spring.datasource.type&quot;, havingValue = &quot;org.apache.tomcat.jdbc.pool.DataSource&quot;,</span><br><span class="line">matchIfMissing = true)</span><br><span class="line">static class Tomcat &#123;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">@ConfigurationProperties(prefix = &quot;spring.datasource.tomcat&quot;)</span><br><span class="line">org.apache.tomcat.jdbc.pool.DataSource dataSource(DataSourceProperties properties) &#123;</span><br><span class="line">org.apache.tomcat.jdbc.pool.DataSource dataSource = createDataSource(properties,</span><br><span class="line">org.apache.tomcat.jdbc.pool.DataSource.class);</span><br><span class="line">DatabaseDriver databaseDriver = DatabaseDriver.fromJdbcUrl(properties.determineUrl());</span><br><span class="line">String validationQuery = databaseDriver.getValidationQuery();</span><br><span class="line">if (validationQuery != null) &#123;</span><br><span class="line">dataSource.setTestOnBorrow(true);</span><br><span class="line">dataSource.setValidationQuery(validationQuery);</span><br><span class="line">&#125;</span><br><span class="line">return dataSource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Hikari DataSource configuration.</span><br><span class="line"> */</span><br><span class="line">@Configuration(proxyBeanMethods = false)</span><br><span class="line">@ConditionalOnClass(HikariDataSource.class)</span><br><span class="line">@ConditionalOnMissingBean(DataSource.class)</span><br><span class="line">@ConditionalOnProperty(name = &quot;spring.datasource.type&quot;, havingValue = &quot;com.zaxxer.hikari.HikariDataSource&quot;,</span><br><span class="line">matchIfMissing = true)</span><br><span class="line">static class Hikari &#123;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">@ConfigurationProperties(prefix = &quot;spring.datasource.hikari&quot;)</span><br><span class="line">HikariDataSource dataSource(DataSourceProperties properties) &#123;</span><br><span class="line">HikariDataSource dataSource = createDataSource(properties, HikariDataSource.class);</span><br><span class="line">if (StringUtils.hasText(properties.getName())) &#123;</span><br><span class="line">dataSource.setPoolName(properties.getName());</span><br><span class="line">&#125;</span><br><span class="line">return dataSource;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * DBCP DataSource configuration.</span><br><span class="line"> */</span><br><span class="line">@Configuration(proxyBeanMethods = false)</span><br><span class="line">@ConditionalOnClass(org.apache.commons.dbcp2.BasicDataSource.class)</span><br><span class="line">@ConditionalOnMissingBean(DataSource.class)</span><br><span class="line">@ConditionalOnProperty(name = &quot;spring.datasource.type&quot;, havingValue = &quot;org.apache.commons.dbcp2.BasicDataSource&quot;,</span><br><span class="line">matchIfMissing = true)</span><br><span class="line">static class Dbcp2 &#123;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">@ConfigurationProperties(prefix = &quot;spring.datasource.dbcp2&quot;)</span><br><span class="line">org.apache.commons.dbcp2.BasicDataSource dataSource(DataSourceProperties properties) &#123;</span><br><span class="line">return createDataSource(properties, org.apache.commons.dbcp2.BasicDataSource.class);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Generic DataSource configuration.</span><br><span class="line"> */</span><br><span class="line">@Configuration(proxyBeanMethods = false)</span><br><span class="line">@ConditionalOnMissingBean(DataSource.class)</span><br><span class="line">@ConditionalOnProperty(name = &quot;spring.datasource.type&quot;)</span><br><span class="line">static class Generic &#123;</span><br><span class="line"></span><br><span class="line">@Bean</span><br><span class="line">DataSource dataSource(DataSourceProperties properties) &#123;</span><br><span class="line">return properties.initializeDataSourceBuilder().build();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后一个Generic是使用其他的连接池，如ali的Druid连接池，通过spirng.datasource.type指定。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Springboot连接池&quot;&gt;&lt;a href=&quot;#Springboot连接池&quot; class=&quot;headerlink&quot; title=&quot;Springboot连接池&quot;&gt;&lt;/a&gt;Springboot连接池&lt;/h1&gt;&lt;h2 id=&quot;springboot-2-0-默认连接池&quot;
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>spring中的@Import注解</title>
    <link href="http://yoursite.com/2020/05/22/Spring/spring%E4%B8%AD%E7%9A%84@Import%E6%B3%A8%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/05/22/Spring/spring%E4%B8%AD%E7%9A%84@Import%E6%B3%A8%E8%A7%A3/</id>
    <published>2020-05-22T07:45:59.000Z</published>
    <updated>2020-05-22T16:54:43.940Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring中-Import注解的作用和使用"><a href="#Spring中-Import注解的作用和使用" class="headerlink" title="Spring中@Import注解的作用和使用"></a>Spring中@Import注解的作用和使用</h1><p>参考：<a href="https://blog.csdn.net/panchao888888/article/details/82882279" target="_blank" rel="noopener">https://blog.csdn.net/panchao888888/article/details/82882279</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring中-Import注解的作用和使用&quot;&gt;&lt;a href=&quot;#Spring中-Import注解的作用和使用&quot; class=&quot;headerlink&quot; title=&quot;Spring中@Import注解的作用和使用&quot;&gt;&lt;/a&gt;Spring中@Import注解的作用和
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>键盘缓冲区</title>
    <link href="http://yoursite.com/2020/05/19/C/%E9%94%AE%E7%9B%98%E7%BC%93%E5%86%B2%E5%8C%BA/"/>
    <id>http://yoursite.com/2020/05/19/C/%E9%94%AE%E7%9B%98%E7%BC%93%E5%86%B2%E5%8C%BA/</id>
    <published>2020-05-19T00:38:14.000Z</published>
    <updated>2020-05-19T14:52:44.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="scanf-为毛要敲回车？——输入输出缓冲区，键盘缓冲区"><a href="#scanf-为毛要敲回车？——输入输出缓冲区，键盘缓冲区" class="headerlink" title="scanf 为毛要敲回车？——输入输出缓冲区，键盘缓冲区"></a>scanf 为毛要敲回车？——输入输出缓冲区，键盘缓冲区</h1><p>scanf 从输入流缓冲区里 读取数值，如果输入缓冲区内已有数值，它就可以取用，如果缓冲区里 没有数值，或数的个数不足，scanf 就要等待。 这是第一点。</p><p>第2点，那么 缓冲区里 的数 从何而来？答：是从键盘缓冲区里来。<br>键盘缓冲区 的数据 只有当 遇到 回车键 时 才 送到 输入流缓冲区，否则 留在 键盘 缓冲区里，没到 输入流缓冲区里去。</p><p>键盘缓冲区：<br>键盘的内部有一块微处理器，它控制着键盘的全部工作，比如主机加电时键盘的自检、扫描，扫描码的缓冲以及与主机的通讯等等。当一个键被按下时，微处理器便根据其位置，将字符信号转换成二进制码，传给主机和显示器。如果操作人员的输入速度很快或CPU正在进行其它的工作，就先将键入的内容送往内存中的键盘缓冲区，等CPU空闲时再从缓冲区中取出暂存的指令分析并执行。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">char a;</span><br><span class="line">int n; //n代表scanf每次接收多少个。</span><br><span class="line">while(1)</span><br><span class="line">&#123;</span><br><span class="line">n=scanf(&quot;%c&quot;,&amp;a);  </span><br><span class="line">printf(&quot;%d&quot;,a);</span><br><span class="line">printf(&quot;--------------------------------%d\n&quot;,n);</span><br><span class="line">&#125;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实验结果说明：scanf会接收缓冲区的字符，当接受完之后，我敲回车，控制台就会出现一次换行符。说明敲一次回车，就是传递一个换行符到输入流缓冲区，然后scanf接收这个换行符，并输出。</p><p>原文链接：<a href="https://blog.csdn.net/shine_journey/article/details/38958763" target="_blank" rel="noopener">https://blog.csdn.net/shine_journey/article/details/38958763</a></p><h1 id="输入流的read-读取文件没内容时返回-1，读取键盘没内容时为什么就阻塞，没有返回值？"><a href="#输入流的read-读取文件没内容时返回-1，读取键盘没内容时为什么就阻塞，没有返回值？" class="headerlink" title="输入流的read()读取文件没内容时返回-1，读取键盘没内容时为什么就阻塞，没有返回值？"></a>输入流的read()读取文件没内容时返回-1，读取键盘没内容时为什么就阻塞，没有返回值？</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">//读取取文件输入流：fos.txt内容为a</span><br><span class="line">public static void method3()throws IOException&#123;</span><br><span class="line">FileInputStream in=new FileInputStream(&quot;fos.txt&quot;);</span><br><span class="line">System.out.println(in.read());</span><br><span class="line">System.out.println(in.read());</span><br><span class="line">System.out.println(in.read());</span><br><span class="line">System.out.println(in.read());</span><br><span class="line">/*</span><br><span class="line">结果为：97 -1 -1 -1 （读取文件内容a输出97后，文件输入流未有可读内容，返回-1并未进行阻塞）</span><br><span class="line">*/</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//读取键盘输入流</span><br><span class="line">public static void method4()throws IOException&#123;</span><br><span class="line">InputStream in=System.in;</span><br><span class="line">System.out.println(in.read());</span><br><span class="line">System.out.println(in.read());</span><br><span class="line">System.out.println(in.read());</span><br><span class="line">System.out.println(in.read());</span><br><span class="line">/*</span><br><span class="line">开始（此时键盘输入流未有可读内容）进行阻塞，键入1后 输出49 13 10 （window的回车为&apos;/r/n&apos;）再次进行阻塞（此时键盘输入流未有可读内容）</span><br><span class="line">结果为：1 49 13 10</span><br><span class="line">*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>回答：因为文件有没有内容可以直接判断，键盘不等待的话，你怎么知道用户多久以后才会输入？</p><p>原文链接：<a href="https://www.zhihu.com/question/303794055" target="_blank" rel="noopener">https://www.zhihu.com/question/303794055</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;scanf-为毛要敲回车？——输入输出缓冲区，键盘缓冲区&quot;&gt;&lt;a href=&quot;#scanf-为毛要敲回车？——输入输出缓冲区，键盘缓冲区&quot; class=&quot;headerlink&quot; title=&quot;scanf 为毛要敲回车？——输入输出缓冲区，键盘缓冲区&quot;&gt;&lt;/a&gt;sc
      
    
    </summary>
    
    
    
      <category term="C" scheme="http://yoursite.com/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>SpringAop与AspectJ是什么</title>
    <link href="http://yoursite.com/2020/04/22/Spring/SpringAop%E4%B8%8EAspectJ%E6%98%AF%E4%BB%80%E4%B9%88/"/>
    <id>http://yoursite.com/2020/04/22/Spring/SpringAop%E4%B8%8EAspectJ%E6%98%AF%E4%BB%80%E4%B9%88/</id>
    <published>2020-04-22T13:45:59.000Z</published>
    <updated>2020-06-03T06:29:03.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringAop与AspectJ是什么"><a href="#SpringAop与AspectJ是什么" class="headerlink" title="SpringAop与AspectJ是什么"></a>SpringAop与AspectJ是什么</h1><h2 id="理解1"><a href="#理解1" class="headerlink" title="理解1"></a>理解1</h2><p>  根据我看spring官方文档的理解（不出意外是最正确的答案）：</p><p>①选择spring的AOP还是AspectJ?</p><p>spring确实有自己的AOP。功能已经基本够用了，除非你的要在接口上动态代理或者方法拦截精确到getter和setter。这些都是写奇葩的需求，一般不使用。</p><p>②在使用AOP的时候，你是用xml还是注解的方式（@Aspect）？<br>1）如果使用xml方式，不需要任何额外的jar包。<br>2）如果使用@Aspect方式，你就可以在类上直接一个@Aspect就搞定，不用费事在xml里配了。但是这需要额外的jar包（ aspectjweaver.jar）。因为spring直接使用AspectJ的注解功能，注意只是使用了它 的注解功能而已。并不是核心功能 ！！！</p><p>注意到文档上还有一句很有意思的话：文档说到 是选择spring AOP还是使用full aspectJ？<br>什么是full aspectJ？如果你使用”full aspectJ”。就是说你可以实现基于接口的动态代理，等等强大的功能。而不仅仅是aspectj的 注-解-功-能 ！！！</p><p>如果用full AspectJ。比如说Load-Time Weaving的方式 还 需要额外的jar包 spring-instrument.jar</p><p>当然，无论是使用spring aop还是 aspectj都需要aspectjweaver.jar spring-aop.jar这两个jar包。  </p><p>参考:<a href="https://blog.csdn.net/maerrrr/article/details/78860420" target="_blank" rel="noopener">https://blog.csdn.net/maerrrr/article/details/78860420</a></p><h2 id="理解2"><a href="#理解2" class="headerlink" title="理解2"></a>理解2</h2><p><strong><em>区别</em></strong></p><p>AspectJ</p><p>AspectJ是一个面向切面的框架，它扩展了Java语言。AspectJ定义了<strong>AOP语法</strong>，所以它有一个<strong>专门的编译器</strong>用来生成遵守Java字节编码规范的Class文件。</p><p>spring aop</p><p>Spring提供了四种类型的Aop支持<br>* 基于经典的SpringAOP<br>* 纯POJO切面<br>* @ASpectJ注解驱动的切面<br>* 注入式AspectJ切面（其实与Spring并无多大的关系，这个就是使用AspectJ这个框架实现Aop编程）</p><p>基于经典的SpringAop</p><p>其使用ProxyFactoryBean创建:<br>增强（通知）的类型有：<br>前置通知：org.springframework.aop.MethodBeforeAdvice<br>后置通知：org.springframework.aop.AfterReturningAdvice<br>环绕通知：org.aopalliance.intercept.MethodInterceptor<br>异常通知：org.springframework.aop.ThrowsAdvice</p><p><strong><em>联系</em></strong></p><p>我们借助于Spring Aop的命名空间可以将纯POJO转换为切面，实际上这些POJO只是提供了满足切点的条件时所需要调用的方法，但是，这种技术需要XML进行配置，不能支持注解。</p><p>所以spring借鉴了AspectJ的切面，以提供注解驱动的AOP，本质上它依然是Spring基于代理的AOP，只是编程模型与AspectJ完全一致，这种风格的好处就是不需要使用XML进行配置。</p><p>使用@Aspect方式，你就可以在类上直接一个@Aspect就搞定，不用费事在xml里配了。但是这需要额外的jar包（ aspectjweaver.jar）。因为spring直接使用AspectJ的注解功能，注意只是使用了它 的注解功能而已，并不是核心功能 。SpringAop的底层技术依然是<a href="https://blog.csdn.net/flyfeifei66/article/details/81481222" target="_blank" rel="noopener">Jdk动态代理和Cglib</a>。</p><h2 id="理解3"><a href="#理解3" class="headerlink" title="理解3"></a>理解3</h2><p> AOP(Aspect OrientedProgramming, 面向切面/方面编程) 旨在从业务逻辑中分离出来横切逻辑【eg:性能监控、日志记录、权限控制等】，提高模块化，即通过AOP解决代码耦合问题，让职责更加单一。</p><p> 运用技术：</p><pre><code>SpringAOP使用了两种代理机制，一种是基于JDK的动态代理，另一种是基于CGLib的动态代理，之所以需要两种代理机制，很大程度上是因为JDK本身只提供基于接口的代理，不支持类的代理。</code></pre><p> 切面植入的方法：</p><pre><code>1、编译期织入2、类装载期织入3、动态代理织入----&gt;在运行期为目标类添加增强生成子类的方式，Spring AOP采用动态代理织入切面</code></pre><p>流行的框架：</p><pre><code>AOP现有两个主要的流行框架，即Spring AOP和Spring+AspectJ</code></pre><p>二者的区别：</p><p> 1、织入的时期不同</p><pre><code>Spring Aop采用的动态织入，而Aspectj是静态织入。静态织入：指在编译时期就织入，即：编译出来的class文件，字节码就已经被织入了。动态织入又分静动两种，静则指织入过程只在第一次调用时执行；动则指根据代码动态运行的中间状态来决定如何操作，每次调用Target的时候都执行。有不清楚的同学，可以自己补下基础的代理知识</code></pre><p> 2、从使用对象不同</p><pre><code> Spring AOP的通知是基于该对象是SpringBean对象才可以，而AspectJ可以在任何Java对象上应用通知。Spring AOP：如果你想要在通过this对象调用的方法上应用通知，那么你必须使用currentProxy对象，并调用其上的相应方法;于此相似，如果你想要在某对象的方法上应用通知，那么你必须使用与该对象相应的Spring bean</code></pre><p> AspectJ：使用AspectJ的一个间接局限是，因为AspectJ通知可以应用于POJO之上，它有可能将通知应用于一个已配置的通知之上。对于一个你没有注意到这方面问题的大范围应用的通知，这有可能导致一个无限循环。</p><pre><code>Spring AOP不同于大多数其他AOP框架。Spring AOP的目的并不是为了提供最完整的AOP实现（虽然Spring AOP具有相当的能力）；而是为了要帮助解决企业应用中的常见问题，提供一个AOP实现与Spring IOC之间的紧密集成。由于Spring AOP是容易实现的，如果你计划在Spring Beans之上将横切关注点模块化，Spring的这一目标将是要点之一。但同样的目标也可能成为一个限制，如果你用的是普通的Java对象而不是Spring beans,并基于此将横切关注点模块化的话。另一方面，AspectJ可用于基于普通Java对象的模块化，但在实施之前需要良好的关于这个主题的知识。</code></pre><p>参考：<a href="https://blog.csdn.net/a128953ad/article/details/50509437" target="_blank" rel="noopener">https://blog.csdn.net/a128953ad/article/details/50509437</a></p><h2 id="理解4-推荐查看"><a href="#理解4-推荐查看" class="headerlink" title="理解4(推荐查看)"></a>理解4(推荐查看)</h2><p>Spring AOP and AspectJ</p><p>现在，一起来讨论Spring AOP and AspectJ，跨越多指标，如能力和目标、织入方式、内部结构、连接点和简单性。</p><p><strong>Capabilities and Goals</strong></p><p>简而言之，Spring AOP和AspectJ有不同的目标。<br>Spring AOP旨在通过Spring IoC提供一个简单的AOP实现，以解决编码人员面临的最常出现的问题。这并不是完整的AOP解决方案，它只能用于Spring容器管理的beans。</p><p>另一方面，AspectJ是最原始的AOP实现技术，提供了玩这个的AOP解决方案。AspectJ更为健壮，相对于Spring AOP也显得更为复杂。值得注意的是，AspectJ能够被应用于所有的领域对象。</p><p><strong>Weaving</strong></p><p>AspectJ and Spring AOP使用了不同的织入方式，这影响了他们在性能和易用性方面的行为。<br>AspectJ使用了三种不同类型的织入：</p><ol><li>编译时织入：AspectJ编译器同时加载我们切面的源代码和我们的应用程序，并生成一个织入后的类文件作为输出。</li><li>编译后织入：这就是所熟悉的二进制织入。它被用来编织现有的类文件和JAR文件与我们的切面。</li><li>加载时织入：这和之前的二进制编织完全一样，所不同的是织入会被延后，直到类加载器将类加载到JVM。</li></ol><p>更多关于AspectJ的信息，请见<a href="https://link.juejin.im/?target=http%3A%2F%2Fwww.baeldung.com%2Faspectj" target="_blank" rel="noopener">head on over to this article</a>。</p><p>AspectJ使用的是编译期和类加载时进行织入，Spring AOP利用的是运行时织入。</p><p>运行时织入，在使用目标对象的代理执行应用程序时，编译这些切面（使用JDK动态代理或者CGLIB代理）。</p><p>如果我们分析本节所有的论点，我们就会开始明白，没有绝对的一个框架比另一个框架更好。<br>简而言之，选择很大程度上取决我们的需求：</p><ul><li>框架：如果应用程序不使用Spring框架，那么我们别无选择，只能放弃使用Spring AOP的想法，因为它无法管理任何超出spring容器范围的东西。 但是，如果我们的应用程序完全是使用Spring框架创建的，那么我们可以使用Spring AOP，因为它很直接便于学习和应用。</li><li>灵活性：鉴于有限的连接点支持，Spring AOP并不是一个完整的AOP解决方案，但它解决了程序员面临的最常见的问题。 如果我们想要深入挖掘并利用AOP达到其最大能力，并希望获得来自各种可用连接点的支持，那么AspectJ是最佳选择。</li><li>性能：如果我们使用有限的切面，那么性能差异很小。 但是，有时候应用程序有数万个切面的情况。 在这种情况下，我们不希望使用运行时织入，所以最好选择AspectJ。 已知AspectJ比Spring AOP快8到35倍。</li><li>共同优点：这两个框架是完全兼容的。 我们可以随时利用Spring AOP，并且仍然使用AspectJ来获得前者不支持的连接点。</li></ul><p>参考：<a href="https://www.cnblogs.com/Irving/p/9739889.html" target="_blank" rel="noopener">https://www.cnblogs.com/Irving/p/9739889.html</a></p><h2 id="理解5"><a href="#理解5" class="headerlink" title="理解5"></a>理解5</h2><p><strong>Spring AOP</strong></p><p>在纯 Java 中实现</p><p>不需要单独的编译过程</p><p>只能使用运行时织入</p><p>功能不强-仅支持方法级编织</p><p>只能在由 Spring 容器管理的 bean 上实现</p><p>仅支持方法执行切入点</p><p>代理是由目标对象创建的, 并且切面应用在这些代理上</p><p>比 AspectJ 慢多了</p><p><strong>AspectJ</strong></p><p>使用 Java 编程语言的扩展实现</p><p>除非设置 LTW，否则需要 AspectJ 编译器 (ajc)</p><p>运行时织入不可用。支持编译时、编译后和加载时织入</p><p>更强大 - 可以编织字段、方法、构造函数、静态初始值设定项、最终类/方法等…。</p><p>可以在所有域对象上实现</p><p>支持所有切入点</p><p>在执行应用程序之前 (在运行时) 前, 各方面直接在代码中进行织入</p><p>更好的性能</p><p>原文链接：<a href="https://blog.csdn.net/weixin_42181142/article/details/101212351" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42181142/article/details/101212351</a></p><h1 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h1><p>  我们知道JDK的动态代理是针对接口的，在运行期生成代理类。</p><p>CGLIB动态代理 是可以针对接口与普通类(继承方式),底层使用ASM框架生成字节码完成代理功能</p><p>我在网上查资料说AspectJ是静态代理 在编译期间就生成了class文件完成了代理。这点容易理解一种编译的技术。<br>那么我的问题是</p><p>问题一<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Spring的AOP为什么需要引入aspectjrt-1.6.8.jar与aspectjweaver-1.6.8.jar这两个包?如果是接口直接使用JDK的动态代理,如果是普通类则用cglib不就完了吗?这是我的第一个问题</span><br><span class="line"></span><br><span class="line">问题二</span><br></pre></td></tr></table></figure></p><p>第二个问题是Spring使用aspectjrt-1.6.8.jar与aspectjweaver-1.6.8.jar包 那么是编译期代理 还是 运行期代理 求详细解释</p><p>参考：<a href="https://www.iteye.com/problems/98151" target="_blank" rel="noopener">https://www.iteye.com/problems/98151</a></p><h1 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h1><p>AspectJ是Eclipse基金组织的开源项目，它是Java语言的一个AOP实现，是最早、功能比较强大的AOP实现之一，对整套AOP机制都有较好的实现，很多其他语言的AOP实现也借鉴或者采纳了AspectJ中的很多设计。在Java领域，AspectJ中的很多语法结构基本上已经成为AOP领域的标准。</p><p>要知道的是，AspectJ框架和Spring框架实现AOP的方式是不一样的，AspectJ是在编译时进行增强，所以它有一个专门的编译器ajc来生成遵守Java字节码编码规范的Class文件。而Spring采用的是动态代理的方式，它并不需要有一个专门的编译器。故也称AspectJ为静态AOP实现，而Spring AOP为动态AOP实现。</p><p>AspectJ主要包含两个部分：第一个部分定义了如何表达、定义AOP编程中的语法规范；第二个部分是工具部分，包括编译器、调试工具等。</p><p><strong><em>虽然 AspectJ 很强大，但是跟 lombok不兼容，在编译期间会打架，谁也不认识谁，所以还是放弃吧，老老实实用 AOP</em></strong></p><h1 id="问题3"><a href="#问题3" class="headerlink" title="问题3"></a>问题3</h1><p>基于Aspect Spring AOP 开发<br>Spring AOP 与ApectJ 的目的一致，都是为了统一处理横切业务，但与AspectJ不同的是，Spring AOP 并不尝试提供完整的AOP功能(即使它完全可以实现)，Spring AOP 更注重的是与Spring IOC容器的结合，并结合该优势来解决横切业务的问题，因此在AOP的功能完善方面，相对来说AspectJ具有更大的优势，同时,Spring注意到AspectJ在AOP的实现方式上依赖于特殊编译器(ajc编译器)，因此Spring很机智回避了这点，转向采用动态代理技术的实现原理来构建Spring AOP的内部机制（动态织入），这是与AspectJ（静态织入）最根本的区别。在AspectJ 1.5后，引入@Aspect形式的注解风格的开发，Spring也非常快地跟进了这种方式，因此Spring 2.0后便使用了与AspectJ一样的注解。请注意，Spring 只是使用了与 AspectJ 5 一样的注解，但仍然没有使用 AspectJ 的编译器，底层依是动态代理技术的实现，因此并不依赖于 AspectJ 的编译器</p><p>原文链接：<a href="https://blog.csdn.net/javazejian/article/details/56267036" target="_blank" rel="noopener">https://blog.csdn.net/javazejian/article/details/56267036</a></p><h1 id="对于AspectJ的使用"><a href="#对于AspectJ的使用" class="headerlink" title="对于AspectJ的使用"></a>对于AspectJ的使用</h1><p>Aspect是实现AOP编程的一种具体实现</p><ol><li><strong>编译时织入</strong><br>，利用ajc编译器替代javac编译器，直接将源文件(java或者aspect文件)编译成class文件并将切面织入进代码。</li><li><strong>编译后织入</strong><br>，利用ajc编译器向javac编译期编译后的class文件或jar文件织入切面代码。</li><li><strong>加载时织入</strong>(LTW)<br>，不使用ajc编译器，利用aspectjweaver.jar工具，使用java agent代理在类加载期将切面织入进代码。</li></ol><h2 id="使用LTW方式-加载时编织"><a href="#使用LTW方式-加载时编织" class="headerlink" title="使用LTW方式(加载时编织)"></a>使用LTW方式(加载时编织)</h2><p>前两种织入方法都依赖于ajc的编译工具，LTW却通过java agent机制在内存中操作类文件，可以不需要ajc的支持做到 <strong>动态织入</strong></p><p>不过，这里有一个挺有意思的问题，我们知道编译期一定会编译AnnoAspect类，那么这时候通过切面语法我们就可以找到他要处理的App类，这大概就是编译阶段织入的大概流程。但是如果在类加载期处理的话，当类加载到App类的时候，我们并不知道这个类需要被AnnoAspect处理。。。因此为了实现LTW，我们肯定要有个配置文件，来告诉类加载器，某某某切面需要优先考虑，他们很可能会影响其他的类。</p><p>为了实现LTW，我们需要在资源目录下配置META-INF/aop.xml文件，来告知类加载器我们当前注册的切面。</p><p>在上面的项目中，我们其实只需要创建src/main/resources/META-INF/aop.xml：</p><p>​    </p><p>参考:<a href="https://blog.csdn.net/whatigame/article/details/103173308" target="_blank" rel="noopener">https://blog.csdn.net/whatigame/article/details/103173308</a></p><h1 id="编织方式"><a href="#编织方式" class="headerlink" title="编织方式"></a>编织方式</h1><h3 id="1-1-LTW与不同的切面织入时机"><a href="#1-1-LTW与不同的切面织入时机" class="headerlink" title="1.1 LTW与不同的切面织入时机"></a>1.1 LTW与不同的切面织入时机</h3><p>AOP——面向切面编程,通过为目标类织入切面的方式,实现对目标类功能的增强。按切面被织如到目标类中的时间划分,主要有以下几种:</p><ul><li>1.运行期织入<br>这是最常见的,比如在运行期通过为目标类生成动态代理的方式实现AOP就属于运行期织入,这也是Spring AOP中的默认实现,并且提供了两种创建动态代理的方式:JDK自带的针对接口的动态代理和使用CGLib动态创建子类的方式创建动态代理。</li><li>2.编译期织入<br>使用特殊的编译器在编译期将切面织入目标类,这种比较少见,因为需要特殊的编译器的支持。</li><li>3.类加载期织入<br>通过字节码编辑技术在类加载期将切面织入目标类中,这是本篇介绍的重点。它的核心思想是:在目标类的class文件被JVM加载前,通过自定义类加载器或者类文件转换器将横切逻辑织入到目标类的class文件中,然后将修改后class文件交给JVM加载。这种织入方式可以简称为LTW(LoadTimeWeaving)。</li></ul><h3 id="1-2-JDK实现LTW的原理"><a href="#1-2-JDK实现LTW的原理" class="headerlink" title="1.2 JDK实现LTW的原理"></a>1.2 JDK实现LTW的原理</h3><p>可以使用JKD的代理功能让代理器访问到JVM的底层组件,借此向JVM注册类文件转换器,在类加载时对类文件的字节码进行转换。具体而言,java.lang.instrument包下定义了ClassFileTransformer接口,该接口的作用如下面的注释所描述</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">* An agent provides an implementation of this interface in order</span><br><span class="line">* to transform class files.</span><br><span class="line">* The transformation occurs before the class is defined by the JVM.</span><br></pre></td></tr></table></figure><p>可以通过实现该接口,并重写如下抽象方法自定义类文件转换规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">byte[]</span><br><span class="line">transform(  ClassLoader         loader,</span><br><span class="line">            String              className,</span><br><span class="line">            Class&lt;?&gt;            classBeingRedefined,</span><br><span class="line">            ProtectionDomain    protectionDomain,</span><br><span class="line">            byte[]              classfileBuffer)</span><br><span class="line">    throws IllegalClassFormatException;</span><br></pre></td></tr></table></figure><p>classfileBuffer是原始类文件对应的字节码数组,返回的byte[]为转化后的字节码数组,如果返回null,则表示不进行字节码处理。</p><p>而java.lang.instrument包下的Instrumentation接口则可以将我们自定义的ClassTransFormer向JVM内部的组件进行注册</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">void</span><br><span class="line">addTransformer(ClassFileTransformer transformer);</span><br></pre></td></tr></table></figure><p>在实际使用中,可以通过JVM的-javaagent代理参数在启动时获取JVM内部组件的引用,将ClassFileTransformer实例注册到JVM中,JVM在加载Class文件时,会先调用这个ClassTransformer的transform()方法对Class文件的字节码进行转换,比如织入切面中定义的横切逻辑,实现AOP功能。</p><p>参考：<a href="https://www.cnblogs.com/takumicx/p/10150344.html" target="_blank" rel="noopener">https://www.cnblogs.com/takumicx/p/10150344.html</a></p><h1 id="装载方式"><a href="#装载方式" class="headerlink" title="装载方式"></a>装载方式</h1><p>编译期织入、装载期织入、运行时织入</p><p>  AOP 实现的关键就在于 AOP 框架自动创建的 AOP 代理，AOP 代理则可分为静态代理和动态代理两大类，其中静态代理是指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；而动态代理则在运行时借助于 JDK 动态代理、CGLIB 等在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。<br>       静态代理分为：编译时织入（特殊编译器实现）、类加载时织入（特殊的类加载器实现）。<br>       动态代理有  ：  jdk动态代理（基于接口来实现）、CGlib（基于类实现）。</p><p>编译期织入：指在Java编译期间，采用特殊的编译器，将切面织入到java类中；</p><p>类加载期织入：指通过特殊的类加载器，在类字节码加载到JVM时，织入切面</p><p>运行期织入：采用cglib或者jdk动态代理进行切面织入</p><p>aspectj的三种织入：</p><p>编译期：把aspect类（aop切面）和目标类放在一起用ajc编译器编译</p><p>后编译期：目标类可能已经被打成了一个jar包，这个时候也可以用ajc命令将jar再织入一次</p><p>类加载期(Load-Time Weaving)：</p><p>在JVM加载类字节码文件时，做字节码替换</p><p>其中前两个时间点，可以理解为静态织入，因为在class文件生成后，就已经织入好了。类加载期织入，可以理解为“动态织入”（注意不同于java动态代理的“动态”）,因为这个类替换是在jvm加载类的时候完成的</p><p>原文链接：<a href="https://blog.csdn.net/wenbingoon/article/details/22888619" target="_blank" rel="noopener">https://blog.csdn.net/wenbingoon/article/details/22888619</a></p><h1 id="Spring到底有没有用到AspectJ的实现-结论"><a href="#Spring到底有没有用到AspectJ的实现-结论" class="headerlink" title="Spring到底有没有用到AspectJ的实现(结论)"></a>Spring到底有没有用到AspectJ的实现(结论)</h1><h2 id="如何判断是织入还是代理"><a href="#如何判断是织入还是代理" class="headerlink" title="如何判断是织入还是代理"></a>如何判断是织入还是代理</h2><p>这个问题很有意思，也是非常容易被搞混的，尤其是在讨论spring aop的时候。我们知道spring里有很多基于动态代理的设计，而我们知道动态代理也可以被用作面向切面的编程，但是spring aop本身却支持aspectj的切面语法，而且spring-aop这个包也引用了aspectj，我们知道aspectj是通过织入的方式来实现aop的。。。那么 <strong>spring aop究竟是通过织入还是代理来实现aop的呢</strong>？</p><h2 id="没错就是动态代理"><a href="#没错就是动态代理" class="headerlink" title="没错就是动态代理"></a>没错就是动态代理</h2><p>其实spring aop还是通过 <strong>动态代理</strong><br>来实现aop的，即使不去看他的源码，我们也可以通过简单的实验来得到这个结论。</p><p>根据aspectj的使用方式，我们知道，如果要向代码中织入切面，那么我们要么采用ajc编译，要么使用aspectjweaver的agent代理。但是spring既没有依赖任何aspectjtools的相关jar包，虽然依赖了aspectjweaver这个包，但是并没有添加agent代理。当然，也存在一种可能就是spring利用aspectjweaver这个包自己实现了动态织入，但是从可复用的角度讲，spring真的会自己重新造轮子？如果真的重新造了那为啥不脱离aspectj彻底重新造，而是用一半造一半呢？</p><p>而且，我们知道用织入和用动态代理有一个很大的区别，如果使用织入的话，那么调业务对象的getClass()方法获得的类名就是这个类本身实现的类名；但是如果使用动态代理的话，调用getClass()方法获得的类名就是动态代理类的类名了。做一个简单的实验我们就可以发现，如果我们使用spring aop来对某一个service进行切面处理，那么调用getClass()方法获得的结果就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">com.mythsman.test.Myservice$$EnhancerBySpringCGLIB$$3afc9148</span><br></pre></td></tr></table></figure><p>显然，虽然spring aop采用了aspectj语法来定义切面，但是在实现切面逻辑的时候还是采用CGLIB来进行动态代理的方法。</p><h2 id="强行织入？"><a href="#强行织入？" class="headerlink" title="强行织入？"></a>强行织入？</h2><p>当然，如果我们想，我们也可以强行采用织入的方式，不过我们就不能将切面类注册为spring的bean，并且采用ajc插件编译或者java agent在类加载时织入。</p><p>参考：<a href="https://blog.csdn.net/whatigame/article/details/103173308" target="_blank" rel="noopener">https://blog.csdn.net/whatigame/article/details/103173308</a></p><h2 id="额外说明"><a href="#额外说明" class="headerlink" title="额外说明"></a>额外说明</h2><p>emmm</p><p>在使用spring-test包测试时，也就是整合junit进行测试</p><p>结果使用xml配置的事务出错，原因是找不到aspectjweaver包下的一些类，添加aspectj包即可</p><p>(但是项目正常启动时可以不添加aspectjweaver包的)，，，，，不知道这个测试包怎么。。。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">Caused by: java.lang.IllegalStateException: Failed to introspect Class [org.springframework.aop.aspectj.AspectJExpressionPointcut] from ClassLoader [sun.misc.Launcher$AppClassLoader@18b4aac2]</span><br><span class="line">at org.springframework.util.ReflectionUtils.getDeclaredMethods(ReflectionUtils.java:659)</span><br><span class="line">at org.springframework.util.ReflectionUtils.doWithMethods(ReflectionUtils.java:556)</span><br><span class="line">at org.springframework.util.ReflectionUtils.doWithMethods(ReflectionUtils.java:541)</span><br><span class="line">at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.determineCandidateConstructors(AutowiredAnnotationBeanPostProcessor.java:245)</span><br><span class="line">... 60 more</span><br><span class="line">Caused by: java.lang.NoClassDefFoundError: org/aspectj/weaver/reflect/ReflectionWorld$ReflectionWorldException</span><br><span class="line">at java.lang.Class.getDeclaredMethods0(Native Method)</span><br><span class="line">at java.lang.Class.privateGetDeclaredMethods(Class.java:2701)</span><br><span class="line">at java.lang.Class.getDeclaredMethods(Class.java:1975)</span><br><span class="line">at org.springframework.util.ReflectionUtils.getDeclaredMethods(ReflectionUtils.java:641)</span><br><span class="line">... 63 more</span><br><span class="line">Caused by: java.lang.ClassNotFoundException: org.aspectj.weaver.reflect.ReflectionWorld$ReflectionWorldException</span><br><span class="line">at java.net.URLClassLoader.findClass(URLClassLoader.java:381)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:424)</span><br><span class="line">at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:338)</span><br><span class="line">at java.lang.ClassLoader.loadClass(ClassLoader.java:357)</span><br><span class="line">... 67 more</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringAop与AspectJ是什么&quot;&gt;&lt;a href=&quot;#SpringAop与AspectJ是什么&quot; class=&quot;headerlink&quot; title=&quot;SpringAop与AspectJ是什么&quot;&gt;&lt;/a&gt;SpringAop与AspectJ是什么&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>关于获取Log实例的参数问题</title>
    <link href="http://yoursite.com/2020/04/20/Logging/%E5%85%B3%E4%BA%8E%E8%8E%B7%E5%8F%96Log%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/04/20/Logging/%E5%85%B3%E4%BA%8E%E8%8E%B7%E5%8F%96Log%E5%AE%9E%E4%BE%8B%E7%9A%84%E5%8F%82%E6%95%B0%E9%97%AE%E9%A2%98/</id>
    <published>2020-04-20T00:50:30.000Z</published>
    <updated>2020-04-21T05:52:17.978Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于Log"><a href="#关于Log" class="headerlink" title="关于Log"></a>关于Log</h1><h2 id="org-apache-commons-logging"><a href="#org-apache-commons-logging" class="headerlink" title="org.apache.commons.logging"></a>org.apache.commons.logging</h2><p>​             使用日志一般需要获取一个Log对象,在类中声明一个私有属性Log</p><p>​            private static Log log = LogFactory.getLog(Test.class);</p><h3 id="org-apache-commons-logging-LogFactory"><a href="#org-apache-commons-logging-LogFactory" class="headerlink" title="org.apache.commons.logging.LogFactory"></a>org.apache.commons.logging.LogFactory</h3><p>​            部分代码分析：</p><p>通过静态方法来选择日志实现，默认是LogApi.JUL（JUL:java.util.logging）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public abstract class LogFactory &#123;</span><br><span class="line"></span><br><span class="line">private static LogApi logApi = LogApi.JUL;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">ClassLoader cl = LogFactory.class.getClassLoader();</span><br><span class="line">try &#123;</span><br><span class="line">// Try Log4j 2.x API</span><br><span class="line">cl.loadClass(&quot;org.apache.logging.log4j.spi.ExtendedLogger&quot;);</span><br><span class="line">logApi = LogApi.LOG4J;</span><br><span class="line">&#125;</span><br><span class="line">catch (ClassNotFoundException ex1) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">// Try SLF4J 1.7 SPI</span><br><span class="line">cl.loadClass(&quot;org.slf4j.spi.LocationAwareLogger&quot;);</span><br><span class="line">logApi = LogApi.SLF4J_LAL;</span><br><span class="line">&#125;</span><br><span class="line">catch (ClassNotFoundException ex2) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">// Try SLF4J 1.7 API</span><br><span class="line">cl.loadClass(&quot;org.slf4j.Logger&quot;);</span><br><span class="line">logApi = LogApi.SLF4J;</span><br><span class="line">&#125;</span><br><span class="line">catch (ClassNotFoundException ex3) &#123;</span><br><span class="line">// Keep java.util.logging as default</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//枚举属性</span><br><span class="line">private enum LogApi &#123;LOG4J, SLF4J_LAL, SLF4J, JUL&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​            </p><p>​        </p><p>​        </p><h2 id="getLog中的参数测试"><a href="#getLog中的参数测试" class="headerlink" title="getLog中的参数测试"></a>getLog中的参数测试</h2><h3 id="测试所用日志maven依赖"><a href="#测试所用日志maven依赖" class="headerlink" title="测试所用日志maven依赖"></a>测试所用日志maven依赖</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- junit测试 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">    &lt;scope&gt;test&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- https://mvnrepository.com/artifact/commons-logging/commons-logging --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-logging&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-logging&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.6.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.slf4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.6.6&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;log4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.2.16&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h3 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package log;</span><br><span class="line"></span><br><span class="line">import org.apache.commons.logging.Log;</span><br><span class="line">import org.apache.commons.logging.LogFactory;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 关于日志的测试</span><br><span class="line"> *  本次测试使用的commons-logging作为日志门面</span><br><span class="line"> *     如果有Log4j，commons-logging的LogFactory初始化静态方法会自动选择日志实现</span><br><span class="line"> *         LogFactory中的枚举属性:private enum LogApi &#123;LOG4J, SLF4J_LAL, SLF4J, JUL&#125;</span><br><span class="line"> *            JUL: java.util.logging(JDK自带的Logging其实是一个鸡肋，竟然没有debug的日志级别,没测试过)</span><br><span class="line"> *            log4j:只要我们在项目中添加了log4j的jar包，那么commons-logging就会自动切到log4j的日志输出。</span><br><span class="line"> *                 log4j必须要有log4j.properties</span><br><span class="line"> * @author Momentonly</span><br><span class="line"> * @date 2020/4/20</span><br><span class="line"> */</span><br><span class="line">public class LogTest &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="log4j的配置文件"><a href="#log4j的配置文件" class="headerlink" title="log4j的配置文件"></a>log4j的配置文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># Global logging configuration</span><br><span class="line">log4j.rootLogger=DEBUG, stdout</span><br><span class="line"></span><br><span class="line">#设置包级别的日志</span><br><span class="line">#log4j.logger.log=DEBUG</span><br><span class="line"></span><br><span class="line"># Console output...</span><br><span class="line">log4j.appender.stdout=org.apache.log4j.ConsoleAppender</span><br><span class="line">log4j.appender.stdout.layout=org.apache.log4j.PatternLayout</span><br><span class="line">log4j.appender.stdout.layout.ConversionPattern=%5p [%t] %l  - %m%n</span><br></pre></td></tr></table></figure><h3 id="测试方法1"><a href="#测试方法1" class="headerlink" title="测试方法1"></a>测试方法1</h3><p>getLog传递一个本类的Class对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//获取一个日志对象</span><br><span class="line">   private static Log log = LogFactory.getLog(LogTest.class);</span><br><span class="line"></span><br><span class="line">   @Test</span><br><span class="line">   public void test1()&#123;</span><br><span class="line">       log.debug(&quot;debug()...&quot;);</span><br><span class="line">       log.info(&quot;start...&quot;);</span><br><span class="line">       log.warn(&quot;end.&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>打印:</p><p> DEBUG [main] log.LogTest.test1(LogTest.java:26)  - debug()…<br> INFO [main] log.LogTest.test1(LogTest.java:27)  - start…<br> WARN [main] log.LogTest.test1(LogTest.java:28)  - end.</p><h3 id="测试方法2"><a href="#测试方法2" class="headerlink" title="测试方法2"></a>测试方法2</h3><p>getLog传递一个字符串参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//获取一个日志对象</span><br><span class="line">   private static Log log = LogFactory.getLog(&quot;这是一个测试类&quot;);</span><br><span class="line"></span><br><span class="line">   @Test</span><br><span class="line">   public void test2()&#123;</span><br><span class="line">       log.debug(&quot;debug()...&quot;);</span><br><span class="line">       log.info(&quot;start...&quot;);</span><br><span class="line">       log.warn(&quot;end.&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>打印：</p><p>DEBUG [main] log.LogTest.test2(LogTest.java:32)  - debug()…<br> INFO [main] log.LogTest.test2(LogTest.java:33)  - start…<br> WARN [main] log.LogTest.test2(LogTest.java:34)  - end.</p><h3 id="测试方法3"><a href="#测试方法3" class="headerlink" title="测试方法3"></a>测试方法3</h3><p>​    getLog传递任意一个Class参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//获取一个日志对象</span><br><span class="line">   private static Log log = LogFactory.getLog(Object.class);</span><br><span class="line"></span><br><span class="line">   @Test</span><br><span class="line">   public void test3()&#123;</span><br><span class="line">       log.debug(&quot;debug()...&quot;);</span><br><span class="line">       log.info(&quot;start...&quot;);</span><br><span class="line">       log.warn(&quot;end.&quot;);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>打印：</p><p>DEBUG [main] log.LogTest.test3(LogTest.java:25)  - debug()…</p><p> INFO [main] log.LogTest.test3(LogTest.java:26)  - start…<br> WARN [main] log.LogTest.test3(LogTest.java:27)  - end.</p><h3 id="测试1-2-3方法总结"><a href="#测试1-2-3方法总结" class="headerlink" title="测试1,2,3方法总结"></a>测试1,2,3方法总结</h3><p>​    发现打印结果的追踪类并没有因为getLog的参数不同而发生改变</p><h3 id="测试方法4"><a href="#测试方法4" class="headerlink" title="测试方法4"></a>测试方法4</h3><p>修改log4j配置文件，关闭日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">log4j.rootLogger=OFF, stdout</span><br></pre></td></tr></table></figure><p>测试方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//获取一个日志对象</span><br><span class="line">    private static Log log = LogFactory.getLog(Object.class);</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test4()&#123;</span><br><span class="line">        log.debug(&quot;debug()...&quot;);</span><br><span class="line">        log.info(&quot;start...&quot;);</span><br><span class="line">        log.warn(&quot;end.&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>没有任何输出</p><h3 id="测试方法5"><a href="#测试方法5" class="headerlink" title="测试方法5"></a>测试方法5</h3><p>修改log4j配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log4j.rootLogger=OFF, stdout</span><br><span class="line">#设置包级别的输出</span><br><span class="line">log4j.logger.java.lang=DEBUG</span><br></pre></td></tr></table></figure><p>测试方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//获取一个日志对象</span><br><span class="line">    private static Log log = LogFactory.getLog(Object.class);</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void test5()&#123;</span><br><span class="line">        log.debug(&quot;debug()...&quot;);</span><br><span class="line">        log.info(&quot;start...&quot;);</span><br><span class="line">        log.warn(&quot;end.&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">DEBUG [main] log.LogTest.test5(LogTest.java:25)  - debug()...</span><br><span class="line"> INFO [main] log.LogTest.test5(LogTest.java:26)  - start...</span><br><span class="line"> WARN [main] log.LogTest.test5(LogTest.java:27)  - end.</span><br></pre></td></tr></table></figure><h3 id="测试4-5方法总结"><a href="#测试4-5方法总结" class="headerlink" title="测试4,5方法总结"></a>测试4,5方法总结</h3><p><strong><em>getLog中的参数不会使调用该日志的类(追踪类)发生改变</em></strong></p><p><strong><em>但是，该参数是Class对象，可以设置包，类，方法级别来定义log4j的输出</em></strong></p><p>(例如在mybatis中通过日志打印sql就设置包级别为你的接口包就可以，但是</p><p>打印的日志追踪类却不是你的接口实现类)</p><h1 id="log4j2"><a href="#log4j2" class="headerlink" title="log4j2"></a>log4j2</h1><p><strong>Log4j2简介</strong></p><p>log4j2是log4j 1.x 的升级版，2015年5月，Apache宣布log4j1.x 停止更新。最新版为1.2.17。</p><p>log4j2参考了logback的一些优秀的设计，并且修复了一些问题，因此带来了一些重大的提升，主要有：</p><p>1、异常处理：在logback中，Appender中的异常不会被应用感知到，但是在log4j2中，提供了一些异常处理机制。</p><p>2、性能提升：log4j2相较于log4j 1和logback都具有很明显的性能提升。</p><p>3、自动重载配置：参考了logback的设计，提供自动刷新参数配置，可以动态的修改日志的级别而不需要重启应用。</p><p>4、无垃圾机制，log4j2在大部分情况下，都可以使用其设计的一套无垃圾机制，避免频繁的日志收集导致的jvm gc。</p><h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>引入依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--添加log4j2相关jar包--&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j-api&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;log4j-core&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.7&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><p>配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;configuration status=&quot;error&quot;&gt;</span><br><span class="line">    &lt;!--先定义所有的appender --&gt;</span><br><span class="line">    &lt;appenders&gt;</span><br><span class="line">        &lt;!--这个输出控制台的配置 --&gt;</span><br><span class="line">        &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt;</span><br><span class="line">            &lt;!--             控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch） --&gt;</span><br><span class="line">            &lt;ThresholdFilter level=&quot;trace&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;</span><br><span class="line">            &lt;!--             这个都知道是输出日志的格式 --&gt;</span><br><span class="line">            &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt;</span><br><span class="line">        &lt;/Console&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用 --&gt;</span><br><span class="line">        &lt;!--append为TRUE表示消息增加到指定文件中，false表示消息覆盖指定的文件内容，默认值是true --&gt;</span><br><span class="line">        &lt;File name=&quot;log&quot; fileName=&quot;D:/logs/log4j2.log&quot; append=&quot;false&quot;&gt;</span><br><span class="line">            &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt;</span><br><span class="line">        &lt;/File&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;!--添加过滤器ThresholdFilter,可以有选择的输出某个级别以上的类别  onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;意思是匹配就接受,否则直接拒绝  --&gt;</span><br><span class="line">        &lt;File name=&quot;ERROR&quot; fileName=&quot;D:/logs/error.log&quot;&gt;</span><br><span class="line">            &lt;ThresholdFilter level=&quot;error&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt;</span><br><span class="line">            &lt;PatternLayout pattern=&quot;%d&#123;yyyy.MM.dd &apos;at&apos; HH:mm:ss z&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt;</span><br><span class="line">        &lt;/File&gt;</span><br><span class="line"> </span><br><span class="line">        &lt;!--这个会打印出所有的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档 --&gt;</span><br><span class="line">        &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;D:/logs/web.log&quot;</span><br><span class="line">                     filePattern=&quot;logs/$$&#123;date:yyyy-MM&#125;/web-%d&#123;MM-dd-yyyy&#125;-%i.log.gz&quot;&gt;</span><br><span class="line">            &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd &apos;at&apos; HH:mm:ss z&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt;</span><br><span class="line">            &lt;SizeBasedTriggeringPolicy size=&quot;2MB&quot;/&gt;</span><br><span class="line">        &lt;/RollingFile&gt;</span><br><span class="line">    &lt;/appenders&gt;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">    &lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效 --&gt;</span><br><span class="line">    &lt;loggers&gt;</span><br><span class="line">        &lt;root level=&quot;trace&quot;&gt;</span><br><span class="line">            &lt;appender-ref ref=&quot;RollingFile&quot;/&gt;</span><br><span class="line">            &lt;appender-ref ref=&quot;Console&quot;/&gt;</span><br><span class="line">            &lt;appender-ref ref=&quot;ERROR&quot; /&gt;</span><br><span class="line">            &lt;appender-ref ref=&quot;log&quot;/&gt;</span><br><span class="line">        &lt;/root&gt;</span><br><span class="line">    &lt;/loggers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><p>测试类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import org.apache.logging.log4j.LogManager;</span><br><span class="line">import org.apache.logging.log4j.Logger;</span><br><span class="line"> </span><br><span class="line">public class log4j2Test &#123;</span><br><span class="line"> </span><br><span class="line">    private static Logger logger= LogManager.getLogger(LogManager.ROOT_LOGGER_NAME);</span><br><span class="line"> </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        for(int i=0;i&lt;3;i++)&#123;</span><br><span class="line">            // 记录trace级别的信息</span><br><span class="line">            logger.trace(&quot;log4j2日志输出：This is trace message.&quot;);</span><br><span class="line">            // 记录debug级别的信息</span><br><span class="line">            logger.debug(&quot;log4j2日志输出：This is debug message.&quot;);</span><br><span class="line">            // 记录info级别的信息</span><br><span class="line">            logger.info(&quot;log4j2日志输出：This is info message.&quot;);</span><br><span class="line">            // 记录error级别的信息</span><br><span class="line">            logger.error(&quot;log4j2日志输出：This is error message.&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="log4j2配置说明"><a href="#log4j2配置说明" class="headerlink" title="log4j2配置说明"></a>log4j2配置说明</h2><p>log4j 2.x版本不再支持像1.x中的.properties后缀的文件配置方式，2.x版本常用.xml后缀的文件进行配置，除此之外还包含.json和.jsn配置文件</p><p>log4j2虽然采用xml风格进行配置，依然包含三个组件,分别是 Logger(记录器)、Appender(输出目的地)、Layout(日志布局)。</p><p>XML配置文件解析</p><p>1、根节点Configuration有两个属性:status和monitorinterval,有两个子节点:Appenders和Loggers(表明可以定义多个Appender和Logger).</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">status用来指定log4j本身的打印日志的级别.</span><br><span class="line">monitorinterval为log4j 2.x新特点自动重载配置。指定自动重新配置的监测间隔时间，单位是s,最小是5s。</span><br></pre></td></tr></table></figure><p>2、Appenders节点，常见的有三种子节点:Console、File、RollingFile</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Console节点用来定义输出到控制台的Appender.</span><br><span class="line">File节点用来定义输出到指定位置的文件的Appender.</span><br><span class="line">RollingFile节点用来定义超过指定大小自动删除旧的创建新的的Appender.</span><br></pre></td></tr></table></figure><p>通过在子节点中加入\<patternlayout pattern="自定义信息格式">进行日志布局</patternlayout></p><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">%c 输出所属类的全名，可写为 %c&#123;Num&#125; ,Num类名输出的范围 如：&quot;com.sun.aaa.classB&quot;,%C&#123;2&#125;将使日志输出输出范围为：aaa.classB</span><br><span class="line">%d 输出日志时间其格式为 可指定格式 如 %d&#123;HH:mm:ss&#125;等</span><br><span class="line">%l 输出日志事件发生位置，包括类目名、发生线程，在代码中的行数</span><br><span class="line">%n 换行符</span><br><span class="line">%m 输出代码指定信息，如info(“message”),输出message</span><br><span class="line">%p 输出日志的优先级，即 FATAL ,ERROR 等</span><br><span class="line">%r 输出从启动到显示该条日志信息所耗费的时间（毫秒数）</span><br><span class="line">%t 输出产生该日志事件的线程名</span><br></pre></td></tr></table></figure><p><a href="javascript:void(0" target="_blank" rel="noopener"><img src="https://common.cnblogs.com/images/copycode.gif" alt="复制代码"></a>;)</p><p>3、Loggers节点，常见的有两种:Root和Logger.</p><p>Root节点用来指定项目的根日志，如果没有单独指定Logger，那么就会默认使用该Root日志输出</p><p>Logger节点用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等。</p><p><strong>logback log4j log4j2 性能实测</strong></p><p><a href="https://blog.souche.com/content/images/2016/12/-----2016-12-05---10.25.26.png" target="_blank" rel="noopener"><img src="https://blog.souche.com/content/images/2016/12/-----2016-12-05---10.25.26.png" alt="img"></a></p><p>可见在同步日志模式下, Logback的性能是最糟糕的</p><p>而log4j2的性能无论在同步日志模式还是异步日志模式下都是最佳的</p><p>参考：<a href="https://www.cnblogs.com/LemonFive/p/10737658.html" target="_blank" rel="noopener">https://www.cnblogs.com/LemonFive/p/10737658.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于Log&quot;&gt;&lt;a href=&quot;#关于Log&quot; class=&quot;headerlink&quot; title=&quot;关于Log&quot;&gt;&lt;/a&gt;关于Log&lt;/h1&gt;&lt;h2 id=&quot;org-apache-commons-logging&quot;&gt;&lt;a href=&quot;#org-apache-comm
      
    
    </summary>
    
    
      <category term="Logging" scheme="http://yoursite.com/categories/Logging/"/>
    
    
      <category term="log" scheme="http://yoursite.com/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>浏览器跨域</title>
    <link href="http://yoursite.com/2020/04/16/Web/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F/"/>
    <id>http://yoursite.com/2020/04/16/Web/%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B7%A8%E5%9F%9F/</id>
    <published>2020-04-16T12:55:11.000Z</published>
    <updated>2020-04-17T07:33:29.253Z</updated>
    
    <content type="html"><![CDATA[<h1 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h1><h2 id="跨域的本质"><a href="#跨域的本质" class="headerlink" title="跨域的本质"></a>跨域的本质</h2><p>浏览器有一个很重要的概念——同源策略(<strong>Same-Origin Policy</strong>)。所谓同源是指，<strong>域名，协议，端口相同</strong>。不同源的客户端脚本(javascript、ActionScript)在没明确授权的情况下，不能读写对方的资源。</p><p>​    </p><p>但是，form表单提交，img,script标签没有跨域问题，但ajax提交存在跨域问题。</p><p>浏览器的策略本质是：一个域名下面的JS，没有经过允许是不能读取另外一个域名的内容，但是浏览器不阻止你向另外一个域名发送请求。</p><p>所以form表单提交没有跨域问题，提交form表单到另外一个域名，原来页面是无法获取新页面的内容，或者说form提交后不需要返回，但是ajax是需要返回的。</p><p>而ajax是想要读取响应内容，浏览器是不允许你这么做的。</p><p>世界本无跨域，是浏览器不允许js访问别的域，但是浏览器却没有限制自己，img标签和script标签都是可以加载其他域的图片或者js文件。这不就是jsonp的跨域嘛，利用浏览器的历史兼容性。</p><p>浏览器的安全策略限制的是js脚本，并不限制src，form表单提交之类的请求。就是说form表单提交不存在安全问题，ajax提交跨域存在安全问题。</p><p>参考：<a href="https://www.cnblogs.com/tangjiao/p/9951477.html" target="_blank" rel="noopener">https://www.cnblogs.com/tangjiao/p/9951477.html</a></p><h2 id="解决跨域方案"><a href="#解决跨域方案" class="headerlink" title="解决跨域方案"></a>解决跨域方案</h2><h3 id="jsonp"><a href="#jsonp" class="headerlink" title="jsonp"></a>jsonp</h3><h4 id="jsonp原理"><a href="#jsonp原理" class="headerlink" title="jsonp原理"></a>jsonp原理</h4><p>​    我们知道，img,script,这种标签如果有相应的src，那么便会发起一个htttp请求来请求相应的资源,如果有script标签对应的路径是一个js文件，那么在下载完毕这个js之后会马上执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;www.somewhere.com/test.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!--此时会发起一个请求来获取test.js，下载完成之后会立即执行test.js--&gt;</span><br></pre></td></tr></table></figure><p>假设我们需要从’<a href="http://www.localhost.com’发起一个获取数据的请求’www.somewhere.com/getdata’,如果有我们以ajax来发起请求，那么由于浏览器同源保护策略的限制，该请求的返回值不会被浏览器所接受，这就是跨域问题。但是script这种标签会发起一个get请求，并且这个请求是不受同源策略限制的，如果有我们将’www.somewhere.com/getdata’以script标签来发送变成如下请求方式，那么是不是就不会有跨域问题了" target="_blank" rel="noopener">www.localhost.com’发起一个获取数据的请求’www.somewhere.com/getdata’,如果有我们以ajax来发起请求，那么由于浏览器同源保护策略的限制，该请求的返回值不会被浏览器所接受，这就是跨域问题。但是script这种标签会发起一个get请求，并且这个请求是不受同源策略限制的，如果有我们将’www.somewhere.com/getdata’以script标签来发送变成如下请求方式，那么是不是就不会有跨域问题了</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=&quot;text/javascript&quot; src=&quot;www.somewhere.com/getdata&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;!--需要这样一个script来发起get请求--&gt;</span><br></pre></td></tr></table></figure><p>答案是肯定的，这也是jsonp跨域的原理(因此也只能是get请求)。</p><h4 id="jsonp的缺点"><a href="#jsonp的缺点" class="headerlink" title="jsonp的缺点"></a>jsonp的缺点</h4><ul><li><ul><li>只能发送get请求。因为script只能发送get请求</li><li>需要后台配合。此种请求方式应该前后端配合，将返回结果包装成callback(result)的形式。</li></ul></li></ul><p>参考：<a href="https://www.cnblogs.com/willing-shang/p/6719875.html" target="_blank" rel="noopener">https://www.cnblogs.com/willing-shang/p/6719875.html</a></p><h4 id="json的一些实践"><a href="#json的一些实践" class="headerlink" title="json的一些实践"></a>json的一些实践</h4><p>参考：<a href="https://blog.csdn.net/zezezuiaiya/article/details/79158548" target="_blank" rel="noopener">https://blog.csdn.net/zezezuiaiya/article/details/79158548</a></p><h3 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h3><p>规范化的跨域请求解决方案，安全可靠。</p><p>优势：</p><ul><li>在服务端进行控制是否允许跨域，可自定义规则</li><li>支持各种请求方式</li></ul><p>缺点：</p><ul><li>会产生额外的请求</li></ul><p>参考：<a href="https://www.jianshu.com/p/98d4bc7565b2" target="_blank" rel="noopener">https://www.jianshu.com/p/98d4bc7565b2</a></p><h3 id="httpclient服务端代理"><a href="#httpclient服务端代理" class="headerlink" title="httpclient服务端代理"></a>httpclient服务端代理</h3><p>​    通过服务端使用httpclient代理发送请求解决跨域（因为跨域是浏览器的限制）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;跨域&quot;&gt;&lt;a href=&quot;#跨域&quot; class=&quot;headerlink&quot; title=&quot;跨域&quot;&gt;&lt;/a&gt;跨域&lt;/h1&gt;&lt;h2 id=&quot;跨域的本质&quot;&gt;&lt;a href=&quot;#跨域的本质&quot; class=&quot;headerlink&quot; title=&quot;跨域的本质&quot;&gt;&lt;/a&gt;跨域的本
      
    
    </summary>
    
    
      <category term="web" scheme="http://yoursite.com/categories/web/"/>
    
    
      <category term="跨域" scheme="http://yoursite.com/tags/%E8%B7%A8%E5%9F%9F/"/>
    
  </entry>
  
  <entry>
    <title>Springmvc注解驱动</title>
    <link href="http://yoursite.com/2020/04/15/Spring/springmvc%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8/"/>
    <id>http://yoursite.com/2020/04/15/Spring/springmvc%E6%B3%A8%E8%A7%A3%E9%A9%B1%E5%8A%A8/</id>
    <published>2020-04-15T07:45:59.000Z</published>
    <updated>2020-04-15T10:51:58.541Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Springmvc注解驱动"><a href="#Springmvc注解驱动" class="headerlink" title="Springmvc注解驱动"></a>Springmvc注解驱动</h1><h2 id="注解驱动的解析"><a href="#注解驱动的解析" class="headerlink" title="注解驱动的解析"></a>注解驱动的解析</h2><p>​    通过查看 spring-webmvc-xxx.jar 下的spring.handlers文件可以发现 mvc前缀的标签都是由 MvcNamespaceHandler 来进行解析的。</p><p>spring.handlers</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http\://www.springframework.org/schema/mvc=org.springframework.web.servlet.config.MvcNamespaceHandler</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class MvcNamespaceHandler extends NamespaceHandlerSupport &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void init() &#123;</span><br><span class="line">registerBeanDefinitionParser(&quot;annotation-driven&quot;, new AnnotationDrivenBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(&quot;default-servlet-handler&quot;, new DefaultServletHandlerBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(&quot;interceptors&quot;, new InterceptorsBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(&quot;resources&quot;, new ResourcesBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(&quot;view-controller&quot;, new ViewControllerBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(&quot;redirect-view-controller&quot;, new ViewControllerBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(&quot;status-controller&quot;, new ViewControllerBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(&quot;view-resolvers&quot;, new ViewResolversBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(&quot;tiles-configurer&quot;, new TilesConfigurerBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(&quot;freemarker-configurer&quot;, new FreeMarkerConfigurerBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(&quot;groovy-configurer&quot;, new GroovyMarkupConfigurerBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(&quot;script-template-configurer&quot;, new ScriptTemplateConfigurerBeanDefinitionParser());</span><br><span class="line">registerBeanDefinitionParser(&quot;cors&quot;, new CorsBeanDefinitionParser());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过查看其内部唯一的方法 init() 的实现可以确定 &lt;mvc:annotation-driven /&gt; 的解析工作是由 AnnotationDrivenBeanDefinitionParser 类全权负责的。其实现了BeanDefinitionParser接口</p><p>唯一的parse()方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class AnnotationDrivenBeanDefinitionParser implements BeanDefinitionParser &#123;</span><br><span class="line"></span><br><span class="line">public static final String HANDLER_MAPPING_BEAN_NAME = RequestMappingHandlerMapping.class.getName();</span><br><span class="line"></span><br><span class="line">public static final String HANDLER_ADAPTER_BEAN_NAME = RequestMappingHandlerAdapter.class.getName();</span><br><span class="line"></span><br><span class="line">//....省略其他属性</span><br><span class="line"></span><br><span class="line">public BeanDefinition parse(Element element, ParserContext parserContext) &#123;</span><br><span class="line"></span><br><span class="line">//.....省略代码</span><br><span class="line"></span><br><span class="line">//此处注册组件</span><br><span class="line">parserContext.registerComponent(new BeanComponentDefinition(handlerMappingDef, HANDLER_MAPPING_BEAN_NAME)); //注册RequestMappingHandlerMapping</span><br><span class="line">parserContext.registerComponent(new BeanComponentDefinition(handlerAdapterDef, HANDLER_ADAPTER_BEAN_NAME)); //注册REquestMappingHandlerAdapter</span><br><span class="line">parserContext.registerComponent(new BeanComponentDefinition(uriCompContribDef, uriCompContribName));</span><br><span class="line">parserContext.registerComponent(new BeanComponentDefinition(exceptionResolver, methodExceptionResolverName));</span><br><span class="line">parserContext.registerComponent(new BeanComponentDefinition(statusExceptionResolver, statusExResolverName));</span><br><span class="line">parserContext.registerComponent(new BeanComponentDefinition(defaultExceptionResolver, defaultExResolverName));</span><br><span class="line">parserContext.registerComponent(new BeanComponentDefinition(mappedCsInterceptorDef, mappedInterceptorName));</span><br><span class="line"></span><br><span class="line">// Ensure BeanNameUrlHandlerMapping (SPR-8289) and default HandlerAdapters are not &quot;turned off&quot;</span><br><span class="line">MvcNamespaceUtils.registerDefaultComponents(parserContext, source);</span><br><span class="line"></span><br><span class="line">parserContext.popAndRegisterContainingComponent();</span><br><span class="line"></span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察该类对所继承接口的实现可以发现:</p><p>​    向SpringMVC容器中注册了 ContentNegotiationManagerFactoryBean<br>​    向SpringMVC容器中注册了 RequestMappingHandlerMapping (间接实现了HandlerMapping接口), order为0<br>​    向SpringMVC容器中注册了 RequestMappingHandlerAdapter (间接实现了HandlerAdapter接口，直接实现了        InitializingBean接口，关于这个接口的实现，参见本人的另外一篇博客)<br>​    向SpringMVC容器中注册了 MappedInterceptor<br>​    向SpringMVC容器中注册了 ExceptionHandlerExceptionResolver (间接实现了HandlerExceptionResolver接口),     order为0<br>​    向SpringMVC容器中注册了 ResponseStatusExceptionResolver (间接实现了HandlerExceptionResolver接口),   order为1<br>​    向SpringMVC容器中注册了 DefaultHandlerExceptionResolver (间接实现了HandlerExceptionResolver接口), order为2</p><h2 id="RequestMappingHandlerMapping"><a href="#RequestMappingHandlerMapping" class="headerlink" title="RequestMappingHandlerMapping"></a>RequestMappingHandlerMapping</h2><h3 id="继承结构"><a href="#继承结构" class="headerlink" title="继承结构"></a>继承结构</h3><p>public class <strong>RequestMappingHandlerMapping</strong> extends RequestMappingInfoHandlerMapping</p><p>​    public abstract class <strong>RequestMappingInfoHandlerMapping</strong> extends     AbstractHandlerMethodMapping</p><p>​    public abstract class <strong>AbstractHandlerMethodMapping</strong>\&lt;T> extends AbstractHandlerMapping implements <strong>InitializingBean</strong>    </p><h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><h4 id="初始化接口"><a href="#初始化接口" class="headerlink" title="初始化接口"></a>初始化接口</h4><p>​    该类实现了InitializingBean接口，因此初始化bean时会调用afterPropertiesSet()方法    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public interface InitializingBean &#123;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Invoked by a BeanFactory after it has set all bean properties supplied</span><br><span class="line"> * (and satisfied BeanFactoryAware and ApplicationContextAware).</span><br><span class="line"> * &lt;p&gt;This method allows the bean instance to perform initialization only</span><br><span class="line"> * possible when all bean properties have been set and to throw an</span><br><span class="line"> * exception in the event of misconfiguration.</span><br><span class="line"> * @throws Exception in the event of misconfiguration (such</span><br><span class="line"> * as failure to set an essential property) or if initialization fails.</span><br><span class="line"> */</span><br><span class="line">void afterPropertiesSet() throws Exception;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>InitializingBean接口为bean提供了初始化方法的方式，它只包括afterPropertiesSet方法，凡是继承该接口的类，在初始化bean的时候都会执行该方法。</p><p>补充说明：</p><p>1、Spring为bean提供了两种初始化bean的方式，实现InitializingBean接口，实现afterPropertiesSet方法，或者在配置文件中通过init-method指定，两种方式可以同时使用。</p><p>2、实现InitializingBean接口是直接调用afterPropertiesSet方法，比通过反射调用init-method指定的方法效率要高一点，但是init-method方式消除了对spring的依赖。</p><p>3、如果调用afterPropertiesSet方法时出错，则不调用init-method指定的方法。</p><p>参考：<a href="https://www.cnblogs.com/weiqihome/p/8922937.html" target="_blank" rel="noopener">https://www.cnblogs.com/weiqihome/p/8922937.html</a></p><h4 id="具体实现接口"><a href="#具体实现接口" class="headerlink" title="具体实现接口"></a>具体实现接口</h4><p>1）public abstract class <strong>AbstractHandlerMethodMapping</strong>该类实现了InitializingBean的afterPropertiesSet()方法</p><p>AbstractHandlerMethodMapping—&gt;afterPropertiesSet()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void afterPropertiesSet() &#123;</span><br><span class="line">initHandlerMethods();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用了initHandlerMethods();</p><p>2）AbstractHandlerMethodMapping–&gt;initHandlerMethods();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Scan beans in the ApplicationContext, detect and register handler methods.</span><br><span class="line"> * @see #isHandler(Class)</span><br><span class="line"> * @see #getMappingForMethod(Method, Class)</span><br><span class="line"> * @see #handlerMethodsInitialized(Map)</span><br><span class="line"> */</span><br><span class="line">protected void initHandlerMethods() &#123;</span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(&quot;Looking for request mappings in application context: &quot; + getApplicationContext());</span><br><span class="line">&#125;</span><br><span class="line">//获取容器中的bean名</span><br><span class="line">String[] beanNames = (this.detectHandlerMethodsInAncestorContexts ?</span><br><span class="line">BeanFactoryUtils.beanNamesForTypeIncludingAncestors(obtainApplicationContext(), Object.class) :</span><br><span class="line">obtainApplicationContext().getBeanNamesForType(Object.class));</span><br><span class="line"></span><br><span class="line">//遍历</span><br><span class="line">for (String beanName : beanNames) &#123;</span><br><span class="line">if (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123;</span><br><span class="line">Class&lt;?&gt; beanType = null;</span><br><span class="line">try &#123;</span><br><span class="line">//根据bean名获取该bean的类型(Class)</span><br><span class="line">beanType = obtainApplicationContext().getType(beanName);</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">// An unresolvable bean type, probably from a lazy bean - let&apos;s ignore it.</span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(&quot;Could not resolve target class for bean with name &apos;&quot; + beanName + &quot;&apos;&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">// isHandler在AbstractHandlerMethodMapping&lt;T&gt;类中抽象方法; </span><br><span class="line">//判断是否是一个Handler</span><br><span class="line">if (beanType != null &amp;&amp; isHandler(beanType)) &#123;</span><br><span class="line">//检测Handler中的方法</span><br><span class="line">detectHandlerMethods(beanName);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">handlerMethodsInitialized(getHandlerMethods());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）String[] beanNames获取容器中的bean名称,然后对bean进行遍历</p><p>4）isHandler()方法</p><p>RequestMappingHandlerMapping类对父类AbstractHandlerMethodMapping\&lt;T>类的实现</p><p>RequestMappingHandlerMapping——–&gt;isHandler</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected boolean isHandler(Class&lt;?&gt; beanType) &#123;</span><br><span class="line">return (AnnotatedElementUtils.hasAnnotation(beanType, Controller.class) ||</span><br><span class="line">AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.class));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：</p><p>​        判断该Bean是否属于Handler</p><p>​        判断依据：是否有Controller注解  ，或者是否有RequestMapping注解</p><p>返回一个boolean类型</p><p>5）如果是一个Handler,则执行 ————- detectHandlerMethods(beanName)</p><p>AbstractHandlerMethodMapping–&gt;detectHandlerMethods(beanName)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Look for handler methods in a handler.</span><br><span class="line"> * @param handler the bean name of a handler or a handler instance</span><br><span class="line"> */</span><br><span class="line">protected void detectHandlerMethods(final Object handler) &#123;</span><br><span class="line">Class&lt;?&gt; handlerType = (handler instanceof String ?</span><br><span class="line">obtainApplicationContext().getType((String) handler) : handler.getClass());</span><br><span class="line"></span><br><span class="line">if (handlerType != null) &#123;</span><br><span class="line">final Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType);</span><br><span class="line">Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">(MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;</span><br><span class="line">try &#123;</span><br><span class="line">//获取映射方法</span><br><span class="line">return getMappingForMethod(method, userType);</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">throw new IllegalStateException(&quot;Invalid mapping on handler class [&quot; +</span><br><span class="line">userType.getName() + &quot;]: &quot; + method, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(methods.size() + &quot; request handler methods found on &quot; + userType + &quot;: &quot; + methods);</span><br><span class="line">&#125;</span><br><span class="line">for (Map.Entry&lt;Method, T&gt; entry : methods.entrySet()) &#123;</span><br><span class="line">Method invocableMethod = AopUtils.selectInvocableMethod(entry.getKey(), userType);</span><br><span class="line">T mapping = entry.getValue();</span><br><span class="line">registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>该方法检测Handler（一个Controller）中的方法并进行注册</strong></p><p>该方法主要代码分析：（没有详细分析，下次分析）</p><p>​    1）获取userType中的映射方法放入Map集合中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType,</span><br><span class="line">(MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123;</span><br><span class="line">try &#123;</span><br><span class="line">return getMappingForMethod(method, userType);</span><br><span class="line">&#125;</span><br><span class="line">catch (Throwable ex) &#123;</span><br><span class="line">throw new IllegalStateException(&quot;Invalid mapping on handler class [&quot; +</span><br><span class="line">userType.getName() + &quot;]: &quot; + method, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>​                        </p><p>​    getMappingForMethod(method, userType)； //返回一个请求映射信息</p><p>​        1）userType为我们自定义的, 被@Controller注解所修饰的类.<br>​        2）method为 java.lang.reflect.Method 类型, 为我们所自定义的userType类型中的方法.<br>​        3）该getMappingForMethod方法也是抽象的, 交由RequestMappingHandlerMapping类来实现.            </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected RequestMappingInfo getMappingForMethod(Method method, Class&lt;?&gt; handlerType) &#123;</span><br><span class="line">// 抽取该方法上注解的@RequestMapping</span><br><span class="line">RequestMappingInfo info = createRequestMappingInfo(method);</span><br><span class="line">if (info != null) &#123;</span><br><span class="line">// 抽取handlerType(即我们自定义的Controller类)上注解的@RequestMapping</span><br><span class="line">RequestMappingInfo typeInfo = createRequestMappingInfo(handlerType);</span><br><span class="line">if (typeInfo != null) &#123;</span><br><span class="line">// 合并两个RequestMapping的信息(controller路径+method)</span><br><span class="line">info = typeInfo.combine(info);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>createRequestMappingInfo()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">protected RequestMappingInfo createRequestMappingInfo(</span><br><span class="line">RequestMapping requestMapping, @Nullable RequestCondition&lt;?&gt; customCondition) &#123;</span><br><span class="line"></span><br><span class="line">RequestMappingInfo.Builder builder = RequestMappingInfo</span><br><span class="line">/* 这里说明我们是可以在配置@RequestMapping时, 使用spel表达式的; 例如@RequestMapping(&quot;/yuyue/$&#123;url.mh&#125;/login&quot;) */</span><br><span class="line">.paths(resolveEmbeddedValuesInPatterns(requestMapping.path()))</span><br><span class="line">.methods(requestMapping.method())</span><br><span class="line">.params(requestMapping.params())</span><br><span class="line">.headers(requestMapping.headers())</span><br><span class="line">.consumes(requestMapping.consumes())</span><br><span class="line">.produces(requestMapping.produces())</span><br><span class="line">.mappingName(requestMapping.name());</span><br><span class="line">if (customCondition != null) &#123;</span><br><span class="line">builder.customCondition(customCondition);</span><br><span class="line">&#125;</span><br><span class="line">return builder.options(this.config).build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）注册获取到的映射方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for (Map.Entry&lt;Method, T&gt; entry : methods.entrySet()) &#123;</span><br><span class="line">Method invocableMethod = AopUtils.selectInvocableMethod(entry.getKey(), userType);</span><br><span class="line">T mapping = entry.getValue();</span><br><span class="line">registerHandlerMethod(handler, invocableMethod, mapping);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>registerHandlerMethod(handler, invocableMethod, mapping);</p><p>​    1）andler为传入的bean name<br>​    2）method为 java.lang.reflect.Method 类型, 为我们所自定义的userType类型中的方法.<br>​    3）mappings.get(method)为我们使用getMappingForMethod 构造的RequestMappingInfo 实例</p><p>AbstractHandlerMethodMapping——-&gt;registerHandlerMethod()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected void registerHandlerMethod(Object handler, Method method, T mapping) &#123;</span><br><span class="line">this.mappingRegistry.register(mapping, handler, method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AbstractHandlerMethodMapping———&gt;register()</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public void register(T mapping, Object handler, Method method) &#123;</span><br><span class="line">this.readWriteLock.writeLock().lock();</span><br><span class="line">try &#123;</span><br><span class="line">HandlerMethod handlerMethod = createHandlerMethod(handler, method);</span><br><span class="line">assertUniqueMethodMapping(handlerMethod, mapping);</span><br><span class="line"></span><br><span class="line">if (logger.isInfoEnabled()) &#123;</span><br><span class="line">logger.info(&quot;Mapped \&quot;&quot; + mapping + &quot;\&quot; onto &quot; + handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line">//mappin与hanlderMethod映射</span><br><span class="line">this.mappingLookup.put(mapping, handlerMethod);</span><br><span class="line"></span><br><span class="line">List&lt;String&gt; directUrls = getDirectUrls(mapping);</span><br><span class="line">for (String url : directUrls) &#123;</span><br><span class="line">//url与mapping映射</span><br><span class="line">this.urlLookup.add(url, mapping);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">String name = null;</span><br><span class="line">if (getNamingStrategy() != null) &#123;</span><br><span class="line">name = getNamingStrategy().getName(handlerMethod, mapping);</span><br><span class="line">addMappingName(name, handlerMethod);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping);</span><br><span class="line">if (corsConfig != null) &#123;</span><br><span class="line">this.corsLookup.put(handlerMethod, corsConfig);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">this.registry.put(mapping, new MappingRegistration&lt;&gt;(mapping, handlerMethod, directUrls, name));</span><br><span class="line">&#125;</span><br><span class="line">finally &#123;</span><br><span class="line">this.readWriteLock.writeLock().unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>//属性：private final Map&lt;T, HandlerMethod&gt; mappingLookup = new LinkedHashMap&lt;&gt;();</p><p>this.mappingLookup.put(mapping, handlerMethod);</p><p>mapping:映射路径(例如：/login)</p><p>handlerMethod: 包含了bean和方法信息</p><p>​    抽取出来RequestMappingInfo 信息 注册到 LinkedHashMap&lt;RequestMappingInfo,HandlerMethod&gt;类型的全局字段handlerMethods</p><p>//属性：private final MultiValueMap&lt;String, T&gt; urlLookup = new LinkedMultiValueMap&lt;&gt;();</p><p>this.urlLookup.add(url, mapping);</p><p>url:浏览器请求路径(例如：/login)</p><p>mapping:映射方法路径(“例如: /login”)</p><p>将映射关系注册到urlLookup全局变量中</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>1)context:component-scan 默认是将所有@Component注解的类扫描进容器;</p><p>​        @Controller自身就是被@Component修饰的</p><p>2）mvc:annotation-driven的解析工作是由 AnnotationDrivenBeanDefinitionParser 类全权负责的。<br>3）AnnotationDrivenBeanDefinitionParser会向SpringMVC容器中注册了 RequestMappingHandlerMapping (间接实现了HandlerMapping接口), order为0<br>4）查看RequestMappingHandlerMapping 类的继承链就会发现, 其祖先类 AbstractHandlerMethodMapping 实现了 InitializingBean<br>5）而对InitializingBean的实现中, 会回调AbstractHandlerMethodMapping–&gt;initHandlerMethods()的实现，其中的isHandler()方法中有对@Controller,@RequestMapping注解的扫描</p><p>参考：<a href="https://blog.csdn.net/lqzkcx3/article/details/78159708" target="_blank" rel="noopener">https://blog.csdn.net/lqzkcx3/article/details/78159708</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Springmvc注解驱动&quot;&gt;&lt;a href=&quot;#Springmvc注解驱动&quot; class=&quot;headerlink&quot; title=&quot;Springmvc注解驱动&quot;&gt;&lt;/a&gt;Springmvc注解驱动&lt;/h1&gt;&lt;h2 id=&quot;注解驱动的解析&quot;&gt;&lt;a href=&quot;#注解
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Log日志的使用</title>
    <link href="http://yoursite.com/2020/04/15/Logging/Log%E6%97%A5%E5%BF%97%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/04/15/Logging/Log%E6%97%A5%E5%BF%97%E7%9A%84%E4%BD%BF%E7%94%A8/</id>
    <published>2020-04-15T07:20:03.000Z</published>
    <updated>2020-04-20T00:47:31.495Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Log的使用"><a href="#Log的使用" class="headerlink" title="Log的使用"></a>Log的使用</h1><p>slf4j与commons-logging只是一个日志门面，实际还是要依赖真正的日志库log4j，虽然slf4j和commons-loggins自带了日志库，但是毕竟log4j才是最强大的。</p><h2 id="commons-logging与Log4j"><a href="#commons-logging与Log4j" class="headerlink" title="commons-logging与Log4j"></a>commons-logging与Log4j</h2><h3 id="为什么同时使用commons-logging和Log4j-为什么不仅使用其中之一？"><a href="#为什么同时使用commons-logging和Log4j-为什么不仅使用其中之一？" class="headerlink" title="为什么同时使用commons-logging和Log4j?为什么不仅使用其中之一？"></a>为什么同时使用commons-logging和Log4j?为什么不仅使用其中之一？</h3><p>​        Commons-loggin的目的是为“所有的Java日志实现”提供一个统一的接口，它自身的日志功能平常弱（只有一个简单的SimpleLog?），所以一般不会单独使用它。Log4j的功能非常全面强大，是目前的首选。我发现几乎所有的<a href="https://www.baidu.com/s?wd=Java开源项目&amp;tn=SE_PcZhidaonwhc_ngpagmjz&amp;rsv_dl=gh_pc_zhidao" target="_blank" rel="noopener">Java开源项目</a>都会用到Log4j，但我同时发现，所有用到Log4j的项目一般也同时会用到commons-loggin。我想，大家都不希望自己的项目与Log4j绑定的太紧密吧。另外一个我能想到的“同时使用commons-logging和Log4j”的原因是，简化使用和配置。</p><h3 id="Commons-logging能帮我们做什么？"><a href="#Commons-logging能帮我们做什么？" class="headerlink" title="Commons-logging能帮我们做什么？"></a>Commons-logging能帮我们做什么？</h3><p>​        提供一个统一的日志接口，简单了操作，同时避免项目与某个日志实现系统紧密a耦合很贴心的帮我们自动选择适当的日志实现系统（这一点非常好！）它甚至不需要配置</p><p>这里看一下它怎么“‘很贴心的’帮我们‘自动选择’‘适当的’日志实现系统”：<br>1) 首先在classpath下寻找自己的配置文件commons-logging.properties，如果找到，则使用其中定义的Log实现类；</p><p>2)如果找不到commons-logging.properties文件，则在查找是否已定义系统环境变量org.apache.commons.logging.Log，找到则使用其定义的Log实现类； </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">建立一个叫 ：CATALINA_OPTS 的环境变量 </span><br><span class="line">给他的值 ： - Dorg.apache.commons.logging.Log = org.apache.commons.logging.impl.SimpleLog  - Dorg.apache.commons.logging.simplelog.defaultlog = warn</span><br></pre></td></tr></table></figure><p>3)  否则，查看classpath中是否有Log4j的包，如果发现，则自动使用Log4j作为日志实现类；</p><p>4)  否则，使用JDK自身的日志实现类（JDK1.4以后才有日志实现类）；</p><p>5)  否则，使用commons-logging自己提供的一个简单的日志实现类SimpleLog；</p><p>可见，commons-logging总是能找到一个日志实现类，并且尽可能找到一个“最合适”的日志实现类。我说它“很贴心”实际上是因为：</p><p>1、可以不需要配置文件；<br>2、自动判断有没有Log4j包，有则自动使用之；<br>3、最悲观的情况下也总能保证提供一个日志实现（SimpleLog）。</p><p>可以看到，commons-logging对编程者和Log4j都非常友好。</p><p>​       为了简化配置commons-logging，一般不使用commons-logging的配置文件，也不设置与commons-logging相关的系统环境变量，而只需将Log4j的Jar包放置到classpash中就可以了。这样就很简单地完成了commons-logging与Log4j的融合。如果不想用Log4j了怎么办？只需将classpath中的Log4j的Jar包删除即可。就这么简单！</p><p>参考： <a href="https://www.cnblogs.com/tv151579/archive/2013/01/20/2868846.html" target="_blank" rel="noopener">https://www.cnblogs.com/tv151579/archive/2013/01/20/2868846.html</a></p><h3 id="Common-loggin说明"><a href="#Common-loggin说明" class="headerlink" title="Common-loggin说明"></a>Common-loggin说明</h3><p>​    严格的说，commons-logging不是一个日志控件，没有日志功能，它只是统一了JDK Logging与Log4j的API，并把日志功能交给JDK Loggings或者是log4j。对于不能确定日志方式的系统，commons-logging是一个不错的选择，Spring，Hibernate，Struts等使用的都是commons-logging</p><h2 id="log4j和sfl4j和lobback到底有什么区别"><a href="#log4j和sfl4j和lobback到底有什么区别" class="headerlink" title="log4j和sfl4j和lobback到底有什么区别"></a>log4j和sfl4j和lobback到底有什么区别</h2><p>SLF4J：即简单日志门面（Simple Logging Facade for Java），不是具体的日志解决方案，它只服务于各种各样的日志系统。SLF4J是一个用于日志系统的简单Facade，允许最终用户在部署其应用时使用其所希望的日志系统<strong>(Log4j logback)。</strong></p><p>在使用SLF4J的时候，不需要在代码中或配置文件中指定你打算使用那个具体的日志系统，SLF4J提供了统一的记录日志的接口，只要按照其提供的方法记录即可，最终日志的格式、记录级别、输出方式等通过具体日志系统的配置来实现，因此可以在应用中灵活切换日志系统。</p><p>log4j：没什么好说的，就是一个打日志，并且有日志系统</p><p>logback和log4j是非常相似的，Logback的内核重写了，在一些关键执行路径上性能提升10倍以上。而且logback不仅性能提升了，初始化内存加载也更小。说白了也是个日志系统，存储日志    </p><p>原文链接：<a href="https://blog.csdn.net/u012954706/article/details/79572028" target="_blank" rel="noopener">https://blog.csdn.net/u012954706/article/details/79572028</a></p><h2 id="Spring自带的日志-JCL"><a href="#Spring自带的日志-JCL" class="headerlink" title="Spring自带的日志(JCL)"></a>Spring自带的日志(JCL)</h2><h4 id="JCL原理"><a href="#JCL原理" class="headerlink" title="JCL原理"></a>JCL原理</h4><p>​    JCL，全称为”Jakarta Commons Logging”，也可称为”Apache Commons Logging”。</p><p>​    JCL这个日志框架跟Log4J，Java Logging API等日志框架不同。JCL采用了设计模式中的“适配器模式”，它对外提供统一的接口，然后在适配类中将对日志的操作委托给具体的日志框架，比如Log4J,Java Logging API等。</p><p>在JCL中对外有两个统一的接口，分别是Log和LogFactory。</p><h4 id="spring使用JCL"><a href="#spring使用JCL" class="headerlink" title="spring使用JCL"></a>spring使用JCL</h4><p>Logging是spring中唯一强制的外部依赖，spring中默认使用的日志是<code>commons-logging</code>，简称<code>JCL</code>，这里说的强制性，是因为在<code>spring-core</code>这个模块中引入了该依赖。不过，引入了该依赖，也无需做任何其他的配置，它是`日志门面.</p><p>spring-jcl-xxx.jar下的 org.apache.commons.logging包中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Copyright 2002-2017 the original author or authors.</span><br><span class="line"> *</span><br><span class="line"> * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span><br><span class="line"> * you may not use this file except in compliance with the License.</span><br><span class="line"> * You may obtain a copy of the License at</span><br><span class="line"> *</span><br><span class="line"> *      http://www.apache.org/licenses/LICENSE-2.0</span><br><span class="line"> *</span><br><span class="line"> * Unless required by applicable law or agreed to in writing, software</span><br><span class="line"> * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span><br><span class="line"> * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span><br><span class="line"> * See the License for the specific language governing permissions and</span><br><span class="line"> * limitations under the License.</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">package org.apache.commons.logging;</span><br><span class="line"></span><br><span class="line">import java.io.Serializable;</span><br><span class="line">import java.util.logging.LogRecord;</span><br><span class="line"></span><br><span class="line">import org.apache.logging.log4j.Level;</span><br><span class="line">import org.apache.logging.log4j.LogManager;</span><br><span class="line">import org.apache.logging.log4j.spi.ExtendedLogger;</span><br><span class="line">import org.apache.logging.log4j.spi.LoggerContext;</span><br><span class="line">import org.slf4j.Logger;</span><br><span class="line">import org.slf4j.LoggerFactory;</span><br><span class="line">import org.slf4j.spi.LocationAwareLogger;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * A minimal incarnation of Apache Commons Logging&apos;s &#123;@code LogFactory&#125; API,</span><br><span class="line"> * providing just the common &#123;@link Log&#125; lookup methods. This is inspired</span><br><span class="line"> * by the JCL-over-SLF4J bridge and should be source as well as binary</span><br><span class="line"> * compatible with all common use of the Commons Logging API (in particular:</span><br><span class="line"> * with &#123;@code LogFactory.getLog(Class/String)&#125; field initializers).</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;This implementation does not support Commons Logging&apos;s original provider</span><br><span class="line"> * detection. It rather only checks for the presence of the Log4j 2.x API</span><br><span class="line"> * and the SLF4J 1.7 API in the Spring Framework classpath, falling back to</span><br><span class="line"> * &#123;@code java.util.logging&#125; if none of the two is available. In that sense,</span><br><span class="line"> * it works as a replacement for the Log4j 2 Commons Logging bridge as well as</span><br><span class="line"> * the JCL-over-SLF4J bridge, both of which become irrelevant for Spring-based</span><br><span class="line"> * setups as a consequence (with no need for manual excludes of the standard</span><br><span class="line"> * Commons Logging API jar anymore either). Furthermore, for simple setups</span><br><span class="line"> * without an external logging provider, Spring does not require any extra jar</span><br><span class="line"> * on the classpath anymore since this embedded log factory automatically</span><br><span class="line"> * delegates to &#123;@code java.util.logging&#125; in such a scenario.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;&lt;b&gt;Note that this Commons Logging variant is only meant to be used for</span><br><span class="line"> * infrastructure logging purposes in the core framework and in extensions.&lt;/b&gt;</span><br><span class="line"> * It also serves as a common bridge for third-party libraries using the</span><br><span class="line"> * Commons Logging API, e.g. Apache HttpClient, Castor and HtmlUnit, bringing</span><br><span class="line"> * them into the same consistent arrangement without any extra bridge jars.</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;&lt;b&gt;For logging need in application code, prefer direct use of Log4j 2.x</span><br><span class="line"> * or SLF4J or &#123;@code java.util.logging&#125;.&lt;/b&gt; Simply put Log4j 2.x or Logback</span><br><span class="line"> * (or another SLF4J provider) onto your classpath, without any extra bridges,</span><br><span class="line"> * and let the framework auto-adapt to your choice.</span><br><span class="line"> *</span><br><span class="line"> * @author Juergen Hoeller (for the &#123;@code spring-jcl&#125; variant)</span><br><span class="line"> * @since 5.0</span><br><span class="line"> */</span><br><span class="line">public abstract class LogFactory &#123;</span><br><span class="line"></span><br><span class="line">private static LogApi logApi = LogApi.JUL;</span><br><span class="line"></span><br><span class="line">static &#123;</span><br><span class="line">ClassLoader cl = LogFactory.class.getClassLoader();</span><br><span class="line">try &#123;</span><br><span class="line">// Try Log4j 2.x API</span><br><span class="line">cl.loadClass(&quot;org.apache.logging.log4j.spi.ExtendedLogger&quot;);</span><br><span class="line">logApi = LogApi.LOG4J;</span><br><span class="line">&#125;</span><br><span class="line">catch (ClassNotFoundException ex1) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">// Try SLF4J 1.7 SPI</span><br><span class="line">cl.loadClass(&quot;org.slf4j.spi.LocationAwareLogger&quot;);</span><br><span class="line">logApi = LogApi.SLF4J_LAL;</span><br><span class="line">&#125;</span><br><span class="line">catch (ClassNotFoundException ex2) &#123;</span><br><span class="line">try &#123;</span><br><span class="line">// Try SLF4J 1.7 API</span><br><span class="line">cl.loadClass(&quot;org.slf4j.Logger&quot;);</span><br><span class="line">logApi = LogApi.SLF4J;</span><br><span class="line">&#125;</span><br><span class="line">catch (ClassNotFoundException ex3) &#123;</span><br><span class="line">// Keep java.util.logging as default</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Convenience method to return a named logger.</span><br><span class="line"> * @param clazz containing Class from which a log name will be derived</span><br><span class="line"> */</span><br><span class="line">public static Log getLog(Class&lt;?&gt; clazz) &#123;</span><br><span class="line">return getLog(clazz.getName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * Convenience method to return a named logger.</span><br><span class="line"> * @param name logical name of the &lt;code&gt;Log&lt;/code&gt; instance to be returned</span><br><span class="line"> */</span><br><span class="line">public static Log getLog(String name) &#123;</span><br><span class="line">switch (logApi) &#123;</span><br><span class="line">case LOG4J:</span><br><span class="line">return Log4jDelegate.createLog(name);</span><br><span class="line">case SLF4J_LAL:</span><br><span class="line">return Slf4jDelegate.createLocationAwareLog(name);</span><br><span class="line">case SLF4J:</span><br><span class="line">return Slf4jDelegate.createLog(name);</span><br><span class="line">default:</span><br><span class="line">// Defensively use lazy-initializing delegate class here as well since the</span><br><span class="line">// java.logging module is not present by default on JDK 9. We are requiring</span><br><span class="line">// its presence if neither Log4j nor SLF4J is available; however, in the</span><br><span class="line">// case of Log4j or SLF4J, we are trying to prevent early initialization</span><br><span class="line">// of the JavaUtilLog adapter - e.g. by a JVM in debug mode - when eagerly</span><br><span class="line">// trying to parse the bytecode for all the cases of this switch clause.</span><br><span class="line">return JavaUtilDelegate.createLog(name);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">........</span><br></pre></td></tr></table></figure><p>通过尝试加载log4j,slf4j等日志来创建Log接口的实现类</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Log的使用&quot;&gt;&lt;a href=&quot;#Log的使用&quot; class=&quot;headerlink&quot; title=&quot;Log的使用&quot;&gt;&lt;/a&gt;Log的使用&lt;/h1&gt;&lt;p&gt;slf4j与commons-logging只是一个日志门面，实际还是要依赖真正的日志库log4j，虽然slf
      
    
    </summary>
    
    
      <category term="Logging" scheme="http://yoursite.com/categories/Logging/"/>
    
    
      <category term="log" scheme="http://yoursite.com/tags/log/"/>
    
  </entry>
  
  <entry>
    <title>设计模式简介</title>
    <link href="http://yoursite.com/2020/04/13/Design%20Pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%82%E8%80%83%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2020/04/13/Design%20Pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%82%E8%80%83%E7%AE%80%E4%BB%8B/</id>
    <published>2020-04-13T11:41:09.000Z</published>
    <updated>2020-04-13T11:52:37.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h1><p>​    设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p><p>​    设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p><h2 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h2><p>​    根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">模式 &amp; 描述</th><th style="text-align:left">包括</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>创建型模式</strong> 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</td><td style="text-align:left">工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern）</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>结构型模式</strong> 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td><td style="text-align:left">适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern）</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>行为型模式</strong> 这些设计模式特别关注对象之间的通信。</td><td style="text-align:left">责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern）</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>J2EE 模式</strong> 这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</td><td style="text-align:left">MVC 模式（MVC Pattern）业务代表模式（Business Delegate Pattern）组合实体模式（Composite Entity Pattern）数据访问对象模式（Data Access Object Pattern）前端控制器模式（Front Controller Pattern）拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）传输对象模式（Transfer Object Pattern）</td></tr></tbody></table><h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><p><strong>1、开闭原则（Open Close Principle）</strong></p><p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p><p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><p><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></p><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p><h2 id="学习网站"><a href="#学习网站" class="headerlink" title="学习网站"></a>学习网站</h2><p> <a href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/design-pattern-tutorial.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计模式简介&quot;&gt;&lt;a href=&quot;#设计模式简介&quot; class=&quot;headerlink&quot; title=&quot;设计模式简介&quot;&gt;&lt;/a&gt;设计模式简介&lt;/h1&gt;&lt;p&gt;​    设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采
      
    
    </summary>
    
    
      <category term="designPattern" scheme="http://yoursite.com/categories/designPattern/"/>
    
    
      <category term="data" scheme="http://yoursite.com/tags/data/"/>
    
  </entry>
  
  <entry>
    <title>IDEA快捷键</title>
    <link href="http://yoursite.com/2020/04/11/Tools/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2020/04/11/Tools/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2020-04-11T15:09:08.000Z</published>
    <updated>2020-06-07T07:44:48.947Z</updated>
    
    <content type="html"><![CDATA[<h1 id="IDEA常用快捷键"><a href="#IDEA常用快捷键" class="headerlink" title="IDEA常用快捷键"></a>IDEA常用快捷键</h1><h2 id="Coding"><a href="#Coding" class="headerlink" title="Coding"></a>Coding</h2><p>crtl + f9          build Project</p><p>alt  + 7            查看类中的方法</p><p>crtl + H           接口，类继承结构</p><p>ctrl + shfit +f12         窗口最大化</p><p>crtl + alt + T         快速surround with，异常处理</p><p>Ctrl + X            剪切一行</p><p>##Crtl + shift + y  删除一行</p><p>crtl + D             复制一行</p><p>crtl + Y            redo  重做</p><p>crtl + Z           undo  撤销</p><p>crtl + I            实现接口方法</p><p>crtl + O          重写方法          </p><p>Shift+Enter    向下插入新行</p><p>Alt+left/right    切换代码视图<br>Alt+Up/Down    在方法间快速移动定位<br>Ctrl+P       可以显示参数信息</p><p>Ctrl+Alt+O    优化导入的类和包(可以在设置中设置自动导入和优化)</p><p>Crtl + B         查看声明</p><p>Crtl + alt + B   查看实现</p><p>shift + shift       查找全部文件</p><p>（</p><p>​        crtl + N    classes</p><p>​        ctrl+shift+n    files</p><p>​        ctrl+shift+alt+n  symbols</p><p>​        ctrl+shift+A  actions</p><p>）</p><p>alt + insert     generate生成</p><p>crtl + alt + t    surround with(try catch，if, while……)</p><p>crtl + shift + o        Load Maven Changes</p><p>ctrl+shift+enter      收尾(结尾分号，if大括号等)</p><p>alt+F1         弹出Select in视图，然后选择Project View中的Project，回车，就可以立刻定位到类的位置</p><p>crtl + E      最近的文件</p><p>crtl + shift  + space   手动提示(suggestions)</p><p>{</p><p>​    ctrl + r:   当前文件内容替换，指的是在当前打开的文件中替换匹配的字符，只操作一个文件。</p><p>​    ctrl + shift + r:   在路径中替换，指的是在选定的目录下或者类包下</p><p>​    使用说明：查找要被替换的字符，再在第二个输入框中输入要替换的字符，点击弹出框的右下角的replace或者      replaceall即可。</p><p>}</p><h2 id="Conf"><a href="#Conf" class="headerlink" title="Conf"></a>Conf</h2><p> Ctrl+Shift+Alt+/      Maintenance（Idea的一些配置)</p><h1 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h1><h2 id="Translation（翻译）"><a href="#Translation（翻译）" class="headerlink" title="Translation（翻译）"></a>Translation（翻译）</h2><p>​        crtl + shift + Y      翻译</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;IDEA常用快捷键&quot;&gt;&lt;a href=&quot;#IDEA常用快捷键&quot; class=&quot;headerlink&quot; title=&quot;IDEA常用快捷键&quot;&gt;&lt;/a&gt;IDEA常用快捷键&lt;/h1&gt;&lt;h2 id=&quot;Coding&quot;&gt;&lt;a href=&quot;#Coding&quot; class=&quot;head
      
    
    </summary>
    
    
      <category term="tools" scheme="http://yoursite.com/categories/tools/"/>
    
    
      <category term="tools" scheme="http://yoursite.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>servlet3.0</title>
    <link href="http://yoursite.com/2020/04/06/Java%20Web/servlet3.0/"/>
    <id>http://yoursite.com/2020/04/06/Java%20Web/servlet3.0/</id>
    <published>2020-04-06T05:54:03.000Z</published>
    <updated>2020-04-06T07:33:13.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Servlet3-0"><a href="#Servlet3-0" class="headerlink" title="Servlet3.0"></a>Servlet3.0</h1><p>​    在Servlet3.0协议规范中</p><p>​    1）包含在JAR文件/META-INFO/resources/路径下的资源可以直接访问(就像在webapp目录下一样)，</p><p>​    2）但是注意：该路径下建立的WEB-INF目录不可以被直接访问，和webapp目录下一样</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Servlet3-0&quot;&gt;&lt;a href=&quot;#Servlet3-0&quot; class=&quot;headerlink&quot; title=&quot;Servlet3.0&quot;&gt;&lt;/a&gt;Servlet3.0&lt;/h1&gt;&lt;p&gt;​    在Servlet3.0协议规范中&lt;/p&gt;
&lt;p&gt;​    1）包含
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="servlet" scheme="http://yoursite.com/tags/servlet/"/>
    
  </entry>
  
</feed>
