<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Momentonly</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-04-13T11:52:37.434Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Moment Only</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>设计模式简介</title>
    <link href="http://yoursite.com/2020/04/13/Design%20Pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%82%E8%80%83%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2020/04/13/Design%20Pattern/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%8F%82%E8%80%83%E7%AE%80%E4%BB%8B/</id>
    <published>2020-04-13T11:41:09.000Z</published>
    <updated>2020-04-13T11:52:37.434Z</updated>
    
    <content type="html"><![CDATA[<h1 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h1><p>​    设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p><p>​    设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p><h2 id="设计模式的类型"><a href="#设计模式的类型" class="headerlink" title="设计模式的类型"></a>设计模式的类型</h2><p>​    根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">模式 &amp; 描述</th><th style="text-align:left">包括</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>创建型模式</strong> 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。</td><td style="text-align:left">工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern）</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>结构型模式</strong> 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。</td><td style="text-align:left">适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern）</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>行为型模式</strong> 这些设计模式特别关注对象之间的通信。</td><td style="text-align:left">责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern）</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>J2EE 模式</strong> 这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。</td><td style="text-align:left">MVC 模式（MVC Pattern）业务代表模式（Business Delegate Pattern）组合实体模式（Composite Entity Pattern）数据访问对象模式（Data Access Object Pattern）前端控制器模式（Front Controller Pattern）拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）传输对象模式（Transfer Object Pattern）</td></tr></tbody></table><h2 id="设计模式的六大原则"><a href="#设计模式的六大原则" class="headerlink" title="设计模式的六大原则"></a>设计模式的六大原则</h2><p><strong>1、开闭原则（Open Close Principle）</strong></p><p>开闭原则的意思是：<strong>对扩展开放，对修改关闭</strong>。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。</p><p><strong>2、里氏代换原则（Liskov Substitution Principle）</strong></p><p>里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><p><strong>3、依赖倒转原则（Dependence Inversion Principle）</strong></p><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。</p><p><strong>4、接口隔离原则（Interface Segregation Principle）</strong></p><p>这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><p><strong>5、迪米特法则，又称最少知道原则（Demeter Principle）</strong></p><p>最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><p><strong>6、合成复用原则（Composite Reuse Principle）</strong></p><p>合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。</p><h2 id="学习网站"><a href="#学习网站" class="headerlink" title="学习网站"></a>学习网站</h2><p> <a href="https://www.runoob.com/design-pattern/design-pattern-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/design-pattern/design-pattern-tutorial.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;设计模式简介&quot;&gt;&lt;a href=&quot;#设计模式简介&quot; class=&quot;headerlink&quot; title=&quot;设计模式简介&quot;&gt;&lt;/a&gt;设计模式简介&lt;/h1&gt;&lt;p&gt;​    设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采
      
    
    </summary>
    
    
      <category term="designPattern" scheme="http://yoursite.com/categories/designPattern/"/>
    
    
      <category term="data" scheme="http://yoursite.com/tags/data/"/>
    
  </entry>
  
  <entry>
    <title>IDEA快捷键</title>
    <link href="http://yoursite.com/2020/04/11/Tools/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/"/>
    <id>http://yoursite.com/2020/04/11/Tools/IDEA%E5%BF%AB%E6%8D%B7%E9%94%AE/</id>
    <published>2020-04-11T15:09:08.000Z</published>
    <updated>2020-04-11T13:53:28.571Z</updated>
    
    <content type="html"><![CDATA[<p>crtl + f9          build</p><p>alt  + 7            查看类中的方法</p><p>crtl + H           接口，类继承结构</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;crtl + f9          build&lt;/p&gt;
&lt;p&gt;alt  + 7            查看类中的方法&lt;/p&gt;
&lt;p&gt;crtl + H           接口，类继承结构&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="tools" scheme="http://yoursite.com/categories/tools/"/>
    
    
      <category term="tools" scheme="http://yoursite.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>servlet3.0</title>
    <link href="http://yoursite.com/2020/04/06/Java%20Web/servlet3.0/"/>
    <id>http://yoursite.com/2020/04/06/Java%20Web/servlet3.0/</id>
    <published>2020-04-06T05:54:03.000Z</published>
    <updated>2020-04-06T07:33:13.181Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Servlet3-0"><a href="#Servlet3-0" class="headerlink" title="Servlet3.0"></a>Servlet3.0</h1><p>​    在Servlet3.0协议规范中</p><p>​    1）包含在JAR文件/META-INFO/resources/路径下的资源可以直接访问(就像在webapp目录下一样)，</p><p>​    2）但是注意：该路径下建立的WEB-INF目录不可以被直接访问，和webapp目录下一样</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Servlet3-0&quot;&gt;&lt;a href=&quot;#Servlet3-0&quot; class=&quot;headerlink&quot; title=&quot;Servlet3.0&quot;&gt;&lt;/a&gt;Servlet3.0&lt;/h1&gt;&lt;p&gt;​    在Servlet3.0协议规范中&lt;/p&gt;
&lt;p&gt;​    1）包含
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="servlet" scheme="http://yoursite.com/tags/servlet/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot不推荐使用jsp</title>
    <link href="http://yoursite.com/2020/04/05/SpringBoot/SpringBoot%E4%B8%8D%E6%8E%A8%E8%8D%90jsp/"/>
    <id>http://yoursite.com/2020/04/05/SpringBoot/SpringBoot%E4%B8%8D%E6%8E%A8%E8%8D%90jsp/</id>
    <published>2020-04-05T13:08:59.000Z</published>
    <updated>2020-04-05T13:16:55.772Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于Springboot不推荐使用Jsp的讨论"><a href="#关于Springboot不推荐使用Jsp的讨论" class="headerlink" title="关于Springboot不推荐使用Jsp的讨论"></a>关于Springboot不推荐使用Jsp的讨论</h1><p>springboot不推荐使用jsp，如果使用了jsp会失去一些springboot的特性，这是为什么呢？jsp和其他模板引擎FreeMarker，thymeleaf有什么区别呢？</p><h2 id="回答1"><a href="#回答1" class="headerlink" title="回答1"></a>回答1</h2><p>原因简单，就因为它叫 JSP (Java Server Page)</p><p>Java社区的领导者JCP 制定JSP规则就是专门为了给 JavaServer 用的， 所以 JSP 的定义里就指定了它是运行在容器里的.</p><p>里面最最重要的就是第一条.</p><blockquote><p>(使用jsp的项目 部署时) 把war包放到 tomcat或者其他 java 容器；或者用 java -jar 启一个可执行的 <strong>war包</strong> 时 是可以正常工作的， 但 <strong>直接执行 jar包是不支持的</strong>。</p><p>也就是说打包方式不一样同样的代码运行结果就是不一样：<br> “java -jar app.jar”  不可以解析jsp<br>“java -jar app.war” 正常解析</p></blockquote><p>剩余几个限制也多少都是因为jsp的规范/法律层面上的原因联锁引起的，或者导致开发者修复/额外考虑的兴致不大。</p><p>至于<strong>从技术层面的开发使用上 用 JSP当模板 和 用其他模板引擎支持的文件没有任何本质的区别</strong>。</p><p>差别仅存在于开发书写效率和程序解析运行效率。</p><p>比如 jsp 和 freemarker 的解析执行效率都是很高的，</p><p>而thymeleaf的书写效率高并且与前端模板语法很相似，学习成本很低。</p><h2 id="回答2"><a href="#回答2" class="headerlink" title="回答2"></a>回答2</h2><p>springboot 是内嵌web容器的，推荐打成jar包不是war包</p><p>你如果想使用jsp也可以啊，自建WEB-INF web.xml  然后像往常一样使用jsp</p><p>打成war包使用外部容器即可，这就相当于失去了一些springboot的特性了</p><p>至于模板引擎其实都差不多，jsp也可以算是模板引擎，springboot推荐的thymeleaf主要嵌入到html的标签属性，这样对前端很友好，有一些优点，但和jsp，FreeMarker比起来也没什么绝对性的优势。</p><p>现在web前端技术飞一样的发展，前后端分离才是主流，模板引擎说白了还是给后端人员用的东西，早就不符合现代的前端思想了，而且和React、Vue这类的前端框架比起来又是连提鞋都不配，所以放弃这些模板引擎改用RestController吧。</p><h2 id="springboot官方说明jsp限制"><a href="#springboot官方说明jsp限制" class="headerlink" title="springboot官方说明jsp限制"></a>springboot官方说明jsp限制</h2><p><a href="https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/reference/htmlsingle/#boot-features-jsp-limitations" target="_blank" rel="noopener">https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/reference/htmlsingle/#boot-features-jsp-limitations</a></p><p>官方：</p><p>28.4.5 JSP Limitations</p><p>When running a Spring Boot application that uses an embedded servlet container (and is packaged as an executable archive), there are some limitations in the JSP support.</p><ul><li>With Jetty and Tomcat, it should work if you use war packaging. An executable war will work when launched with <code>java -jar</code>, and will also be deployable to any standard container. JSPs are not supported when using an executable jar.</li><li>Undertow does not support JSPs.</li><li>Creating a custom <code>error.jsp</code> page does not override the default view for <a href="https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/reference/htmlsingle/#boot-features-error-handling" target="_blank" rel="noopener">error handling</a>. <a href="https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/reference/htmlsingle/#boot-features-error-handling-custom-error-pages" target="_blank" rel="noopener">Custom error pages</a> should be used instead.</li></ul><p>There is a <a href="https://github.com/spring-projects/spring-boot/tree/v2.1.1.RELEASE/spring-boot-samples/spring-boot-sample-web-jsp" target="_blank" rel="noopener">JSP sample</a> so that you can see how to set things up.</p><p>翻译：28.4.5 JSP的局限性</p><p>在运行使用嵌入式servlet容器(并打包为可执行归档文件)的Spring引导应用程序时，JSP支持存在一些限制。</p><p>对于Jetty和Tomcat，如果使用war打包，它应该可以工作。一个可执行的war在使用java -jar启动时可以工作，并且也可以部署到任何标准容器中。使用可执行jar时不支持jsp。</p><p>Undertow不支持jsp。</p><p>创建自定义error.jsp页面不会覆盖用于错误处理的默认视图。应该使用自定义错误页面。</p><p>这里有一个JSP示例，以便您了解如何进行设置。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于Springboot不推荐使用Jsp的讨论&quot;&gt;&lt;a href=&quot;#关于Springboot不推荐使用Jsp的讨论&quot; class=&quot;headerlink&quot; title=&quot;关于Springboot不推荐使用Jsp的讨论&quot;&gt;&lt;/a&gt;关于Springboot不推荐使用
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>事务的隔离级别和传播机制</title>
    <link href="http://yoursite.com/2020/04/04/DataBase/Transaction/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8C%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6/"/>
    <id>http://yoursite.com/2020/04/04/DataBase/Transaction/%E4%BA%8B%E5%8A%A1%E7%9A%84%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E5%92%8C%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6/</id>
    <published>2020-04-04T08:15:01.000Z</published>
    <updated>2020-04-04T13:22:32.422Z</updated>
    
    <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="什么是事务？"><a href="#什么是事务？" class="headerlink" title="什么是事务？"></a>什么是事务？</h2><p>​            要么全部都要执行，要么就都不执行。</p><h2 id="事务所具有的四种特性"><a href="#事务所具有的四种特性" class="headerlink" title="事务所具有的四种特性"></a>事务所具有的四种特性</h2><h3 id="原子性-（Atimicty）"><a href="#原子性-（Atimicty）" class="headerlink" title="原子性 （Atimicty）"></a>原子性 （Atimicty）</h3><p>​        个人理解，就是事务执行不可分割，要么全部完成，要么全部拉倒不干。</p><h3 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h3><p>​        关于一致性这个概念我们来举个例子说明吧，假设张三给李四转了100元，那么需要先从张三那边扣除100，然后李四那边增加100，这个转账的过程对于其他事务而言是无法看到的，这种状态始终都在保持一致，这个过程我们称之为一致性。</p><h3 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h3><p>​        并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据是独立的；</p><h3 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h3><p>​        一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</p><h2 id="事务并发问题"><a href="#事务并发问题" class="headerlink" title="事务并发问题"></a>事务并发问题</h2><p><strong><em>脏读：</em></strong>    事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据<br><strong><em>不可重复读：</em></strong>事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。<br><strong><em>幻读：</em></strong>    用户A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是用户B就在这个时候插入了一条具体分数的记录，当修改A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。（一个事务读到另一个事务已提交的insert数据）</p><p>概念：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">脏读:  指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据， 那么另外一 个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。</span><br><span class="line"></span><br><span class="line">不可重复读:  指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。 那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。</span><br><span class="line"></span><br><span class="line">幻觉读:</span><br><span class="line">理解1：指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及 到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，就会发生操作第一个事务的用户发现表中还有 没有修改的数据行,也就是说幻像读是指同一查询在同一事务中多次进行，由于其他提交事务所做的插入操作，每次返回不同的结果集，此时发生幻像读,就好象发生了幻觉一样。</span><br><span class="line">理解2：</span><br><span class="line">幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。幻读和不可重复读都是读取了另一条已经提交的事务(这点就脏读不同)，所不同的是不可重复读可能发生在update,delete操作中，而幻读发生在insert操作中。</span><br></pre></td></tr></table></figure><p><strong>小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表</strong></p><p>思考：mysql的不可重复读解决了幻读？<a href="https://www.cnblogs.com/liyus/p/10556563.html" target="_blank" rel="noopener">https://www.cnblogs.com/liyus/p/10556563.html</a></p><h2 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h2><p>事务隔离级别                                               脏读    不可重复读    幻读<br>读未提交（read-uncommitted）               是            是                 是<br>读已提交（read-committed）                    否            是                 是<br>可重复读（repeatable-read）                    否             否                是<br>串行化（serializable）                                 否            否                 否</p><p>MYSQL: 默认为REPEATABLE_READ级别<br>SQLSERVER: 默认为READ_COMMITTED</p><h1 id="Spring对事务的处理"><a href="#Spring对事务的处理" class="headerlink" title="Spring对事务的处理"></a>Spring对事务的处理</h1><h2 id="编程式事务和声明式事务"><a href="#编程式事务和声明式事务" class="headerlink" title="编程式事务和声明式事务"></a>编程式事务和声明式事务</h2><pre><code>编程式事务需要你在代码中直接加入处理事务的逻辑,可能需要在代码中显式调用beginTransaction()、commit()、rollback()等事务管理相关的方法,如在执行a方法时候需要事务处理,你需要在a方法开始时候开启事务,处理完后。在方法结束时候,关闭事务.</code></pre><p>​        声明式的事务的做法是在a方法外围添加注解或者直接在配置文件中定义,a方法需要事务处理,在spring中会通过配置文件在a方法前后拦截,并添加事务.</p><p>​        二者区别.编程式事务侵入性比较强，但处理粒度更细. </p><p><strong>声明式事务</strong>：通过AOP（面向切面）方式在方法前使用编程式事务的方法开启事务，在方法后提交或回滚。用配置文件的方法或注解方法（如：@Transactional）控制事务。</p><p><strong>编程式事务</strong>：手动开启、提交、回滚事务。</p><p>spring在事务方面进行了各种操作的封装，特别是声明式事务的出现，让开发变得更加的舒心.</p><h2 id="spring事务定义及状态描述"><a href="#spring事务定义及状态描述" class="headerlink" title="spring事务定义及状态描述"></a>spring事务定义及状态描述</h2><p>从事务管理器PlatformTransactionManager中可以看出，spring完成事务管理还需2个关键元素：事务定义TransactionDefinition及事务状态TransactionStatus描述。</p><p>事务定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface TransactionDefinition &#123;</span><br><span class="line">    int getPropagationBehavior(); //传播行为，默认PROPAGATION_REQUIRED</span><br><span class="line">    int getIsolationLevel();  //隔离级别，默认数据库默认级别，如mysql为可重复读</span><br><span class="line">    int getTimeout();</span><br><span class="line">    boolean isReadOnly();  //是否只读，查询操作可以设置为true</span><br><span class="line">    String getName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>事务状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface TransactionStatus extends SavepointManager &#123;</span><br><span class="line">    boolean isNewTransaction();  //是否新事务</span><br><span class="line">    boolean hasSavepoint();  //是否有恢复点</span><br><span class="line">    void setRollbackOnly();</span><br><span class="line">    boolean isRollbackOnly();</span><br><span class="line">    void flush(); //Flush the underlying session to the datastore, if applicable: for example, all affected Hibernate/JPA sessions.</span><br><span class="line">    boolean isCompleted();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="什么是事务的传播行为"><a href="#什么是事务的传播行为" class="headerlink" title="什么是事务的传播行为"></a>什么是事务的传播行为</h2><p>​        Spring在TransactionDefinition接口中规定了7种类型的事务传播行为。事务传播行为是Spring框架独有的事务增强特性，他不属于的事务实际提供方数据库行为。这是Spring为我们提供的强大的工具箱，使用事务传播行可以为我们的开发工作提供许多便利。但是人们对他的误解也颇多，你一定也听过“service方法事务最好不要嵌套”的传言。要想正确的使用工具首先需要了解工具。</p><p>什么是事务传播行为？</p><p><strong><em>事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时事务如何传播。</em></strong></p><h2 id="事务的传播行为"><a href="#事务的传播行为" class="headerlink" title="事务的传播行为"></a>事务的传播行为</h2><p>1）PROPAGATION_REQUIRED</p><p>​    说明： 如果当前已经存在事务，那么加入该事务，如果不存在事务，创建一个事务，这是默认的传播属性值。</p><p>2）PROPAGATION_SUPPORTS</p><p>​    说明:     如果当前已经存在事务，那么加入该事务，否则创建一个所谓的空事务（可以认为无事务执行）。</p><p>3) PROPAGATION_MANDATORY</p><p>说明：当前必须存在一个事务，否则抛出异常。</p><p>4)PROPAGATN_REQUIRES_NEW</p><p>说明：如果当前存在事务，先把当前事务相关内容封装到一个实体，然后重新创建一个新事务，接受这个实体为参数，用于事务的恢复。更直白的说法就是暂停当前事务(当前无事务则不需要)，创建一个新事务。 针对这种情况，两个事务没有依赖关系，可以实现新事务回滚了，但外部事务继续执行。</p><p>5)Propagation.NOT_SUPPORTED</p><p>说明：如果当前存在事务，挂起当前事务，然后新的方法在没有事务的环境中执行，没有spring事务的环境下，sql的提交完全依赖于 defaultAutoCommit属性值 。</p><p>6) PROPAGATION_NEVER</p><p>说明： 如果当前存在事务，则抛出异常，否则在无事务环境上执行代码。</p><p>7）PROPAGATION_NESTED</p><p>说明： 如果当前存在事务，则使用 SavePoint 技术把当前事务状态进行保存，然后底层共用一个连接，当NESTED内部出错的时候，自行回滚到 SavePoint这个状态，只要外部捕获到了异常，就可以继续进行外部的事务提交，而不会受到内嵌业务的干扰，但是，如果外部事务抛出了异常，整个大事务都会回滚。</p><p>​        注意： spring配置事务管理器要主动指定 nestedTransactionAllowed=true，如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=&quot;dataTransactionManager&quot;</span><br><span class="line">    class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;</span><br><span class="line">        &lt;property name=&quot;dataSource&quot; ref=&quot;dataDataSource&quot; /&gt;</span><br><span class="line">        &lt;property name=&quot;nestedTransactionAllowed&quot; value=&quot;true&quot; /&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br></pre></td></tr></table></figure><p>例子：</p><p>​        </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public void service()&#123;</span><br><span class="line">    serviceA();</span><br><span class="line">    try&#123;</span><br><span class="line">        serviceB();</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">serviceA()&#123;</span><br><span class="line">    do sql</span><br><span class="line">&#125;</span><br><span class="line">@Transactional(propagation=Propagation.NESTED)</span><br><span class="line">serviceB()&#123;</span><br><span class="line">    do sql1</span><br><span class="line">    1/0;</span><br><span class="line">    do sql2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>serviceB是一个内嵌的业务，内部抛出了运行时异常，所以serviceB整个被回滚了，由于service捕获了异常，所以serviceA是可以正常提交的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public void service()&#123;</span><br><span class="line">     serviceA();</span><br><span class="line">     serviceB();</span><br><span class="line">     1/0;</span><br><span class="line">&#125;</span><br><span class="line">@Transactional(propagation=Propagation.NESTED)</span><br><span class="line">serviceA()&#123;</span><br><span class="line">    do sql</span><br><span class="line">&#125;</span><br><span class="line">serviceB()&#123;</span><br><span class="line">    do sql</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于service抛出了异常，所以会导致整个service方法被回滚。（这就是跟PROPAGATION_REQUIRES_NEW不一样的地方了，NESTED方式下的内嵌业务会受到外部事务的异常而回滚。）</p><h2 id="实现原理浅析"><a href="#实现原理浅析" class="headerlink" title="实现原理浅析"></a>实现原理浅析</h2><p>​        前面举例说明了spring事务提供的几种传播属性，用于满足多种不同的业务需求，大家可以依业务而定。接着我们再来看看spring实现这些传播属性最重要的技术依赖是什么。本小节列举 PROPAGATION_REQUIRES_NEW 和 Propagation.NESTED 分别进行简要说明。 </p><p>​        1、 PROPAGATION_REQUIRES_NEW 实现原理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public void service()&#123;</span><br><span class="line">    serviceB();</span><br><span class="line">    try&#123;</span><br><span class="line">        serviceA();</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Transactional(propagation=Propagation.REQUIRES_NEW)</span><br><span class="line">serviceA()&#123;</span><br><span class="line">    do sql 1</span><br><span class="line">    1/0;</span><br><span class="line">    do sql 2</span><br><span class="line">&#125;</span><br><span class="line">serviceB()&#123;</span><br><span class="line">    do sql</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        </p><p>执行原理图如下</p><p>​            </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">before service,执行a和b</span><br><span class="line"></span><br><span class="line">​执行serviceB</span><br><span class="line"></span><br><span class="line">​before serviceA, 执行c和d</span><br><span class="line"></span><br><span class="line">​执行serviceA</span><br><span class="line"></span><br><span class="line">​抛出异常</span><br><span class="line"></span><br><span class="line">​after serviceA, 执行e</span><br><span class="line"></span><br><span class="line">​after service,执行f</span><br></pre></td></tr></table></figure><p>a. 创建事务状态对象，获取一个新的连接，重置连接的 autoCommit，fetchSize，timeout等属性</p><p>b. 把连接绑定到ThreadLocal变量</p><p>c. 挂起当前事务，把当前事务状态对象，连接等信息封装成一SuspendedResources对象，可用于恢复</p><p>d. 创建新的事务状态对象，重新获取新的连接，重置新连接的 autoCommit，fetchSize，timeout等属性，同时，保存SuspendedResources对象，用于事务的恢复，把新的连接绑定到ThreadLocal变量（覆盖操作）</p><p>e. 捕获到异常，回滚ThreadLocal中的连接，恢复连接参数，关闭连接，恢复SuspendedResources</p><p>f. 提交ThreadLocal变量中的连接(导致serviceB被提交)，还原连接参数，关闭连接，连接归还数据源</p><p>所以程序执行的结果就是 serviceA被回滚了，serviceB成功提交了。</p><p>2、 PROPAGATION_NESTED 实现原理 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Transactional</span><br><span class="line">public void service()&#123;</span><br><span class="line">    serviceA();</span><br><span class="line">    try&#123;</span><br><span class="line">         serviceB();</span><br><span class="line">    &#125;catch(Exception e)&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">serviceA()&#123;</span><br><span class="line">    do sql</span><br><span class="line">&#125;</span><br><span class="line">@Transactional(propagation=Propagation.NESTED)</span><br><span class="line">serviceB()&#123;</span><br><span class="line">    do sql1</span><br><span class="line">    1/0;</span><br><span class="line">    do sql2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行原理图如下：</p><p>a. 创建事务状态对象，获取一个新的连接，重置连接的 autoCommit，fetchSize，timeout等属性</p><p>b. 把连接绑定到ThreadLocal变量</p><p>c. 标记使用当前事务状态对象，获取ThreadLocal连接对象，保存当前连接的SavePoint，用于异常恢复，此时的SavePoint就是执行完serviceA后的状态</p><p>d. 捕获到异常，使用c中的SavePoint进行事务回滚，也就是把状态回滚到执行serviceA后的状态，serviceB方法所有执行不生效</p><p>e. 获取ThreadLocal中的连接对象，提交事务，恢复连接属性，关闭连接</p><p>其他:</p><p>​        spring在底层数据源的基础上，利用 ThreadLocal，SavePoint等技术点实现了多种事务传播属性，便于实现各种复杂的业务。只有理解了传播属性的原理才能更好的驾驭spring事务。Spring回滚事务依赖于对异常的捕获，默认情况下，只有抛出RuntimeException和Error才会回滚事务，当然可以进行配置，更多信息可以查看 @Transactional 这个注解。</p><p>Spring事务的几个传播机制先假设A是大方法，B是小方法</p><p>​    required，A没有事务时调用B方法（B的事务隔离级别是required），B就会开启自己单独的事务，B要回滚的话，也是回滚B。A有事务时，B就加入到A这个事务（B不开启自己的事务了），这里发生回滚的话，AB的事务就都被回滚了。</p><p>​    new ， A没有事务时调用B方法（B的事务隔离级别是new），B就会开启自己单独的事务，B要回滚的话，也是回滚B。A有事务时，B还是会开启自己的事务，B事务发生回滚时，AB事务都会一起回滚，但是当执行了B事务时,A事务时挂起的，当执行完B事务且commit成功后，B事务结束，A事务恢复，若此时A事务发生回滚，那只是A事务回滚，不影响B事务的提交了。</p><p>​    nested，A没有事务调用B方法时（B的事务隔离级别是nested），此时就相当于是required了。A有事务时，B事务也开启，但B事务此时是相当于A事务的嵌套子事务，B事务发生回滚时，会回到B事务开启执行时的savepoint（保存点），此时B事务已经结束了，然后继续从B事务开始时的保存点开始，继续A事务。如果期间B事务没回滚，那B事务的提交也是要和A事务一起提交，而且此时B事务没回滚执行完之后，但A事务出现回滚，AB事务就没法提交，那就都回滚了（这就是嵌套子事务的概念吧？）</p><p>require回滚整个事务，nested回滚到创建回滚点的地方</p><p>参考：<a href="https://www.cnblogs.com/tartis/p/9232660.html" target="_blank" rel="noopener">https://www.cnblogs.com/tartis/p/9232660.html</a></p><p>​            <a href="https://blog.csdn.net/f45056231p/article/details/83510291" target="_blank" rel="noopener">https://blog.csdn.net/f45056231p/article/details/83510291</a></p><p>​            <a href="https://blog.csdn.net/chuangxin/article/details/80921704" target="_blank" rel="noopener">https://blog.csdn.net/chuangxin/article/details/80921704</a></p><h1 id="只读事务的概念"><a href="#只读事务的概念" class="headerlink" title="只读事务的概念"></a>只读事务的概念</h1><p>​    从这一点设置的时间点开始（时间点a）到这个事务结束的过程中，其他事务所提交的数据，该事务将看不见！（查询中不会出现别人在时间点a之后提交的数据）</p><p>应用场合：</p><p>​    如果你一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持SQL执行期间的读一致性；<br>​    如果你一次执行多条查询语句，例如统计查询，报表查询，在这种场景下，多条查询SQL必须保证整体的读一致性，否则，在前条SQL查询之后，后条SQL查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时，应该启用事务支持。<br>【注意是一次执行多次查询来统计某些信息，这时为了保证数据整体的一致性，要用只读事务】</p><p>怎样设置：</p><p>对于只读查询，可以指定事务类型为readonly，即只读事务。<br>由于只读事务不存在数据的修改，因此数据库将会为只读事务提供一些优化手段，例如Oracle对于只读事务，不启动回滚段，不记录回滚log。</p><p>（1）在JDBC中，指定只读事务的办法为： connection.setReadOnly(true);</p><p>（2）在Hibernate中，指定只读事务的办法为： session.setFlushMode(FlushMode.NEVER);<br>此时，Hibernate也会为只读事务提供Session方面的一些优化手段</p><p>（3）在Spring的Hibernate封装中，指定只读事务的办法为： bean配置文件中，prop属性增加“readOnly”<br>或者用注解方式@Transactional(readOnly=true)<br>【 if the transaction is marked as read-only, Spring will set the Hibernate Session’s flush mode to FLUSH_NEVER,<br>and will set the JDBC transaction to read-only】也就是说在Spring中设置只读事务是利用上面两种方式</p><p>在将事务设置成只读后，相当于将数据库设置成只读数据库，此时若要进行写的操作，会出现错误</p><p>参考：<a href="https://blog.csdn.net/andyzhaojianhui/article/details/51984157" target="_blank" rel="noopener">https://blog.csdn.net/andyzhaojianhui/article/details/51984157</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;事务&quot;&gt;&lt;a href=&quot;#事务&quot; class=&quot;headerlink&quot; title=&quot;事务&quot;&gt;&lt;/a&gt;事务&lt;/h1&gt;&lt;h2 id=&quot;什么是事务？&quot;&gt;&lt;a href=&quot;#什么是事务？&quot; class=&quot;headerlink&quot; title=&quot;什么是事务？&quot;&gt;&lt;/a&gt;什
      
    
    </summary>
    
    
      <category term="database" scheme="http://yoursite.com/categories/database/"/>
    
    
      <category term="Transaction" scheme="http://yoursite.com/tags/Transaction/"/>
    
  </entry>
  
  <entry>
    <title>Springmvc中的404</title>
    <link href="http://yoursite.com/2020/03/26/Spring/Springmvc%E4%B8%AD%E7%9A%84404/"/>
    <id>http://yoursite.com/2020/03/26/Spring/Springmvc%E4%B8%AD%E7%9A%84404/</id>
    <published>2020-03-26T07:45:59.000Z</published>
    <updated>2020-03-26T15:05:31.155Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于404"><a href="#关于404" class="headerlink" title="关于404"></a>关于404</h1><h2 id="Springmvc中的基本流程"><a href="#Springmvc中的基本流程" class="headerlink" title="Springmvc中的基本流程"></a>Springmvc中的基本流程</h2><p>SpringMVC从浏览器发送请求，到服务器响应数据，一共会经过哪些步骤：</p><ol><li>浏览器发送请求到前端控制器 DispatherServlet</li><li>前端控制器将请求消息转发给处理器映射器 HandlerMapping</li><li>处理器映射器将请求消息中的路径根据其映射关系,找到需要执行的Controller方法信息,并返回给前端控制器返回途中经过拦截器(拦截器根据方法拦截,经处理器映射器处理后已确定需要执行的方法信息)</li><li>前端控制器将执行方法的映射信息发送给处理器适配器HandlerAdapter</li><li>处理器适配器根据方法信息,发送给处理器Handler,找到对应的Controller方法并执行</li><li>Handler执行完返回一个ModelAndView对象给处理器适配器</li><li>处理器适配器将ModelAndView对象返回给前端控制器</li><li>前端控制器将ModelAndView对象发送给视图解析器ViewResolver</li><li>视图解析器将ModelAndView对象解析,返回一个View对象给前端控制器</li><li>前端控制器将Model中的数据填充到View中,得到一个具体的页面</li><li>前端控制器将页面视图响应给浏览器</li></ol><h2 id="springmvc的404"><a href="#springmvc的404" class="headerlink" title="springmvc的404"></a>springmvc的404</h2><p>  1）如 404 等是通过 Servlet (DispatcherServlet.noHandlerFound) 的处理并返回 response ( response.sendError) ，并未到达 Controller 层，所以并不能捕获到。</p><p>2）如果是用户请求了一个不存在的页面，没有对应的@RequestMapping，此时Spring的DispatcherServlet就会处理掉返回404，不会进入任何一个controller</p><p>3）还有比如spring security之类的权限管理模块，如果用户的密码正确，但是该账户的权限组没有权限访问当前页面，此时权限模块会有自己的AccessDeniedHandler处理，也不会进入配置的@ControllerAdvice</p><p>如果采用spring boot 或者AppInitializer来配置，需要在AppInitializer的实现类中重写createDispatcherServlet方法：</p><p>1）设置抛出NoHandlerFoundException异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">    protected DispatcherServlet createDispatcherServlet(WebApplicationContext servletAppContext) &#123;</span><br><span class="line">        final DispatcherServlet dispatcherServlet = (DispatcherServlet) super.createDispatcherServlet(servletAppContext);</span><br><span class="line">        //设置抛出NoHandlerFoundException异常</span><br><span class="line">        dispatcherServlet.setThrowExceptionIfNoHandlerFound(true);</span><br><span class="line">        return dispatcherServlet;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>2）同时在@ControllerAdvice中添加方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@ExceptionHandler</span><br><span class="line">    public ResponseEntity&lt;String&gt; handleResourceNotFoundException(NoHandlerFoundException nhre) &#123;</span><br><span class="line">        logger.error(nhre.getMessage(), nhre);</span><br><span class="line">        return new ResponseEntity&lt;String&gt;(&quot;Not Found&quot;, HttpStatus.NOT_FOUND);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们可以配置Spring在没有对应的@RequestMapping时，不要自行处理，让他抛出一个NoHandlerFoundException的异常，从而让我们配置的@ControllerAdvice进行统一处理</p><p>如果是xml风格的配置，可以在DispatcherServlet对应的配置文件中配置</p><p>如果是之前介绍的class风格的配置，可以这样配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dispatcherServlet.setThrowExceptionIfNoHandlerFound(true);//for NoHandlerFoundException</span><br></pre></td></tr></table></figure><p>实现方式1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet&gt;</span><br><span class="line">  &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt;</span><br><span class="line">  &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;</span><br><span class="line">  &lt;init-param&gt;</span><br><span class="line">   &lt;!-- 设置抛出NoHandlerFound异常，即404--&gt;</span><br><span class="line">    &lt;param-name&gt;throwExceptionIfNoHandlerFound&lt;/param-name&gt;</span><br><span class="line">    &lt;param-value&gt;true&lt;/param-value&gt;</span><br><span class="line">  &lt;/init-param&gt;</span><br><span class="line">  &lt;init-param&gt;</span><br><span class="line">    &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt;</span><br><span class="line">    &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt;</span><br><span class="line">  &lt;/init-param&gt;</span><br><span class="line">  &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;</span><br><span class="line">&lt;/servlet&gt;</span><br></pre></td></tr></table></figure><p>参考:           <a href="https://www.cnblogs.com/yangchongxing/p/9271900.html" target="_blank" rel="noopener">https://www.cnblogs.com/yangchongxing/p/9271900.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于404&quot;&gt;&lt;a href=&quot;#关于404&quot; class=&quot;headerlink&quot; title=&quot;关于404&quot;&gt;&lt;/a&gt;关于404&lt;/h1&gt;&lt;h2 id=&quot;Springmvc中的基本流程&quot;&gt;&lt;a href=&quot;#Springmvc中的基本流程&quot; class=&quot;he
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Springmvc视图解析与渲染</title>
    <link href="http://yoursite.com/2020/03/26/Spring/springmvc%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%B8%B2%E6%9F%93/"/>
    <id>http://yoursite.com/2020/03/26/Spring/springmvc%E8%A7%86%E5%9B%BE%E8%A7%A3%E6%9E%90%E4%B8%8E%E6%B8%B2%E6%9F%93/</id>
    <published>2020-03-26T07:45:59.000Z</published>
    <updated>2020-04-05T07:50:44.433Z</updated>
    
    <content type="html"><![CDATA[<h1 id="springmvc视图解析与渲染"><a href="#springmvc视图解析与渲染" class="headerlink" title="springmvc视图解析与渲染"></a>springmvc视图解析与渲染</h1><h2 id="springmvc处理步骤"><a href="#springmvc处理步骤" class="headerlink" title="springmvc处理步骤"></a>springmvc处理步骤</h2><p>具体步骤：</p><p>第一步：发起请求到前端控制器(DispatcherServlet)</p><p>第二步：前端控制器请求HandlerMapping查找 Handler （可以根据xml配置、注解进行查找）</p><p>第三步：处理器映射器HandlerMapping向前端控制器返回Handler，HandlerMapping会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象，多个HandlerInterceptor拦截器对象），通过这种策略模式，很容易添加新的映射策略</p><p>第四步：前端控制器调用处理器适配器去执行Handler</p><p>第五步：处理器适配器HandlerAdapter将会根据适配的结果去执行Handler</p><p>第六步：Handler执行完成给适配器返回ModelAndView</p><p>第七步：处理器适配器向前端控制器返回ModelAndView （ModelAndView是springmvc框架的一个底层对象，包括 Model和view）</p><p><strong><em>第八步：前端控制器请求视图解析器去进行视图解析 （根据逻辑视图名解析成真正的视图(jsp)），通过这种策略很容易更换其他视图技术，只需要更改视图解析器即可</em></strong></p><p><strong><em>第九步：视图解析器向前端控制器返回View</em></strong></p><p><strong><em>第十步：前端控制器进行视图渲染 （视图渲染将模型数据(在ModelAndView对象中)填充到request域）</em></strong></p><p><strong><em>第十一步：前端控制器向用户响应结果</em></strong></p><h2 id="视图解析与渲染-render方法"><a href="#视图解析与渲染-render方法" class="headerlink" title="视图解析与渲染(render方法)"></a>视图解析与渲染(render方法)</h2><p>org.springframework.web.servlet.DispatcherServlet#doDispatch方法中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());//945行返回了 ModelAndView 对象</span><br><span class="line">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);// 959行进行的就是返回值处理问题</span><br></pre></td></tr></table></figure><p>org.springframework.web.servlet.DispatcherServlet#processDispatchResult方法中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">render(mv, request, response); //1012进行视图的渲染（包含视图解析）</span><br></pre></td></tr></table></figure><p><strong><em>org.springframework.web.servlet.DispatcherServlet#render 方法</em></strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line">// Determine locale for request and apply it to the response.</span><br><span class="line">Locale locale =</span><br><span class="line">(this.localeResolver != null ? this.localeResolver.resolveLocale(request) : request.getLocale());</span><br><span class="line">response.setLocale(locale);</span><br><span class="line"></span><br><span class="line">View view;</span><br><span class="line">String viewName = mv.getViewName();</span><br><span class="line">if (viewName != null) &#123;</span><br><span class="line">// We need to resolve the view name.</span><br><span class="line">view = resolveViewName(viewName, mv.getModelInternal(), locale, request);</span><br><span class="line">if (view == null) &#123;</span><br><span class="line">throw new ServletException(&quot;Could not resolve view with name &apos;&quot; + mv.getViewName() +</span><br><span class="line">&quot;&apos; in servlet with name &apos;&quot; + getServletName() + &quot;&apos;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">// No need to lookup: the ModelAndView object contains the actual View object.</span><br><span class="line">view = mv.getView();</span><br><span class="line">if (view == null) &#123;</span><br><span class="line">throw new ServletException(&quot;ModelAndView [&quot; + mv + &quot;] neither contains a view name nor a &quot; +</span><br><span class="line">&quot;View object in servlet with name &apos;&quot; + getServletName() + &quot;&apos;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Delegate to the View object for rendering.</span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(&quot;Rendering view [&quot; + view + &quot;] in DispatcherServlet with name &apos;&quot; + getServletName() + &quot;&apos;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">try &#123;</span><br><span class="line">if (mv.getStatus() != null) &#123;</span><br><span class="line">response.setStatus(mv.getStatus().value());</span><br><span class="line">&#125;</span><br><span class="line">view.render(mv.getModelInternal(), request, response);</span><br><span class="line">&#125;</span><br><span class="line">catch (Exception ex) &#123;</span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(&quot;Error rendering view [&quot; + view + &quot;] in DispatcherServlet with name &apos;&quot; +</span><br><span class="line">getServletName() + &quot;&apos;&quot;, ex);</span><br><span class="line">&#125;</span><br><span class="line">throw ex;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>view = resolveViewName(viewName, mv.getModelInternal(), locale, request);视图解析，返回视图view</p><p>view.render(mv.getModelInternal(), request, response); 视图渲染</p><h2 id="视图解析：通过视图解析器进行视图的解析"><a href="#视图解析：通过视图解析器进行视图的解析" class="headerlink" title="视图解析：通过视图解析器进行视图的解析"></a>视图解析：通过视图解析器进行视图的解析</h2><p>1.解析一个视图名到一个视图对象，具体解析的过程是：在容器中查找所有配置好的视图解析器（List类型），然后进行遍历，</p><p>只要有一个视图解析器能解析出视图就返回 View 对象，若遍历完成后都不能解析出视图，那么返回 null。</p><p>具体来看：</p><p>org.springframework.web.servlet.DispatcherServlet#resolveViewName</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">protected View resolveViewName(String viewName, @Nullable Map&lt;String, Object&gt; model,</span><br><span class="line">Locale locale, HttpServletRequest request) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">if (this.viewResolvers != null) &#123;</span><br><span class="line">for (ViewResolver viewResolver : this.viewResolvers) &#123;</span><br><span class="line">View view = viewResolver.resolveViewName(viewName, locale);</span><br><span class="line">if (view != null) &#123;</span><br><span class="line">return view;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解析一个视图名到一个视图对象，具体解析的过程是：在容器中查找所有配置好的视图解析器（List类型），然后进行遍历，只要有一个视图解析器能解析出视图就返回 View 对象，若遍历完成后都不能解析出视图，那么返回 null。</p><p>创建视图，以 InternalResourceViewResolver为例，继承UrlBasedViewResolver</p><p>org.springframework.web.servlet.view.UrlBasedViewResolver#createView</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected View createView(String viewName, Locale locale) throws Exception &#123;</span><br><span class="line">// If this resolver is not supposed to handle the given view,</span><br><span class="line">// return null to pass on to the next resolver in the chain.</span><br><span class="line">if (!canHandle(viewName, locale)) &#123;</span><br><span class="line">return null;</span><br><span class="line">&#125;</span><br><span class="line">// Check for special &quot;redirect:&quot; prefix.</span><br><span class="line">if (viewName.startsWith(REDIRECT_URL_PREFIX)) &#123;</span><br><span class="line">String redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length());</span><br><span class="line">RedirectView view = new RedirectView(redirectUrl, isRedirectContextRelative(), isRedirectHttp10Compatible());</span><br><span class="line">String[] hosts = getRedirectHosts();</span><br><span class="line">if (hosts != null) &#123;</span><br><span class="line">view.setHosts(hosts);</span><br><span class="line">&#125;</span><br><span class="line">return applyLifecycleMethods(viewName, view);</span><br><span class="line">&#125;</span><br><span class="line">// Check for special &quot;forward:&quot; prefix.</span><br><span class="line">if (viewName.startsWith(FORWARD_URL_PREFIX)) &#123;</span><br><span class="line">String forwardUrl = viewName.substring(FORWARD_URL_PREFIX.length());</span><br><span class="line">return new InternalResourceView(forwardUrl);</span><br><span class="line">&#125;</span><br><span class="line">// Else fall back to superclass implementation: calling loadView.</span><br><span class="line">return super.createView(viewName, locale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在创建视图前会检查返回值是否是以：”redirect:” 或 “forward:” 开头的。</strong></p><p><strong>如果是重定向：则创建一个重定向视图，返回创建的视图。如果是转发：则返回通过 转发 url 创建的 InternalResourceView</strong> <strong>视图。</strong></p><p>super.createView(viewName, locale),调用父类创建视图</p><p>org.springframework.web.servlet.view.UrlBasedViewResolver#loadView</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">protected View createView(String viewName, Locale locale) throws Exception &#123;</span><br><span class="line">return loadView(viewName, locale);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用具体的 InternalResourceViewResolver ，然后又调用 父类的 buildView() 方法</p><p>org.springframework.web.servlet.view.UrlBasedViewResolver#buildView</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">protected AbstractUrlBasedView buildView(String viewName) throws Exception &#123;</span><br><span class="line">Class&lt;?&gt; viewClass = getViewClass();</span><br><span class="line">Assert.state(viewClass != null, &quot;No view class&quot;);</span><br><span class="line"></span><br><span class="line">AbstractUrlBasedView view = (AbstractUrlBasedView) BeanUtils.instantiateClass(viewClass);</span><br><span class="line">view.setUrl(getPrefix() + viewName + getSuffix());</span><br><span class="line"></span><br><span class="line">String contentType = getContentType();</span><br><span class="line">if (contentType != null) &#123;</span><br><span class="line">view.setContentType(contentType);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">view.setRequestContextAttribute(getRequestContextAttribute());</span><br><span class="line">view.setAttributesMap(getAttributesMap());</span><br><span class="line"></span><br><span class="line">Boolean exposePathVariables = getExposePathVariables();</span><br><span class="line">if (exposePathVariables != null) &#123;</span><br><span class="line">view.setExposePathVariables(exposePathVariables);</span><br><span class="line">&#125;</span><br><span class="line">Boolean exposeContextBeansAsAttributes = getExposeContextBeansAsAttributes();</span><br><span class="line">if (exposeContextBeansAsAttributes != null) &#123;</span><br><span class="line">view.setExposeContextBeansAsAttributes(exposeContextBeansAsAttributes);</span><br><span class="line">&#125;</span><br><span class="line">String[] exposedContextBeanNames = getExposedContextBeanNames();</span><br><span class="line">if (exposedContextBeanNames != null) &#123;</span><br><span class="line">view.setExposedContextBeanNames(exposedContextBeanNames);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return view;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看出：是通过 BeanUtils.instantiateClass(getViewClass()) 来创建 View 对象的。这个例子与其说是 InternalResourceViewResolver ，倒不如说是 UrlBasedViewResolver 类型的例子。</p><p>从这里也可以看出：该类型最终要到的目标URL为：getPrefix() + viewName + getSuffix()</p><h2 id="视图渲染"><a href="#视图渲染" class="headerlink" title="视图渲染"></a>视图渲染</h2><h3 id="View接口"><a href="#View接口" class="headerlink" title="View接口"></a>View接口</h3><p>官方文档：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`* MVC View for a web interaction. Implementations are responsible for rendering* content, and exposing the model. A single view exposes multiple model attributes.** &lt;p&gt;This class and the MVC approach associated with it is discussed in Chapter 12 of* &lt;a href=&quot;http://www.amazon.com/exec/obidos/tg/detail/-/0764543857/&quot;&gt;Expert One-On-One J2EE Design and Development&lt;/a&gt;* by Rod Johnson (Wrox, 2002).** &lt;p&gt;View implementations may differ widely. An obvious implementation would be* JSP-based. Other implementations might be XSLT-based, or use an HTML generation library.* This interface is designed to avoid restricting the range of possible implementations.** &lt;p&gt;Views should be beans. They are likely to be instantiated as beans by a ViewResolver.* As this interface is stateless, view implementations should be thread-safe.`</span><br></pre></td></tr></table></figure><p>说明：</p><p>SpringMVC 对一个 web 来说是相互作用的（不太明白）。View 的实现类是负责呈现内容的，并且 exposes（暴露、揭露、揭发的意思，这里就按暴露解释吧，想不出合适的词语） 模型的。</p><p>一个单一的视图可以包含多个模型。</p><p>View 的实现可能有很大的不同。一个明显的实现是基于 JSP 的。其他的实现可能是基于 XSLT 的，或者是一个 HTML 生成库。</p><p>设计这个接口是为了避免约束可能实现的范围（这里是不是说，我们可以通过实现该接口来自定义扩展自定义视图？）。</p><p>所有的视图都应该是一个 Bean 类。他们可能被 ViewResolver 当做一个 bean 进行实例化。</p><p>由于这个接口是无状态的，View 的所有实现类应该是线程安全的。</p><h3 id="View接口的实现类"><a href="#View接口的实现类" class="headerlink" title="View接口的实现类"></a>View接口的实现类</h3><p><strong><em>IDEA中crtl+H可查看View接口所有的实现类</em></strong></p><h3 id="具体渲染的一个过程"><a href="#具体渲染的一个过程" class="headerlink" title="具体渲染的一个过程"></a>具体渲染的一个过程</h3><p>​        举例：View类型为JstlView</p><p>继承关系：</p><p>public class <strong><em>JstlView</em></strong> extends <strong><em>InternalResourceView</em></strong></p><p>​    public class <strong><em>InternalResourceView</em></strong> extends <strong><em>AbstractUrlBasedView</em></strong></p><p>​        public abstract class <strong><em>AbstractUrlBasedView</em></strong> extends <strong><em>AbstractView</em></strong> implements InitializingBean </p><p>​                    public abstract class <strong><em>AbstractView</em></strong> extends WebApplicationObjectSupport implements <strong><em>View</em></strong>,     BeanNameAware</p><p>通过org.springframework.web.servlet.DispatcherServlet#render 方法中的渲染view.render(mv.getModelInternal(), request, response);</p><p>进入到org.springframework.web.servlet.view.AbstractView#render</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void render(@Nullable Map&lt;String, ?&gt; model, HttpServletRequest request,</span><br><span class="line">HttpServletResponse response) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">if (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(&quot;Rendering view with name &apos;&quot; + this.beanName + &quot;&apos; with model &quot; + model +</span><br><span class="line">&quot; and static attributes &quot; + this.staticAttributes);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Map&lt;String, Object&gt; mergedModel = createMergedOutputModel(model, request, response);</span><br><span class="line">prepareResponse(request, response);</span><br><span class="line">renderMergedOutputModel(mergedModel, getRequestToExpose(request), response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>renderMergedOutputModel(mergedModel, getRequestToExpose(request), response);</p><p>这里只看 org.springframework.web.servlet.view.InternalResourceView#renderMergedOutputModel 这个方法</p><p>renderMergedOutputModel（渲染合并输出模型）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void renderMergedOutputModel(</span><br><span class="line">Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">// Expose the model object as request attributes.</span><br><span class="line">exposeModelAsRequestAttributes(model, request);</span><br><span class="line"></span><br><span class="line">// Expose helpers as request attributes, if any.</span><br><span class="line">exposeHelpers(request);</span><br><span class="line"></span><br><span class="line">// Determine the path for the request dispatcher.</span><br><span class="line">String dispatcherPath = prepareForRendering(request, response);</span><br><span class="line"></span><br><span class="line">// Obtain a RequestDispatcher for the target resource (typically a JSP).</span><br><span class="line">RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath);</span><br><span class="line">if (rd == null) &#123;</span><br><span class="line">throw new ServletException(&quot;Could not get RequestDispatcher for [&quot; + getUrl() +</span><br><span class="line">&quot;]: Check that the corresponding file exists within your web application archive!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// If already included or response already committed, perform include, else forward.</span><br><span class="line">if (useInclude(request, response)) &#123;</span><br><span class="line">response.setContentType(getContentType());</span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(&quot;Including resource [&quot; + getUrl() + &quot;] in InternalResourceView &apos;&quot; + getBeanName() + &quot;&apos;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">rd.include(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">else &#123;</span><br><span class="line">// Note: The forwarded resource is supposed to determine the content type itself.</span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(&quot;Forwarding to resource [&quot; + getUrl() + &quot;] in InternalResourceView &apos;&quot; + getBeanName() + &quot;&apos;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">rd.forward(request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath);//创建RequestDispatcher</p><p>rd.forward(request, response); //转发请求</p><p>可以看到前面的几个步骤都是为 RequestDispatch 做准备，装填数据。最后，到目标页面是通过转发。</p><h3 id="DispatcherServlet做最后处理"><a href="#DispatcherServlet做最后处理" class="headerlink" title="DispatcherServlet做最后处理"></a>DispatcherServlet做最后处理</h3><p>DispatcherServlet继承FrameworkServlet</p><p>FrameworkServlet重写service()方法,(也重写了doGet,doPost方法等）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">protected void service(HttpServletRequest request, HttpServletResponse response)</span><br><span class="line">throws ServletException, IOException &#123;</span><br><span class="line"></span><br><span class="line">HttpMethod httpMethod = HttpMethod.resolve(request.getMethod());</span><br><span class="line">if (HttpMethod.PATCH == httpMethod || httpMethod == null) &#123;</span><br><span class="line">processRequest(request, response);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">super.service(request, response);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1）service()方法或者super.service()方法，以及super.service()方法调用的doGet(),doPost()等等都调用processRequest()方法</p><p>2）processRequest()方法，processRequest()调用doService()方法</p><p>3）doService()调用doDispatch(request, response)，</p><p>4）doDispatch(request, response)调用processDispatchResult()，</p><p>5）processDispatchResult方法调用render()方法，虽然在render()方法中请求已经转发，但是后面还做了一些异常处理等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Handle the result of handler selection and handler invocation, which is</span><br><span class="line"> * either a ModelAndView or an Exception to be resolved to a ModelAndView.</span><br><span class="line"> */</span><br><span class="line">private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,</span><br><span class="line">@Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,</span><br><span class="line">@Nullable Exception exception) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">boolean errorView = false;</span><br><span class="line"></span><br><span class="line">if (exception != null) &#123;</span><br><span class="line">if (exception instanceof ModelAndViewDefiningException) &#123;</span><br><span class="line">logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception);</span><br><span class="line">mv = ((ModelAndViewDefiningException) exception).getModelAndView();</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null);</span><br><span class="line">mv = processHandlerException(request, response, handler, exception);</span><br><span class="line">errorView = (mv != null);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Did the handler return a view to render?</span><br><span class="line">if (mv != null &amp;&amp; !mv.wasCleared()) &#123;</span><br><span class="line">render(mv, request, response);</span><br><span class="line">if (errorView) &#123;</span><br><span class="line">WebUtils.clearErrorRequestAttributes(request);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">if (logger.isDebugEnabled()) &#123;</span><br><span class="line">logger.debug(&quot;Null ModelAndView returned to DispatcherServlet with name &apos;&quot; + getServletName() +</span><br><span class="line">&quot;&apos;: assuming HandlerAdapter completed request handling&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;</span><br><span class="line">// Concurrent handling started during a forward</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if (mappedHandler != null) &#123;</span><br><span class="line">mappedHandler.triggerAfterCompletion(request, response, null);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>介绍了 SpringMVC 视图解析和视图渲染问题是如何解决的。SpringMVC 为逻辑视图提供了多种视图解析策略，可以在配置文件中配置多个视图的解析策略。并制定其先后顺序。</p><p>这里所说的视图解析策略，就是指视图解析器。视图解析器会将逻辑视图名解析为一个具体的视图对象。再说视图渲染的过程，视图对模型进行了渲染，最终将模型的数据以某种形式呈现给用户。</p><p>参考：<a href="https://www.cnblogs.com/solverpeng/p/5743609.html" target="_blank" rel="noopener">https://www.cnblogs.com/solverpeng/p/5743609.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;springmvc视图解析与渲染&quot;&gt;&lt;a href=&quot;#springmvc视图解析与渲染&quot; class=&quot;headerlink&quot; title=&quot;springmvc视图解析与渲染&quot;&gt;&lt;/a&gt;springmvc视图解析与渲染&lt;/h1&gt;&lt;h2 id=&quot;springmvc
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>jsp中使用基路径</title>
    <link href="http://yoursite.com/2020/03/25/Java%20Web/jsp%E4%BD%BF%E7%94%A8%E5%9F%BA%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2020/03/25/Java%20Web/jsp%E4%BD%BF%E7%94%A8%E5%9F%BA%E8%B7%AF%E5%BE%84/</id>
    <published>2020-03-25T07:20:03.000Z</published>
    <updated>2020-03-25T07:07:17.603Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基路径的使用问题"><a href="#基路径的使用问题" class="headerlink" title="基路径的使用问题"></a>基路径的使用问题</h1><h2 id="在jsp中使用基路径base-href"><a href="#在jsp中使用基路径base-href" class="headerlink" title="在jsp中使用基路径base href"></a>在jsp中使用基路径base href</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">%@</span> <span class="attr">page</span> <span class="attr">contentType</span>=<span class="string">"text/html;charset=UTF-8"</span> <span class="attr">language</span>=<span class="string">"java"</span> <span class="attr">isELIgnored</span>=<span class="string">"false"</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">%</span></span></span><br><span class="line"><span class="tag">    <span class="attr">String</span> <span class="attr">path</span> = <span class="string">request.getContextPath();//项目的发布路径，例如:</span> /<span class="attr">rabc</span></span></span><br><span class="line"><span class="tag">    <span class="attr">String</span> <span class="attr">basePath</span> =   <span class="string">request.getScheme()+</span>"<span class="attr">:</span>//"+<span class="attr">request.getServerName</span>()+"<span class="attr">:</span>"+<span class="attr">request.getServerPort</span>()+<span class="attr">path</span>+"/";</span></span><br><span class="line"><span class="tag">%&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">"&lt;%=basePath%&gt;"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>欢迎使用路人丁OA<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"test"</span>&gt;</span>测试<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>a标签中的路径    href=”test”         则访问           <a href="http://localhost:8080/动态获取项目名/test" target="_blank" rel="noopener">http://localhost:8080/动态获取项目名/test</a></p><p>​    推荐使用</p><p>a标签中的路径    href=”/test”        则访问          <a href="http://localhost:8080/test" target="_blank" rel="noopener">http://localhost:8080/test</a></p><h2 id="不使用base-href"><a href="#不使用base-href" class="headerlink" title="不使用base href"></a>不使用base href</h2><h3 id="一"><a href="#一" class="headerlink" title="一"></a>一</h3><p>a标签中的路径    href=”test”         则访问          当前路径的相对路径</p><p>​        例如当前路径   <a href="http://localhost:8080/项目名/duty/duty.html" target="_blank" rel="noopener">http://localhost:8080/项目名/duty/duty.html</a></p><p>​        则访问               <a href="http://localhost:8080/项目名/duty/test" target="_blank" rel="noopener">http://localhost:8080/项目名/duty/test</a></p><p>因此该种方式不推荐使用</p><h2 id="二"><a href="#二" class="headerlink" title="二"></a>二</h2><p>a标签中的路径    href=”/test”        则访问          <a href="http://localhost:8080/test" target="_blank" rel="noopener">http://localhost:8080/test</a></p><p>在项目直接部署在根路径下可以使用，即不使用项目名</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基路径的使用问题&quot;&gt;&lt;a href=&quot;#基路径的使用问题&quot; class=&quot;headerlink&quot; title=&quot;基路径的使用问题&quot;&gt;&lt;/a&gt;基路径的使用问题&lt;/h1&gt;&lt;h2 id=&quot;在jsp中使用基路径base-href&quot;&gt;&lt;a href=&quot;#在jsp中使用基路径
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="jsp" scheme="http://yoursite.com/tags/jsp/"/>
    
  </entry>
  
  <entry>
    <title>jsp中的标签库</title>
    <link href="http://yoursite.com/2020/03/20/Java%20Web/jsp%E7%9A%84%E6%A0%87%E7%AD%BE%E5%BA%93/"/>
    <id>http://yoursite.com/2020/03/20/Java%20Web/jsp%E7%9A%84%E6%A0%87%E7%AD%BE%E5%BA%93/</id>
    <published>2020-03-20T08:20:03.000Z</published>
    <updated>2020-03-20T10:11:20.685Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JSP中的标签库"><a href="#JSP中的标签库" class="headerlink" title="JSP中的标签库"></a>JSP中的标签库</h1><h2 id="标签库运行原理"><a href="#标签库运行原理" class="headerlink" title="标签库运行原理"></a>标签库运行原理</h2><p>​        JSP标签的定义步骤：</p><p>​                    1  创建标记处理类( 处理标签的类必须扩展javax.servlet.jsp.TagSupport 或 BodyTagSupport)</p><p>​                    2   创建TLD文件</p><p>​                    3   在jsp页面通过指令引入标签库                </p><h2 id="自定义标签库"><a href="#自定义标签库" class="headerlink" title="自定义标签库"></a>自定义标签库</h2><p>​        创建标记处理类:        </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package test; </span><br><span class="line">import javax.servlet.jsp.JspException; </span><br><span class="line">import javax.servlet.jsp.JspWriter; </span><br><span class="line">import javax.servlet.jsp.tagext.TagSupport; </span><br><span class="line"></span><br><span class="line">public class OutputTag extends TagSupport &#123; </span><br><span class="line">private String name=null; </span><br><span class="line">public void setName(String name) &#123; </span><br><span class="line">this.name = name; </span><br><span class="line">&#125; </span><br><span class="line">public int doEndTag() throws JspException </span><br><span class="line">&#123; </span><br><span class="line">try &#123; </span><br><span class="line">JspWriter out = pageContext.getOut(); </span><br><span class="line">out.print(&quot;Hello! &quot; + name); </span><br><span class="line">　　&#125; catch (Exception e) &#123; throw new JspException(e); &#125; </span><br><span class="line">return EVAL_PAGE; </span><br><span class="line">&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>1 如何输出到jsp页面：调用JspWriter JspWriter out = pageContext.getOut();out.print……记住这个方法就可以了。<br>2 输出后如何作处理，函数会返回几个值之一。EVAL_PAGE 表示tag已处理完毕，返回jsp页面。还有几个值，例如 EVAL_BODY_AGAIN 和EVAL_BODY_INCLUDE等 跟流程控制有关. </p><p>Tag系列的Interface里定义的静态int,通过他们也能一窥tag组键的执行流程,这几个静态值分别是：<br>SKIP_BODY ： 跳过了开始和结束标签之间的代码,一般是在doStartTag中使用<br>EVAL_BODY_INCLUDE ：处理嵌套的标签,一般是在doStartTag中使用,由负责处理标签正文的tag接口提供<br>EVAL_BODY_BUFFERED :对包含的内容进行解析 一般是在doStartTag中使用,由负责处理标签正文的bodyTag接口提供,目的是通知jsp容器作好读取正文的工作(创建一个body-content包装正文和获取存放操作结果的out对象,便于以后的操作和输出).<br>EVAL_BODY_AGAIN:处理标签正文,嵌套标签的iteratorTag接口的使用<br>SKIP_PAGE ： 忽略剩下的页面,一般是在doEndTag中使用<br>EVAL_PAGE ： 继续执行下面的页, 一般是在doEndTag中使用</p><p>编写tld 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot; ?&gt; </span><br><span class="line">&lt;!DOCTYPE taglib PUBLIC &quot;-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.2//EN&quot; &quot;http://java.sun.com/dtd/web-jsptaglibrary_1_2.dtd&quot;&gt; </span><br><span class="line">&lt;taglib&gt; </span><br><span class="line">&lt;tlib-version&gt;1.0&lt;/tlib-version&gt; </span><br><span class="line">&lt;jsp-version&gt;1.2&lt;/jsp-version&gt; </span><br><span class="line">&lt;short-name&gt;test&lt;/short-name&gt; </span><br><span class="line">&lt;!--OutputTag--&gt; </span><br><span class="line">&lt;tag&gt; </span><br><span class="line">&lt;name&gt;out&lt;/name&gt; </span><br><span class="line">&lt;!-- 全限定路径 --&gt;</span><br><span class="line">&lt;tag-class&gt;test.OutputTag&lt;/tag-class&gt; </span><br><span class="line">&lt;body-content&gt;empty&lt;/body-content&gt; </span><br><span class="line">&lt;attribute&gt; </span><br><span class="line">&lt;name&gt;name&lt;/name&gt; </span><br><span class="line">&lt;required&gt;false&lt;/required&gt; </span><br><span class="line">&lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt; </span><br><span class="line">&lt;/attribute&gt; </span><br><span class="line">&lt;/tag&gt; </span><br><span class="line">&lt;/taglib&gt;</span><br></pre></td></tr></table></figure><p>在WEB-INF下新建tlds文件夹，把这个文件取名为test.tld，放到tlds文件夹下。引用时的路径应该这样：WEB-INF\tlds\test.tld </p><p>关于tld的简单说明：<br>short-name：taglib的名称，也称为前缀。比如“c:out value=””/” 里的“c”<br>name：tag的名字。例如“c:out value=””/” 里的”out”，我们的类也取名为out，由于有前缀作区分，不会同其他库的    同名tag组件混淆<br>tag-class：完整的tag组件路径,记着带包名<br>body-content：指tag之间的内容。例如c:out value=”” …… /c 起始和关闭标签之间就是body-content。由于没有处理body-content ，所以上面设为empty,如果是嵌套标签,或则是要在服务器端处理标签体的话,就是jsp了<br>“attribute”里的name：属性名字。例如c:out value=””/里的value。名字可任意取，只要类里提供相应的set方法即  可。<br>required：是否必填属性。<br>rtexprvalue：是否支持运行时表达式取值就是是否可以&lt;%=%&gt;或则是${}方式传值。<br>这是tag的强大功能。 </p><p>编写jsp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=&quot;java&quot;%&gt; </span><br><span class="line">&lt;%@ taglib uri=&quot;/WEB-INF/tlds/test.tld&quot; prefix=&quot;test&quot;%&gt; </span><br><span class="line">&lt;html&gt; </span><br><span class="line">&lt;body&gt; </span><br><span class="line">Test Tag: &lt;test:out name=&quot;TEST&quot;/&gt; </span><br><span class="line">&lt;/body&gt; </span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2 id="标签库的uri路径引入"><a href="#标签库的uri路径引入" class="headerlink" title="标签库的uri路径引入"></a>标签库的uri路径引入</h2><p>​            在JSP中使用标签是很平常的事情，在制作自定义标签时，通常都需要写tld文件来定义标签的各种属性，对应的java类，前缀等等。标签与tld文件紧紧相连，那么，到底应该怎么放置tld文件？在web.xml中怎么定义tld文件的位置？</p><p>​        Web容器(jsp引擎)遇到类似【&lt;c:import】这样的标签时，会通过prefix定位到uri，再根据uri定位到相应的tld文件，对tld文件进行解析。其中uri ——–tld文件的映射关系如下：</p><p>​        <strong>Key</strong>   （Uri）                                                              <strong>Value</strong>（String[] taglib_tld_location）</p><p>​    /jstl-examples-taglib、                                            taglib_tld_location[0] + taglib_tld_location[1]</p><p><a href="http://java.sun.com/jstl/core" target="_blank" rel="noopener">http://java.sun.com/jstl/core</a>                                        </p><p>Tld文件路径定义方式</p><p>​        如下<strong><em>方式1和方式2只能在2.3版本使用</em></strong>，Servlet2.4开始便不能在web.xml中定义taglib了。</p><p>​        &lt;!DOCTYPE web-app</p><pre><code>PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;</code></pre><p>​                    “<a href="http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt;" target="_blank" rel="noopener">http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt;</a></p><p>l          <strong>方式1</strong>：</p><p>​                如下所示，在web.xml中定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &lt;taglib&gt;</span><br><span class="line">      &lt;taglib-uri&gt;/jstl-examples-taglib&lt;/taglib-uri&gt;</span><br><span class="line">      &lt;taglib-location&gt;/WEB-INF/lib/jstl-examples.tld&lt;/taglib-location&gt;</span><br><span class="line">&lt;/taglib&gt;</span><br></pre></td></tr></table></figure><p>如果这样定义的话，映射关系便如下：</p><p>/jstl-examples-taglib —————-{“/WEB-INF/lib/jstl-examples.tld”,””} // taglib_tld_location[0]就足以表示tld路径，因此taglib_tld_location[1]为空。</p><p>​    <strong>方式二:</strong></p><p>​        如下所示，在web.xml中定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> &lt;taglib&gt;</span><br><span class="line">      &lt;taglib-uri&gt;/jstl-examples-taglib&lt;/taglib-uri&gt;</span><br><span class="line">      &lt;taglib-location&gt;/WEB-INF/lib/jstl-examples.jar&lt;/taglib-location&gt;</span><br><span class="line">&lt;/taglib&gt;</span><br></pre></td></tr></table></figure><p>如果这样定义的话，映射关系便如下：</p><p>/jstl-examples-taglib     ———–     {“/WEB-INF/lib/ jstl-examples.jar”,” META-INF/taglib.tld”}</p><p> // taglib_tld_location[0]表示jar路径，taglib_tld_location[1]固定为META-INF/taglib.tld(也就是说，tld在jar文件中的保存路径必须是META-INF/taglib.tld，名称必须是taglib.tld)。这就是说一个jar里只能有一个tld。如果代码中不固定为taglib.tld的话，也很难处理，因为如果tld的名称可以随便定义的话，出现多个tld在jar文件中时将会导致混乱。</p><p><strong>方式三：</strong></p><p>不需要在web.xml中定义，只需要把tld保存在web应用能够使用的jar文件中的META-INF路径下便可。这种情况的机制是这样的：web容器会遍历当前web应用能够访问的jar文件，从jar文件中查找META-INF/xxx.tld文件，当找到一个tld文件之后，便会解析tld文件，取出<taglib>节点的<uri>值，把uri作为key值生成映射关系。</uri></taglib></p><p>如下所示的jstl的core标签库的tld文件，便会有如下的映射关系</p><p><a href="http://java.sun.com/jstl/core" target="_blank" rel="noopener">http://java.sun.com/jstl/core</a> ——–{“tld文件所在的jar文件的路径”,” META-INF/xxx.tld”}</p><p>//taglib_tld_location[0]表示jar路径，taglib_tld_location[1]为所搜到的tld在jar文件中的相对路径</p><p>例：这是jstl.jar中的META-INF/c.tld文件的部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">&lt;description&gt;JSTL 1.1 core library&lt;/description&gt;</span><br><span class="line">  &lt;display-name&gt;JSTL core&lt;/display-name&gt;</span><br><span class="line">  &lt;tlib-version&gt;1.1&lt;/tlib-version&gt;</span><br><span class="line">  &lt;short-name&gt;c&lt;/short-name&gt;</span><br><span class="line">  &lt;uri&gt;http://java.sun.com/jsp/jstl/core&lt;/uri&gt;</span><br><span class="line"></span><br><span class="line">  &lt;validator&gt;</span><br><span class="line">    &lt;description&gt;</span><br><span class="line">        Provides core validation features for JSTL tags.</span><br><span class="line">    &lt;/description&gt;</span><br><span class="line">    &lt;validator-class&gt;</span><br><span class="line">        org.apache.taglibs.standard.tlv.JstlCoreTLV</span><br><span class="line">    &lt;/validator-class&gt;</span><br><span class="line">  &lt;/validator&gt;</span><br><span class="line"></span><br><span class="line">  &lt;tag&gt;</span><br><span class="line">    &lt;description&gt;</span><br><span class="line">        Catches any Throwable that occurs in its body and optionally</span><br><span class="line">        exposes it.</span><br><span class="line">    &lt;/description&gt;</span><br><span class="line">    &lt;name&gt;catch&lt;/name&gt;</span><br><span class="line">    &lt;tag-class&gt;org.apache.taglibs.standard.tag.common.core.CatchTag&lt;/tag-class&gt;</span><br><span class="line">    &lt;body-content&gt;JSP&lt;/body-content&gt;</span><br><span class="line">    &lt;attribute&gt;</span><br><span class="line">        &lt;description&gt;</span><br><span class="line">Name of the exported scoped variable for the</span><br><span class="line">exception thrown from a nested action. The type of the</span><br><span class="line">scoped variable is the type of the exception thrown.</span><br><span class="line">        &lt;/description&gt;</span><br><span class="line">        &lt;name&gt;var&lt;/name&gt;</span><br><span class="line">        &lt;required&gt;false&lt;/required&gt;</span><br><span class="line">        &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt;</span><br><span class="line">    &lt;/attribute&gt;</span><br><span class="line">  &lt;/tag&gt;</span><br></pre></td></tr></table></figure><p>Tld文件的解析逻辑</p><p>以jstl为例：</p><p>Web容器遇到类似【&lt;c:import】标签时，就会通过在头部中定义的&lt;%@ taglib prefix=”c” uri=”<a href="http://java.sun.com/jstl/core&quot;" target="_blank" rel="noopener">http://java.sun.com/jstl/core&quot;</a> %&gt;找到uri，再根据此uri便可以定位到taglib_tld_location。当taglib_tld_location[0]不是jar文件时，便直接使用java的FileInputStream读取tld文件；当taglib_tld_location[0]是jar文件时，则会</p><p>通过如下代码读取tld文件。</p><p>URL jarFileUrl = new URL(“jar:” + location[0] + “!/“);</p><p>ZipEntry jarEntry = jarFile.getEntry(location[1]);</p><p>总结:</p><p>​        tld的定义可以不在web.xml中定义，这时需要保证tld在web应用能够访问的jar中，并且保存在jar的META-INF目录下。此时JSP直接使用tld中定义的\&lt;uri>便可；</p><p>如果在web.xml中定义tld的路径的话，可以直接指定tld文件路径，此时要保证tld不在jar包中(比如在WEB-INF目录下)；也可以指定为jar文件路径，此时要保证tld在jar中且路径为META-INF/taglib.tld。</p><p>在web.xml中定义的uri优先级要高于tld文件中定义的优先级。</p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>​        jsp中使用JSTL，需要哪些jar包?</p><p>​                jstl.jar和standard.jar</p><p>​                standard.jar是JSP标准标签库，和jstl.jar 1.0版本中一起使用，</p><p>​                但在jstl-1.2.jar就不再需要了</p><p>参考:    JSP标签在tomcat中的运行原理  <a href="https://www.iteye.com/blog/jianfulove-1826982" target="_blank" rel="noopener">https://www.iteye.com/blog/jianfulove-1826982</a></p><p>​             jsp自定义标签(taglib)编写的原理和实现 <a href="https://blog.csdn.net/zhangdaiscott/article/details/8622975" target="_blank" rel="noopener">https://blog.csdn.net/zhangdaiscott/article/details/8622975</a></p><p>​            如何引用自定义标签库中的tld文件 <a href="http://blog.sina.com.cn/s/blog_7ffe993c01019ebe.html" target="_blank" rel="noopener">http://blog.sina.com.cn/s/blog_7ffe993c01019ebe.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;JSP中的标签库&quot;&gt;&lt;a href=&quot;#JSP中的标签库&quot; class=&quot;headerlink&quot; title=&quot;JSP中的标签库&quot;&gt;&lt;/a&gt;JSP中的标签库&lt;/h1&gt;&lt;h2 id=&quot;标签库运行原理&quot;&gt;&lt;a href=&quot;#标签库运行原理&quot; class=&quot;header
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="jsp" scheme="http://yoursite.com/tags/jsp/"/>
    
  </entry>
  
  <entry>
    <title>mybatis中xml映射和方法注解两种配置sql语句的方式是否可以同时存在</title>
    <link href="http://yoursite.com/2019/12/12/DataBase/MyBatis/mybatis%E4%B8%ADxml%E6%98%A0%E5%B0%84%E5%92%8C%E6%96%B9%E6%B3%95%E6%B3%A8%E8%A7%A3%E4%B8%A4%E7%A7%8D%E9%85%8D%E7%BD%AEsql%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E5%AD%98%E5%9C%A8/"/>
    <id>http://yoursite.com/2019/12/12/DataBase/MyBatis/mybatis%E4%B8%ADxml%E6%98%A0%E5%B0%84%E5%92%8C%E6%96%B9%E6%B3%95%E6%B3%A8%E8%A7%A3%E4%B8%A4%E7%A7%8D%E9%85%8D%E7%BD%AEsql%E8%AF%AD%E5%8F%A5%E7%9A%84%E6%96%B9%E5%BC%8F%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%90%8C%E6%97%B6%E5%AD%98%E5%9C%A8/</id>
    <published>2019-12-12T03:07:30.000Z</published>
    <updated>2019-12-12T03:12:41.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="mybatis中xml映射和方法注解两种配置sql语句的方式是否可以同时存在"><a href="#mybatis中xml映射和方法注解两种配置sql语句的方式是否可以同时存在" class="headerlink" title="mybatis中xml映射和方法注解两种配置sql语句的方式是否可以同时存在"></a>mybatis中xml映射和方法注解两种配置sql语句的方式是否可以同时存在</h1><p>​    不能进行同时设置。执行会找不到接口的mapper代理工厂。mybatis会先解析xml文件，将解析后的sql封装在mapperstament中并放进Configuration的mappedStatements中，将命名空间和方法名（也就是id）作为key，mappedStatements是个自定义map。然后生成接口的代理工程，生产代理工厂后会解析注解，解析完注解，也会生成mapperstament，也会往统一的Configuration大对象里面放，但是放的时候自定义map会先判断是否存在，此时已经存在了，存在就会抛出IllegalArgumentException(name + “ already contains value for “ + key）。但是创建代理工厂的时候把异常吃掉了，所以加载的时候不会报错，但是不会给接口生成代理工厂。没有代理工厂，接口就没有实现类去操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;mybatis中xml映射和方法注解两种配置sql语句的方式是否可以同时存在&quot;&gt;&lt;a href=&quot;#mybatis中xml映射和方法注解两种配置sql语句的方式是否可以同时存在&quot; class=&quot;headerlink&quot; title=&quot;mybatis中xml映射和方法
      
    
    </summary>
    
    
      <category term="database" scheme="http://yoursite.com/categories/database/"/>
    
    
      <category term="mybatis" scheme="http://yoursite.com/tags/mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Spring中的事件处理</title>
    <link href="http://yoursite.com/2019/09/04/Spring/Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2019/09/04/Spring/Spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/</id>
    <published>2019-09-04T07:45:59.000Z</published>
    <updated>2019-09-04T08:21:06.028Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Spring中的事件处理"><a href="#Spring中的事件处理" class="headerlink" title="Spring中的事件处理"></a>Spring中的事件处理</h2><p>Spring 的核心是 <strong>ApplicationContext</strong>，它负责管理 beans 的完整生命周期。当加载 beans 时，ApplicationContext 发布某些类型的事件。例如，当上下文启动时，<em>ContextStartedEvent</em> 发布，当上下文停止ContextStoppedEvent发布。</p><p>通过 <em>ApplicationEvent</em> 类和 <em>ApplicationListener</em> 接口来提供在 <em>ApplicationContext</em> 中处理事件。如果一个 bean 实现 <em>ApplicationListener</em>，那么每次 <em>ApplicationEvent</em> 被发布到 ApplicationContext 上，那个 bean 会被通知。</p><p>Spring 提供了以下的标准事件：</p><table><thead><tr><th style="text-align:left">序号</th><th style="text-align:left">Spring 内置事件 &amp; 描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left"><strong>ContextRefreshedEvent*</strong>ApplicationContext<em> 被初始化或刷新时，该事件被发布。这也可以在 </em>ConfigurableApplicationContext*接口中使用 refresh() 方法来发生。</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left"><strong>ContextStartedEvent</strong>当使用 <em>ConfigurableApplicationContext</em> 接口中的 start() 方法启动 <em>ApplicationContext</em> 时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left"><strong>ContextStoppedEvent</strong>当使用 <em>ConfigurableApplicationContext</em> 接口中的 stop() 方法停止 <em>ApplicationContext</em> 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作。</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left"><strong>ContextClosedEvent</strong>当使用 <em>ConfigurableApplicationContext</em> 接口中的 close() 方法关闭 <em>ApplicationContext</em> 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启。</td></tr><tr><td style="text-align:left">5</td><td style="text-align:left"><strong>RequestHandledEvent</strong>这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务。</td></tr></tbody></table><p><strong><em>由于 Spring 的事件处理是单线程的，所以如果一个事件被发布，直至并且除非所有的接收者得到的该消息，该进程被阻塞并且流程将不会继续。因此，如果事件处理被使用，在设计应用程序时应注意。</em></strong></p><h2 id="监听上下文事件"><a href="#监听上下文事件" class="headerlink" title="监听上下文事件"></a>监听上下文事件</h2><p>为了监听上下文事件，一个 bean 应该实现只有一个方法 <strong>onApplicationEvent()</strong> 的 <em>ApplicationListener</em> 接口。因此，我们写一个例子来看看事件是如何传播的，以及如何可以用代码来执行基于某些事件所需的任务。</p><p>让我们在恰当的位置使用 Eclipse IDE，然后按照下面的步骤来创建一个 Spring 应用程序：</p><table><thead><tr><th style="text-align:left">步骤</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">1</td><td style="text-align:left">创建一个名称为 <em>SpringEvent</em>Test 的项目，并且在创建项目的 <strong>src</strong> 文件夹中创建一个包com.szxy</td></tr><tr><td style="text-align:left">2</td><td style="text-align:left">使用 <em>Add External JARs</em> 选项，添加所需的 Spring 库</td></tr><tr><td style="text-align:left">3</td><td style="text-align:left">在 <em>com.szxy包中创建 Java 类 </em>HelloSpringEvent<em>、</em>CStartEventHandler<em>、</em>CStopEventHandler* 和 Start</td></tr><tr><td style="text-align:left">4</td><td style="text-align:left">在 <strong>src</strong> 文件夹中创建 Bean 的配置文件 <em>applicationContext.xml.xml</em></td></tr><tr><td style="text-align:left">5</td><td style="text-align:left">最后一步是创建的所有 Java 文件和 Bean 配置文件的内容，并运行应用程序，解释如下所示.</td></tr></tbody></table><p>这里是 <strong>HelloSpringEvent.java</strong> 文件的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">package com.szxy;</span><br><span class="line"></span><br><span class="line">public class HelloSpringEvent &#123;</span><br><span class="line"></span><br><span class="line">private String msg;</span><br><span class="line"></span><br><span class="line">public HelloSpringEvent()&#123;</span><br><span class="line">System.out.println(&quot;HelloSpringEvent 初始化&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public String getMsg() &#123;</span><br><span class="line">return msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void setMsg(String msg) &#123;</span><br><span class="line">this.msg = msg;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是 <strong>CStartEventHandler.java</strong> 文件的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.szxy;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationListener;</span><br><span class="line">import org.springframework.context.event.ContextStartedEvent;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * ContextStartedEvent:</span><br><span class="line"> * 当使用 ConfigurableApplicationContext 接口中的 start()方法启动 ApplicationContext时,</span><br><span class="line"> * 该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。</span><br><span class="line"> * @author Administrator</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class CStartEventHandler implements ApplicationListener&lt;ContextStartedEvent&gt;&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onApplicationEvent(ContextStartedEvent event) &#123;</span><br><span class="line">System.out.println(&quot;ContextStartedEvent start!!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是 <strong>CStopEventHandler.java</strong> 文件的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.szxy;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationListener;</span><br><span class="line">import org.springframework.context.event.ContextStoppedEvent;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * ContextStoppedEvent:</span><br><span class="line"> * 当使用 ConfigurableApplicationContext 接口中的 stop() 方法停止 ApplicationContext 时，</span><br><span class="line"> *发布这个事件。你可以在接受到这个事件后做必要的清理的工作。</span><br><span class="line"> * @author Administrator</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class CStopEventHandler implements ApplicationListener&lt;ContextStoppedEvent&gt;&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onApplicationEvent(ContextStoppedEvent event) &#123;</span><br><span class="line">System.out.println(&quot;ContextStoppedEvent stop!!&quot;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是 <strong>Start.java</strong> 文件的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">package com.szxy;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line">public class Start &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//加载spring配置文件,初始化所有的bean</span><br><span class="line">ClassPathXmlApplicationContext ac = </span><br><span class="line">new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;);</span><br><span class="line"></span><br><span class="line">//启动spring容器</span><br><span class="line">ac.start();</span><br><span class="line"></span><br><span class="line">HelloSpringEvent hello = ac.getBean(&quot;helloSpringEvent&quot;, HelloSpringEvent.class);</span><br><span class="line">System.out.println(hello.getMsg());</span><br><span class="line"></span><br><span class="line">//停止spring容器</span><br><span class="line">ac.stop();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是配置文件 <strong>applicationContext.xml</strong> 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;</span><br><span class="line">    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">    xsi:schemaLocation=&quot;</span><br><span class="line">        http://www.springframework.org/schema/beans </span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;helloSpringEvent&quot; class=&quot;com.szxy.HelloSpringEvent&quot;&gt;</span><br><span class="line">&lt;property name=&quot;msg&quot;&gt;</span><br><span class="line">&lt;value&gt;Test SpringEvent!!&lt;/value&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;cStartEventHandler&quot; class=&quot;com.szxy.CStartEventHandler&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=&quot;cStopEventHandler&quot; class=&quot;com.szxy.CStopEventHandler&quot;&gt;&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><p>一旦你完成了创建源和 bean 的配置文件，我们就可以运行该应用程序。如果你的应用程序一切都正常，将输出以下消息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">HelloSpringEvent 初始化</span><br><span class="line">ContextStartedEvent start!!</span><br><span class="line">Test SpringEvent!!</span><br><span class="line">ContextStoppedEvent stop!!</span><br></pre></td></tr></table></figure><p>注意：</p><p>​        <strong><em>由于 Spring 的事件处理是单线程的，所以如果一个事件被发布，直至并且除非所有的接收者得到的该消息，该进程被阻塞并且流程将不会继续。因此，如果事件处理被使用，在设计应用程序时应注意。</em></strong></p><p>例如：</p><p>​         CStartEventHandler类的监听函数处理中加入一个阻塞调用System.in.read();</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">package com.szxy;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.ApplicationListener;</span><br><span class="line">import org.springframework.context.event.ContextStartedEvent;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * ContextStartedEvent:</span><br><span class="line"> * 当使用 ConfigurableApplicationContext 接口中的 start()方法启动 ApplicationContext时,</span><br><span class="line"> * 该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。</span><br><span class="line"> * @author Administrator</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">public class CStartEventHandler implements ApplicationListener&lt;ContextStartedEvent&gt;&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void onApplicationEvent(ContextStartedEvent event) &#123;</span><br><span class="line">System.out.println(&quot;ContextStartedEvent start!!&quot;);</span><br><span class="line">try &#123;</span><br><span class="line">System.in.read();</span><br><span class="line">&#125; catch (IOException e) &#123;</span><br><span class="line">// TODO Auto-generated catch block</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>​        </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">HelloSpringEvent 初始化</span><br><span class="line">ContextStartedEvent start!!</span><br></pre></td></tr></table></figure><p>可以看出进程被阻塞了，程序不会往下继续执行</p><p>参考：</p><p>​        <a href="https://wiki.jikexueyuan.com/project/spring/event-handling-in-spring.html" target="_blank" rel="noopener">https://wiki.jikexueyuan.com/project/spring/event-handling-in-spring.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Spring中的事件处理&quot;&gt;&lt;a href=&quot;#Spring中的事件处理&quot; class=&quot;headerlink&quot; title=&quot;Spring中的事件处理&quot;&gt;&lt;/a&gt;Spring中的事件处理&lt;/h2&gt;&lt;p&gt;Spring 的核心是 &lt;strong&gt;Applicatio
      
    
    </summary>
    
    
      <category term="Spring" scheme="http://yoursite.com/categories/Spring/"/>
    
    
      <category term="Spring" scheme="http://yoursite.com/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot学习</title>
    <link href="http://yoursite.com/2019/09/04/SpringBoot/SpringBoot%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2019/09/04/SpringBoot/SpringBoot%E5%AD%A6%E4%B9%A0/</id>
    <published>2019-09-04T07:45:59.000Z</published>
    <updated>2019-09-11T09:27:00.499Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="SpringBoot官方定义"><a href="#SpringBoot官方定义" class="headerlink" title="SpringBoot官方定义"></a>SpringBoot官方定义</h2><p>​    Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”.</p><p>​    We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration.</p><p>Spring Boot使创建独立的、基于生产级Spring的应用程序变得很容易，您可以“直接运行”这些应用程序。</p><p>我们对Spring平台和第三方库有自己的见解，这样您就可以轻松入门了。大多数Spring引导应用程序只需要很少的Spring配置。</p><h2 id="SpringBoot学习"><a href="#SpringBoot学习" class="headerlink" title="SpringBoot学习"></a>SpringBoot学习</h2><h3 id="SpringBoot的启动"><a href="#SpringBoot的启动" class="headerlink" title="SpringBoot的启动"></a>SpringBoot的启动</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * SpringBoot 启动类</span><br><span class="line"> * 注意：</span><br><span class="line"> * 启动器存放的位置。启动器可以和 controller位于同一个包下，或者位于 controller的上一级 包中，</span><br><span class="line"> * 但是不能放到 controller的平级以及子包下。</span><br><span class="line"> * @author Administrator</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line">@SpringBootApplication</span><br><span class="line">public class App &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//启动SpringBoot</span><br><span class="line">SpringApplication.run(App.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        </p><h3 id="SpringBoot的静态资源访问"><a href="#SpringBoot的静态资源访问" class="headerlink" title="SpringBoot的静态资源访问"></a>SpringBoot的静态资源访问</h3><p>​    源码分析</p><p>​        org.springframework.boot.autoconfigure.web.ResourceProperties</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123;</span><br><span class="line">&quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;,</span><br><span class="line">&quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &#125;;</span><br></pre></td></tr></table></figure><p>因此，在类路径下的这几个目录都可以访问到静态资源</p><p><strong><em>注意1：</em></strong></p><p>​        在maven中的src/main下建立webapp目录，可以访问静态资源</p><p>分析：</p><p>​            eclipse编译会产生一个target/classes目录,有eclipse中.classpath文件指定编译输出目录</p><p>​                            output=”target/classes”</p><p>​            maven中则将所有的资源打成一个jar或者war包，如果是jar包，则jar目录结构和eclipse中</p><p>​            中的target/classes下的目录结构相同，<strong><em>由项目中的包文件以及一个META-INF文件夹组成</em></strong></p><p>​        用法：</p><p>​            可以使用Maven中的资源打包插件,将src/main/webapp下的静态资源打包至META-INF/resources</p><p>​            </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;build&gt;</span><br><span class="line">    &lt;resources&gt;</span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;src/main/resources&lt;/directory&gt;</span><br><span class="line">        &lt;includes&gt;</span><br><span class="line">            &lt;include&gt;**/**&lt;/include&gt;</span><br><span class="line">        &lt;/includes&gt;</span><br><span class="line">            &lt;!-- 开启过滤，用指定的参数替换directory下的文件中的参数 --&gt;</span><br><span class="line">        &lt;filtering&gt;true&lt;/filtering&gt;</span><br><span class="line">    &lt;/resource&gt;</span><br><span class="line">            </span><br><span class="line">        &lt;resource&gt;</span><br><span class="line">            &lt;directory&gt;src/main/webapp&lt;/directory&gt;</span><br><span class="line">            &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt;</span><br><span class="line">            &lt;includes&gt;</span><br><span class="line">                &lt;include&gt;**/**&lt;/include&gt;</span><br><span class="line">            &lt;/includes&gt;</span><br><span class="line">        &lt;/resource&gt; </span><br><span class="line">    &lt;/resources&gt;</span><br><span class="line">&lt;/build&gt;</span><br></pre></td></tr></table></figure><p>​            </p><p><strong><em>注意2：</em></strong></p><p>​            在有多个目录下有相同的静态资源，则优先级顺序优先级序</p><p>​            /META-INF/resources      &gt;        resources          &gt;            static           &gt;           public</p><p>注意3：</p><p>​        静态资源路径也可以通过配置文件指定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spring.resources.static-locations=指定路径</span><br></pre></td></tr></table></figure><p>#修改默认的静态资源存放目录，多个路径可以用逗号隔开</p><p>spring.resources.static-locations=classpath:/</p><p>修改后，默认路径无效</p><p><strong><em>注意4：</em></strong>    访问时使用相对路径，</p><p>​                    如果使用绝对路径static，public等默认是不计入路径的</p><p>参考：<a href="https://blog.csdn.net/qq_34797335/article/details/80194137" target="_blank" rel="noopener">https://blog.csdn.net/qq_34797335/article/details/80194137</a></p><h3 id="SprinBoot的配置文件"><a href="#SprinBoot的配置文件" class="headerlink" title="SprinBoot的配置文件"></a>SprinBoot的配置文件</h3><p>SpringBoot配置文件支持yml格式和properties格式,默认命名为</p><p>​        application.properties    </p><p>​        application.yml</p><p>两种配置文件选择哪一种都可以</p><p>配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好；</p><p>yml全称YAML， YAML（Yet Another Markup Language）（发音 /ˈjæməl/ ）, 一种基于Unicode</p><p>容易阅读，容易和脚本语言交互的，用来表达资料序列的编程语言。yaml语言广泛用于书写配置文件。</p><p>yml主要特点参考：<a href="https://www.cnblogs.com/geeklove01/p/8284236.html" target="_blank" rel="noopener">https://www.cnblogs.com/geeklove01/p/8284236.html</a></p><p>注：</p><p>​        配置文件也可以不使用默认的配置名称,只需要在启动类中手动读取配置文件即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">public class SpringbootConfigApplication &#123;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">//变更配置文件读取位置启动</span><br><span class="line">new SpringApplicationBuilder(SpringbootConfigApplication.class).   properties(&quot;spring.config.location=classpath:/springbootconfig.properties&quot;).run(args);</span><br><span class="line">//读取默认配置文件启动</span><br><span class="line">SpringApplication.run(SpringbootConfigApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringBoot&quot;&gt;&lt;a href=&quot;#SpringBoot&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot&quot;&gt;&lt;/a&gt;SpringBoot&lt;/h1&gt;&lt;h2 id=&quot;SpringBoot官方定义&quot;&gt;&lt;a href=&quot;#SpringB
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot的原理分析</title>
    <link href="http://yoursite.com/2019/09/04/SpringBoot/SpringBoot%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <id>http://yoursite.com/2019/09/04/SpringBoot/SpringBoot%E7%9A%84%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</id>
    <published>2019-09-04T07:45:59.000Z</published>
    <updated>2019-09-13T14:57:04.285Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h2 id="SpringBoot官方定义"><a href="#SpringBoot官方定义" class="headerlink" title="SpringBoot官方定义"></a>SpringBoot官方定义</h2><p>​    Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”.</p><p>​    We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration.</p><p>Spring Boot使创建独立的、基于生产级Spring的应用程序变得很容易，您可以“直接运行”这些应用程序。</p><p>我们对Spring平台和第三方库有自己的见解，这样您就可以轻松入门了。大多数Spring引导应用程序只需要很少的Spring配置。</p><h2 id="SpringBoot原理分析"><a href="#SpringBoot原理分析" class="headerlink" title="SpringBoot原理分析"></a>SpringBoot原理分析</h2><p>​    SpringBoot是Spring框架对“约定大于配置(Convention over Configuration)”理念的最佳实践。SpringBoot应用本质上就是一个基于Spring框架的应用。</p><p>spring-boot-starter-xxx是官方提供的starter，</p><p>xxx-spring-boot-starter是第三方提供的starter。</p><h3 id="springboot扩展机制——spring-factories"><a href="#springboot扩展机制——spring-factories" class="headerlink" title="springboot扩展机制——spring factories"></a>springboot扩展机制——spring factories</h3><p>Spring Boot中有一种非常解耦的扩展机制：Spring Factories。这种扩展机制实际上是仿照Java中的SPI扩展机制来实现的。</p><h4 id="什么是SPI机制"><a href="#什么是SPI机制" class="headerlink" title="什么是SPI机制"></a>什么是SPI机制</h4><p>SPI的全名为Service Provider Interface.大多数开发人员可能不熟悉，因为这个是针对厂商或者插件的。在java.util.ServiceLoader的文档里有比较详细的介绍。<br>简单的总结下java SPI机制的思想。我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块的方案，xml解析模块、jdbc模块的方案等。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。<br>java SPI就是提供这样的一个机制：为某个接口寻找服务实现的机制。有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。</p><h4 id="Spring-Boot中的SPI机制"><a href="#Spring-Boot中的SPI机制" class="headerlink" title="Spring Boot中的SPI机制"></a>Spring Boot中的SPI机制</h4><p>在Spring中也有一种类似与Java SPI的加载机制。它在META-INF/spring.factories文件中配置接口的实现类名称，然后在程序中读取这些配置文件并实例化。<br>这种自定义的SPI机制是Spring Boot Starter实现的基础。 </p><h4 id="Spring-Factories实现原理"><a href="#Spring-Factories实现原理" class="headerlink" title="Spring Factories实现原理"></a>Spring Factories实现原理</h4><p>​        spring-core包里定义了SpringFactoriesLoader类，这个类实现了检索META-INF/spring.factories文件，并获取指定接口的配置的功能。在这个类中定义了两个对外的方法：</p><p>loadFactories 根据接口类获取其实现类的实例，这个方法返回的是对象列表。<br>loadFactoryNames 根据接口获取其接口类的名称，这个方法返回的是类名的列表。<br>上面的两个方法的关键都是从指定的ClassLoader中获取spring.factories文件，并解析得到类名列表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load and instantiate the factory implementations of the given type from</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@value</span> #FACTORIES_RESOURCE_LOCATION&#125;, using the given class loader.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;The returned factories are sorted in accordance with the &#123;<span class="doctag">@link</span> AnnotationAwareOrderComparator&#125;.</span></span><br><span class="line"><span class="comment"> * &lt;p&gt;If a custom instantiation strategy is required, use &#123;<span class="doctag">@link</span> #loadFactoryNames&#125;</span></span><br><span class="line"><span class="comment"> * to obtain all registered factory names.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factoryClass the interface or abstract class representing the factory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classLoader the ClassLoader to use for loading (can be &#123;<span class="doctag">@code</span> null&#125; to use the default)</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #loadFactoryNames</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if any factory implementation class cannot</span></span><br><span class="line"><span class="comment"> * be loaded or if an error occurs while instantiating any factory</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">loadFactories</span><span class="params">(Class&lt;T&gt; factoryClass, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">Assert.notNull(factoryClass, <span class="string">"'factoryClass' must not be null"</span>);</span><br><span class="line">ClassLoader classLoaderToUse = classLoader;</span><br><span class="line"><span class="keyword">if</span> (classLoaderToUse == <span class="keyword">null</span>) &#123;</span><br><span class="line">classLoaderToUse = SpringFactoriesLoader.class.getClassLoader();</span><br><span class="line">&#125;</span><br><span class="line">List&lt;String&gt; factoryNames = loadFactoryNames(factoryClass, classLoaderToUse);</span><br><span class="line"><span class="keyword">if</span> (logger.isTraceEnabled()) &#123;</span><br><span class="line">logger.trace(<span class="string">"Loaded ["</span> + factoryClass.getName() + <span class="string">"] names: "</span> + factoryNames);</span><br><span class="line">&#125;</span><br><span class="line">List&lt;T&gt; result = <span class="keyword">new</span> ArrayList&lt;T&gt;(factoryNames.size());</span><br><span class="line"><span class="keyword">for</span> (String factoryName : factoryNames) &#123;</span><br><span class="line">result.add(instantiateFactory(factoryName, factoryClass, classLoaderToUse));</span><br><span class="line">&#125;</span><br><span class="line">AnnotationAwareOrderComparator.sort(result);</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Load the fully qualified class names of factory implementations of the</span></span><br><span class="line"><span class="comment"> * given type from &#123;<span class="doctag">@value</span> #FACTORIES_RESOURCE_LOCATION&#125;, using the given</span></span><br><span class="line"><span class="comment"> * class loader.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> factoryClass the interface or abstract class representing the factory</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> classLoader the ClassLoader to use for loading resources; can be</span></span><br><span class="line"><span class="comment"> * &#123;<span class="doctag">@code</span> null&#125; to use the default</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@see</span> #loadFactories</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span> IllegalArgumentException if an error occurs while loading factory names</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryClass, ClassLoader classLoader)</span> </span>&#123;</span><br><span class="line">String factoryClassName = factoryClass.getName();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Enumeration&lt;URL&gt; urls = (classLoader != <span class="keyword">null</span> ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">List&lt;String&gt; result = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line"><span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">URL url = urls.nextElement();</span><br><span class="line">Properties properties = PropertiesLoaderUtils.loadProperties(<span class="keyword">new</span> UrlResource(url));</span><br><span class="line">String factoryClassNames = properties.getProperty(factoryClassName);</span><br><span class="line">result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unable to load ["</span> + factoryClass.getName() +</span><br><span class="line"><span class="string">"] factories from location ["</span> + FACTORIES_RESOURCE_LOCATION + <span class="string">"]"</span>, ex);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>loadFactoryNames()在这个方法中会遍历整个ClassLoader中所有jar包下的spring.factories文件。也就是说我们可以在自己的jar中配置spring.factories文件，不会影响到其它地方的配置，也不会被别人的配置覆盖。</p><p>spring.factories的是通过Properties解析得到的，所以我们在写文件中的内容都是安装下面这种方式配置的：</p><p>com.xxx.interface=com.xxx.classname</p><p>如果一个接口希望配置多个实现类，可以使用’,’进行分割。</p><p>Spring Factories在Spring Boot中的应用</p><p>​        在spring-boot-1.5.10.RELEASE.jar包下，/META-INF/spring.factories</p><p>​        打开spring.factories</p><p>​        </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># PropertySource Loaders</span><br><span class="line">org.springframework.boot.env.PropertySourceLoader=\</span><br><span class="line">org.springframework.boot.env.PropertiesPropertySourceLoader,\</span><br><span class="line">org.springframework.boot.env.YamlPropertySourceLoader</span><br><span class="line"></span><br><span class="line"># Run Listeners</span><br><span class="line">org.springframework.boot.SpringApplicationRunListener=\</span><br><span class="line">org.springframework.boot.context.event.EventPublishingRunListener</span><br><span class="line"></span><br><span class="line">...................................</span><br></pre></td></tr></table></figure><p>在spring-boot-autoconfigure-1.5.10.RELEASE.jar包下，/META-INF/spring.factories</p><p>​        打开spring.factories</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"># Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line">org.springframework.boot.autoconfigure.logging.AutoConfigurationReportLoggingInitializer</span><br><span class="line"></span><br><span class="line"># Application Listeners</span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span><br><span class="line"></span><br><span class="line"># Auto Configuration Import Listeners</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener</span><br><span class="line"></span><br><span class="line"># Auto Configuration Import Filters</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnClassCondition</span><br><span class="line"></span><br><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration</span><br><span class="line"></span><br><span class="line"># Failure analyzers</span><br><span class="line">org.springframework.boot.diagnostics.FailureAnalyzer=\</span><br><span class="line">org.springframework.boot.autoconfigure.diagnostics.analyzer.NoSuchBeanDefinitionFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.DataSourceBeanCreationFailureAnalyzer,\</span><br><span class="line">org.springframework.boot.autoconfigure.jdbc.HikariDriverConfigurationFailureAnalyzer</span><br><span class="line"></span><br><span class="line"># Template availability providers</span><br><span class="line">org.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider=\</span><br><span class="line">org.springframework.boot.autoconfigure.freemarker.FreeMarkerTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.mustache.MustacheTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.thymeleaf.ThymeleafTemplateAvailabilityProvider,\</span><br><span class="line">org.springframework.boot.autoconfigure.web.JspTemplateAvailabilityProvider</span><br></pre></td></tr></table></figure><p>这是关于spirngboot自动配置的类的定义,这样通过解析factories文件就能实例化这些定义的类</p><p>分析：</p><p>​        自动配置这些类都使用了spring的注解，spring容器在实例化这些类时,通过这些类上的注解可以完成</p><p>注册某些Bean等</p><p>例如：</p><p>​            @Configuration</p><p>​            @Bean</p><p>​            能够被springIOC使用的工厂注解和bean的Annotation，springIOC通过注解就可以注入bean</p><p>自定义的factories</p><p>​            mybatis-spring-boot-autoconfigure-1.1.1.jar中的META-INF/spring.factories</p><p>​    打开spring.factories</p><p>​        </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration</span><br></pre></td></tr></table></figure><p>通过扩展机制配置了一个MybatisAutoConfiguration类,可以查看源码进行具体分析</p><p>参考：<a href="https://blog.csdn.net/gwd1154978352/article/details/89248273" target="_blank" rel="noopener">https://blog.csdn.net/gwd1154978352/article/details/89248273</a></p><h3 id="SpringBoot的starter机制"><a href="#SpringBoot的starter机制" class="headerlink" title="SpringBoot的starter机制"></a>SpringBoot的starter机制</h3><p>​         starter机制明显是在通过扩展机制来进行实现的，通过扩展机制，可以自定义实现</p><p>​    springboot启动器</p><h4 id="起步依赖"><a href="#起步依赖" class="headerlink" title="起步依赖"></a>起步依赖</h4><p>​                以一个web项目为例:</p><p>​                        spring-boot-starter-web包自动帮我们引入了web模块开发需要的相关jar包，</p><p>​                        mybatis-spring-boot-starter帮我们引入了dao开发相关的jar包。</p><h4 id="自动配置"><a href="#自动配置" class="headerlink" title="自动配置"></a>自动配置</h4><p>​                    对springboot中的mybatis进行分析</p><p>​                    mybatis-spring-boot-starter这个包是第三方提供的</p><p>​            mybatis-spring-boot-starter这个包帮我们引入了mybatis-spring-boot-autoconfigure这个包</p><p>里面有MybatisAutoConfiguration这个类,源码如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">...................</span><br><span class="line">@Configuration</span><br><span class="line">@ConditionalOnClass(&#123; SqlSessionFactory.class, SqlSessionFactoryBean.class &#125;)</span><br><span class="line">@ConditionalOnBean(DataSource.class)</span><br><span class="line">@EnableConfigurationProperties(MybatisProperties.class)</span><br><span class="line">@AutoConfigureAfter(DataSourceAutoConfiguration.class)</span><br><span class="line">public class MybatisAutoConfiguration &#123;</span><br><span class="line">........................................</span><br><span class="line">  @Bean</span><br><span class="line">  @ConditionalOnMissingBean</span><br><span class="line">  public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception &#123;</span><br><span class="line">    SqlSessionFactoryBean factory = new SqlSessionFactoryBean();</span><br><span class="line">    factory.setDataSource(dataSource);</span><br><span class="line">    factory.setVfs(SpringBootVFS.class);</span><br><span class="line">    if (StringUtils.hasText(this.properties.getConfigLocation())) &#123;</span><br><span class="line">      factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation()));</span><br><span class="line">    &#125;</span><br><span class="line">    factory.setConfiguration(properties.getConfiguration());</span><br><span class="line">    if (!ObjectUtils.isEmpty(this.interceptors)) &#123;</span><br><span class="line">      factory.setPlugins(this.interceptors);</span><br><span class="line">    &#125;</span><br><span class="line">    if (this.databaseIdProvider != null) &#123;</span><br><span class="line">      factory.setDatabaseIdProvider(this.databaseIdProvider);</span><br><span class="line">    &#125;</span><br><span class="line">    if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) &#123;</span><br><span class="line">      factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage());</span><br><span class="line">    &#125;</span><br><span class="line">    if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) &#123;</span><br><span class="line">      factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage());</span><br><span class="line">    &#125;</span><br><span class="line">    if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) &#123;</span><br><span class="line">      factory.setMapperLocations(this.properties.resolveMapperLocations());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return factory.getObject();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> ..............................</span><br></pre></td></tr></table></figure><p>​            @Configuration,@Bean这两个注解一起使用就可以创建一个基于java代码的配置类，可以用来替代相应的xml配置文件。</p><p>@Configuration注解的类可以看作是能生产让Spring IoC容器管理的Bean实例的工厂。</p><p>@Bean注解告诉Spring，一个带有@Bean的注解方法将返回一个对象，该对象应该被注册到spring容器中。</p><p>所以上面的MybatisAutoConfiguration这个类，自动帮我们生成了SqlSessionFactory这些Mybatis的重要实例并交给spring容器管理，从而完成bean的自动注册。</p><p>自动配置条件依赖</p><p>从MybatisAutoConfiguration这个类中使用的注解可以看出，要完成自动配置是有依赖条件的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@ConditionalOnBean，仅在当前上下文中存在某个bean时，才会实例化这个Bean。</span><br><span class="line"></span><br><span class="line">@ConditionalOnClass，某个class位于类路径上，才会实例化这个Bean。</span><br><span class="line"></span><br><span class="line">@ConditionalOnExpression，当表达式为true的时候，才会实例化这个Bean。</span><br><span class="line"></span><br><span class="line">@ConditionalOnMissingBean，仅在当前上下文中不存在某个bean时，才会实例化这个Bean。</span><br><span class="line"></span><br><span class="line">@ConditionalOnMissingClass，某个class在类路径上不存在的时候，才会实例化这个Bean。</span><br><span class="line"></span><br><span class="line">@ConditionalOnNotWebApplication，不是web应用时才会实例化这个Bean。</span><br><span class="line"></span><br><span class="line">@AutoConfigureAfter，在某个bean完成自动配置后实例化这个bean。</span><br><span class="line"></span><br><span class="line">@AutoConfigureBefore，在某个bean完成自动配置前实例化这个bean。</span><br></pre></td></tr></table></figure><p>​        </p><p>所以要完成Mybatis的自动配置，需要在类路径中存在SqlSessionFactory.class、SqlSessionFactoryBean.class这两个类，需要存在DataSource这个bean且这个bean完成自动注册。</p><p>​    进入DataSourceAutoConfiguration这个类，这个类是在spring-boot-autoconfigure-2.0.4.RELEASE.jar这个包下的，通过扩展机制也自动进行了配置。</p><p>​    自动配置这个包帮们引入了jdbc、kafka、logging、mail、mongo等包。很多包需要我们引入相应jar后自动配置才生效。</p><p>bean参数获取</p><p>​        springboot是如何读取yml或者properites配置文件的的属性来创建数据源的？</p><p>​        在DataSourceAutoConfiguration类里面，我们注意到使用了EnableConfigurationProperties这个注解。  DataSourceProperties中封装了数据源的各个属性，且使用了注解ConfigurationProperties指定了配置文件的前缀。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">@ConfigurationProperties(</span><br><span class="line">    prefix = &quot;spring.datasource&quot;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>@ConfigurationProperties注解的作用是把yml或者properties配置文件转化为bean。</p><p>@EnableConfigurationProperties注解的作用是使@ConfigurationProperties注解生效。如果只配置    @ConfigurationProperties注解，在spring容器中是获取不到yml或者properties配置文件转化的bean的。  </p><p>通过这种方式，把yml或者properties配置参数转化为bean，这些bean又是如何被发现与加载的？</p><p>bean发现</p><p>​    我们通常在启动类中加@SpringBootApplication这个注解</p><p>​    实际上重要的只有三个Annotation：</p><p>@Configuration（@SpringBootConfiguration里面还是应用了@Configuration）</p><p>@EnableAutoConfiguration</p><p>@ComponentScan</p><p>@Configuration的作用上面我们已经知道了，被注解的类将成为一个bean配置类。</p><p>@ComponentScan的作用就是自动扫描并加载符合条件的组件，比如@Component和@Repository等，最终将这些bean定义加载到spring容器中。</p><p>@EnableAutoConfiguration 这个注解的功能很重要，借助@Import的支持，收集和注册依赖包中相关的bean定义。对于详解可以查看springboot中对于这个注解的实现。最终还是借助spring.factories注册bean。</p><p>@EnableAutoConfiguration注解引入了@AutoConfigurationPackage和@Import这两个注解。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@SuppressWarnings(&quot;deprecation&quot;)</span><br><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@AutoConfigurationPackage</span><br><span class="line">@Import(EnableAutoConfigurationImportSelector.class)</span><br><span class="line">public @interface EnableAutoConfiguration &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>@AutoConfigurationPackage的作用就是自动配置的包，@Import导入需要自动配置的组件。</p><p>进入@AutoConfigurationPackage，发现也是引入了@Import注解</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Target(&#123;ElementType.TYPE&#125;)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@Import(&#123;Registrar.class&#125;)</span><br><span class="line">public @interface AutoConfigurationPackage &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        查看Registrar</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void registerBeanDefinitions(AnnotationMetadata metadata,</span><br><span class="line">BeanDefinitionRegistry registry) &#123;</span><br><span class="line">register(registry, new PackageImport(metadata).getPackageName());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123;</span><br><span class="line">return Collections.&lt;Object&gt;singleton(new PackageImport(metadata));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>new AutoConfigurationPackages.PackageImport(metadata)).getPackageName()</p><p>new AutoConfigurationPackages.PackageImport(metadata)</p><p>这两句代码的作用就是加载启动类所在的包下的主类与子类的所有组件注册到spring容器，这就是前文所说的springboot默认扫描启动类所在的包下的主类与子类的所有组件。</p><p>那问题又来了，要搜集并注册到spring容器的那些beans来自哪里？</p><p>@EnableAutoConfiguration类上的@Import(EnableAutoConfigurationImportSelector.class)</p><p>选择EnableAutoConfigurationImportSelector的父类AutoConfigurationImportSelector</p><p>在AutoConfigurationImportSelector中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered &#123;</span><br><span class="line">private static final String[] NO_IMPORTS = new String[0];</span><br><span class="line">...</span><br><span class="line">    public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        if(!this.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            return NO_IMPORTS;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader);</span><br><span class="line">            AnnotationAttributes attributes = this.getAttributes(annotationMetadata);</span><br><span class="line">            List configurations = this.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">            configurations = this.removeDuplicates(configurations);</span><br><span class="line">            Set exclusions = this.getExclusions(annotationMetadata, attributes);</span><br><span class="line">            this.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">            configurations.removeAll(exclusions);</span><br><span class="line">            configurations = this.filter(configurations, autoConfigurationMetadata);</span><br><span class="line">            this.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">            return StringUtils.toStringArray(configurations);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">    protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;</span><br><span class="line">        List configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader());</span><br><span class="line">        Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;);</span><br><span class="line">        return configurations;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SpringFactoriesLoader.loadFactoryNames方法调用loadSpringFactories方法从所有的jar包中读取META-INF/spring.factories文件信息。</p><p>loadSpringFactories方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123;</span><br><span class="line">        MultiValueMap result = (MultiValueMap)cache.get(classLoader);</span><br><span class="line">        if(result != null) &#123;</span><br><span class="line">            return result;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Enumeration ex = classLoader != null?classLoader.getResources(&quot;META-INF/spring.factories&quot;):ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;);</span><br><span class="line">                LinkedMultiValueMap result1 = new LinkedMultiValueMap();</span><br><span class="line"></span><br><span class="line">                while(ex.hasMoreElements()) &#123;</span><br><span class="line">                    URL url = (URL)ex.nextElement();</span><br><span class="line">                    UrlResource resource = new UrlResource(url);</span><br><span class="line">                    Properties properties = PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">                    Iterator var6 = properties.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">                    while(var6.hasNext()) &#123;</span><br><span class="line">                        Entry entry = (Entry)var6.next();</span><br><span class="line">                        List factoryClassNames = Arrays.asList(StringUtils.commaDelimitedListToStringArray((String)entry.getValue()));</span><br><span class="line">                        result1.addAll((String)entry.getKey(), factoryClassNames);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                cache.put(classLoader, result1);</span><br><span class="line">                return result1;</span><br><span class="line">            &#125; catch (IOException var9) &#123;</span><br><span class="line">                throw new IllegalArgumentException(&quot;Unable to load factories from location [META-INF/spring.factories]&quot;, var9);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>下面是spring-boot-autoconfigure这个jar中spring.factories文件部分内容，其中有一个key为<strong><em>org.springframework.boot.autoconfigure.EnableAutoConfiguration</em></strong>的值定义了需要自动配置的bean，通过读取这个配置获取一组@Configuration类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener</span><br><span class="line"></span><br><span class="line"># Auto Configuration Import Filters</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnClassCondition</span><br><span class="line"></span><br><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br><span class="line">.............</span><br></pre></td></tr></table></figure><p>个xxxAutoConfiguration都是一个基于java的bean配置类。实际上，这些xxxAutoConfiguratio不是所有都会被加载，会根据xxxAutoConfiguration上的@ConditionalOnClass等条件判断是否加载。</p><p>如上代码段，通过反射机制将spring.factories中@Configuration类实例化为对应的java实例。到此我们已经知道怎么发现要自动配置的bean了，最后一步就是怎么样将这些bean加载到spring容器。</p><p>bean加载</p><p>​        如果要让一个普通类交给Spring容器管理，通常有以下方法：</p><p>1、使用 @Configuration与@Bean 注解</p><p>2、使用@Controller @Service @Repository @Component 注解标注该类，然后启用@ComponentScan自动扫描</p><p>3、使用@Import 方法</p><p>springboot中使用了@Import 方法</p><p>@EnableAutoConfiguration注解中使用了@Import({AutoConfigurationImportSelector.class})注解，AutoConfigurationImportSelector实现了DeferredImportSelector接口，</p><p>DeferredImportSelector接口继承了ImportSelector接口，ImportSelector接口只有一个selectImports方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class AutoConfigurationImportSelector implements DeferredImportSelector&#123;</span><br><span class="line">...</span><br><span class="line">    public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">        if(!this.isEnabled(annotationMetadata)) &#123;</span><br><span class="line">            return NO_IMPORTS;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader);</span><br><span class="line">            AnnotationAttributes attributes = this.getAttributes(annotationMetadata);</span><br><span class="line">            List configurations = this.getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">            configurations = this.removeDuplicates(configurations);</span><br><span class="line">            Set exclusions = this.getExclusions(annotationMetadata, attributes);</span><br><span class="line">            this.checkExcludedClasses(configurations, exclusions);</span><br><span class="line">            configurations.removeAll(exclusions);</span><br><span class="line">            configurations = this.filter(configurations, autoConfigurationMetadata);</span><br><span class="line">            this.fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">            return StringUtils.toStringArray(configurations);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public interface DeferredImportSelector extends ImportSelector &#123;</span><br><span class="line">    @Nullable</span><br><span class="line">    default Class&lt;? extends DeferredImportSelector.Group&gt; getImportGroup() &#123;</span><br><span class="line">        return null;</span><br><span class="line">&#125;</span><br><span class="line">public interface Group &#123;...&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这是@Import注解的定义，实现该接口可以自定义返回一组bean</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface ImportSelector &#123;</span><br><span class="line">    String[] selectImports(AnnotationMetadata var1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><p>selectImports方法返回一组bean，@EnableAutoConfiguration注解借助@Import注解将这组bean注入到spring容器中，springboot正式通过这种机制来完成bean的注入的。</p><p>总结:</p><p>​        我们可以将自动配置的关键几步以及相应的注解总结如下：</p><p>1、@Configuration&amp;与@Bean-&gt;基于java代码的bean配置，</p><p>2、@Conditional-&gt;设置自动配置条件依赖</p><p>3、@EnableConfigurationProperties与@ConfigurationProperties-&gt;读取配置文件转换为bean。</p><p>4、@EnableAutoConfiguration、@AutoConfigurationPackage 与@Import-&gt;实现bean发现与加载。</p><p>参考：<a href="https://www.cnblogs.com/hjwublog/p/10332042.html#autoid-1-0-0" target="_blank" rel="noopener">https://www.cnblogs.com/hjwublog/p/10332042.html#autoid-1-0-0</a></p><h3 id="SpringBoot中的启动类分析"><a href="#SpringBoot中的启动类分析" class="headerlink" title="SpringBoot中的启动类分析"></a>SpringBoot中的启动类分析</h3><p>​            SpringBoot启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.hafiz.springbootdemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.SpringApplication;</span><br><span class="line"><span class="keyword">import</span> org.springframework.boot.autoconfigure.SpringBootApplication;</span><br><span class="line"></span><br><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringbootDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(SpringbootDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    </p><h4 id="SpringBootApplication注解"><a href="#SpringBootApplication注解" class="headerlink" title="@SpringBootApplication注解"></a>@SpringBootApplication注解</h4><p>​    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Inherited</span><br><span class="line">@SpringBootConfiguration</span><br><span class="line">@EnableAutoConfiguration</span><br><span class="line">@ComponentScan(excludeFilters = &#123;</span><br><span class="line">@Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),</span><br><span class="line">@Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</span><br><span class="line">public @interface SpringBootApplication &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们看到<code>@SpringBootApplication</code>其实是一个复合的注解，起主要作用的就是<code>@SpringBootConfiguration</code>、<code>@EnableAutoConfiguration</code>以及<code>@ComponentScan</code> 三个注解组成.</p><h5 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Target(ElementType.TYPE)</span><br><span class="line">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="line">@Documented</span><br><span class="line">@Configuration</span><br><span class="line">public @interface SpringBootConfiguration &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，这里面依旧没有什么新东西，它SpringBoot为了区别<code>@Configuration</code>而新提供的专属于SpringBoot的注解，功能和<code>@Configuration</code>一模一样。</p><h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h4><p>简单的来说，就是该注解借助<code>@Import</code>注解的支持，Spring的IoC容器收集和注册特定场景相关的Bean定义：</p><p>关于‘Enable’开头的spring注解        </p><ul><li><code>@EnableScheduling</code>是通过<code>@Import</code>将Spring调度框架相关的bean都加载到IoC容器。</li><li><code>@EnableMBeanExport</code>是通过<code>@Import</code>将JMX相关的bean定义加载到IoC容器。</li><li><code>@EnableAutoConfiguration</code>注解也是借助<code>@Import</code>将所有复合配置条件的bean定义加载到IoC容器</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(EnableAutoConfigurationImportSelector.class)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableAutoConfiguration &#123;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    这其中最关键的就是<code>@Import(EnableAutoConfigurationImportSelector.class)</code>了，<code>EnableAutoConfigurationImportSelector.class</code>可以帮助SpringBoot应用将所有符合条件的@Configuration配置类都加载到当前SpringBoot创建并使用的IoC容器。</p><p>下面我们给出<code>EnableAutoConfigurationImportSelector.java</code>的父类<code>AutoConfigurationImportSelector.java</code>的部分源码，来解释和验证</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class AutoConfigurationImportSelector</span><br><span class="line">        implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware,</span><br><span class="line">BeanFactoryAware, EnvironmentAware, Ordered &#123;</span><br><span class="line"></span><br><span class="line">    protected List&lt;AutoConfigurationImportFilter&gt; getAutoConfigurationImportFilters() &#123;</span><br><span class="line">        return SpringFactoriesLoader.loadFactories(AutoConfigurationImportFilter.class,</span><br><span class="line">                this.beanClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line">    protected List&lt;AutoConfigurationImportListener&gt; getAutoConfigurationImportListeners() &#123;</span><br><span class="line">        return SpringFactoriesLoader.loadFactories(AutoConfigurationImportListener.class,</span><br><span class="line">                this.beanClassLoader);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上源码可以看出，<code>@EnableAutoConfiguration</code>正是借助<code>SpringFactoriesLoader</code>的支持，完成所有配置类都加载</p><p>到当前SpringBoot创建并使用的IOC容器.</p><h4 id="SpringFactoriesLoader详解"><a href="#SpringFactoriesLoader详解" class="headerlink" title="SpringFactoriesLoader详解"></a>SpringFactoriesLoader详解</h4><p>​            SpringFactoriesLoader属于Spring框架专属的一种扩展方案(其功能和使用方式类似于Java的SPI方案:java.util.ServiceLoader)，它的主要功能就是从指定的配置文件<code>META-INF/spring.factories</code>中加载配置，spring.factories是一个非常经典的java properties文件，内容格式是Key=Value形式，只不过这Key以及Value都非常特殊，为Java类的完整类名(Fully qualified name)。</p><p>​        对于<code>@EnableAutoConfiguraion</code>来说，SpringFactoriesLoader的用途和其本意稍微不同，它本意是为了提供SPI扩展，而在<code>@EnableAutoConfiguration</code>这个场景下，它更多的是提供了一种配置查找的功能的支持。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"># Initializers</span><br><span class="line">org.springframework.context.ApplicationContextInitializer=\</span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line">org.springframework.boot.autoconfigure.logging.AutoConfigurationReportLoggingInitializer</span><br><span class="line"></span><br><span class="line"># Application Listeners</span><br><span class="line">org.springframework.context.ApplicationListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span><br><span class="line"></span><br><span class="line"># Auto Configuration Import Listeners</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportListener=\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener</span><br><span class="line"></span><br><span class="line"># Auto Configuration Import Filters</span><br><span class="line">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnClassCondition</span><br><span class="line"></span><br><span class="line"># Auto Configure</span><br><span class="line">org.springframework.boot.autoconfigure.EnableAutoConfiguration=\</span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br></pre></td></tr></table></figure><p>这是spring-boot-autoconfigure-1.5.10.RELEASE.jar下的spring.factories。</p><h4 id="非必须的-ComponentScan解析"><a href="#非必须的-ComponentScan解析" class="headerlink" title="非必须的@ComponentScan解析"></a>非必须的<code>@ComponentScan</code>解析</h4><p>​        为什么说这个注解是非必需的呢？因为我们知道作为Spring框架里的老成员，@ComponentScan的功能就是自动扫描并加载复合条件的组件或Bean定义，最终将这些bean定义加载到当前使用的容器中。这个过程，我们可以手工单个进行注册，不是一定要通过这个注解批量扫描和注册，所以说<code>@ComponentScan</code>是非必需的。</p><p>​        所以，如果我们当前应用没有任何bean定义需要通过<code>@ComponentScan</code>加载到当前SpringBoot应用对应的IoC容器，那么，去掉<code>@ComponentScan</code>注解，当前的SpringBoot应用依旧可以完美运行！</p><p>​    </p><h3 id="扩展机制和starter进行自定义实现"><a href="#扩展机制和starter进行自定义实现" class="headerlink" title="扩展机制和starter进行自定义实现"></a>扩展机制和starter进行自定义实现</h3><p>​        自定义封装一个starter</p><p>​                </p><p>​            </p><p>​    参考:<a href="https://www.cnblogs.com/hjwublog/p/10335464.html" target="_blank" rel="noopener">https://www.cnblogs.com/hjwublog/p/10335464.html</a></p><h3 id="springboot中的元数据"><a href="#springboot中的元数据" class="headerlink" title="springboot中的元数据"></a>springboot中的元数据</h3><p>​    spring-boot-autoconfigure-1.5.10.RELEASE.jar包含元数据文件，提供所有支持的配置属性的详细信息。这些文件旨在允许IDE开发人员在用户使用application.properties 或application.yml文件时提供上下文帮助和自动补全 。</p><p>主要的元数据文件是在编译器通过处理所有被<strong><em>@ConfigurationProperties</em></strong>注解的节点来自动生成的。（自定义的</p><p>一些自动配置包也可以提供，例如mybatis-spring-boot-autoconfigure.jar）</p><p>配置元数据位于jar文件中的META-INF/spring-configuration-metadata.json，它们使用一个具有”groups”或”properties”分类节点的简单JSON格式。</p><p>如果不知道springboot是否支持某个配置的话，可以查看元数据文件看是否有对应的节点。</p><p>注意：</p><p>​        在application.properties中，驼峰的写法有两种，都是可以的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">spring.datasource.driverClassName=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure><p>​        </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;SpringBoot&quot;&gt;&lt;a href=&quot;#SpringBoot&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot&quot;&gt;&lt;/a&gt;SpringBoot&lt;/h1&gt;&lt;h2 id=&quot;SpringBoot官方定义&quot;&gt;&lt;a href=&quot;#SpringB
      
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/categories/SpringBoot/"/>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>java的classpath</title>
    <link href="http://yoursite.com/2019/08/25/JavaSE/java%E7%9A%84classpath/"/>
    <id>http://yoursite.com/2019/08/25/JavaSE/java%E7%9A%84classpath/</id>
    <published>2019-08-25T09:46:31.000Z</published>
    <updated>2019-09-11T09:23:44.847Z</updated>
    
    <content type="html"><![CDATA[<h2 id="java中classpath理解"><a href="#java中classpath理解" class="headerlink" title="java中classpath理解"></a>java中classpath理解</h2><h3 id="类路径-classpath"><a href="#类路径-classpath" class="headerlink" title="类路径(classpath)"></a>类路径(classpath)</h3><p>​            默认java虚拟机要从classpath环境变量的路径中搜索class文件去执行，对于java虚拟机来说，这不是类文件，而是类。它只有类路径，而没有文件系统路径。而classpath环境变量正是为java虚拟机提供搜索类路径的环境。注意，<strong><em>虚拟机不会递归搜索classpath定义的路径。</em></strong>（因此，在spring中有classpath*,表示递归classpath定义的路径下的所有路径）</p><p>java编译器编译.java文件和java虚拟机执行.class文件时的路径和写法不一样。在没有设置任何classpath环境变量的情况下，javac可以编译全路径的.java文件</p><p>​        要明确的是javac编译器搜索的是文件路径，和环境变量classpath无关。而java虚拟机搜索的是类文件，严格地说是类，搜索路径由环境变量classpath决定，且有先后顺序</p><p>(1).何时需要使用-classpath：当你要编译或执行的类引用了其它的类，但被引用类的.class文件不在当前目录下时，就需要通过-classpath来引入类路径</p><p>(2).何时需要指定路径：当你要编译的类所在的目录和你执行javac命令的目录不是同一个目录时，就需要指定源文件的路径(CLASSPATH是用来指定.class路径的，不是用来指定.java文件的路径的)</p><h2 id="包-package"><a href="#包-package" class="headerlink" title="包(package)"></a>包(package)</h2><h4 id="1）"><a href="#1）" class="headerlink" title="1）"></a>1）</h4><p>​    包是类的集合。在java源文件的第一行(不包括注释行或空行)写上package关键字并给定包名，即可将该类文件放到包中。</p><p>​    javac在编译时从路径上搜索文件。例如，将这个Cat.java放到com/longshuai/home下。执行时java虚拟机从classpath搜索要加载的类文件，而加载类的方式是使用”.”连接各类名。所以编译这个文件和java虚拟机执行这个文件时的方法分别是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac com/longshuai/home/Cat.java</span><br><span class="line">java com.longshuai.home.Cat</span><br></pre></td></tr></table></figure><p>注意，嵌套的包之间没有任何关系，例如java.util包和java.util.jar包没有任何依赖关系。</p><h4 id="2）"><a href="#2）" class="headerlink" title="2）"></a>2）</h4><p>​            在某个java源文件中，无法直接使用其他文件中的类，除非要使用的这个类正好能被classpath的路径搜索到。要引用非classpath下的其他类，只能将其添加到classpath或者装入package中，然后引用包中的类。</p><p>​    导入包时可以在尾部使用星号”<em>“通配导入的所有类，只能在尾部使用”</em>“，因为”<em>“匹配的是类名，而不是包名。也因此，不能在非结尾处使用”</em>“号来表示导入其他包中的类，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import com.longshuai.home.*; //导入com.longshuai.home包中的所有类</span><br><span class="line">import com.longshuai.*;      //导入com.longshuai包中所有类，但不会导入com.longshuai.home中类</span><br></pre></td></tr></table></figure><h4 id="类搜索机制"><a href="#类搜索机制" class="headerlink" title="类搜索机制"></a>类搜索机制</h4><p>​        在java虚拟机搜索类文件时，除了classpath环境变量指定的路径，还会先搜索两个默认的路径:jre/lib和jre/lib/ext下的jar文件中似乎否有待搜索的类。</p><p>​    例如，当classpath设置为”.;d:\myjava;d:\myjar.jar”时，要搜索com.longshuai.com.Cat类文件：<br>(a).先搜索jre/lib和jre/lib/ext下的jar文件;<br>(b).再搜索当前目录下是否有com\longshuai\com\Cat.class;<br>(c).再搜索d:\myjava\Cat.class;<br>(d).搜索d:\myjar.jar文件中是否有com.longshuai.com.Cat类。</p><p>如果在某个java源文件中引用了某个类，则在编译时，将通过以下几种方式判断该类是否合理有效：</p><p>(1).搜索导入的包类中是否包含该类。<br>(2).搜索隐式导入的java.lang包，该包是默认导入的。<br>(3).当前文件中是否定义了该类。<br>(4).按照类路径的搜索规则((a)-(d))搜索其中是否有该类。</p><h3 id="JAVA获取classpath路径："><a href="#JAVA获取classpath路径：" class="headerlink" title="JAVA获取classpath路径："></a>JAVA获取classpath路径：</h3><p>ClassLoader 提供了两个方法用于从装载的类路径中取得资源：</p><p>​        public URL  getResource (String name);<br>​        public InputStream  getResourceAsStream (String name);  </p><p>   这里name是资源的类路径，它是相对与“/”根路径下的位置。getResource得到的是一个URL对象来定位资源，而getResourceAsStream取得该资源输入流的引用保证程序可以从正确的位置抽取数据。<br>       但是真正使用的不是ClassLoader的这两个方法，而是Class的 getResource和getResourceAsStream方法，因为Class对象可以从你的类得到（如YourClass.class或 YourClass.getClass()），而ClassLoader则需要再调用一次YourClass.getClassLoader()方法，不过根据JDK文档的说法，Class对象的这两个方法其实是“委托”（delegate）给装载它的ClassLoader来做的，所以只需要使用 Class对象的这两个方法就可以了。</p><p>​       因此，直接调用  this.getClass().getResourceAsStream(String name) ;获取流，静态化方法中则使用ClassLoader.getSystemResourceAsStream (String name) ; 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1.this.getClass().getResource（&quot;&quot;） </span><br><span class="line">得到的是当前类class文件的URI目录。不包括自己！</span><br><span class="line">如：file：/D：/workspace/jbpmtest3/bin/com/test/</span><br><span class="line"></span><br><span class="line">2.this.getClass().getResource（&quot;/&quot;） </span><br><span class="line">得到的是当前的classpath的绝对URI路径 。</span><br><span class="line">如：file：/D：/workspace/jbpmtest3/bin/</span><br><span class="line"></span><br><span class="line">3.this.getClass() .getClassLoader().getResource（&quot;&quot;） </span><br><span class="line">得到的也是当前ClassPath的绝对URI路径 。</span><br><span class="line">如：file：/D：/workspace/jbpmtest3/bin/</span><br><span class="line"></span><br><span class="line">4.ClassLoader.getSystemResource（&quot;&quot;） </span><br><span class="line">得到的也是当前ClassPath的绝对URI路径 。</span><br><span class="line">如：file：/D：/workspace/jbpmtest3/bin/</span><br><span class="line"></span><br><span class="line">5.Thread.currentThread().getContextClassLoader ().getResource（&quot;&quot;） </span><br><span class="line">得到的也是当前ClassPath的绝对URI路径 。</span><br><span class="line">如：file：/D：/workspace/jbpmtest3/bin/</span><br><span class="line"></span><br><span class="line">6.ServletActionContext.getServletContext().getRealPath(“/”) </span><br><span class="line">Web应用程序 中，得到Web应用程序的根目录的绝对路径。这样，我们只需要提供相对于Web应用程序根目录的路径，就可以构建出定位资源的绝对路径。</span><br><span class="line">如：file：/D:/workspace/.metadata/.plugins/org.eclipse.wst.server.core/tmp0/wtpwebapps/WebProject</span><br></pre></td></tr></table></figure><p>注意点：</p><p>1.尽量不要使用相对于System.getProperty（”user.dir”）当前用户目录的相对路径。这是一颗定时炸 弹，随时可能要你的命。</p><p>2.尽量使用URI形式的绝对路径资源。它可以很容易的转变为URI，URL，File对象。</p><p>3.尽量使用相对classpath的相对路径。不要使用绝对路径。使用上面ClassLoaderUtil类的public static URL getExtendResource（String relativePath）方法已经能够使用相对于classpath的相对路径定位所有位置的资源。</p><p>4.绝对不要使用硬编码的绝对路径。因为，我们完全可以使用ClassLoader类的getResource（””）方法得到当前classpath的绝对路径。如果你一定要指定一个绝对路径，那么使用配置文件，也比硬编码要好得多！</p><p>获得CLASSPATH之外路径的方法：<br>URL base = this.getClass（）.getResource（””）； //先获得本类的所在位置，如/home/popeye/testjava/build/classes/net/<br>      String path = new File（base.getFile（）， “……/……/……/“+name）.getCanonicalPath（）； //就可以得到/home/popeye/testjava/name</p><p>另外，如果从ANT启动程序，this.getClass().getResource(“”)取出来的比较怪，直接用JAVA命令行调试就可成功。</p><p>PS：以上内容来自转载</p><p>在dos下编译<a href="http://lib.csdn.net/base/javase" target="_blank" rel="noopener">Java</a>程序，就要用到classpath这个概念，尤其是在没有设置环境变量的时候。classpath就是存放.class等编译后文件的路径。</p><p><strong>在spring中，classpath 和 classpath* 区别：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classpath：只会到你的class路径中查找找文件;</span><br><span class="line">classpath*：不仅包含class路径，还将递归classpath定义的路径下的所有子路径</span><br></pre></td></tr></table></figure><h4 id="如何执行指定class文件目录（classpath）"><a href="#如何执行指定class文件目录（classpath）" class="headerlink" title="如何执行指定class文件目录（classpath）"></a>如何执行指定class文件目录（classpath）</h4><p>如果我们 Java 编译后的class文件不在当前目录，我们可以使用 -classpath 来指定class文件目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:&gt; java -classpath C:\java\DemoClasses HelloWorld</span><br></pre></td></tr></table></figure><p>以上命令中我们使用了 -classpath 参数指定了 HelloWorld 的 class 文件所在目录。</p><p>如果class文件在jar文件中，则命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c:&gt; java -classpath C:\java\myclasses.jar com.test.HelloWorld</span><br></pre></td></tr></table></figure><p><strong>javac：</strong> 如果当前你要编译的 java 文件中引用了其它的类(比如说：继承)，但该引用类的 .class 文件不在当前目录下，这种情况下就需要在 javac 命令后面加上 -classpath 参数，通过使用以下三种类型的方法 来指导编译器在编译的时候去指定的路径下查找引用类。</p><ul><li>(1).绝对路径：<strong>javac -classpath c:/junit3.8.1/junit.jar Xxx.java</strong></li><li>(2).相对路径：<strong>javac -classpath ../junit3.8.1/Junit.javr Xxx.java</strong></li><li>(3).系统变量：<strong>javac -classpath %CLASSPATH% Xxx.java</strong> (注意：%CLASSPATH%表示使用系统变量CLASSPATH的值进行查找，这里假设Junit.jar的路径就包含在CLASSPATH系统变量中)</li></ul><p><strong>总结：</strong></p><ul><li>(1).何时需要使用 -classpath：当你要编译或执行的类引用了其它的类，但被引用类的 .class 文件不在当前目录下时，就需要通过 -classpath 来引入类</li><li>(2).何时需要指定路径：当你要编译的类所在的目录和你执行 javac 命令的目录不是同一个目录时，就需要指定源文件的路径(CLASSPATH 是用来指定 .class 路径的，不是用来指定 .java 文件的路径的)</li></ul><h4 id="assembly打包duboo-provider的理解"><a href="#assembly打包duboo-provider的理解" class="headerlink" title="assembly打包duboo-provider的理解"></a>assembly打包duboo-provider的理解</h4><p>assembly打包的目录结构</p><p>​            bin</p><p>​                    start.bat</p><p>​                    …..</p><p>​            conf</p><p>​                dubbo.properties</p><p>​            lib</p><p>​                    所有的jar包</p><p>assembly的bin下的start.bat</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@echo off &amp; setlocal enabledelayedexpansion</span><br><span class="line"></span><br><span class="line">set LIB_JARS=&quot;&quot;</span><br><span class="line">cd ..\lib</span><br><span class="line">for %%i in (*) do set LIB_JARS=!LIB_JARS!;..\lib\%%i</span><br><span class="line">cd ..\bin</span><br><span class="line"></span><br><span class="line">if &quot;&quot;%1&quot;&quot; == &quot;&quot;debug&quot;&quot; goto debug</span><br><span class="line">if &quot;&quot;%1&quot;&quot; == &quot;&quot;jmx&quot;&quot; goto jmx</span><br><span class="line"></span><br><span class="line">java -Xms64m -Xmx1024m -XX:MaxPermSize=64M -classpath ..\conf;%LIB_JARS% com.alibaba.dubbo.container.Main</span><br><span class="line">goto end</span><br><span class="line"></span><br><span class="line">:debug</span><br><span class="line">java -Xms64m -Xmx1024m -XX:MaxPermSize=64M -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=n -classpath ..\conf;%LIB_JARS% com.alibaba.dubbo.container.Main</span><br><span class="line">goto end</span><br><span class="line"></span><br><span class="line">:jmx</span><br><span class="line">java -Xms64m -Xmx1024m -XX:MaxPermSize=64M -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -classpath ..\conf;%LIB_JARS% com.alibaba.dubbo.container.Main</span><br><span class="line"></span><br><span class="line">:end</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>java -Xms64m -Xmx1024m -XX:MaxPermSize=64M -classpath ..\conf;%LIB_JARS% com.alibaba.dubbo.container.Main</p><p>​        根据以上的理解，该命令是执行com.alibaba.dubbo.container.Main</p><p>但是该类需要依赖许多其他类，因此需要指定-classpath (..\conf是一个配置文件，将其加入到</p><p>classpath中，%LIB_JARS%是执行com.alibaba.dubbo.container.Main所依赖的所有jar包路径,</p><p>也将其加载到classpath中，这样，com.alibaba.dubbo.container.Main才可以正确执行)</p><p>注意：</p><p>​        加入echo  %LIB_JARS% 测试打印结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;;..\lib\aopalliance-1.0.jar;..\lib\aspectjweaver-1.8.4.jar;..\lib\commons-logging-1.2.jar;..\lib\druid-1.0.9.jar;..\lib\dubbo-2.5.4.jar;..\lib\dubbo-mapper-0.0.1-SNAPSHOT.jar;..\lib\dubbo-pojo-0.0.1-SNAPSHOT.jar;..\lib\dubbo-user-interface-0.0.1-SNAPSHOT.jar;..\lib\dubbo-user-service-0.0.1-SNAPSHOT.jar;..\lib\hamcrest-core-1.3.jar;..\lib\javassist-3.20.0-GA.jar;..\lib\jline-0.9.94.jar;..\lib\junit-4.12.jar;..\lib\log4j-1.2.16.jar;..\lib\mybatis-3.2.8.jar;..\lib\mybatis-spring-1.2.2.jar;..\lib\mysql-connector-java-5.1.32.jar;..\lib\netty-3.2.5.Final.jar;..\lib\netty-3.7.0.Final.jar;..\lib\slf4j-api-1.6.1.jar;..\lib\slf4j-log4j12-1.6.4.jar;..\lib\spring-aop-4.1.3.RELEASE.jar;..\lib\spring-aspects-4.1.3.RELEASE.jar;..\lib\spring-beans-4.1.3.RELEASE.jar;..\lib\spring-context-4.1.3.RELEASE.jar;..\lib\spring-core-4.1.3.RELEASE.jar;..\lib\spring-expression-4.1.3.RELEASE.jar;..\lib\spring-jdbc-4.1.3.RELEASE.jar;..\lib\spring-tx-4.1.3.RELEASE.jar;..\lib\spring-web-4.1.3.RELEASE.jar;..\lib\zkclient-0.10.jar;..\lib\zookeeper-3.4.8.jar</span><br></pre></td></tr></table></figure><p>是所有jar的路径，通过-classpath将其加入到类路径中，这样就可以引用这些jar中的.class或者资源文件</p><h4 id="eclipse中执行的classpath分析"><a href="#eclipse中执行的classpath分析" class="headerlink" title="eclipse中执行的classpath分析"></a>eclipse中执行的classpath分析</h4><p>​        eclipse的项目文件夹有一个.classpath文件，用于描述classpath</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;classpath&gt;</span><br><span class="line">&lt;classpathentry kind=&quot;src&quot; path=&quot;src&quot;/&gt;</span><br><span class="line">&lt;classpathentry kind=&quot;con&quot; path=&quot;org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8&quot;/&gt;</span><br><span class="line">&lt;classpathentry kind=&quot;lib&quot; path=&quot;lib/mysql-connector-java-8.0.11.jar&quot;/&gt;</span><br><span class="line">&lt;classpathentry kind=&quot;lib&quot; path=&quot;lib/commons-beanutils-1.9.3.jar&quot;/&gt;</span><br><span class="line">&lt;classpathentry kind=&quot;lib&quot; path=&quot;lib/commons-logging-1.2.jar&quot;/&gt;</span><br><span class="line">&lt;classpathentry kind=&quot;output&quot; path=&quot;bin&quot;/&gt;</span><br><span class="line">&lt;/classpath&gt;</span><br></pre></td></tr></table></figure><p>将src目录，以及所引用的jar路径都添加到classpath中，这样才能保证程序正常执行。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>​    将一个路径添加到classpath中，则该路径下的目录或者资源可以被直接通过类路径被访问到，例如:</p><p>​            hello目录下有test,resource两个文件夹，test中有com/szxy/Test.class，resource中有一个res/index.html,   </p><p>​                    hello</p><p>​                            test</p><p>​                                    com</p><p>​                                            test</p><p>​                                                    Test.class</p><p>​                            resource</p><p>​                                    res</p><p>​                                            index.html        </p><p>执行        java -classpath ./test;./resource     com.bjsxt.Test，将test和resouce都加载到类路径中，</p><p>com.szxy.Test类中需要加载这个资源，通过getResourceAsStream(“res/index.html”),</p><p>因为类路径是test目录下和resource目录下，因此可以拿到资源res/index.html,</p><p>需要注意一点，不能直接getResourceAsStream(“index.html”)，因为类路径加载了不会递归查询，除非将</p><p>hello/resource/res也添加到类路径中才可以直接拿到，否则必须从类路径下沿着路径找到资源.</p><p>参考：</p><p>​        <a href="https://www.cnblogs.com/jixp/articles/9349845.html" target="_blank" rel="noopener">https://www.cnblogs.com/jixp/articles/9349845.html</a></p><p>​        <a href="https://www.runoob.com/java/env-classpath.html" target="_blank" rel="noopener">https://www.runoob.com/java/env-classpath.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;java中classpath理解&quot;&gt;&lt;a href=&quot;#java中classpath理解&quot; class=&quot;headerlink&quot; title=&quot;java中classpath理解&quot;&gt;&lt;/a&gt;java中classpath理解&lt;/h2&gt;&lt;h3 id=&quot;类路径-class
      
    
    </summary>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/categories/JavaSE/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>dubbo使用</title>
    <link href="http://yoursite.com/2019/08/25/JavaAdvancedTechnology/Dubbo/dubbo%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2019/08/25/JavaAdvancedTechnology/Dubbo/dubbo%E4%BD%BF%E7%94%A8/</id>
    <published>2019-08-25T09:46:31.000Z</published>
    <updated>2019-08-27T06:02:09.810Z</updated>
    
    <content type="html"><![CDATA[<h3 id="assembly打包后启动provider分析"><a href="#assembly打包后启动provider分析" class="headerlink" title="assembly打包后启动provider分析"></a>assembly打包后启动provider分析</h3><p>assembly打包的目录结构</p><p>​            bin</p><p>​                    start.bat</p><p>​                    …..</p><p>​            conf</p><p>​                dubbo.properties</p><p>​            lib</p><p>​                    所有的jar包</p><p>assembly包的bin下的start.bat（windows下的启动脚本）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@echo off &amp; setlocal enabledelayedexpansion</span><br><span class="line"></span><br><span class="line">set LIB_JARS=&quot;&quot;</span><br><span class="line">cd ..\lib</span><br><span class="line">for %%i in (*) do set LIB_JARS=!LIB_JARS!;..\lib\%%i</span><br><span class="line">cd ..\bin</span><br><span class="line"></span><br><span class="line">if &quot;&quot;%1&quot;&quot; == &quot;&quot;debug&quot;&quot; goto debug</span><br><span class="line">if &quot;&quot;%1&quot;&quot; == &quot;&quot;jmx&quot;&quot; goto jmx</span><br><span class="line"></span><br><span class="line">java -Xms64m -Xmx1024m -XX:MaxPermSize=64M -classpath ..\conf;%LIB_JARS% com.alibaba.dubbo.container.Main</span><br><span class="line">goto end</span><br><span class="line"></span><br><span class="line">:debug</span><br><span class="line">java -Xms64m -Xmx1024m -XX:MaxPermSize=64M -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=n -classpath ..\conf;%LIB_JARS% com.alibaba.dubbo.container.Main</span><br><span class="line">goto end</span><br><span class="line"></span><br><span class="line">:jmx</span><br><span class="line">java -Xms64m -Xmx1024m -XX:MaxPermSize=64M -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -classpath ..\conf;%LIB_JARS% com.alibaba.dubbo.container.Main</span><br><span class="line"></span><br><span class="line">:end</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>java -Xms64m -Xmx1024m -XX:MaxPermSize=64M -classpath ..\conf;%LIB_JARS% com.alibaba.dubbo.container.Main</p><p>​        根据以上的理解，该命令是执行com.alibaba.dubbo.container.Main</p><p>但是该类需要依赖许多其他类，因此需要指定-classpath (..\conf是一个配置文件，将其加入到</p><p>classpath中，%LIB_JARS%是执行com.alibaba.dubbo.container.Main所依赖的所有jar包路径,</p><p>也将其加载到classpath中，这样，com.alibaba.dubbo.container.Main才可以正确执行)</p><p>注意：</p><p>​        加入echo  %LIB_JARS% 测试打印结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;&quot;;..\lib\aopalliance-1.0.jar;..\lib\aspectjweaver-1.8.4.jar;..\lib\commons-logging-1.2.jar;..\lib\druid-1.0.9.jar;..\lib\dubbo-2.5.4.jar;..\lib\dubbo-mapper-0.0.1-SNAPSHOT.jar;..\lib\dubbo-pojo-0.0.1-SNAPSHOT.jar;..\lib\dubbo-user-interface-0.0.1-SNAPSHOT.jar;..\lib\dubbo-user-service-0.0.1-SNAPSHOT.jar;..\lib\hamcrest-core-1.3.jar;..\lib\javassist-3.20.0-GA.jar;..\lib\jline-0.9.94.jar;..\lib\junit-4.12.jar;..\lib\log4j-1.2.16.jar;..\lib\mybatis-3.2.8.jar;..\lib\mybatis-spring-1.2.2.jar;..\lib\mysql-connector-java-5.1.32.jar;..\lib\netty-3.2.5.Final.jar;..\lib\netty-3.7.0.Final.jar;..\lib\slf4j-api-1.6.1.jar;..\lib\slf4j-log4j12-1.6.4.jar;..\lib\spring-aop-4.1.3.RELEASE.jar;..\lib\spring-aspects-4.1.3.RELEASE.jar;..\lib\spring-beans-4.1.3.RELEASE.jar;..\lib\spring-context-4.1.3.RELEASE.jar;..\lib\spring-core-4.1.3.RELEASE.jar;..\lib\spring-expression-4.1.3.RELEASE.jar;..\lib\spring-jdbc-4.1.3.RELEASE.jar;..\lib\spring-tx-4.1.3.RELEASE.jar;..\lib\spring-web-4.1.3.RELEASE.jar;..\lib\zkclient-0.10.jar;..\lib\zookeeper-3.4.8.jar</span><br></pre></td></tr></table></figure><p>是所有jar的路径，通过-classpath将其加入到类路径中，这样就可以jvm就可以加载到这些jar中的.class或者资源文件</p><h3 id="linux环境下运行问题"><a href="#linux环境下运行问题" class="headerlink" title="linux环境下运行问题"></a>linux环境下运行问题</h3><h4 id="问题1-启动provider"><a href="#问题1-启动provider" class="headerlink" title="问题1:启动provider"></a>问题1:启动provider</h4><p>以下是start.sh部分代码，linux下的执行脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">JAVA_OPTS=&quot; -Djava.awt.headless=true -Djava.net.preferIPv4Stack=true &quot;</span><br><span class="line">JAVA_DEBUG_OPTS=&quot;&quot;</span><br><span class="line">if [ &quot;$1&quot; = &quot;debug&quot; ]; then</span><br><span class="line">    JAVA_DEBUG_OPTS=&quot; -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=n &quot;</span><br><span class="line">fi</span><br><span class="line">JAVA_JMX_OPTS=&quot;&quot;</span><br><span class="line">if [ &quot;$1&quot; = &quot;jmx&quot; ]; then</span><br><span class="line">    JAVA_JMX_OPTS=&quot; -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false &quot;</span><br><span class="line">fi</span><br><span class="line">JAVA_MEM_OPTS=&quot;&quot;</span><br><span class="line">BITS=`java -version 2&gt;&amp;1 | grep -i 64-bit`</span><br><span class="line">if [ -n &quot;$BITS&quot; ]; then</span><br><span class="line">    JAVA_MEM_OPTS=&quot; -server -Xmx2g -Xms2g -Xmn256m -XX:PermSize=128m -Xss256k -XX:+DisableExplicitGC -XX:+UseConcMarkSweepGC -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:LargePageSizeInBytes=128m -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=70 &quot;</span><br><span class="line">else</span><br><span class="line">    JAVA_MEM_OPTS=&quot; -server -Xms1g -Xmx1g -XX:PermSize=128m -XX:SurvivorRatio=2 -XX:+UseParallelGC &quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo -e &quot;Starting the $SERVER_NAME ...\c&quot;</span><br><span class="line">nohup java $JAVA_OPTS $JAVA_MEM_OPTS $JAVA_DEBUG_OPTS $JAVA_JMX_OPTS -classpath $CONF_DIR:$LIB_JARS com.alibaba.dubbo.container.Main &gt; $STDOUT_FILE 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure><p>注意：</p><p>java $JAVA_OPTS $JAVA_MEM_OPTS $JAVA_DEBUG_OPTS $JAVA_JMX_OPTS -classpath $CONF_DIR:$LIB_JARS com.alibaba.dubbo.container.Main &gt; $STDOUT_FILE 2&gt;&amp;1 &amp;</p><p>使用了JVM参数，如果配置不当，则会导致服务无法启动，直接jvm错误（产生hs_err_pid8647.log日志文件）</p><p>目前不会配置，因此直接删除JVM参数即可,java  -classpath $CONF_DIR:$LIB_JARS com.alibaba.dubbo.container.Main &gt; $STDOUT_FILE 2&gt;&amp;1 &amp;</p><h4 id="问题2：consumer调用provider"><a href="#问题2：consumer调用provider" class="headerlink" title="问题2：consumer调用provider"></a>问题2：consumer调用provider</h4><p>​        consumer调用provider总是产生Timeout,原本是以为服务运行时间过长导致的，于是在provider中</p><p>的META-INF/spring/application-dubbo.xml配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 设置超时时间 --&gt;</span><br><span class="line">&lt;dubbo:provider timeout=&quot;5000&quot;&gt;&lt;/dubbo:provider&gt;</span><br></pre></td></tr></table></figure><p>在dubbo-admin中可以看到超时时间被设置为5s，但是还是出现Timeout,不是该问题</p><p>以下是报异常的部分代码</p><p>root cause:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">com.alibaba.dubbo.remoting.TimeoutException: Waiting server-side response timeout. start time: 2019-08-26 19:52:03.221, end time: 2019-08-26 19:52:08.222, client elapsed: 0 ms, server elapsed: 5001 ms, timeout: 5000 ms, request: Request [id=6, version=2.0.0, twoway=true, event=false, broken=false, data=RpcInvocation [methodName=selectUsersAll, parameterTypes=[], arguments=[], attachments=&#123;path=com.bjsxt.dubbo.service.FindUserDubboService, interface=com.bjsxt.dubbo.service.FindUserDubboService, version=0.0.0, timeout=5000&#125;]], channel: /192.168.1.112:48407 -&gt; /192.168.1.113:20880</span><br><span class="line">com.alibaba.dubbo.remoting.exchange.support.DefaultFuture.get(DefaultFuture.java:136)</span><br><span class="line">com.alibaba.dubbo.remoting.exchange.support.DefaultFuture.get(DefaultFuture.java:113)</span><br><span class="line">com.alibaba.dubbo.rpc.protocol.dubbo.DubboInvoker.doInvoke(DubboInvoker.java:97)</span><br><span class="line">com.alibaba.dubbo.rpc.protocol.AbstractInvoker.invoke(AbstractInvoker.java:144)</span><br><span class="line">com.alibaba.dubbo.monitor.support.MonitorFilter.invoke(MonitorFilter.java:75)</span><br><span class="line">com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:69)</span><br><span class="line">com.alibaba.dubbo.rpc.protocol.dubbo.filter.FutureFilter.invoke(FutureFilter.java:54)</span><br><span class="line">com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:69)</span><br><span class="line">com.alibaba.dubbo.rpc.filter.ConsumerContextFilter.invoke(ConsumerContextFilter.java:48)</span><br><span class="line">com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:69)</span><br><span class="line">com.alibaba.dubbo.rpc.listener.ListenerInvokerWrapper.invoke(ListenerInvokerWrapper.java:74)</span><br><span class="line">com.alibaba.dubbo.rpc.protocol.InvokerWrapper.invoke(InvokerWrapper.java:53)</span><br><span class="line">com.alibaba.dubbo.rpc.cluster.support.FailoverClusterInvoker.doInvoke(FailoverClusterInvoker.java:77)</span><br><span class="line">com.alibaba.dubbo.rpc.cluster.support.AbstractClusterInvoker.invoke(AbstractClusterInvoker.java:229)</span><br><span class="line">com.alibaba.dubbo.rpc.cluster.support.wrapper.MockClusterInvoker.invoke(MockClusterInvoker.java:72)</span><br><span class="line">com.alibaba.dubbo.rpc.proxy.InvokerInvocationHandler.invoke(InvokerInvocationHandler.java:52)</span><br><span class="line">com.alibaba.dubbo.common.bytecode.proxy1.selectUsersAll(proxy1.java)</span><br><span class="line">com.bjsxt.service.impl.UserServiceImpl.selectUserAll(UserServiceImpl.java:42)</span><br><span class="line">com.bjsxt.controller.UsersController.findAll(UsersController.java:31)</span><br><span class="line">sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)</span><br><span class="line">sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)</span><br><span class="line">sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)</span><br><span class="line">java.lang.reflect.Method.invoke(Method.java:483)</span><br><span class="line">org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:221)</span><br><span class="line">org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:137)</span><br><span class="line">org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:110)</span><br><span class="line">org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:777)</span><br><span class="line">org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:706)</span><br><span class="line">org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85)</span><br><span class="line">org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:943)</span><br><span class="line">org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:877)</span><br><span class="line">org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:966)</span><br><span class="line">org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:857)</span><br><span class="line">javax.servlet.http.HttpServlet.service(HttpServlet.java:621)</span><br><span class="line">org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:842)</span><br><span class="line">javax.servlet.http.HttpServlet.service(HttpServlet.java:728)</span><br><span class="line">org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51)</span><br><span class="line">org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88)</span><br><span class="line">org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107)</span><br></pre></td></tr></table></figure><p>问题解决：</p><p>​        provider(192.168.1.113)中使用的是192.168.1.103的主机的mysql,而192.168.1.103的防火墙需要打开</p><p>​        然后重启provider即可.</p><p>注意：</p><p>​        consumer和provider两台主机需要开放dubbo协议连接的所需端口(连接形成一个channel: /192.168.1.112:52877 -&gt; /192.168.1.113:20880)</p><p>​            </p><p>1）provider：配置服务端口</p><p>​        linux中开放服务端口，例如20880（或者关闭防火墙，否则consumer启动失败）</p><p>​        iptables相关配置：                </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1)iptables -nL --line-number    查看规则，行号</span><br><span class="line">2)iptables -D INPUT 6        删除行号为6的规则</span><br><span class="line"># 因为最后一行是reject-with icmp-host-prohibited，拒绝所有,因此需要插入到最后一行前面</span><br><span class="line">3)iptables -I INPUT 3  -p tcp --dport 8080 -j ACCEPT     添加规则插入到第3行，</span><br><span class="line">#注意不要使用service iptables restart,否则规则会到最后一行</span><br><span class="line">4)iptables-save          保存即可</span><br></pre></td></tr></table></figure><p>​                </p><p>2）consumer:</p><p>​                请求连接并获得回应：channel: /192.168.1.112:37711 -&gt; /192.168.1.113:20880</p><p>注意：37711端口没有开放为什么可以得到回应?                                </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">IPtable第一条规则</span><br><span class="line">1    ACCEPT   all  --  0.0.0.0/0      0.0.0.0/0      state RELATED,ESTABLISHED </span><br><span class="line">这个想要进入的封包是否为刚刚我发出去的回应?如果是刚刚我发出去的回应,那麼就可以予以接受放行.</span><br><span class="line">ESTABLISHED：已建立的链接状态.</span><br><span class="line">RELATED：该封包为本机发出的封包有关.</span><br></pre></td></tr></table></figure><p>192.168.1.112:37711向192.168.1.113:20880请求服务，provider处理完毕，再通过192.168.1.113:20880将结果回应给192.168.1.112:37711。</p><p>由于是37711建立的连接，按照iptables的第一条规则所以允许接收，因此consumer的37711这个端口可以不建立iptables放行规则。                                                            </p><h3 id="Dubbo注册IP混乱的问题"><a href="#Dubbo注册IP混乱的问题" class="headerlink" title="Dubbo注册IP混乱的问题"></a>Dubbo注册IP混乱的问题</h3><h4 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h4><p>​            关闭其他网卡服务，例如虚拟机的vmnet1,vmnet8</p><h4 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h4><p>a) 通过hostname命令得到机器名<br>b) 通过vim /etc/hosts设置机器名对应的外网IP<br>127.0.0.1  localhost  localhost.localdomain<br>外网IP    VM_31_182_centos</p><p>示例配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4</span><br><span class="line">::1         localhost localhost.localdomain localhost6 localhost6.localdomain6</span><br><span class="line">192.168.1.112 slave1</span><br></pre></td></tr></table></figure><h3 id="consumer启动问题以及远程部署"><a href="#consumer启动问题以及远程部署" class="headerlink" title="consumer启动问题以及远程部署"></a>consumer启动问题以及远程部署</h3><h4 id="远程部署consumer"><a href="#远程部署consumer" class="headerlink" title="远程部署consumer"></a>远程部署consumer</h4><p>​    通过maven插件远程部署consumer(一个web项目)至tomcat，由于 zookeeper 注册中心没有开启，    </p><p>因此consumer无法从zookeeper获取服务接口信息，初始化会失败，即项目启动失败。</p><p>注意：</p><p>​        远程部署需要配置tomcat用户,conf/tomcat-users.xml</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;role rolename=&quot;manager-gui&quot;/&gt;</span><br><span class="line">&lt;role rolename=&quot;manager-script&quot;/&gt;</span><br><span class="line">&lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager-gui,manager-script&quot;/&gt;</span><br></pre></td></tr></table></figure><h4 id="将consumer项目拷贝至tomcat的webapps下"><a href="#将consumer项目拷贝至tomcat的webapps下" class="headerlink" title="将consumer项目拷贝至tomcat的webapps下"></a>将consumer项目拷贝至tomcat的webapps下</h4><p>注意：</p><p>​        在consumer的项目中，如果使用的某些路径是/,则要将其拷贝至ROOT中</p><p>将consumer拷贝至webapps目录下，启动tomcat,如果zookeeper注册中心没有启动，</p><p>或者zookeeper启动但是consumer无法获取需要的服务接口信息，都会导致consumer启动</p><p>失败.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;assembly打包后启动provider分析&quot;&gt;&lt;a href=&quot;#assembly打包后启动provider分析&quot; class=&quot;headerlink&quot; title=&quot;assembly打包后启动provider分析&quot;&gt;&lt;/a&gt;assembly打包后启动prov
      
    
    </summary>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/categories/JavaSE/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>solor全文检索服务</title>
    <link href="http://yoursite.com/2019/08/25/JavaAdvancedTechnology/Solr/Solr%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2019/08/25/JavaAdvancedTechnology/Solr/Solr%E5%85%A8%E6%96%87%E6%A3%80%E7%B4%A2%E6%9C%8D%E5%8A%A1/</id>
    <published>2019-08-25T09:46:31.000Z</published>
    <updated>2019-09-03T03:05:19.949Z</updated>
    
    <content type="html"><![CDATA[<h1 id="全文检索"><a href="#全文检索" class="headerlink" title="全文检索"></a>全文检索</h1><h2 id="为什么使用全文检索"><a href="#为什么使用全文检索" class="headerlink" title="为什么使用全文检索"></a>为什么使用全文检索</h2><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>​    没有使用全文检索的时候，大部分会利用WHERE子句匹配LIKE关键词，在庞大的数据字段中搜索某些想要的字，如：    select * from test  WHERE Notes LIKE ‘%你好%’</p><p>​    然而这种查询方式非常没有效率，即使在Notes字段建立了一般的索引，帮助也不大，因为SQL SERVER为数据表建立的索引是排序过的数据结构。因此，可以用二分搜索算法来快速寻找数据，但搜索’%你好%’可没有什么顺序可言，因为搜索条件以’%’开头.<br><strong><em>全文检索则提供完全不同的索引架构，以关键词为基础建立全文检索索引。搭配特有的SQL查询语法，对于大型文本的字词查询更具弹性和效率</em></strong>        </p><p>例1：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">我们有一个表大概有50万条数据，其中有一个字段是字符串类型需要实现like 模糊查询，我们使用的是mysql，虽然已经建立了索引，但是由于使用的是%a%模式匹配，很不给力，在大量并发下，数据库会挂掉，或者用户等到抓狂查询结果还不出来，后来想出了一个办法解决了这个问题，每次查询可以控制在15ms左右，效果很是不错。我们采用是全文索引技术：</span><br><span class="line">1、使用lucene或者其他可以提供全文索引的nosql数据库，比如tt server或mongodb</span><br><span class="line">2、把需要模糊查询的字段的字符串数据进行”全分词“，即把所有可能分词都枚举出来，比如abc,可以分成a,ab,abc,b,bc,c</span><br><span class="line">3、把这些分好的term建立索引，如果使用lucene则需要建立一个分词器，能把传入的字符串分解成第2步描述的分词后建立索引，如果使用的是mongodb，则把分好的词存入一个字段并且建立索引，如果使用的tt server，那就简单了，直接建立qgram类型的索引即可，不需要自己去分词，我们最终就是使用tt server解决的问题</span><br><span class="line">4、使用各自提供的查询语法进行查询，绝对高效</span><br><span class="line">最终采用tt server的qgram方式实现，50多万条数据的模糊查询时间不超过15毫秒，有缓存的情况可能是0ms。</span><br></pre></td></tr></table></figure><p>例2：mysql的全文索引与like实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在数据库使用中，DBA都会告诉大家SQL的LIKE条件为%XXX%号时，由于不能使用索引，当数据量变大时(比如超过百万条)，全表扫描会导致性能很差。</span><br><span class="line">　　但是在实际业务中，很难避免MySQL全文检索并Like索引的这种需求。比如模糊搜索用户帐号，昵称之类。既然这个需求必须做，但又不可以直接用LIKE。这里我和大家分享一下我们关于这种需求的一种解决方案。当然别人也可能采用过类似的办法，我不是很清楚。所以也用一下“原创”吧。</span><br><span class="line"></span><br><span class="line">　　MySQL数据库很早就支持全文索引，但是全文索引和LIKE语句是不同的。具体点说，全文索引的单位是词，耳LIKE匹配的是字符。当然实际的区别更大，比如“老鼠爱大米”这段文本用全文搜索的话，条件“老鼠爱大米”，“老鼠和大米”，“大米老鼠”，“大米与老鼠”会搜索到内容，但是“爱”，“鼠爱”，“爱大”不会搜索到内容。反之，使用LIKE搜索时，“老鼠和大米”，“大米老鼠”，“大米与老鼠”不会找到内容，而“爱”，“鼠爱”，“爱大”会找到内容。我们这里不讨论两种方式的优劣，根据实际情况每种功能都会有各自的实际需求。比如对于大段文本，全文检索是最好的方法，但是对于姓名，帐号，昵称等很短的通常无意义文本，LIKE会更合适一些。</span><br><span class="line">　　虽然全文检索和LIKE搜索不同，但是在特殊情况下，可以用全文搜索功能来实现LIKE搜索。具体就是每个字符作为一个词，而且使用双引号来限制词精确匹配(简单点说就是老鼠大米和大米老鼠不同)，这样可以实现LIKE搜索的功能。</span><br><span class="line">　　</span><br><span class="line"></span><br><span class="line">来自：https://www.cnblogs.com/bobsoft/archive/2012/10/07/2714545.html</span><br></pre></td></tr></table></figure><p>例3：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">当我们访问购物网站的时候，我们可以根据我们随意所想的内容输入关键字就可以查询出相关的内容，这是怎么做到呢？这些随意的数据不可能是根据数据库的字段查询的，那是怎么查询出来的呢，为什么千奇百怪的关键字都可以查询出来呢？</span><br><span class="line">答案就是全文检索工具的实现，luncence采用了词元匹配和切分词。举个例子：北京天安门----luncence切分词：北京  京天  天安  安门  等等这些分词。所以我们搜索的时候都可以检索到。</span><br><span class="line">有一种分词器就是IKanalyzer中文分词器，它有细粒度切分和智能切分，即根据某种智能算法。</span><br><span class="line">这就使用solr的最大的好处：检索功能的实现。</span><br><span class="line"></span><br><span class="line">来自：https://blog.csdn.net/jokeylin/article/details/80562148</span><br></pre></td></tr></table></figure><h3 id="有数据库为什么要solr"><a href="#有数据库为什么要solr" class="headerlink" title="有数据库为什么要solr"></a>有数据库为什么要solr</h3><p>​        lucene负责数据存储，而solr只是一个引擎提供搜索和插入而已，跟数据库的解释器一样，有什么好处呢，比如一个数据库有一个字段存了1000个字，你想从这些字里面搜一个词的时候，普通的数据库只会让你使用like去查询，他会遍历每个字去模糊匹配，效率很低，而且有些是无法查询的，当然除了像一些特殊的数据库带有分词，比如postgresql，那lucene做的事情就是分词，然后去匹配分词的词中是否有你想搜的词就好了，当然了，为了提高这种检索效率和内存节省底层做了很复杂的事情，可以这么简单的认为，全文搜索这件事情上数据库是无法满足的</p><h4 id="二"><a href="#二" class="headerlink" title="二"></a>二</h4><p>​    大型的SQL数据库上很难执行高速的查询。Solr是Apache 下的一个开源项目，使用Java基于Lucene开发的全文检索服务；它是一个<strong>独立的企业级搜索应用服务器</strong>，它对外提供类似于Web-service的API接口。用户可以通过http请求，向搜索引擎服务器提交一定格式的XML文件，生成索引；也可以通过Http Get操作提出查找请求，并得到XML格式的返回结果。</p><p>​    为什么使用solr???????</p><p>　<strong><em>第一点原因来自SQL数据库在性能上缺乏亮点。基本上，你需要在你的查询中使用JOIN操作。</em></strong></p><p>　<strong><em>第二点原因是文档的天然数据特性：松散的文本文件，这种查询都是需要使用LIKE。然而joins和likes都是性能杀手，在目前的数据库引擎中是不方便的。</em></strong></p><p>所以，很多时候希望找到一种跟SQL完全不同的数据检索方式：倒排索引。</p><p>这种数据结构类似与美化过的词典：</p><p>　　　　　　key是单个的term</p><p>　　　　　　values是跟term对应的文档列表</p><p>这种数据方式可以帮助在大型的数据库上面进行高速查询。</p><h2 id="全文检索定义"><a href="#全文检索定义" class="headerlink" title="全文检索定义"></a>全文检索定义</h2><h3 id="数据分类"><a href="#数据分类" class="headerlink" title="数据分类"></a>数据分类</h3><p>我们生活中的数据总体分为两种：结构化数据和非结构化数据。</p><ul><li>结构化数据：指具有固定格式或有限长度的数据，如数据库中的数据，元数据等。</li><li>非结构化数据：指不定长或无固定格式的数据，如邮件，word文档等磁盘上的文件。</li></ul><h3 id="非结构化数据查询方法"><a href="#非结构化数据查询方法" class="headerlink" title="非结构化数据查询方法"></a>非结构化数据查询方法</h3><h4 id="顺序扫描法-Serial-Scanning"><a href="#顺序扫描法-Serial-Scanning" class="headerlink" title="顺序扫描法(Serial Scanning)"></a>顺序扫描法(Serial Scanning)</h4><p>​        所谓顺序扫描，比如要找内容包含某一个字符串的文件，就是一个文档一个文档的看，对于每一个文档，从头看到尾，如果此文档包含此字符串，则此文档为我们要找的文件，接着看下一个文件，直到扫描完所有的文件。如利用windows的搜索也可以搜索文件内容，只是相当的慢。</p><h4 id="全文检索-Full-text-Search"><a href="#全文检索-Full-text-Search" class="headerlink" title="全文检索(Full-text Search)"></a>全文检索(Full-text Search)</h4><p>​        将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之索引。<br>例如：字典。字典的拼音表和部首检字表就相当于字典的索引，对每一个字的解释是非结构化的，如果字典没有音节表和部首检字表，在茫茫辞海中找一个字只能顺序扫描。然而字的某些信息可以提取出来进行结构化处理，比如读音，就比较结构化，分声母和韵母，分别只有几种可以一一列举，于是将读音拿出来按一定的顺序排列，每一项读音都指向此字的详细解释的页数。我们搜索时按结构化的拼音搜到读音，然后按其指向的页数，便可找到我们的非结构化数据——也即对字的解释。<br>这种先建立索引，再对索引进行搜索的过程就叫全文检索(Full-text Search)。<br>虽然创建索引的过程也是非常耗时的，但是索引一旦创建就可以多次使用，全文检索主要处理的是查询，所以耗时间创建索引是值得的。</p><h3 id="如何实现全文检索"><a href="#如何实现全文检索" class="headerlink" title="如何实现全文检索"></a>如何实现全文检索</h3><p>可以使用Lucene实现全文检索。Lucene是apache下的一个开放源代码的全文检索引擎工具包（提供了Jar包，实现全文检索的类库）。它提供了完整的查询引擎和索引引擎，部分文本分析引擎。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便地在目标系统中实现全文检索的功能。<br>注意：Lucene只是一个引擎，只是一个工具包，如果使用Lucene开发全文检索功能，要记住Lucene是不能单独运行的。</p><h3 id="全文检索技术的应用场景"><a href="#全文检索技术的应用场景" class="headerlink" title="全文检索技术的应用场景"></a>全文检索技术的应用场景</h3><p>对于数据量大、数据结构不固定的数据可采用全文检索方式搜索。例如：</p><p>使用全文检索技术可以实现搜索引擎（百度、google…），搜索引擎可以搜索互联网上所有的内容（网页、pdf电子书、视频、音乐）。<br>Lucene和搜索引擎的区别：搜索引擎是对外提供全文检索服务，是可以单独运行的。Lucene只是一个工具包不能单独运行，需要在project中加入lucene的jar包，最终project在JVM中运行。<br>使用全文检索技术可以实现站内搜索，站内搜索只能搜索本网站的信息（网页、pdf电子书、视频、音乐、关系数据库中的信息等等），比如：电商网站搜索商品信息，论坛网站搜索网内帖子。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>全文检索过程分为索引、搜索两个过程：</p><h4 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h4><p>从关系数据库中、互联网上、文件系统采集源数据(要搜索的目标信息)，源数据的来源是很广泛的。<br>将源数据采集到一个统一的地方，要创建索引，将索引创建到一个索引库（文件系统）中，从源数据库中提取关键信息，从关键信息中抽取一个一个词，词和源数据是有关联的。也即创建索引时，词和源数据有关联，索引库中记录了这个关联，如果找到了词就说明找到了源数据（http的网页、pdf电子书等……）。</p><h4 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h4><p>用户执行搜索（全文检索）编写查询关键字。<br>从索引库中搜索索引，根据查询关键字搜索索引库中的一个一个词。<br>展示搜索的结果。</p><h2 id="全文检索实现"><a href="#全文检索实现" class="headerlink" title="全文检索实现"></a>全文检索实现</h2><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>​        对文档索引的过程，将用户要搜索的文档内容进行索引，索引存储在索引库（index）中。<br>这里我们要搜索的文档是磁盘上的文本文件，根据案例描述：凡是文件名或文件内容包括关键字的文件都要找出来，这里要对文件名和文件内容创建索引。</p><h3 id="获得原始文档"><a href="#获得原始文档" class="headerlink" title="获得原始文档"></a>获得原始文档</h3><p>​    原始文档是指要索引和搜索的内容。原始内容包括互联网上的网页、数据库中的数据、磁盘上的文件等    </p><p>​    从互联网上、数据库、文件系统中等数据源处获取需要搜索的原始信息，这个过程就是信息采集，信息采集的目的是为了对原始内容进行索引。针对不同的源数据，使用不同的技术进行采集获得原始文档：</p><p><strong><em>针对互联网上的数据，使用http协议抓取html网页到本地，生成一个html文件。</em></strong><br><strong><em>针对关系数据库中的数据，连接数据库读取表中的数据。</em></strong><br><strong><em>针对文件系统中的数据，通过流读取文件系统的文件。</em></strong></p><p>以上技术中使用第一种较多，因为目前全文检索主要搜索数据的来源是互联网，在Internet上采集信息的软件通常称为爬虫或蜘蛛，也称为网络机器人，爬虫访问互联网上的每一个网页，将获取到的网页内容存储起来，所以搜索引擎使用一种爬虫程序抓取网页（ 通过http抓取html网页信息）。<br>Lucene不提供信息采集的类库，需要自己编写一个爬虫程序实现信息采集，也可以通过一些开源软件实现信息采集，以下是一些爬虫项目（了解）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Solr（http://lucene.apache.org/solr），solr是apache的一个子项目，支持从关系数据库、xml文档中提取原始数据。</span><br><span class="line">Nutch（http://lucene.apache.org/nutch）, Nutch是apache的一个子项目，包括大规模爬虫工具，能够抓取和分辨web网站数据。</span><br><span class="line">jsoup（http://jsoup.org/ ），jsoup是一款Java的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。</span><br><span class="line">Heritrix（http://sourceforge.net/projects/archive-crawler/files/），Heritrix是一个由java开发的、开源的网络爬虫，用户可以使用它来从网上抓取想要的资源。其最出色之处在于它良好的可扩展性，方便用户实现自己的抓取逻辑。</span><br></pre></td></tr></table></figure><h3 id="创建文档对象"><a href="#创建文档对象" class="headerlink" title="创建文档对象"></a>创建文档对象</h3><h3 id="分析文档"><a href="#分析文档" class="headerlink" title="分析文档"></a>分析文档</h3><h3 id="创建索引-1"><a href="#创建索引-1" class="headerlink" title="创建索引"></a>创建索引</h3><h3 id="查询索引"><a href="#查询索引" class="headerlink" title="查询索引"></a>查询索引</h3><h3 id="用户查询接口"><a href="#用户查询接口" class="headerlink" title="用户查询接口"></a>用户查询接口</h3><h3 id="创建查询"><a href="#创建查询" class="headerlink" title="创建查询"></a>创建查询</h3><h3 id="执行查询"><a href="#执行查询" class="headerlink" title="执行查询"></a>执行查询</h3><h3 id="渲染结果"><a href="#渲染结果" class="headerlink" title="渲染结果"></a>渲染结果</h3><h2 id="Solr集群配置的一些说明"><a href="#Solr集群配置的一些说明" class="headerlink" title="Solr集群配置的一些说明"></a>Solr集群配置的一些说明</h2><p>​        1)安装zookeeper集群，做配置管理</p><p>​        2)安装四个tomcat,和四个索引库，依旧是一对一(solr的web服务中web.xml配置索引库的绝对路径)</p><p>​        3)上传索引库的配置文件至zookeeper(索引库目录下的collection/conf)</p><p>​        4)修改每一个索引库下的 solr.xml,指定当前实例运行的ip地址及端口号        </p><p>​        5)修改每一台solr的tomcat的bin目录下 catalina.sh文件中加入DzkHost指定zookeeper服务器地址</p><p>​                    JAVA_OPTS=”-DzkHost=192.168.70.147:2181,192.168.70.147:2182,192.168.70.14 7:2183”</p><p>​        </p><p>注意：加入JAVA_OPTS的参数的含义，也就是程序可以读取该键值对配置            </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">JVM自定义参数通过java命令的可选项:</span><br><span class="line">-D&lt;name&gt;=&lt;value&gt;</span><br><span class="line">来传入JVM，传入的参数作为system的property。因此在程序中可以通过下面的语句获取参数值：</span><br><span class="line">System.getProperty(&lt;name&gt;)</span><br><span class="line"></span><br><span class="line">public class JVMParameter &#123;</span><br><span class="line"> </span><br><span class="line">    /**</span><br><span class="line">     * 运行前设置JVM参数 -Djvm.index=1</span><br><span class="line">     * @param args</span><br><span class="line">     */</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        // TODO Auto-generated method stub</span><br><span class="line">        String jvmIndex = System.getProperty(&quot;jvm.index&quot;);</span><br><span class="line">        System.out.println(&quot;jvmIndex=&quot; + jvmIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">运行class命令：</span><br><span class="line">java -Djvm.index=1 JVMParameter</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line">JVM自定义参数可用来在集群环境区分当前class运行在哪个JVM上，可以达到让某个class只在某个指定的JVM上运行，避免多个JVM同时运行，出现混乱。也可以作为程序读取的配置信息</span><br></pre></td></tr></table></figure><p>参考：        </p><p>​        <a href="https://blog.csdn.net/qq_16162981/article/details/70142166" target="_blank" rel="noopener">https://blog.csdn.net/qq_16162981/article/details/70142166</a></p><p>​        <a href="https://blog.csdn.net/yerenyuan_pku/article/details/72582979" target="_blank" rel="noopener">https://blog.csdn.net/yerenyuan_pku/article/details/72582979</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;全文检索&quot;&gt;&lt;a href=&quot;#全文检索&quot; class=&quot;headerlink&quot; title=&quot;全文检索&quot;&gt;&lt;/a&gt;全文检索&lt;/h1&gt;&lt;h2 id=&quot;为什么使用全文检索&quot;&gt;&lt;a href=&quot;#为什么使用全文检索&quot; class=&quot;headerlink&quot; title=
      
    
    </summary>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/categories/JavaSE/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Maven项目构建工具</title>
    <link href="http://yoursite.com/2019/08/14/Tools/Maven%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    <id>http://yoursite.com/2019/08/14/Tools/Maven%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/</id>
    <published>2019-08-14T15:24:08.000Z</published>
    <updated>2019-08-16T10:00:13.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Maven"><a href="#Maven" class="headerlink" title="Maven"></a>Maven</h1><h2 id="Maven-简介"><a href="#Maven-简介" class="headerlink" title="Maven 简介"></a>Maven 简介</h2><p>​                Maven 是一个项目管理工具，它包含了一个项目对象模 型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管 理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标 (goal)的逻辑!</p><h2 id="IDEA使用Maven遇到的坑"><a href="#IDEA使用Maven遇到的坑" class="headerlink" title="IDEA使用Maven遇到的坑"></a>IDEA使用Maven遇到的坑</h2><h3 id="tomcat插件"><a href="#tomcat插件" class="headerlink" title="tomcat插件"></a>tomcat插件</h3><p>​                    tomcat:run                </p><p>​                    如果没有在src/main下找到webapp，则就直接启动，因此就算删除webapp目录还是可以启动tomcat                                    如果找到了webapp目录,就将当前项目发布(并不会在target中生成war包) </p><h3 id="使用maven打war包后放入tomcat运行"><a href="#使用maven打war包后放入tomcat运行" class="headerlink" title="使用maven打war包后放入tomcat运行"></a>使用maven打war包后放入tomcat运行</h3><p>​            打包时的项目根路径有两种方式：</p><p>1）默认从src/main/webapp作为项目根目录</p><p>​                                                    </p><p>2）在pom文件中指定                                                    </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugin&gt;</span><br><span class="line">    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;2.2&lt;/version&gt;</span><br><span class="line">    &lt;configuration&gt;</span><br><span class="line">    &lt;!-- 指定web.xml的路径--&gt;</span><br><span class="line">    &lt;webXml&gt;web\WEB-INF\web.xml&lt;/webXml&gt;</span><br><span class="line">    &lt;!-- 指定jsp、js、css的路径 --&gt;</span><br><span class="line">    &lt;warSourceDirectory&gt;web&lt;/warSourceDirectory&gt;</span><br><span class="line">    &lt;/configuration&gt;</span><br><span class="line"> &lt;/plugin&gt;</span><br></pre></td></tr></table></figure><p>​        注意:打war包可以，但是指定的项目目录不被maven的tomcat插件识别，无法发布比较坑                </p><p>3）将war包放到到tomcat的webapps目录进行发布</p><p>​        注意:</p><p>​                    路径问题:</p><p>​                        引入：</p><p>​                                例如：IDEA发布时使用Application context为/,</p><p>​                                            即使用<a href="http://localhost:8080就可以访问项目" target="_blank" rel="noopener">http://localhost:8080就可以访问项目</a>                                                                    </p><p>​                                            但是，在重定向时路径/表示服务器根路径，</p><p>​                                            则路径写法：/项目名/需要跳转的路径</p><p>​                                                   如果写死,项目在需要使用项目名或者不需要使用项目名访问时，访问就会出现问题    </p><p>​                                                    或者是jsp文件中路径</p><p>​                        解决：</p><p>​                                项目中最好使用req.getContextPath() + “/login”来得到工程名+路径</p><p>​                                这样在发布时有没有项目名都可以正常运行</p><p>​                                jsp文件可以使用基路径来控制:先得到路径，再使用basePath标签</p><p>​                    </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Maven&quot;&gt;&lt;a href=&quot;#Maven&quot; class=&quot;headerlink&quot; title=&quot;Maven&quot;&gt;&lt;/a&gt;Maven&lt;/h1&gt;&lt;h2 id=&quot;Maven-简介&quot;&gt;&lt;a href=&quot;#Maven-简介&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="tools" scheme="http://yoursite.com/categories/tools/"/>
    
    
      <category term="tools" scheme="http://yoursite.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>tomcat9.0的filter拦截静态资源问题</title>
    <link href="http://yoursite.com/2019/08/13/Java%20Web/tomcat9.0%E7%9A%84filter%E6%8B%A6%E6%88%AA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/08/13/Java%20Web/tomcat9.0%E7%9A%84filter%E6%8B%A6%E6%88%AA%E9%9D%99%E6%80%81%E8%B5%84%E6%BA%90%E9%97%AE%E9%A2%98/</id>
    <published>2019-08-13T15:33:08.000Z</published>
    <updated>2019-08-14T04:28:33.026Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h2><p>tomcat9.0中，servlet-api.jar中的Filter接口有三个方法：</p><p>​    init():    public default void init(FilterConfig filterConfig);</p><p>​    doFilter():     public void doFilter(ServletRequest request, ServletResponse response,FilterChain chain);</p><p>​    destory():     public default void destroy();</p><p>init()和destory()有default修饰，也就是说，</p><p>可以不实现init()和destory()方法，实现该接口的类会继承这两个方法</p><h2 id="无法解决的问题"><a href="#无法解决的问题" class="headerlink" title="无法解决的问题"></a>无法解决的问题</h2><p>？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？</p><p>定义MyFilter实现Filter接口，重写doFilter()方法，拦截路径/*，这样会拦截所有的资源。</p><p>接着，对请求和响应进行设置编码格式,再放行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)</span><br><span class="line">throws IOException, ServletException &#123;</span><br><span class="line">//设置请求编码格式</span><br><span class="line">request.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">//设置响应编码格式</span><br><span class="line">response.setCharacterEncoding(&quot;utf-8&quot;);</span><br><span class="line">//浏览器的解码格式</span><br><span class="line">response.setContentType(&quot;text/html;charset=utf-8&quot;);</span><br><span class="line">//放行</span><br><span class="line">chain.doFilter(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>问题出现:    </p><p>​                    访问静态资源全部变成document类型</p><p>​                                例如访问一个图片，该图片会以文档的形式被浏览器解析</p><p>问题定位:</p><p>​                    设置响应编码格式的问题，具体原因</p><p>​                                    浏览器解析成text/html格式</p><p>​                                    response.setContentType(“text/html;charset=utf-8”);</p><p>​                                                                    </p><p>解决:</p><p>​            解决1</p><p>​                    tomcat7不会出现该问题    </p><p>​            解决2：</p><p>​                    对静态资源，非静态资源进行判断</p><p>​                                如果是静态资源，不设置响应编码格式</p><p>​                                            默认会自动设置响应格式</p><p>​                                                            例如：图片格式Content-Type:image/jpeg;charset=utf-8</p><p>​                                如果是非静态资源，再设置响应编码格式</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;引入&quot;&gt;&lt;a href=&quot;#引入&quot; class=&quot;headerlink&quot; title=&quot;引入&quot;&gt;&lt;/a&gt;引入&lt;/h2&gt;&lt;p&gt;tomcat9.0中，servlet-api.jar中的Filter接口有三个方法：&lt;/p&gt;
&lt;p&gt;​    init():    publ
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>servlet中的请求路径</title>
    <link href="http://yoursite.com/2019/08/09/Java%20Web/servlet%E4%B8%AD%E7%9A%84%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2019/08/09/Java%20Web/servlet%E4%B8%AD%E7%9A%84%E8%AF%B7%E6%B1%82%E8%B7%AF%E5%BE%84/</id>
    <published>2019-08-09T07:23:02.000Z</published>
    <updated>2019-08-10T16:04:20.452Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于servlet配置中-和"><a href="#关于servlet配置中-和" class="headerlink" title="关于servlet配置中 / 和 /*"></a>关于servlet配置中 / 和 /*</h1><p>配置为 / ，结果 test、test.do、test.html 都可以请求到，但是test.jsp请求不到</p><p><strong>“/‘表示匹配所有请求（其中包含除.jsp和.jspx外的所有后缀）。</strong></p><p>如果不配置静态资源，<strong><em>它会把匹配所有请求都当做是对控制器的访问，去掉后缀进行匹配</em></strong>。例如你访问/main.css会变成/main，这也是造成你引入的.css,.js等静态资源无法访问的原因，因为他们都被当做控制器的路径了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;url-pattern&gt;/&lt;/url-pattern&gt;</span><br><span class="line"></span><br><span class="line">这个/不会覆盖任何其他servlet。它只对所有请求替换servlet容器的内置默认servlet，这与任何其他注册的servlet都不匹配。这通常只在静态资源(CSS/JS/Image/etc)和目录清单上调用。servlet容器的内置默认servlet还能够处理HTTP缓存请求、媒体(音频/视频)流和文件下载恢复。通常，您不希望覆盖默认的servlet，因为否则您就必须处理它的所有任务，这并不简单(JSF实用程序库)OmniFaces有一个开源 例)。因此，这也是servlet的一个糟糕的URL模式。</span><br><span class="line"></span><br><span class="line">至于为什么JSP页面不访问这个servlet，这是因为servlet容器的内置JSPservlet将被调用，默认情况下，它已经映射到了更具体的URL模式上*.jsp.</span><br></pre></td></tr></table></figure><p>配置为 /* ，结果 test、test.do、test.html、test.jsp 都可以请求到，这意味着如果你配置成这个，跳转回jsp页面都会被拦截，所以需要注意</p><p><strong>“/*“表示匹配所有请求（包含所有后缀）</strong></p><p>这里*<em>.jsp比”/\</em>“的匹配度低，所以配置后会使.jsp也进入DispatcherServlet,而.jsp既不是控制器路径也不是静态资源，所以就算配了静态资源还是访问不到，所以这个/*的配置不适用于DispatcherServlet,一般用于过滤器来拦截所有资源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line"></span><br><span class="line">这个/*在servlet上覆盖所有其他servlet，包括servlet容器提供的所有servlet，比如默认的servlet和JSP servlet。不管您发出什么请求，它都将在那个servlet中结束。因此，对于servlet来说，这是一个糟糕的URL模式。</span><br></pre></td></tr></table></figure><p><strong><em>通常，/\</em>在上Filter使用。它可以通过调用FilterChain#doFilter().放行*</strong></p><p>参考1：<a href="https://www.cnblogs.com/coder-lichao/p/10698996.html" target="_blank" rel="noopener">https://www.cnblogs.com/coder-lichao/p/10698996.html</a></p><h1 id="do错误"><a href="#do错误" class="headerlink" title="/*.do错误"></a>/*.do错误</h1><p>Servlet和filter是J2EE开发中常用的技术，使用方便，配置简单，老少皆宜。</p><p>　　估计大多数朋友都是直接配置用，也没有关心过具体的细节，今天遇到一个问题，上网查了servlet的规范才发现，servlet和filter中的url-pattern还是有一些文章在里面的，总结了一些东西，放出来供大家参考，以免遇到问题又要浪费时间。</p><h2 id="一、servlet容器对url的匹配过程"><a href="#一、servlet容器对url的匹配过程" class="headerlink" title="　　一、servlet容器对url的匹配过程"></a>　　一、servlet容器对url的匹配过程</h2><p>　　当一个请求发送到servlet容器的时候，容器先会将请求的url减去当前应用上下文的路径作为servlet的映射url，比如我访问的是 <a href="http://localhost/test/aaa.html，我的应用上下文是test，容器会将http://localhost/test去掉，" target="_blank" rel="noopener">http://localhost/test/aaa.html，我的应用上下文是test，容器会将http://localhost/test去掉，</a> 剩下的/aaa.html部分拿来做servlet的映射匹配。这个映射匹配过程是有顺序的，而且当有一个servlet匹配成功以后，就不会去理会剩下 的servlet了（filter不同，后文会提到）。其匹配规则和顺序如下：</p><p>　　1. 精确路径匹配。例子：比如servletA 的url-pattern为 /test，servletB的url-pattern为 /* ，这个时候，如果我访问的url为<a href="http://localhost/test" target="_blank" rel="noopener">http://localhost/test</a> ，这个时候容器就会先进行精确路径匹配，发现/test正好被servletA精确匹配，那么就去调用servletA，也不会去理会其他的 servlet了。</p><p>　　2. 最长路径匹配。例子：servletA的url-pattern为/test/<em>，而servletB的url-pattern为/test/a/</em>，此 时访问<a href="http://localhost/test/a时，容器会选择路径最长的servlet来匹配，也就是这里的servletB" target="_blank" rel="noopener">http://localhost/test/a时，容器会选择路径最长的servlet来匹配，也就是这里的servletB</a>.</p><p>　　3. 扩展匹配，如果url最后一段包含扩展，容器将会根据扩展选择合适的servlet.例子：servletA的url-pattern：*.action</p><p>　　4. 如果前面三条规则都没有找到一个servlet，容器会根据url选择对应的请求资源。如果应用定义了一个default servlet，则容器会将请求丢给default servlet（什么是default servlet？后面会讲）。</p><p>　　根据这个规则表，就能很清楚的知道servlet的匹配过程，所以定义servlet的时候也要考虑url-pattern的写法，以免出错。</p><p>　　对于filter，不会像servlet那样只匹配一个servlet，因为filter的集合是一个链，所以只会有处理的顺序不同，而不会出现只选择一个filter.Filter的处理顺序和filter-mapping在web.xml中定义的顺序相同。</p><h2 id="二、url-pattern详解"><a href="#二、url-pattern详解" class="headerlink" title="　二、url-pattern详解"></a>　二、url-pattern详解</h2><p>　　在web.xml文件中，以下语法用于定义映射：</p><p>　　以“/‘开头和以”/*“结尾的是用来做路径映射的</p><p>　　以前缀“*.”开头的是用来做扩展映射的</p><p>　　“是用来定义default servlet映射的。</p><p>　　剩下的都是用来定义详细映射的。比如： /aa/bb/cc.action</p><p>　　所以，为什么定义“/*.action”这样一个看起来很正常的匹配会错？因为这个匹配即属于路径映射，也属于扩展映射，导致容器无法判断。</p><p>原文：<a href="https://passw0rd-j.iteye.com/blog/2156919" target="_blank" rel="noopener">https://passw0rd-j.iteye.com/blog/2156919</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;关于servlet配置中-和&quot;&gt;&lt;a href=&quot;#关于servlet配置中-和&quot; class=&quot;headerlink&quot; title=&quot;关于servlet配置中 / 和 /*&quot;&gt;&lt;/a&gt;关于servlet配置中 / 和 /*&lt;/h1&gt;&lt;p&gt;配置为 / ，结果 te
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://yoursite.com/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://yoursite.com/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>java中调用父类方法之super关键字</title>
    <link href="http://yoursite.com/2019/08/04/JavaSE/java%E4%B8%AD%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95%E4%B9%8Bsuper%E5%85%B3%E9%94%AE%E5%AD%97/"/>
    <id>http://yoursite.com/2019/08/04/JavaSE/java%E4%B8%AD%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BB%E6%96%B9%E6%B3%95%E4%B9%8Bsuper%E5%85%B3%E9%94%AE%E5%AD%97/</id>
    <published>2019-08-04T15:12:33.000Z</published>
    <updated>2019-08-04T15:24:51.360Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">String name;</span><br><span class="line"><span class="keyword">int</span> age;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"我是父类的test()方法"</span>);</span><br><span class="line">System.out.println(<span class="string">"父类姓名="</span> + <span class="keyword">this</span>.name + <span class="string">" 父类年龄="</span> + <span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">super</span>.test();</span><br><span class="line">System.out.println(<span class="string">"我是子类的test()方法"</span>);</span><br><span class="line">System.out.println(<span class="string">"子类姓名="</span> + <span class="keyword">this</span>.name + <span class="string">" 子类年龄="</span> + <span class="keyword">this</span>.age);</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Son son = <span class="keyword">new</span> Son();</span><br><span class="line">son.name = <span class="string">"test"</span>;</span><br><span class="line">son.age = <span class="number">18</span>;</span><br><span class="line">son.test();</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理解1：</p><p>1）我觉得super.test()只是在说调用父类中的test方法，并不是说用父类对象来调用父类的test方法。而你使用son子对象来调用子类的test方法，此时虽然子类test中有父类的test方法，但是你此时是使用son子对象来调用父类的test方法的，所以父类的test方法里面的this指的是调用该方法的son子对象</p><p>2）这里面的super关键词，我觉得就是作为一个对于父类的方法的指示。参考Java核心卷；有些人认为 super 与 this 引用是类似的概念， 实际上，这样比较并不太恰当。这是因为 super 不是一个对象的引用， 不能将 super 赋给另一个对象变量， 它只是一个指示编译器调用超类方法的特殊关键字.</p><p>理解2：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">public class Servlets &#123;</span><br><span class="line">    public void service(String req,String resp)&#123;</span><br><span class="line">    System.out.println(&quot;Servlets:service:(1)&quot;);</span><br><span class="line">    if(req.equals(&quot;doGet&quot;))&#123;</span><br><span class="line">    doGet();</span><br><span class="line">    &#125;else if(resp.equals(&quot;doPost&quot;))&#123;</span><br><span class="line">    doPost();</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public void doGet()&#123;</span><br><span class="line">    System.out.println(&quot;Servlets.doGet:(2)&quot;);</span><br><span class="line">    int i=1/0;</span><br><span class="line">    &#125;</span><br><span class="line">public void doPost() &#123;</span><br><span class="line">System.out.println(&quot;Servlets.doPost:(3)&quot;);</span><br><span class="line">    int i=1/0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Son extends Servlets&#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void service(String req, String resp) &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;Son.service:(4)&quot;);</span><br><span class="line">super.service(req, resp);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void doGet() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;Son.doGet:(5)&quot;);</span><br><span class="line">super.doGet();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void doPost() &#123;</span><br><span class="line">// TODO Auto-generated method stub</span><br><span class="line">System.out.println(&quot;Son.doPost(6)&quot;);</span><br><span class="line">super.doPost();</span><br><span class="line">&#125;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br><span class="line">//测试类</span><br><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">Son son=new Son();</span><br><span class="line">son.service(&quot;doGet&quot;,&quot;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Son.service:(4)</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zero</span><br><span class="line">Servlets:service:(1)</span><br><span class="line">Son.doGet:(5)</span><br><span class="line">Servlets.doGet:(2)</span><br><span class="line">at com.servlet_source_test.Servlets.doGet(Servlets.java:14)</span><br><span class="line">at com.servlet_source_test.Son.doGet(Son.java:16)</span><br><span class="line">at com.servlet_source_test.Servlets.service(Servlets.java:7)</span><br><span class="line">at com.servlet_source_test.Son.service(Son.java:9)</span><br><span class="line">at com.servlet_source_test.Test.main(Test.java:6)</span><br></pre></td></tr></table></figure><p>分析：son对象调用service，service中调用super.service(),父类的service中调用this.doGet()方法，很明显调用的是子类的doGet()方法,该this是son对象， super只是一个指示编译器调用超类方法的特殊关键字.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=
      
    
    </summary>
    
    
      <category term="JavaSE" scheme="http://yoursite.com/categories/JavaSE/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
</feed>
