{"meta":{"title":"Momentonly","subtitle":null,"description":null,"author":"Moment Only","url":"http://yoursite.com"},"pages":[{"title":"","date":"2019-07-13T02:34:24.788Z","updated":"2018-12-31T06:06:59.363Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"123layout: categoriestitle: categories ---"},{"title":"","date":"2019-07-13T02:34:38.979Z","updated":"2018-12-31T06:06:40.300Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"123layout: tagstitle: tags ---"}],"posts":[{"title":"设计模式简介","slug":"Design Pattern/设计模式参考简介","date":"2020-04-13T11:41:09.000Z","updated":"2020-04-13T11:52:37.434Z","comments":true,"path":"2020/04/13/Design Pattern/设计模式参考简介/","link":"","permalink":"http://yoursite.com/2020/04/13/Design Pattern/设计模式参考简介/","excerpt":"","text":"设计模式简介​ 设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 ​ 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 设计模式的类型​ 根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。 序号 模式 &amp; 描述 包括 1 创建型模式 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern） 2 结构型模式 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern） 3 行为型模式 这些设计模式特别关注对象之间的通信。 责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern） 4 J2EE 模式 这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。 MVC 模式（MVC Pattern）业务代表模式（Business Delegate Pattern）组合实体模式（Composite Entity Pattern）数据访问对象模式（Data Access Object Pattern）前端控制器模式（Front Controller Pattern）拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）传输对象模式（Transfer Object Pattern） 设计模式的六大原则1、开闭原则（Open Close Principle） 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle） 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 3、依赖倒转原则（Dependence Inversion Principle） 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 5、迪米特法则，又称最少知道原则（Demeter Principle） 最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle） 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。 学习网站 https://www.runoob.com/design-pattern/design-pattern-tutorial.html","categories":[{"name":"designPattern","slug":"designPattern","permalink":"http://yoursite.com/categories/designPattern/"}],"tags":[{"name":"data","slug":"data","permalink":"http://yoursite.com/tags/data/"}]},{"title":"IDEA快捷键","slug":"Tools/IDEA快捷键","date":"2020-04-11T15:09:08.000Z","updated":"2020-04-11T13:53:28.571Z","comments":true,"path":"2020/04/11/Tools/IDEA快捷键/","link":"","permalink":"http://yoursite.com/2020/04/11/Tools/IDEA快捷键/","excerpt":"","text":"crtl + f9 build alt + 7 查看类中的方法 crtl + H 接口，类继承结构","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/tags/tools/"}]},{"title":"servlet3.0","slug":"Java Web/servlet3.0","date":"2020-04-06T05:54:03.000Z","updated":"2020-04-06T07:33:13.181Z","comments":true,"path":"2020/04/06/Java Web/servlet3.0/","link":"","permalink":"http://yoursite.com/2020/04/06/Java Web/servlet3.0/","excerpt":"","text":"Servlet3.0​ 在Servlet3.0协议规范中 ​ 1）包含在JAR文件/META-INFO/resources/路径下的资源可以直接访问(就像在webapp目录下一样)， ​ 2）但是注意：该路径下建立的WEB-INF目录不可以被直接访问，和webapp目录下一样","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"servlet","slug":"servlet","permalink":"http://yoursite.com/tags/servlet/"}]},{"title":"SpringBoot不推荐使用jsp","slug":"SpringBoot/SpringBoot不推荐jsp","date":"2020-04-05T13:08:59.000Z","updated":"2020-04-05T13:16:55.772Z","comments":true,"path":"2020/04/05/SpringBoot/SpringBoot不推荐jsp/","link":"","permalink":"http://yoursite.com/2020/04/05/SpringBoot/SpringBoot不推荐jsp/","excerpt":"","text":"关于Springboot不推荐使用Jsp的讨论springboot不推荐使用jsp，如果使用了jsp会失去一些springboot的特性，这是为什么呢？jsp和其他模板引擎FreeMarker，thymeleaf有什么区别呢？ 回答1原因简单，就因为它叫 JSP (Java Server Page) Java社区的领导者JCP 制定JSP规则就是专门为了给 JavaServer 用的， 所以 JSP 的定义里就指定了它是运行在容器里的. 里面最最重要的就是第一条. (使用jsp的项目 部署时) 把war包放到 tomcat或者其他 java 容器；或者用 java -jar 启一个可执行的 war包 时 是可以正常工作的， 但 直接执行 jar包是不支持的。 也就是说打包方式不一样同样的代码运行结果就是不一样： “java -jar app.jar” 不可以解析jsp“java -jar app.war” 正常解析 剩余几个限制也多少都是因为jsp的规范/法律层面上的原因联锁引起的，或者导致开发者修复/额外考虑的兴致不大。 至于从技术层面的开发使用上 用 JSP当模板 和 用其他模板引擎支持的文件没有任何本质的区别。 差别仅存在于开发书写效率和程序解析运行效率。 比如 jsp 和 freemarker 的解析执行效率都是很高的， 而thymeleaf的书写效率高并且与前端模板语法很相似，学习成本很低。 回答2springboot 是内嵌web容器的，推荐打成jar包不是war包 你如果想使用jsp也可以啊，自建WEB-INF web.xml 然后像往常一样使用jsp 打成war包使用外部容器即可，这就相当于失去了一些springboot的特性了 至于模板引擎其实都差不多，jsp也可以算是模板引擎，springboot推荐的thymeleaf主要嵌入到html的标签属性，这样对前端很友好，有一些优点，但和jsp，FreeMarker比起来也没什么绝对性的优势。 现在web前端技术飞一样的发展，前后端分离才是主流，模板引擎说白了还是给后端人员用的东西，早就不符合现代的前端思想了，而且和React、Vue这类的前端框架比起来又是连提鞋都不配，所以放弃这些模板引擎改用RestController吧。 springboot官方说明jsp限制https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/reference/htmlsingle/#boot-features-jsp-limitations 官方： 28.4.5 JSP Limitations When running a Spring Boot application that uses an embedded servlet container (and is packaged as an executable archive), there are some limitations in the JSP support. With Jetty and Tomcat, it should work if you use war packaging. An executable war will work when launched with java -jar, and will also be deployable to any standard container. JSPs are not supported when using an executable jar. Undertow does not support JSPs. Creating a custom error.jsp page does not override the default view for error handling. Custom error pages should be used instead. There is a JSP sample so that you can see how to set things up. 翻译：28.4.5 JSP的局限性 在运行使用嵌入式servlet容器(并打包为可执行归档文件)的Spring引导应用程序时，JSP支持存在一些限制。 对于Jetty和Tomcat，如果使用war打包，它应该可以工作。一个可执行的war在使用java -jar启动时可以工作，并且也可以部署到任何标准容器中。使用可执行jar时不支持jsp。 Undertow不支持jsp。 创建自定义error.jsp页面不会覆盖用于错误处理的默认视图。应该使用自定义错误页面。 这里有一个JSP示例，以便您了解如何进行设置。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"事务的隔离级别和传播机制","slug":"DataBase/Transaction/事务的隔离级别和传播机制","date":"2020-04-04T08:15:01.000Z","updated":"2020-04-04T13:22:32.422Z","comments":true,"path":"2020/04/04/DataBase/Transaction/事务的隔离级别和传播机制/","link":"","permalink":"http://yoursite.com/2020/04/04/DataBase/Transaction/事务的隔离级别和传播机制/","excerpt":"","text":"事务什么是事务？​ 要么全部都要执行，要么就都不执行。 事务所具有的四种特性原子性 （Atimicty）​ 个人理解，就是事务执行不可分割，要么全部完成，要么全部拉倒不干。 一致性（Consistency）​ 关于一致性这个概念我们来举个例子说明吧，假设张三给李四转了100元，那么需要先从张三那边扣除100，然后李四那边增加100，这个转账的过程对于其他事务而言是无法看到的，这种状态始终都在保持一致，这个过程我们称之为一致性。 隔离性（Isolation）​ 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据是独立的； 持久性（Durability）​ 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 事务并发问题脏读： 事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。幻读： 用户A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是用户B就在这个时候插入了一条具体分数的记录，当修改A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。（一个事务读到另一个事务已提交的insert数据） 概念： 12345678脏读: 指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据， 那么另外一 个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。不可重复读: 指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。 那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。幻觉读:理解1：指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及 到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，就会发生操作第一个事务的用户发现表中还有 没有修改的数据行,也就是说幻像读是指同一查询在同一事务中多次进行，由于其他提交事务所做的插入操作，每次返回不同的结果集，此时发生幻像读,就好象发生了幻觉一样。理解2：幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。幻读和不可重复读都是读取了另一条已经提交的事务(这点就脏读不同)，所不同的是不可重复读可能发生在update,delete操作中，而幻读发生在insert操作中。 小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表 思考：mysql的不可重复读解决了幻读？https://www.cnblogs.com/liyus/p/10556563.html 事务隔离级别事务隔离级别 脏读 不可重复读 幻读读未提交（read-uncommitted） 是 是 是读已提交（read-committed） 否 是 是可重复读（repeatable-read） 否 否 是串行化（serializable） 否 否 否 MYSQL: 默认为REPEATABLE_READ级别SQLSERVER: 默认为READ_COMMITTED Spring对事务的处理编程式事务和声明式事务编程式事务需要你在代码中直接加入处理事务的逻辑,可能需要在代码中显式调用beginTransaction()、commit()、rollback()等事务管理相关的方法,如在执行a方法时候需要事务处理,你需要在a方法开始时候开启事务,处理完后。在方法结束时候,关闭事务. ​ 声明式的事务的做法是在a方法外围添加注解或者直接在配置文件中定义,a方法需要事务处理,在spring中会通过配置文件在a方法前后拦截,并添加事务. ​ 二者区别.编程式事务侵入性比较强，但处理粒度更细. 声明式事务：通过AOP（面向切面）方式在方法前使用编程式事务的方法开启事务，在方法后提交或回滚。用配置文件的方法或注解方法（如：@Transactional）控制事务。 编程式事务：手动开启、提交、回滚事务。 spring在事务方面进行了各种操作的封装，特别是声明式事务的出现，让开发变得更加的舒心. spring事务定义及状态描述从事务管理器PlatformTransactionManager中可以看出，spring完成事务管理还需2个关键元素：事务定义TransactionDefinition及事务状态TransactionStatus描述。 事务定义 1234567public interface TransactionDefinition &#123; int getPropagationBehavior(); //传播行为，默认PROPAGATION_REQUIRED int getIsolationLevel(); //隔离级别，默认数据库默认级别，如mysql为可重复读 int getTimeout(); boolean isReadOnly(); //是否只读，查询操作可以设置为true String getName();&#125; 事务状态 12345678public interface TransactionStatus extends SavepointManager &#123; boolean isNewTransaction(); //是否新事务 boolean hasSavepoint(); //是否有恢复点 void setRollbackOnly(); boolean isRollbackOnly(); void flush(); //Flush the underlying session to the datastore, if applicable: for example, all affected Hibernate/JPA sessions. boolean isCompleted();&#125; 什么是事务的传播行为​ Spring在TransactionDefinition接口中规定了7种类型的事务传播行为。事务传播行为是Spring框架独有的事务增强特性，他不属于的事务实际提供方数据库行为。这是Spring为我们提供的强大的工具箱，使用事务传播行可以为我们的开发工作提供许多便利。但是人们对他的误解也颇多，你一定也听过“service方法事务最好不要嵌套”的传言。要想正确的使用工具首先需要了解工具。 什么是事务传播行为？ 事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时事务如何传播。 事务的传播行为1）PROPAGATION_REQUIRED ​ 说明： 如果当前已经存在事务，那么加入该事务，如果不存在事务，创建一个事务，这是默认的传播属性值。 2）PROPAGATION_SUPPORTS ​ 说明: 如果当前已经存在事务，那么加入该事务，否则创建一个所谓的空事务（可以认为无事务执行）。 3) PROPAGATION_MANDATORY 说明：当前必须存在一个事务，否则抛出异常。 4)PROPAGATN_REQUIRES_NEW 说明：如果当前存在事务，先把当前事务相关内容封装到一个实体，然后重新创建一个新事务，接受这个实体为参数，用于事务的恢复。更直白的说法就是暂停当前事务(当前无事务则不需要)，创建一个新事务。 针对这种情况，两个事务没有依赖关系，可以实现新事务回滚了，但外部事务继续执行。 5)Propagation.NOT_SUPPORTED 说明：如果当前存在事务，挂起当前事务，然后新的方法在没有事务的环境中执行，没有spring事务的环境下，sql的提交完全依赖于 defaultAutoCommit属性值 。 6) PROPAGATION_NEVER 说明： 如果当前存在事务，则抛出异常，否则在无事务环境上执行代码。 7）PROPAGATION_NESTED 说明： 如果当前存在事务，则使用 SavePoint 技术把当前事务状态进行保存，然后底层共用一个连接，当NESTED内部出错的时候，自行回滚到 SavePoint这个状态，只要外部捕获到了异常，就可以继续进行外部的事务提交，而不会受到内嵌业务的干扰，但是，如果外部事务抛出了异常，整个大事务都会回滚。 ​ 注意： spring配置事务管理器要主动指定 nestedTransactionAllowed=true，如下所示： 12345&lt;bean id=&quot;dataTransactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataDataSource&quot; /&gt; &lt;property name=&quot;nestedTransactionAllowed&quot; value=&quot;true&quot; /&gt; &lt;/bean&gt; 例子： ​ 1234567891011121314151617@Transactionalpublic void service()&#123; serviceA(); try&#123; serviceB(); &#125;catch(Exception e)&#123; &#125;&#125;serviceA()&#123; do sql&#125;@Transactional(propagation=Propagation.NESTED)serviceB()&#123; do sql1 1/0; do sql2&#125; serviceB是一个内嵌的业务，内部抛出了运行时异常，所以serviceB整个被回滚了，由于service捕获了异常，所以serviceA是可以正常提交的。 12345678910111213@Transactionalpublic void service()&#123; serviceA(); serviceB(); 1/0;&#125;@Transactional(propagation=Propagation.NESTED)serviceA()&#123; do sql&#125;serviceB()&#123; do sql&#125; 由于service抛出了异常，所以会导致整个service方法被回滚。（这就是跟PROPAGATION_REQUIRES_NEW不一样的地方了，NESTED方式下的内嵌业务会受到外部事务的异常而回滚。） 实现原理浅析​ 前面举例说明了spring事务提供的几种传播属性，用于满足多种不同的业务需求，大家可以依业务而定。接着我们再来看看spring实现这些传播属性最重要的技术依赖是什么。本小节列举 PROPAGATION_REQUIRES_NEW 和 Propagation.NESTED 分别进行简要说明。 ​ 1、 PROPAGATION_REQUIRES_NEW 实现原理 123456789101112131415161718@Transactionalpublic void service()&#123; serviceB(); try&#123; serviceA(); &#125;catch(Exception e)&#123; &#125;&#125;@Transactional(propagation=Propagation.REQUIRES_NEW)serviceA()&#123; do sql 1 1/0; do sql 2&#125;serviceB()&#123; do sql&#125; ​ 执行原理图如下 ​ 12345678910111213before service,执行a和b​ 执行serviceB​ before serviceA, 执行c和d​ 执行serviceA​ 抛出异常​ after serviceA, 执行e​ after service,执行f a. 创建事务状态对象，获取一个新的连接，重置连接的 autoCommit，fetchSize，timeout等属性 b. 把连接绑定到ThreadLocal变量 c. 挂起当前事务，把当前事务状态对象，连接等信息封装成一SuspendedResources对象，可用于恢复 d. 创建新的事务状态对象，重新获取新的连接，重置新连接的 autoCommit，fetchSize，timeout等属性，同时，保存SuspendedResources对象，用于事务的恢复，把新的连接绑定到ThreadLocal变量（覆盖操作） e. 捕获到异常，回滚ThreadLocal中的连接，恢复连接参数，关闭连接，恢复SuspendedResources f. 提交ThreadLocal变量中的连接(导致serviceB被提交)，还原连接参数，关闭连接，连接归还数据源 所以程序执行的结果就是 serviceA被回滚了，serviceB成功提交了。 2、 PROPAGATION_NESTED 实现原理 1234567891011121314151617@Transactionalpublic void service()&#123; serviceA(); try&#123; serviceB(); &#125;catch(Exception e)&#123; &#125;&#125;serviceA()&#123; do sql&#125;@Transactional(propagation=Propagation.NESTED)serviceB()&#123; do sql1 1/0; do sql2&#125; 执行原理图如下： a. 创建事务状态对象，获取一个新的连接，重置连接的 autoCommit，fetchSize，timeout等属性 b. 把连接绑定到ThreadLocal变量 c. 标记使用当前事务状态对象，获取ThreadLocal连接对象，保存当前连接的SavePoint，用于异常恢复，此时的SavePoint就是执行完serviceA后的状态 d. 捕获到异常，使用c中的SavePoint进行事务回滚，也就是把状态回滚到执行serviceA后的状态，serviceB方法所有执行不生效 e. 获取ThreadLocal中的连接对象，提交事务，恢复连接属性，关闭连接 其他: ​ spring在底层数据源的基础上，利用 ThreadLocal，SavePoint等技术点实现了多种事务传播属性，便于实现各种复杂的业务。只有理解了传播属性的原理才能更好的驾驭spring事务。Spring回滚事务依赖于对异常的捕获，默认情况下，只有抛出RuntimeException和Error才会回滚事务，当然可以进行配置，更多信息可以查看 @Transactional 这个注解。 Spring事务的几个传播机制先假设A是大方法，B是小方法 ​ required，A没有事务时调用B方法（B的事务隔离级别是required），B就会开启自己单独的事务，B要回滚的话，也是回滚B。A有事务时，B就加入到A这个事务（B不开启自己的事务了），这里发生回滚的话，AB的事务就都被回滚了。 ​ new ， A没有事务时调用B方法（B的事务隔离级别是new），B就会开启自己单独的事务，B要回滚的话，也是回滚B。A有事务时，B还是会开启自己的事务，B事务发生回滚时，AB事务都会一起回滚，但是当执行了B事务时,A事务时挂起的，当执行完B事务且commit成功后，B事务结束，A事务恢复，若此时A事务发生回滚，那只是A事务回滚，不影响B事务的提交了。 ​ nested，A没有事务调用B方法时（B的事务隔离级别是nested），此时就相当于是required了。A有事务时，B事务也开启，但B事务此时是相当于A事务的嵌套子事务，B事务发生回滚时，会回到B事务开启执行时的savepoint（保存点），此时B事务已经结束了，然后继续从B事务开始时的保存点开始，继续A事务。如果期间B事务没回滚，那B事务的提交也是要和A事务一起提交，而且此时B事务没回滚执行完之后，但A事务出现回滚，AB事务就没法提交，那就都回滚了（这就是嵌套子事务的概念吧？） require回滚整个事务，nested回滚到创建回滚点的地方 参考：https://www.cnblogs.com/tartis/p/9232660.html ​ https://blog.csdn.net/f45056231p/article/details/83510291 ​ https://blog.csdn.net/chuangxin/article/details/80921704 只读事务的概念​ 从这一点设置的时间点开始（时间点a）到这个事务结束的过程中，其他事务所提交的数据，该事务将看不见！（查询中不会出现别人在时间点a之后提交的数据） 应用场合： ​ 如果你一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持SQL执行期间的读一致性；​ 如果你一次执行多条查询语句，例如统计查询，报表查询，在这种场景下，多条查询SQL必须保证整体的读一致性，否则，在前条SQL查询之后，后条SQL查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时，应该启用事务支持。【注意是一次执行多次查询来统计某些信息，这时为了保证数据整体的一致性，要用只读事务】 怎样设置： 对于只读查询，可以指定事务类型为readonly，即只读事务。由于只读事务不存在数据的修改，因此数据库将会为只读事务提供一些优化手段，例如Oracle对于只读事务，不启动回滚段，不记录回滚log。 （1）在JDBC中，指定只读事务的办法为： connection.setReadOnly(true); （2）在Hibernate中，指定只读事务的办法为： session.setFlushMode(FlushMode.NEVER);此时，Hibernate也会为只读事务提供Session方面的一些优化手段 （3）在Spring的Hibernate封装中，指定只读事务的办法为： bean配置文件中，prop属性增加“readOnly”或者用注解方式@Transactional(readOnly=true)【 if the transaction is marked as read-only, Spring will set the Hibernate Session’s flush mode to FLUSH_NEVER,and will set the JDBC transaction to read-only】也就是说在Spring中设置只读事务是利用上面两种方式 在将事务设置成只读后，相当于将数据库设置成只读数据库，此时若要进行写的操作，会出现错误 参考：https://blog.csdn.net/andyzhaojianhui/article/details/51984157","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"Transaction","slug":"Transaction","permalink":"http://yoursite.com/tags/Transaction/"}]},{"title":"Springmvc中的404","slug":"Spring/Springmvc中的404","date":"2020-03-26T07:45:59.000Z","updated":"2020-03-26T15:05:31.155Z","comments":true,"path":"2020/03/26/Spring/Springmvc中的404/","link":"","permalink":"http://yoursite.com/2020/03/26/Spring/Springmvc中的404/","excerpt":"","text":"关于404Springmvc中的基本流程SpringMVC从浏览器发送请求，到服务器响应数据，一共会经过哪些步骤： 浏览器发送请求到前端控制器 DispatherServlet 前端控制器将请求消息转发给处理器映射器 HandlerMapping 处理器映射器将请求消息中的路径根据其映射关系,找到需要执行的Controller方法信息,并返回给前端控制器返回途中经过拦截器(拦截器根据方法拦截,经处理器映射器处理后已确定需要执行的方法信息) 前端控制器将执行方法的映射信息发送给处理器适配器HandlerAdapter 处理器适配器根据方法信息,发送给处理器Handler,找到对应的Controller方法并执行 Handler执行完返回一个ModelAndView对象给处理器适配器 处理器适配器将ModelAndView对象返回给前端控制器 前端控制器将ModelAndView对象发送给视图解析器ViewResolver 视图解析器将ModelAndView对象解析,返回一个View对象给前端控制器 前端控制器将Model中的数据填充到View中,得到一个具体的页面 前端控制器将页面视图响应给浏览器 springmvc的404 1）如 404 等是通过 Servlet (DispatcherServlet.noHandlerFound) 的处理并返回 response ( response.sendError) ，并未到达 Controller 层，所以并不能捕获到。 2）如果是用户请求了一个不存在的页面，没有对应的@RequestMapping，此时Spring的DispatcherServlet就会处理掉返回404，不会进入任何一个controller 3）还有比如spring security之类的权限管理模块，如果用户的密码正确，但是该账户的权限组没有权限访问当前页面，此时权限模块会有自己的AccessDeniedHandler处理，也不会进入配置的@ControllerAdvice 如果采用spring boot 或者AppInitializer来配置，需要在AppInitializer的实现类中重写createDispatcherServlet方法： 1）设置抛出NoHandlerFoundException异常 1234567@Override protected DispatcherServlet createDispatcherServlet(WebApplicationContext servletAppContext) &#123; final DispatcherServlet dispatcherServlet = (DispatcherServlet) super.createDispatcherServlet(servletAppContext); //设置抛出NoHandlerFoundException异常 dispatcherServlet.setThrowExceptionIfNoHandlerFound(true); return dispatcherServlet; &#125; 2）同时在@ControllerAdvice中添加方法： 12345@ExceptionHandler public ResponseEntity&lt;String&gt; handleResourceNotFoundException(NoHandlerFoundException nhre) &#123; logger.error(nhre.getMessage(), nhre); return new ResponseEntity&lt;String&gt;(&quot;Not Found&quot;, HttpStatus.NOT_FOUND); &#125; 我们可以配置Spring在没有对应的@RequestMapping时，不要自行处理，让他抛出一个NoHandlerFoundException的异常，从而让我们配置的@ControllerAdvice进行统一处理 如果是xml风格的配置，可以在DispatcherServlet对应的配置文件中配置 如果是之前介绍的class风格的配置，可以这样配置： 1dispatcherServlet.setThrowExceptionIfNoHandlerFound(true);//for NoHandlerFoundException 实现方式1： 1234567891011121314&lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!-- 设置抛出NoHandlerFound异常，即404--&gt; &lt;param-name&gt;throwExceptionIfNoHandlerFound&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; 参考: https://www.cnblogs.com/yangchongxing/p/9271900.html","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Springmvc视图解析与渲染","slug":"Spring/springmvc视图解析与渲染","date":"2020-03-26T07:45:59.000Z","updated":"2020-04-05T07:50:44.433Z","comments":true,"path":"2020/03/26/Spring/springmvc视图解析与渲染/","link":"","permalink":"http://yoursite.com/2020/03/26/Spring/springmvc视图解析与渲染/","excerpt":"","text":"springmvc视图解析与渲染springmvc处理步骤具体步骤： 第一步：发起请求到前端控制器(DispatcherServlet) 第二步：前端控制器请求HandlerMapping查找 Handler （可以根据xml配置、注解进行查找） 第三步：处理器映射器HandlerMapping向前端控制器返回Handler，HandlerMapping会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象，多个HandlerInterceptor拦截器对象），通过这种策略模式，很容易添加新的映射策略 第四步：前端控制器调用处理器适配器去执行Handler 第五步：处理器适配器HandlerAdapter将会根据适配的结果去执行Handler 第六步：Handler执行完成给适配器返回ModelAndView 第七步：处理器适配器向前端控制器返回ModelAndView （ModelAndView是springmvc框架的一个底层对象，包括 Model和view） 第八步：前端控制器请求视图解析器去进行视图解析 （根据逻辑视图名解析成真正的视图(jsp)），通过这种策略很容易更换其他视图技术，只需要更改视图解析器即可 第九步：视图解析器向前端控制器返回View 第十步：前端控制器进行视图渲染 （视图渲染将模型数据(在ModelAndView对象中)填充到request域） 第十一步：前端控制器向用户响应结果 视图解析与渲染(render方法)org.springframework.web.servlet.DispatcherServlet#doDispatch方法中 12mv = ha.handle(processedRequest, response, mappedHandler.getHandler());//945行返回了 ModelAndView 对象processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);// 959行进行的就是返回值处理问题 org.springframework.web.servlet.DispatcherServlet#processDispatchResult方法中 1render(mv, request, response); //1012进行视图的渲染（包含视图解析） org.springframework.web.servlet.DispatcherServlet#render 方法 12345678910111213141516171819202122232425262728293031323334353637383940414243protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; // Determine locale for request and apply it to the response. Locale locale = (this.localeResolver != null ? this.localeResolver.resolveLocale(request) : request.getLocale()); response.setLocale(locale); View view; String viewName = mv.getViewName(); if (viewName != null) &#123; // We need to resolve the view name. view = resolveViewName(viewName, mv.getModelInternal(), locale, request); if (view == null) &#123; throw new ServletException(&quot;Could not resolve view with name &apos;&quot; + mv.getViewName() + &quot;&apos; in servlet with name &apos;&quot; + getServletName() + &quot;&apos;&quot;); &#125; &#125; else &#123; // No need to lookup: the ModelAndView object contains the actual View object. view = mv.getView(); if (view == null) &#123; throw new ServletException(&quot;ModelAndView [&quot; + mv + &quot;] neither contains a view name nor a &quot; + &quot;View object in servlet with name &apos;&quot; + getServletName() + &quot;&apos;&quot;); &#125; &#125; // Delegate to the View object for rendering. if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Rendering view [&quot; + view + &quot;] in DispatcherServlet with name &apos;&quot; + getServletName() + &quot;&apos;&quot;); &#125; try &#123; if (mv.getStatus() != null) &#123; response.setStatus(mv.getStatus().value()); &#125; view.render(mv.getModelInternal(), request, response); &#125; catch (Exception ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Error rendering view [&quot; + view + &quot;] in DispatcherServlet with name &apos;&quot; + getServletName() + &quot;&apos;&quot;, ex); &#125; throw ex; &#125; &#125; view = resolveViewName(viewName, mv.getModelInternal(), locale, request);视图解析，返回视图view view.render(mv.getModelInternal(), request, response); 视图渲染 视图解析：通过视图解析器进行视图的解析1.解析一个视图名到一个视图对象，具体解析的过程是：在容器中查找所有配置好的视图解析器（List类型），然后进行遍历， 只要有一个视图解析器能解析出视图就返回 View 对象，若遍历完成后都不能解析出视图，那么返回 null。 具体来看： org.springframework.web.servlet.DispatcherServlet#resolveViewName 12345678910111213protected View resolveViewName(String viewName, @Nullable Map&lt;String, Object&gt; model, Locale locale, HttpServletRequest request) throws Exception &#123; if (this.viewResolvers != null) &#123; for (ViewResolver viewResolver : this.viewResolvers) &#123; View view = viewResolver.resolveViewName(viewName, locale); if (view != null) &#123; return view; &#125; &#125; &#125; return null; &#125; 解析一个视图名到一个视图对象，具体解析的过程是：在容器中查找所有配置好的视图解析器（List类型），然后进行遍历，只要有一个视图解析器能解析出视图就返回 View 对象，若遍历完成后都不能解析出视图，那么返回 null。 创建视图，以 InternalResourceViewResolver为例，继承UrlBasedViewResolver org.springframework.web.servlet.view.UrlBasedViewResolver#createView 12345678910111213141516171819202122232425@Override protected View createView(String viewName, Locale locale) throws Exception &#123; // If this resolver is not supposed to handle the given view, // return null to pass on to the next resolver in the chain. if (!canHandle(viewName, locale)) &#123; return null; &#125; // Check for special &quot;redirect:&quot; prefix. if (viewName.startsWith(REDIRECT_URL_PREFIX)) &#123; String redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length()); RedirectView view = new RedirectView(redirectUrl, isRedirectContextRelative(), isRedirectHttp10Compatible()); String[] hosts = getRedirectHosts(); if (hosts != null) &#123; view.setHosts(hosts); &#125; return applyLifecycleMethods(viewName, view); &#125; // Check for special &quot;forward:&quot; prefix. if (viewName.startsWith(FORWARD_URL_PREFIX)) &#123; String forwardUrl = viewName.substring(FORWARD_URL_PREFIX.length()); return new InternalResourceView(forwardUrl); &#125; // Else fall back to superclass implementation: calling loadView. return super.createView(viewName, locale); &#125; 在创建视图前会检查返回值是否是以：”redirect:” 或 “forward:” 开头的。 如果是重定向：则创建一个重定向视图，返回创建的视图。如果是转发：则返回通过 转发 url 创建的 InternalResourceView 视图。 super.createView(viewName, locale),调用父类创建视图 org.springframework.web.servlet.view.UrlBasedViewResolver#loadView 123protected View createView(String viewName, Locale locale) throws Exception &#123; return loadView(viewName, locale);&#125; 调用具体的 InternalResourceViewResolver ，然后又调用 父类的 buildView() 方法 org.springframework.web.servlet.view.UrlBasedViewResolver#buildView 123456789101112131415161718192021222324252627282930protected AbstractUrlBasedView buildView(String viewName) throws Exception &#123; Class&lt;?&gt; viewClass = getViewClass(); Assert.state(viewClass != null, &quot;No view class&quot;); AbstractUrlBasedView view = (AbstractUrlBasedView) BeanUtils.instantiateClass(viewClass); view.setUrl(getPrefix() + viewName + getSuffix()); String contentType = getContentType(); if (contentType != null) &#123; view.setContentType(contentType); &#125; view.setRequestContextAttribute(getRequestContextAttribute()); view.setAttributesMap(getAttributesMap()); Boolean exposePathVariables = getExposePathVariables(); if (exposePathVariables != null) &#123; view.setExposePathVariables(exposePathVariables); &#125; Boolean exposeContextBeansAsAttributes = getExposeContextBeansAsAttributes(); if (exposeContextBeansAsAttributes != null) &#123; view.setExposeContextBeansAsAttributes(exposeContextBeansAsAttributes); &#125; String[] exposedContextBeanNames = getExposedContextBeanNames(); if (exposedContextBeanNames != null) &#123; view.setExposedContextBeanNames(exposedContextBeanNames); &#125; return view; &#125; 可以看出：是通过 BeanUtils.instantiateClass(getViewClass()) 来创建 View 对象的。这个例子与其说是 InternalResourceViewResolver ，倒不如说是 UrlBasedViewResolver 类型的例子。 从这里也可以看出：该类型最终要到的目标URL为：getPrefix() + viewName + getSuffix() 视图渲染View接口官方文档： 1`* MVC View for a web interaction. Implementations are responsible for rendering* content, and exposing the model. A single view exposes multiple model attributes.** &lt;p&gt;This class and the MVC approach associated with it is discussed in Chapter 12 of* &lt;a href=&quot;http://www.amazon.com/exec/obidos/tg/detail/-/0764543857/&quot;&gt;Expert One-On-One J2EE Design and Development&lt;/a&gt;* by Rod Johnson (Wrox, 2002).** &lt;p&gt;View implementations may differ widely. An obvious implementation would be* JSP-based. Other implementations might be XSLT-based, or use an HTML generation library.* This interface is designed to avoid restricting the range of possible implementations.** &lt;p&gt;Views should be beans. They are likely to be instantiated as beans by a ViewResolver.* As this interface is stateless, view implementations should be thread-safe.` 说明： SpringMVC 对一个 web 来说是相互作用的（不太明白）。View 的实现类是负责呈现内容的，并且 exposes（暴露、揭露、揭发的意思，这里就按暴露解释吧，想不出合适的词语） 模型的。 一个单一的视图可以包含多个模型。 View 的实现可能有很大的不同。一个明显的实现是基于 JSP 的。其他的实现可能是基于 XSLT 的，或者是一个 HTML 生成库。 设计这个接口是为了避免约束可能实现的范围（这里是不是说，我们可以通过实现该接口来自定义扩展自定义视图？）。 所有的视图都应该是一个 Bean 类。他们可能被 ViewResolver 当做一个 bean 进行实例化。 由于这个接口是无状态的，View 的所有实现类应该是线程安全的。 View接口的实现类IDEA中crtl+H可查看View接口所有的实现类 具体渲染的一个过程​ 举例：View类型为JstlView 继承关系： public class JstlView extends InternalResourceView ​ public class InternalResourceView extends AbstractUrlBasedView ​ public abstract class AbstractUrlBasedView extends AbstractView implements InitializingBean ​ public abstract class AbstractView extends WebApplicationObjectSupport implements View, BeanNameAware 通过org.springframework.web.servlet.DispatcherServlet#render 方法中的渲染view.render(mv.getModelInternal(), request, response); 进入到org.springframework.web.servlet.view.AbstractView#render 12345678910111213@Override public void render(@Nullable Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Rendering view with name &apos;&quot; + this.beanName + &quot;&apos; with model &quot; + model + &quot; and static attributes &quot; + this.staticAttributes); &#125; Map&lt;String, Object&gt; mergedModel = createMergedOutputModel(model, request, response); prepareResponse(request, response); renderMergedOutputModel(mergedModel, getRequestToExpose(request), response); &#125; renderMergedOutputModel(mergedModel, getRequestToExpose(request), response); 这里只看 org.springframework.web.servlet.view.InternalResourceView#renderMergedOutputModel 这个方法 renderMergedOutputModel（渲染合并输出模型） 12345678910111213141516171819202122232425262728293031323334353637@Override protected void renderMergedOutputModel( Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; // Expose the model object as request attributes. exposeModelAsRequestAttributes(model, request); // Expose helpers as request attributes, if any. exposeHelpers(request); // Determine the path for the request dispatcher. String dispatcherPath = prepareForRendering(request, response); // Obtain a RequestDispatcher for the target resource (typically a JSP). RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath); if (rd == null) &#123; throw new ServletException(&quot;Could not get RequestDispatcher for [&quot; + getUrl() + &quot;]: Check that the corresponding file exists within your web application archive!&quot;); &#125; // If already included or response already committed, perform include, else forward. if (useInclude(request, response)) &#123; response.setContentType(getContentType()); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Including resource [&quot; + getUrl() + &quot;] in InternalResourceView &apos;&quot; + getBeanName() + &quot;&apos;&quot;); &#125; rd.include(request, response); &#125; else &#123; // Note: The forwarded resource is supposed to determine the content type itself. if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Forwarding to resource [&quot; + getUrl() + &quot;] in InternalResourceView &apos;&quot; + getBeanName() + &quot;&apos;&quot;); &#125; rd.forward(request, response); &#125; &#125; RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath);//创建RequestDispatcher rd.forward(request, response); //转发请求 可以看到前面的几个步骤都是为 RequestDispatch 做准备，装填数据。最后，到目标页面是通过转发。 DispatcherServlet做最后处理DispatcherServlet继承FrameworkServlet FrameworkServlet重写service()方法,(也重写了doGet,doPost方法等） 123456789101112@Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; HttpMethod httpMethod = HttpMethod.resolve(request.getMethod()); if (HttpMethod.PATCH == httpMethod || httpMethod == null) &#123; processRequest(request, response); &#125; else &#123; super.service(request, response); &#125; &#125; 1）service()方法或者super.service()方法，以及super.service()方法调用的doGet(),doPost()等等都调用processRequest()方法 2）processRequest()方法，processRequest()调用doService()方法 3）doService()调用doDispatch(request, response)， 4）doDispatch(request, response)调用processDispatchResult()， 5）processDispatchResult方法调用render()方法，虽然在render()方法中请求已经转发，但是后面还做了一些异常处理等 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Handle the result of handler selection and handler invocation, which is * either a ModelAndView or an Exception to be resolved to a ModelAndView. */ private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception &#123; boolean errorView = false; if (exception != null) &#123; if (exception instanceof ModelAndViewDefiningException) &#123; logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception); mv = ((ModelAndViewDefiningException) exception).getModelAndView(); &#125; else &#123; Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null); mv = processHandlerException(request, response, handler, exception); errorView = (mv != null); &#125; &#125; // Did the handler return a view to render? if (mv != null &amp;&amp; !mv.wasCleared()) &#123; render(mv, request, response); if (errorView) &#123; WebUtils.clearErrorRequestAttributes(request); &#125; &#125; else &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Null ModelAndView returned to DispatcherServlet with name &apos;&quot; + getServletName() + &quot;&apos;: assuming HandlerAdapter completed request handling&quot;); &#125; &#125; if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; // Concurrent handling started during a forward return; &#125; if (mappedHandler != null) &#123; mappedHandler.triggerAfterCompletion(request, response, null); &#125; &#125; 总结介绍了 SpringMVC 视图解析和视图渲染问题是如何解决的。SpringMVC 为逻辑视图提供了多种视图解析策略，可以在配置文件中配置多个视图的解析策略。并制定其先后顺序。 这里所说的视图解析策略，就是指视图解析器。视图解析器会将逻辑视图名解析为一个具体的视图对象。再说视图渲染的过程，视图对模型进行了渲染，最终将模型的数据以某种形式呈现给用户。 参考：https://www.cnblogs.com/solverpeng/p/5743609.html","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"jsp中使用基路径","slug":"Java Web/jsp使用基路径","date":"2020-03-25T07:20:03.000Z","updated":"2020-03-25T07:07:17.603Z","comments":true,"path":"2020/03/25/Java Web/jsp使用基路径/","link":"","permalink":"http://yoursite.com/2020/03/25/Java Web/jsp使用基路径/","excerpt":"","text":"基路径的使用问题在jsp中使用基路径base href123456789101112131415&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" isELIgnored=\"false\" %&gt;&lt;% String path = request.getContextPath();//项目的发布路径，例如: /rabc String basePath = request.getScheme()+\"://\"+request.getServerName()+\":\"+request.getServerPort()+path+\"/\";%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;base href=\"&lt;%=basePath%&gt;\"&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;欢迎使用路人丁OA&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"test\"&gt;测试&lt;/a&gt;&lt;/body&gt; a标签中的路径 href=”test” 则访问 http://localhost:8080/动态获取项目名/test ​ 推荐使用 a标签中的路径 href=”/test” 则访问 http://localhost:8080/test 不使用base href一a标签中的路径 href=”test” 则访问 当前路径的相对路径 ​ 例如当前路径 http://localhost:8080/项目名/duty/duty.html ​ 则访问 http://localhost:8080/项目名/duty/test 因此该种方式不推荐使用 二a标签中的路径 href=”/test” 则访问 http://localhost:8080/test 在项目直接部署在根路径下可以使用，即不使用项目名","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/tags/jsp/"}]},{"title":"jsp中的标签库","slug":"Java Web/jsp的标签库","date":"2020-03-20T08:20:03.000Z","updated":"2020-03-20T10:11:20.685Z","comments":true,"path":"2020/03/20/Java Web/jsp的标签库/","link":"","permalink":"http://yoursite.com/2020/03/20/Java Web/jsp的标签库/","excerpt":"","text":"JSP中的标签库标签库运行原理​ JSP标签的定义步骤： ​ 1 创建标记处理类( 处理标签的类必须扩展javax.servlet.jsp.TagSupport 或 BodyTagSupport) ​ 2 创建TLD文件 ​ 3 在jsp页面通过指令引入标签库 自定义标签库​ 创建标记处理类: 12345678910111213141516171819package test; import javax.servlet.jsp.JspException; import javax.servlet.jsp.JspWriter; import javax.servlet.jsp.tagext.TagSupport; public class OutputTag extends TagSupport &#123; private String name=null; public void setName(String name) &#123; this.name = name; &#125; public int doEndTag() throws JspException &#123; try &#123; JspWriter out = pageContext.getOut(); out.print(&quot;Hello! &quot; + name); &#125; catch (Exception e) &#123; throw new JspException(e); &#125; return EVAL_PAGE; &#125; &#125; 1 如何输出到jsp页面：调用JspWriter JspWriter out = pageContext.getOut();out.print……记住这个方法就可以了。2 输出后如何作处理，函数会返回几个值之一。EVAL_PAGE 表示tag已处理完毕，返回jsp页面。还有几个值，例如 EVAL_BODY_AGAIN 和EVAL_BODY_INCLUDE等 跟流程控制有关. Tag系列的Interface里定义的静态int,通过他们也能一窥tag组键的执行流程,这几个静态值分别是：SKIP_BODY ： 跳过了开始和结束标签之间的代码,一般是在doStartTag中使用EVAL_BODY_INCLUDE ：处理嵌套的标签,一般是在doStartTag中使用,由负责处理标签正文的tag接口提供EVAL_BODY_BUFFERED :对包含的内容进行解析 一般是在doStartTag中使用,由负责处理标签正文的bodyTag接口提供,目的是通知jsp容器作好读取正文的工作(创建一个body-content包装正文和获取存放操作结果的out对象,便于以后的操作和输出).EVAL_BODY_AGAIN:处理标签正文,嵌套标签的iteratorTag接口的使用SKIP_PAGE ： 忽略剩下的页面,一般是在doEndTag中使用EVAL_PAGE ： 继续执行下面的页, 一般是在doEndTag中使用 编写tld 文件 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot; ?&gt; &lt;!DOCTYPE taglib PUBLIC &quot;-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.2//EN&quot; &quot;http://java.sun.com/dtd/web-jsptaglibrary_1_2.dtd&quot;&gt; &lt;taglib&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;jsp-version&gt;1.2&lt;/jsp-version&gt; &lt;short-name&gt;test&lt;/short-name&gt; &lt;!--OutputTag--&gt; &lt;tag&gt; &lt;name&gt;out&lt;/name&gt; &lt;!-- 全限定路径 --&gt;&lt;tag-class&gt;test.OutputTag&lt;/tag-class&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;attribute&gt; &lt;name&gt;name&lt;/name&gt; &lt;required&gt;false&lt;/required&gt; &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;/tag&gt; &lt;/taglib&gt; 在WEB-INF下新建tlds文件夹，把这个文件取名为test.tld，放到tlds文件夹下。引用时的路径应该这样：WEB-INF\\tlds\\test.tld 关于tld的简单说明：short-name：taglib的名称，也称为前缀。比如“c:out value=””/” 里的“c”name：tag的名字。例如“c:out value=””/” 里的”out”，我们的类也取名为out，由于有前缀作区分，不会同其他库的 同名tag组件混淆tag-class：完整的tag组件路径,记着带包名body-content：指tag之间的内容。例如c:out value=”” …… /c 起始和关闭标签之间就是body-content。由于没有处理body-content ，所以上面设为empty,如果是嵌套标签,或则是要在服务器端处理标签体的话,就是jsp了“attribute”里的name：属性名字。例如c:out value=””/里的value。名字可任意取，只要类里提供相应的set方法即 可。required：是否必填属性。rtexprvalue：是否支持运行时表达式取值就是是否可以&lt;%=%&gt;或则是${}方式传值。这是tag的强大功能。 编写jsp 1234567&lt;%@ page language=&quot;java&quot;%&gt; &lt;%@ taglib uri=&quot;/WEB-INF/tlds/test.tld&quot; prefix=&quot;test&quot;%&gt; &lt;html&gt; &lt;body&gt; Test Tag: &lt;test:out name=&quot;TEST&quot;/&gt; &lt;/body&gt; &lt;/html&gt; 标签库的uri路径引入​ 在JSP中使用标签是很平常的事情，在制作自定义标签时，通常都需要写tld文件来定义标签的各种属性，对应的java类，前缀等等。标签与tld文件紧紧相连，那么，到底应该怎么放置tld文件？在web.xml中怎么定义tld文件的位置？ ​ Web容器(jsp引擎)遇到类似【&lt;c:import】这样的标签时，会通过prefix定位到uri，再根据uri定位到相应的tld文件，对tld文件进行解析。其中uri ——–tld文件的映射关系如下： ​ Key （Uri） Value（String[] taglib_tld_location） ​ /jstl-examples-taglib、 taglib_tld_location[0] + taglib_tld_location[1] http://java.sun.com/jstl/core Tld文件路径定义方式 ​ 如下方式1和方式2只能在2.3版本使用，Servlet2.4开始便不能在web.xml中定义taglib了。 ​ &lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; ​ “http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt; l 方式1： ​ 如下所示，在web.xml中定义 1234 &lt;taglib&gt; &lt;taglib-uri&gt;/jstl-examples-taglib&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/lib/jstl-examples.tld&lt;/taglib-location&gt;&lt;/taglib&gt; 如果这样定义的话，映射关系便如下： /jstl-examples-taglib —————-{“/WEB-INF/lib/jstl-examples.tld”,””} // taglib_tld_location[0]就足以表示tld路径，因此taglib_tld_location[1]为空。 ​ 方式二: ​ 如下所示，在web.xml中定义 1234 &lt;taglib&gt; &lt;taglib-uri&gt;/jstl-examples-taglib&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/lib/jstl-examples.jar&lt;/taglib-location&gt;&lt;/taglib&gt; 如果这样定义的话，映射关系便如下： /jstl-examples-taglib ———– {“/WEB-INF/lib/ jstl-examples.jar”,” META-INF/taglib.tld”} // taglib_tld_location[0]表示jar路径，taglib_tld_location[1]固定为META-INF/taglib.tld(也就是说，tld在jar文件中的保存路径必须是META-INF/taglib.tld，名称必须是taglib.tld)。这就是说一个jar里只能有一个tld。如果代码中不固定为taglib.tld的话，也很难处理，因为如果tld的名称可以随便定义的话，出现多个tld在jar文件中时将会导致混乱。 方式三： 不需要在web.xml中定义，只需要把tld保存在web应用能够使用的jar文件中的META-INF路径下便可。这种情况的机制是这样的：web容器会遍历当前web应用能够访问的jar文件，从jar文件中查找META-INF/xxx.tld文件，当找到一个tld文件之后，便会解析tld文件，取出节点的值，把uri作为key值生成映射关系。 如下所示的jstl的core标签库的tld文件，便会有如下的映射关系 http://java.sun.com/jstl/core ——–{“tld文件所在的jar文件的路径”,” META-INF/xxx.tld”} //taglib_tld_location[0]表示jar路径，taglib_tld_location[1]为所搜到的tld在jar文件中的相对路径 例：这是jstl.jar中的META-INF/c.tld文件的部分 12345678910111213141516171819202122232425262728293031323334&lt;description&gt;JSTL 1.1 core library&lt;/description&gt; &lt;display-name&gt;JSTL core&lt;/display-name&gt; &lt;tlib-version&gt;1.1&lt;/tlib-version&gt; &lt;short-name&gt;c&lt;/short-name&gt; &lt;uri&gt;http://java.sun.com/jsp/jstl/core&lt;/uri&gt; &lt;validator&gt; &lt;description&gt; Provides core validation features for JSTL tags. &lt;/description&gt; &lt;validator-class&gt; org.apache.taglibs.standard.tlv.JstlCoreTLV &lt;/validator-class&gt; &lt;/validator&gt; &lt;tag&gt; &lt;description&gt; Catches any Throwable that occurs in its body and optionally exposes it. &lt;/description&gt; &lt;name&gt;catch&lt;/name&gt; &lt;tag-class&gt;org.apache.taglibs.standard.tag.common.core.CatchTag&lt;/tag-class&gt; &lt;body-content&gt;JSP&lt;/body-content&gt; &lt;attribute&gt; &lt;description&gt;Name of the exported scoped variable for theexception thrown from a nested action. The type of thescoped variable is the type of the exception thrown. &lt;/description&gt; &lt;name&gt;var&lt;/name&gt; &lt;required&gt;false&lt;/required&gt; &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;/tag&gt; Tld文件的解析逻辑 以jstl为例： Web容器遇到类似【&lt;c:import】标签时，就会通过在头部中定义的&lt;%@ taglib prefix=”c” uri=”http://java.sun.com/jstl/core&quot; %&gt;找到uri，再根据此uri便可以定位到taglib_tld_location。当taglib_tld_location[0]不是jar文件时，便直接使用java的FileInputStream读取tld文件；当taglib_tld_location[0]是jar文件时，则会 通过如下代码读取tld文件。 URL jarFileUrl = new URL(“jar:” + location[0] + “!/“); ZipEntry jarEntry = jarFile.getEntry(location[1]); 总结: ​ tld的定义可以不在web.xml中定义，这时需要保证tld在web应用能够访问的jar中，并且保存在jar的META-INF目录下。此时JSP直接使用tld中定义的\\&lt;uri>便可； 如果在web.xml中定义tld的路径的话，可以直接指定tld文件路径，此时要保证tld不在jar包中(比如在WEB-INF目录下)；也可以指定为jar文件路径，此时要保证tld在jar中且路径为META-INF/taglib.tld。 在web.xml中定义的uri优先级要高于tld文件中定义的优先级。 补充​ jsp中使用JSTL，需要哪些jar包? ​ jstl.jar和standard.jar ​ standard.jar是JSP标准标签库，和jstl.jar 1.0版本中一起使用， ​ 但在jstl-1.2.jar就不再需要了 参考: JSP标签在tomcat中的运行原理 https://www.iteye.com/blog/jianfulove-1826982 ​ jsp自定义标签(taglib)编写的原理和实现 https://blog.csdn.net/zhangdaiscott/article/details/8622975 ​ 如何引用自定义标签库中的tld文件 http://blog.sina.com.cn/s/blog_7ffe993c01019ebe.html","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/tags/jsp/"}]},{"title":"mybatis中xml映射和方法注解两种配置sql语句的方式是否可以同时存在","slug":"DataBase/MyBatis/mybatis中xml映射和方法注解两种配置sql语句的方式是否可以同时存在","date":"2019-12-12T03:07:30.000Z","updated":"2019-12-12T03:12:41.363Z","comments":true,"path":"2019/12/12/DataBase/MyBatis/mybatis中xml映射和方法注解两种配置sql语句的方式是否可以同时存在/","link":"","permalink":"http://yoursite.com/2019/12/12/DataBase/MyBatis/mybatis中xml映射和方法注解两种配置sql语句的方式是否可以同时存在/","excerpt":"","text":"mybatis中xml映射和方法注解两种配置sql语句的方式是否可以同时存在​ 不能进行同时设置。执行会找不到接口的mapper代理工厂。mybatis会先解析xml文件，将解析后的sql封装在mapperstament中并放进Configuration的mappedStatements中，将命名空间和方法名（也就是id）作为key，mappedStatements是个自定义map。然后生成接口的代理工程，生产代理工厂后会解析注解，解析完注解，也会生成mapperstament，也会往统一的Configuration大对象里面放，但是放的时候自定义map会先判断是否存在，此时已经存在了，存在就会抛出IllegalArgumentException(name + “ already contains value for “ + key）。但是创建代理工厂的时候把异常吃掉了，所以加载的时候不会报错，但是不会给接口生成代理工厂。没有代理工厂，接口就没有实现类去操作。","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"}]},{"title":"Spring中的事件处理","slug":"Spring/Spring中的事件处理","date":"2019-09-04T07:45:59.000Z","updated":"2019-09-04T08:21:06.028Z","comments":true,"path":"2019/09/04/Spring/Spring中的事件处理/","link":"","permalink":"http://yoursite.com/2019/09/04/Spring/Spring中的事件处理/","excerpt":"","text":"Spring中的事件处理Spring 的核心是 ApplicationContext，它负责管理 beans 的完整生命周期。当加载 beans 时，ApplicationContext 发布某些类型的事件。例如，当上下文启动时，ContextStartedEvent 发布，当上下文停止ContextStoppedEvent发布。 通过 ApplicationEvent 类和 ApplicationListener 接口来提供在 ApplicationContext 中处理事件。如果一个 bean 实现 ApplicationListener，那么每次 ApplicationEvent 被发布到 ApplicationContext 上，那个 bean 会被通知。 Spring 提供了以下的标准事件： 序号 Spring 内置事件 &amp; 描述 1 ContextRefreshedEvent*ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在 ConfigurableApplicationContext*接口中使用 refresh() 方法来发生。 2 ContextStartedEvent当使用 ConfigurableApplicationContext 接口中的 start() 方法启动 ApplicationContext 时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。 3 ContextStoppedEvent当使用 ConfigurableApplicationContext 接口中的 stop() 方法停止 ApplicationContext 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作。 4 ContextClosedEvent当使用 ConfigurableApplicationContext 接口中的 close() 方法关闭 ApplicationContext 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启。 5 RequestHandledEvent这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务。 由于 Spring 的事件处理是单线程的，所以如果一个事件被发布，直至并且除非所有的接收者得到的该消息，该进程被阻塞并且流程将不会继续。因此，如果事件处理被使用，在设计应用程序时应注意。 监听上下文事件为了监听上下文事件，一个 bean 应该实现只有一个方法 onApplicationEvent() 的 ApplicationListener 接口。因此，我们写一个例子来看看事件是如何传播的，以及如何可以用代码来执行基于某些事件所需的任务。 让我们在恰当的位置使用 Eclipse IDE，然后按照下面的步骤来创建一个 Spring 应用程序： 步骤 描述 1 创建一个名称为 SpringEventTest 的项目，并且在创建项目的 src 文件夹中创建一个包com.szxy 2 使用 Add External JARs 选项，添加所需的 Spring 库 3 在 com.szxy包中创建 Java 类 HelloSpringEvent、CStartEventHandler、CStopEventHandler* 和 Start 4 在 src 文件夹中创建 Bean 的配置文件 applicationContext.xml.xml 5 最后一步是创建的所有 Java 文件和 Bean 配置文件的内容，并运行应用程序，解释如下所示. 这里是 HelloSpringEvent.java 文件的内容： 12345678910111213141516171819package com.szxy;public class HelloSpringEvent &#123; private String msg; public HelloSpringEvent()&#123; System.out.println(&quot;HelloSpringEvent 初始化&quot;); &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; &#125; 下面是 CStartEventHandler.java 文件的内容： 1234567891011121314151617181920package com.szxy;import org.springframework.context.ApplicationListener;import org.springframework.context.event.ContextStartedEvent;/** * ContextStartedEvent: * 当使用 ConfigurableApplicationContext 接口中的 start()方法启动 ApplicationContext时, * 该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。 * @author Administrator * */public class CStartEventHandler implements ApplicationListener&lt;ContextStartedEvent&gt;&#123; @Override public void onApplicationEvent(ContextStartedEvent event) &#123; System.out.println(&quot;ContextStartedEvent start!!&quot;); &#125;&#125; 下面是 CStopEventHandler.java 文件的内容： 1234567891011121314151617181920package com.szxy;import org.springframework.context.ApplicationListener;import org.springframework.context.event.ContextStoppedEvent;/** * ContextStoppedEvent: * 当使用 ConfigurableApplicationContext 接口中的 stop() 方法停止 ApplicationContext 时， * 发布这个事件。你可以在接受到这个事件后做必要的清理的工作。 * @author Administrator * */public class CStopEventHandler implements ApplicationListener&lt;ContextStoppedEvent&gt;&#123; @Override public void onApplicationEvent(ContextStoppedEvent event) &#123; System.out.println(&quot;ContextStoppedEvent stop!!&quot;); &#125;&#125; 下面是 Start.java 文件的内容： 1234567891011121314151617181920package com.szxy;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Start &#123; public static void main(String[] args) &#123; //加载spring配置文件,初始化所有的bean ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;); //启动spring容器 ac.start(); HelloSpringEvent hello = ac.getBean(&quot;helloSpringEvent&quot;, HelloSpringEvent.class); System.out.println(hello.getMsg()); //停止spring容器 ac.stop(); &#125;&#125; 下面是配置文件 applicationContext.xml 文件： 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;helloSpringEvent&quot; class=&quot;com.szxy.HelloSpringEvent&quot;&gt; &lt;property name=&quot;msg&quot;&gt; &lt;value&gt;Test SpringEvent!!&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;cStartEventHandler&quot; class=&quot;com.szxy.CStartEventHandler&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;cStopEventHandler&quot; class=&quot;com.szxy.CStopEventHandler&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 一旦你完成了创建源和 bean 的配置文件，我们就可以运行该应用程序。如果你的应用程序一切都正常，将输出以下消息： 1234HelloSpringEvent 初始化ContextStartedEvent start!!Test SpringEvent!!ContextStoppedEvent stop!! 注意： ​ 由于 Spring 的事件处理是单线程的，所以如果一个事件被发布，直至并且除非所有的接收者得到的该消息，该进程被阻塞并且流程将不会继续。因此，如果事件处理被使用，在设计应用程序时应注意。 例如： ​ CStartEventHandler类的监听函数处理中加入一个阻塞调用System.in.read(); 12345678910111213141516171819202122232425262728package com.szxy;import java.io.IOException;import org.springframework.context.ApplicationListener;import org.springframework.context.event.ContextStartedEvent;/** * ContextStartedEvent: * 当使用 ConfigurableApplicationContext 接口中的 start()方法启动 ApplicationContext时, * 该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。 * @author Administrator * */public class CStartEventHandler implements ApplicationListener&lt;ContextStartedEvent&gt;&#123; @Override public void onApplicationEvent(ContextStartedEvent event) &#123; System.out.println(&quot;ContextStartedEvent start!!&quot;); try &#123; System.in.read(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 运行结果： ​ 12HelloSpringEvent 初始化ContextStartedEvent start!! 可以看出进程被阻塞了，程序不会往下继续执行 参考： ​ https://wiki.jikexueyuan.com/project/spring/event-handling-in-spring.html","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"SpringBoot学习","slug":"SpringBoot/SpringBoot学习","date":"2019-09-04T07:45:59.000Z","updated":"2019-09-11T09:27:00.499Z","comments":true,"path":"2019/09/04/SpringBoot/SpringBoot学习/","link":"","permalink":"http://yoursite.com/2019/09/04/SpringBoot/SpringBoot学习/","excerpt":"","text":"SpringBootSpringBoot官方定义​ Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”. ​ We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration. Spring Boot使创建独立的、基于生产级Spring的应用程序变得很容易，您可以“直接运行”这些应用程序。 我们对Spring平台和第三方库有自己的见解，这样您就可以轻松入门了。大多数Spring引导应用程序只需要很少的Spring配置。 SpringBoot学习SpringBoot的启动123456789101112131415/** * SpringBoot 启动类 * 注意： * 启动器存放的位置。启动器可以和 controller位于同一个包下，或者位于 controller的上一级 包中， * 但是不能放到 controller的平级以及子包下。 * @author Administrator * */@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; //启动SpringBoot SpringApplication.run(App.class, args); &#125;&#125; ​ SpringBoot的静态资源访问​ 源码分析 ​ org.springframework.boot.autoconfigure.web.ResourceProperties 123private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; &quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &#125;; 因此，在类路径下的这几个目录都可以访问到静态资源 注意1： ​ 在maven中的src/main下建立webapp目录，可以访问静态资源 分析： ​ eclipse编译会产生一个target/classes目录,有eclipse中.classpath文件指定编译输出目录 ​ output=”target/classes” ​ maven中则将所有的资源打成一个jar或者war包，如果是jar包，则jar目录结构和eclipse中 ​ 中的target/classes下的目录结构相同，由项目中的包文件以及一个META-INF文件夹组成 ​ 用法： ​ 可以使用Maven中的资源打包插件,将src/main/webapp下的静态资源打包至META-INF/resources ​ 1234567891011121314151617181920&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/**&lt;/include&gt; &lt;/includes&gt; &lt;!-- 开启过滤，用指定的参数替换directory下的文件中的参数 --&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/webapp&lt;/directory&gt; &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt; &lt;includes&gt; &lt;include&gt;**/**&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; ​ 注意2： ​ 在有多个目录下有相同的静态资源，则优先级顺序优先级序 ​ /META-INF/resources &gt; resources &gt; static &gt; public 注意3： ​ 静态资源路径也可以通过配置文件指定 1spring.resources.static-locations=指定路径 #修改默认的静态资源存放目录，多个路径可以用逗号隔开 spring.resources.static-locations=classpath:/ 修改后，默认路径无效 注意4： 访问时使用相对路径， ​ 如果使用绝对路径static，public等默认是不计入路径的 参考：https://blog.csdn.net/qq_34797335/article/details/80194137 SprinBoot的配置文件SpringBoot配置文件支持yml格式和properties格式,默认命名为 ​ application.properties ​ application.yml 两种配置文件选择哪一种都可以 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好； yml全称YAML， YAML（Yet Another Markup Language）（发音 /ˈjæməl/ ）, 一种基于Unicode 容易阅读，容易和脚本语言交互的，用来表达资料序列的编程语言。yaml语言广泛用于书写配置文件。 yml主要特点参考：https://www.cnblogs.com/geeklove01/p/8284236.html 注： ​ 配置文件也可以不使用默认的配置名称,只需要在启动类中手动读取配置文件即可 12345678910@SpringBootApplicationpublic class SpringbootConfigApplication &#123; public static void main(String[] args) &#123; //变更配置文件读取位置启动 new SpringApplicationBuilder(SpringbootConfigApplication.class). properties(&quot;spring.config.location=classpath:/springbootconfig.properties&quot;).run(args); //读取默认配置文件启动 SpringApplication.run(SpringbootConfigApplication.class, args); &#125;&#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"SpringBoot的原理分析","slug":"SpringBoot/SpringBoot的原理分析","date":"2019-09-04T07:45:59.000Z","updated":"2019-09-13T14:57:04.285Z","comments":true,"path":"2019/09/04/SpringBoot/SpringBoot的原理分析/","link":"","permalink":"http://yoursite.com/2019/09/04/SpringBoot/SpringBoot的原理分析/","excerpt":"","text":"SpringBootSpringBoot官方定义​ Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”. ​ We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration. Spring Boot使创建独立的、基于生产级Spring的应用程序变得很容易，您可以“直接运行”这些应用程序。 我们对Spring平台和第三方库有自己的见解，这样您就可以轻松入门了。大多数Spring引导应用程序只需要很少的Spring配置。 SpringBoot原理分析​ SpringBoot是Spring框架对“约定大于配置(Convention over Configuration)”理念的最佳实践。SpringBoot应用本质上就是一个基于Spring框架的应用。 spring-boot-starter-xxx是官方提供的starter， xxx-spring-boot-starter是第三方提供的starter。 springboot扩展机制——spring factoriesSpring Boot中有一种非常解耦的扩展机制：Spring Factories。这种扩展机制实际上是仿照Java中的SPI扩展机制来实现的。 什么是SPI机制SPI的全名为Service Provider Interface.大多数开发人员可能不熟悉，因为这个是针对厂商或者插件的。在java.util.ServiceLoader的文档里有比较详细的介绍。简单的总结下java SPI机制的思想。我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块的方案，xml解析模块、jdbc模块的方案等。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。java SPI就是提供这样的一个机制：为某个接口寻找服务实现的机制。有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。 Spring Boot中的SPI机制在Spring中也有一种类似与Java SPI的加载机制。它在META-INF/spring.factories文件中配置接口的实现类名称，然后在程序中读取这些配置文件并实例化。这种自定义的SPI机制是Spring Boot Starter实现的基础。 Spring Factories实现原理​ spring-core包里定义了SpringFactoriesLoader类，这个类实现了检索META-INF/spring.factories文件，并获取指定接口的配置的功能。在这个类中定义了两个对外的方法： loadFactories 根据接口类获取其实现类的实例，这个方法返回的是对象列表。loadFactoryNames 根据接口获取其接口类的名称，这个方法返回的是类名的列表。上面的两个方法的关键都是从指定的ClassLoader中获取spring.factories文件，并解析得到类名列表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Load and instantiate the factory implementations of the given type from * &#123;@value #FACTORIES_RESOURCE_LOCATION&#125;, using the given class loader. * &lt;p&gt;The returned factories are sorted in accordance with the &#123;@link AnnotationAwareOrderComparator&#125;. * &lt;p&gt;If a custom instantiation strategy is required, use &#123;@link #loadFactoryNames&#125; * to obtain all registered factory names. * @param factoryClass the interface or abstract class representing the factory * @param classLoader the ClassLoader to use for loading (can be &#123;@code null&#125; to use the default) * @see #loadFactoryNames * @throws IllegalArgumentException if any factory implementation class cannot * be loaded or if an error occurs while instantiating any factory */public static &lt;T&gt; List&lt;T&gt; loadFactories(Class&lt;T&gt; factoryClass, ClassLoader classLoader) &#123; Assert.notNull(factoryClass, \"'factoryClass' must not be null\"); ClassLoader classLoaderToUse = classLoader; if (classLoaderToUse == null) &#123; classLoaderToUse = SpringFactoriesLoader.class.getClassLoader(); &#125; List&lt;String&gt; factoryNames = loadFactoryNames(factoryClass, classLoaderToUse); if (logger.isTraceEnabled()) &#123; logger.trace(\"Loaded [\" + factoryClass.getName() + \"] names: \" + factoryNames); &#125; List&lt;T&gt; result = new ArrayList&lt;T&gt;(factoryNames.size()); for (String factoryName : factoryNames) &#123; result.add(instantiateFactory(factoryName, factoryClass, classLoaderToUse)); &#125; AnnotationAwareOrderComparator.sort(result); return result; &#125; /** * Load the fully qualified class names of factory implementations of the * given type from &#123;@value #FACTORIES_RESOURCE_LOCATION&#125;, using the given * class loader. * @param factoryClass the interface or abstract class representing the factory * @param classLoader the ClassLoader to use for loading resources; can be * &#123;@code null&#125; to use the default * @see #loadFactories * @throws IllegalArgumentException if an error occurs while loading factory names */ public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, ClassLoader classLoader) &#123; String factoryClassName = factoryClass.getName(); try &#123; Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); List&lt;String&gt; result = new ArrayList&lt;String&gt;(); while (urls.hasMoreElements()) &#123; URL url = urls.nextElement(); Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url)); String factoryClassNames = properties.getProperty(factoryClassName); result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames))); &#125; return result; &#125; catch (IOException ex) &#123; throw new IllegalArgumentException(\"Unable to load [\" + factoryClass.getName() + \"] factories from location [\" + FACTORIES_RESOURCE_LOCATION + \"]\", ex); &#125; &#125; loadFactoryNames()在这个方法中会遍历整个ClassLoader中所有jar包下的spring.factories文件。也就是说我们可以在自己的jar中配置spring.factories文件，不会影响到其它地方的配置，也不会被别人的配置覆盖。 spring.factories的是通过Properties解析得到的，所以我们在写文件中的内容都是安装下面这种方式配置的： com.xxx.interface=com.xxx.classname 如果一个接口希望配置多个实现类，可以使用’,’进行分割。 Spring Factories在Spring Boot中的应用 ​ 在spring-boot-1.5.10.RELEASE.jar包下，/META-INF/spring.factories ​ 打开spring.factories ​ 12345678910# PropertySource Loadersorg.springframework.boot.env.PropertySourceLoader=\\org.springframework.boot.env.PropertiesPropertySourceLoader,\\org.springframework.boot.env.YamlPropertySourceLoader# Run Listenersorg.springframework.boot.SpringApplicationRunListener=\\org.springframework.boot.context.event.EventPublishingRunListener................................... 在spring-boot-autoconfigure-1.5.10.RELEASE.jar包下，/META-INF/spring.factories ​ 打开spring.factories 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129# Initializersorg.springframework.context.ApplicationContextInitializer=\\org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\\org.springframework.boot.autoconfigure.logging.AutoConfigurationReportLoggingInitializer# Application Listenersorg.springframework.context.ApplicationListener=\\org.springframework.boot.autoconfigure.BackgroundPreinitializer# Auto Configuration Import Listenersorg.springframework.boot.autoconfigure.AutoConfigurationImportListener=\\org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener# Auto Configuration Import Filtersorg.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\\org.springframework.boot.autoconfigure.condition.OnClassCondition# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration# Failure analyzersorg.springframework.boot.diagnostics.FailureAnalyzer=\\org.springframework.boot.autoconfigure.diagnostics.analyzer.NoSuchBeanDefinitionFailureAnalyzer,\\org.springframework.boot.autoconfigure.jdbc.DataSourceBeanCreationFailureAnalyzer,\\org.springframework.boot.autoconfigure.jdbc.HikariDriverConfigurationFailureAnalyzer# Template availability providersorg.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider=\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerTemplateAvailabilityProvider,\\org.springframework.boot.autoconfigure.mustache.MustacheTemplateAvailabilityProvider,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAvailabilityProvider,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafTemplateAvailabilityProvider,\\org.springframework.boot.autoconfigure.web.JspTemplateAvailabilityProvider 这是关于spirngboot自动配置的类的定义,这样通过解析factories文件就能实例化这些定义的类 分析： ​ 自动配置这些类都使用了spring的注解，spring容器在实例化这些类时,通过这些类上的注解可以完成 注册某些Bean等 例如： ​ @Configuration ​ @Bean ​ 能够被springIOC使用的工厂注解和bean的Annotation，springIOC通过注解就可以注入bean 自定义的factories ​ mybatis-spring-boot-autoconfigure-1.1.1.jar中的META-INF/spring.factories ​ 打开spring.factories ​ 123# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration 通过扩展机制配置了一个MybatisAutoConfiguration类,可以查看源码进行具体分析 参考：https://blog.csdn.net/gwd1154978352/article/details/89248273 SpringBoot的starter机制​ starter机制明显是在通过扩展机制来进行实现的，通过扩展机制，可以自定义实现 ​ springboot启动器 起步依赖​ 以一个web项目为例: ​ spring-boot-starter-web包自动帮我们引入了web模块开发需要的相关jar包， ​ mybatis-spring-boot-starter帮我们引入了dao开发相关的jar包。 自动配置​ 对springboot中的mybatis进行分析 ​ mybatis-spring-boot-starter这个包是第三方提供的 ​ mybatis-spring-boot-starter这个包帮我们引入了mybatis-spring-boot-autoconfigure这个包 里面有MybatisAutoConfiguration这个类,源码如下 1234567891011121314151617181920212223242526272829303132333435363738...................@Configuration@ConditionalOnClass(&#123; SqlSessionFactory.class, SqlSessionFactoryBean.class &#125;)@ConditionalOnBean(DataSource.class)@EnableConfigurationProperties(MybatisProperties.class)@AutoConfigureAfter(DataSourceAutoConfiguration.class)public class MybatisAutoConfiguration &#123; ........................................ @Bean @ConditionalOnMissingBean public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean factory = new SqlSessionFactoryBean(); factory.setDataSource(dataSource); factory.setVfs(SpringBootVFS.class); if (StringUtils.hasText(this.properties.getConfigLocation())) &#123; factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation())); &#125; factory.setConfiguration(properties.getConfiguration()); if (!ObjectUtils.isEmpty(this.interceptors)) &#123; factory.setPlugins(this.interceptors); &#125; if (this.databaseIdProvider != null) &#123; factory.setDatabaseIdProvider(this.databaseIdProvider); &#125; if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) &#123; factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage()); &#125; if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) &#123; factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage()); &#125; if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) &#123; factory.setMapperLocations(this.properties.resolveMapperLocations()); &#125; return factory.getObject(); &#125; .............................. ​ @Configuration,@Bean这两个注解一起使用就可以创建一个基于java代码的配置类，可以用来替代相应的xml配置文件。 @Configuration注解的类可以看作是能生产让Spring IoC容器管理的Bean实例的工厂。 @Bean注解告诉Spring，一个带有@Bean的注解方法将返回一个对象，该对象应该被注册到spring容器中。 所以上面的MybatisAutoConfiguration这个类，自动帮我们生成了SqlSessionFactory这些Mybatis的重要实例并交给spring容器管理，从而完成bean的自动注册。 自动配置条件依赖 从MybatisAutoConfiguration这个类中使用的注解可以看出，要完成自动配置是有依赖条件的。 123456789101112131415@ConditionalOnBean，仅在当前上下文中存在某个bean时，才会实例化这个Bean。@ConditionalOnClass，某个class位于类路径上，才会实例化这个Bean。@ConditionalOnExpression，当表达式为true的时候，才会实例化这个Bean。@ConditionalOnMissingBean，仅在当前上下文中不存在某个bean时，才会实例化这个Bean。@ConditionalOnMissingClass，某个class在类路径上不存在的时候，才会实例化这个Bean。@ConditionalOnNotWebApplication，不是web应用时才会实例化这个Bean。@AutoConfigureAfter，在某个bean完成自动配置后实例化这个bean。@AutoConfigureBefore，在某个bean完成自动配置前实例化这个bean。 ​ 所以要完成Mybatis的自动配置，需要在类路径中存在SqlSessionFactory.class、SqlSessionFactoryBean.class这两个类，需要存在DataSource这个bean且这个bean完成自动注册。 ​ 进入DataSourceAutoConfiguration这个类，这个类是在spring-boot-autoconfigure-2.0.4.RELEASE.jar这个包下的，通过扩展机制也自动进行了配置。 ​ 自动配置这个包帮们引入了jdbc、kafka、logging、mail、mongo等包。很多包需要我们引入相应jar后自动配置才生效。 bean参数获取 ​ springboot是如何读取yml或者properites配置文件的的属性来创建数据源的？ ​ 在DataSourceAutoConfiguration类里面，我们注意到使用了EnableConfigurationProperties这个注解。 DataSourceProperties中封装了数据源的各个属性，且使用了注解ConfigurationProperties指定了配置文件的前缀。 123@ConfigurationProperties( prefix = &quot;spring.datasource&quot;) @ConfigurationProperties注解的作用是把yml或者properties配置文件转化为bean。 @EnableConfigurationProperties注解的作用是使@ConfigurationProperties注解生效。如果只配置 @ConfigurationProperties注解，在spring容器中是获取不到yml或者properties配置文件转化的bean的。 通过这种方式，把yml或者properties配置参数转化为bean，这些bean又是如何被发现与加载的？ bean发现 ​ 我们通常在启动类中加@SpringBootApplication这个注解 ​ 实际上重要的只有三个Annotation： @Configuration（@SpringBootConfiguration里面还是应用了@Configuration） @EnableAutoConfiguration @ComponentScan @Configuration的作用上面我们已经知道了，被注解的类将成为一个bean配置类。 @ComponentScan的作用就是自动扫描并加载符合条件的组件，比如@Component和@Repository等，最终将这些bean定义加载到spring容器中。 @EnableAutoConfiguration 这个注解的功能很重要，借助@Import的支持，收集和注册依赖包中相关的bean定义。对于详解可以查看springboot中对于这个注解的实现。最终还是借助spring.factories注册bean。 @EnableAutoConfiguration注解引入了@AutoConfigurationPackage和@Import这两个注解。 12345678910@SuppressWarnings(&quot;deprecation&quot;)@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; ...&#125; @AutoConfigurationPackage的作用就是自动配置的包，@Import导入需要自动配置的组件。 进入@AutoConfigurationPackage，发现也是引入了@Import注解 1234567@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(&#123;Registrar.class&#125;)public @interface AutoConfigurationPackage &#123;&#125; ​ 查看Registrar 1234567891011121314static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123; @Override public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123; register(registry, new PackageImport(metadata).getPackageName()); &#125; @Override public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123; return Collections.&lt;Object&gt;singleton(new PackageImport(metadata)); &#125; &#125; new AutoConfigurationPackages.PackageImport(metadata)).getPackageName() new AutoConfigurationPackages.PackageImport(metadata) 这两句代码的作用就是加载启动类所在的包下的主类与子类的所有组件注册到spring容器，这就是前文所说的springboot默认扫描启动类所在的包下的主类与子类的所有组件。 那问题又来了，要搜集并注册到spring容器的那些beans来自哪里？ @EnableAutoConfiguration类上的@Import(EnableAutoConfigurationImportSelector.class) 选择EnableAutoConfigurationImportSelector的父类AutoConfigurationImportSelector 在AutoConfigurationImportSelector中 123456789101112131415161718192021222324252627282930public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered &#123;private static final String[] NO_IMPORTS = new String[0];... public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if(!this.isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; else &#123; AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader); AnnotationAttributes attributes = this.getAttributes(annotationMetadata); List configurations = this.getCandidateConfigurations(annotationMetadata, attributes); configurations = this.removeDuplicates(configurations); Set exclusions = this.getExclusions(annotationMetadata, attributes); this.checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = this.filter(configurations, autoConfigurationMetadata); this.fireAutoConfigurationImportEvents(configurations, exclusions); return StringUtils.toStringArray(configurations); &#125; &#125;... protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; List configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;); return configurations; &#125;...&#125; SpringFactoriesLoader.loadFactoryNames方法调用loadSpringFactories方法从所有的jar包中读取META-INF/spring.factories文件信息。 loadSpringFactories方法 1234567891011121314151617181920212223242526272829private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123; MultiValueMap result = (MultiValueMap)cache.get(classLoader); if(result != null) &#123; return result; &#125; else &#123; try &#123; Enumeration ex = classLoader != null?classLoader.getResources(&quot;META-INF/spring.factories&quot;):ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;); LinkedMultiValueMap result1 = new LinkedMultiValueMap(); while(ex.hasMoreElements()) &#123; URL url = (URL)ex.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); Iterator var6 = properties.entrySet().iterator(); while(var6.hasNext()) &#123; Entry entry = (Entry)var6.next(); List factoryClassNames = Arrays.asList(StringUtils.commaDelimitedListToStringArray((String)entry.getValue())); result1.addAll((String)entry.getKey(), factoryClassNames); &#125; &#125; cache.put(classLoader, result1); return result1; &#125; catch (IOException var9) &#123; throw new IllegalArgumentException(&quot;Unable to load factories from location [META-INF/spring.factories]&quot;, var9); &#125; &#125; &#125; 下面是spring-boot-autoconfigure这个jar中spring.factories文件部分内容，其中有一个key为org.springframework.boot.autoconfigure.EnableAutoConfiguration的值定义了需要自动配置的bean，通过读取这个配置获取一组@Configuration类。 123456789101112131415org.springframework.boot.autoconfigure.AutoConfigurationImportListener=\\org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener# Auto Configuration Import Filtersorg.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\\org.springframework.boot.autoconfigure.condition.OnClassCondition# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\............. 个xxxAutoConfiguration都是一个基于java的bean配置类。实际上，这些xxxAutoConfiguratio不是所有都会被加载，会根据xxxAutoConfiguration上的@ConditionalOnClass等条件判断是否加载。 如上代码段，通过反射机制将spring.factories中@Configuration类实例化为对应的java实例。到此我们已经知道怎么发现要自动配置的bean了，最后一步就是怎么样将这些bean加载到spring容器。 bean加载 ​ 如果要让一个普通类交给Spring容器管理，通常有以下方法： 1、使用 @Configuration与@Bean 注解 2、使用@Controller @Service @Repository @Component 注解标注该类，然后启用@ComponentScan自动扫描 3、使用@Import 方法 springboot中使用了@Import 方法 @EnableAutoConfiguration注解中使用了@Import({AutoConfigurationImportSelector.class})注解，AutoConfigurationImportSelector实现了DeferredImportSelector接口， DeferredImportSelector接口继承了ImportSelector接口，ImportSelector接口只有一个selectImports方法。 1234567891011121314151617181920public class AutoConfigurationImportSelector implements DeferredImportSelector&#123;... public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if(!this.isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; else &#123; AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader); AnnotationAttributes attributes = this.getAttributes(annotationMetadata); List configurations = this.getCandidateConfigurations(annotationMetadata, attributes); configurations = this.removeDuplicates(configurations); Set exclusions = this.getExclusions(annotationMetadata, attributes); this.checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = this.filter(configurations, autoConfigurationMetadata); this.fireAutoConfigurationImportEvents(configurations, exclusions); return StringUtils.toStringArray(configurations); &#125;&#125;...&#125; 1234567public interface DeferredImportSelector extends ImportSelector &#123; @Nullable default Class&lt;? extends DeferredImportSelector.Group&gt; getImportGroup() &#123; return null;&#125;public interface Group &#123;...&#125;&#125; ​ 这是@Import注解的定义，实现该接口可以自定义返回一组bean 123public interface ImportSelector &#123; String[] selectImports(AnnotationMetadata var1);&#125; ​ selectImports方法返回一组bean，@EnableAutoConfiguration注解借助@Import注解将这组bean注入到spring容器中，springboot正式通过这种机制来完成bean的注入的。 总结: ​ 我们可以将自动配置的关键几步以及相应的注解总结如下： 1、@Configuration&amp;与@Bean-&gt;基于java代码的bean配置， 2、@Conditional-&gt;设置自动配置条件依赖 3、@EnableConfigurationProperties与@ConfigurationProperties-&gt;读取配置文件转换为bean。 4、@EnableAutoConfiguration、@AutoConfigurationPackage 与@Import-&gt;实现bean发现与加载。 参考：https://www.cnblogs.com/hjwublog/p/10332042.html#autoid-1-0-0 SpringBoot中的启动类分析​ SpringBoot启动类 123456789101112package com.hafiz.springbootdemo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class SpringbootDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootDemoApplication.class, args); &#125;&#125; ​ @SpringBootApplication注解​ 123456789101112@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; ...&#125; 我们看到@SpringBootApplication其实是一个复合的注解，起主要作用的就是@SpringBootConfiguration、@EnableAutoConfiguration以及@ComponentScan 三个注解组成. @SpringBootConfiguration1234567@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Configurationpublic @interface SpringBootConfiguration &#123;&#125; 我们可以看到，这里面依旧没有什么新东西，它SpringBoot为了区别@Configuration而新提供的专属于SpringBoot的注解，功能和@Configuration一模一样。 @EnableAutoConfiguration简单的来说，就是该注解借助@Import注解的支持，Spring的IoC容器收集和注册特定场景相关的Bean定义： 关于‘Enable’开头的spring注解 @EnableScheduling是通过@Import将Spring调度框架相关的bean都加载到IoC容器。 @EnableMBeanExport是通过@Import将JMX相关的bean定义加载到IoC容器。 @EnableAutoConfiguration注解也是借助@Import将所有复合配置条件的bean定义加载到IoC容器 12345678910@SuppressWarnings(\"deprecation\")@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; ...&#125; ​ 这其中最关键的就是@Import(EnableAutoConfigurationImportSelector.class)了，EnableAutoConfigurationImportSelector.class可以帮助SpringBoot应用将所有符合条件的@Configuration配置类都加载到当前SpringBoot创建并使用的IoC容器。 下面我们给出EnableAutoConfigurationImportSelector.java的父类AutoConfigurationImportSelector.java的部分源码，来解释和验证 12345678910111213public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware,BeanFactoryAware, EnvironmentAware, Ordered &#123; protected List&lt;AutoConfigurationImportFilter&gt; getAutoConfigurationImportFilters() &#123; return SpringFactoriesLoader.loadFactories(AutoConfigurationImportFilter.class, this.beanClassLoader); &#125; protected List&lt;AutoConfigurationImportListener&gt; getAutoConfigurationImportListeners() &#123; return SpringFactoriesLoader.loadFactories(AutoConfigurationImportListener.class, this.beanClassLoader); &#125;&#125; 以上源码可以看出，@EnableAutoConfiguration正是借助SpringFactoriesLoader的支持，完成所有配置类都加载 到当前SpringBoot创建并使用的IOC容器. SpringFactoriesLoader详解​ SpringFactoriesLoader属于Spring框架专属的一种扩展方案(其功能和使用方式类似于Java的SPI方案:java.util.ServiceLoader)，它的主要功能就是从指定的配置文件META-INF/spring.factories中加载配置，spring.factories是一个非常经典的java properties文件，内容格式是Key=Value形式，只不过这Key以及Value都非常特殊，为Java类的完整类名(Fully qualified name)。 ​ 对于@EnableAutoConfiguraion来说，SpringFactoriesLoader的用途和其本意稍微不同，它本意是为了提供SPI扩展，而在@EnableAutoConfiguration这个场景下，它更多的是提供了一种配置查找的功能的支持。 1234567891011121314151617181920212223# Initializersorg.springframework.context.ApplicationContextInitializer=\\org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\\org.springframework.boot.autoconfigure.logging.AutoConfigurationReportLoggingInitializer# Application Listenersorg.springframework.context.ApplicationListener=\\org.springframework.boot.autoconfigure.BackgroundPreinitializer# Auto Configuration Import Listenersorg.springframework.boot.autoconfigure.AutoConfigurationImportListener=\\org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener# Auto Configuration Import Filtersorg.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\\org.springframework.boot.autoconfigure.condition.OnClassCondition# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\ 这是spring-boot-autoconfigure-1.5.10.RELEASE.jar下的spring.factories。 非必须的@ComponentScan解析​ 为什么说这个注解是非必需的呢？因为我们知道作为Spring框架里的老成员，@ComponentScan的功能就是自动扫描并加载复合条件的组件或Bean定义，最终将这些bean定义加载到当前使用的容器中。这个过程，我们可以手工单个进行注册，不是一定要通过这个注解批量扫描和注册，所以说@ComponentScan是非必需的。 ​ 所以，如果我们当前应用没有任何bean定义需要通过@ComponentScan加载到当前SpringBoot应用对应的IoC容器，那么，去掉@ComponentScan注解，当前的SpringBoot应用依旧可以完美运行！ ​ 扩展机制和starter进行自定义实现​ 自定义封装一个starter ​ ​ ​ 参考:https://www.cnblogs.com/hjwublog/p/10335464.html springboot中的元数据​ spring-boot-autoconfigure-1.5.10.RELEASE.jar包含元数据文件，提供所有支持的配置属性的详细信息。这些文件旨在允许IDE开发人员在用户使用application.properties 或application.yml文件时提供上下文帮助和自动补全 。 主要的元数据文件是在编译器通过处理所有被@ConfigurationProperties注解的节点来自动生成的。（自定义的 一些自动配置包也可以提供，例如mybatis-spring-boot-autoconfigure.jar） 配置元数据位于jar文件中的META-INF/spring-configuration-metadata.json，它们使用一个具有”groups”或”properties”分类节点的简单JSON格式。 如果不知道springboot是否支持某个配置的话，可以查看元数据文件看是否有对应的节点。 注意： ​ 在application.properties中，驼峰的写法有两种，都是可以的 123spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.driverClassName=com.mysql.jdbc.Driver ​","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"java的classpath","slug":"JavaSE/java的classpath","date":"2019-08-25T09:46:31.000Z","updated":"2019-09-11T09:23:44.847Z","comments":true,"path":"2019/08/25/JavaSE/java的classpath/","link":"","permalink":"http://yoursite.com/2019/08/25/JavaSE/java的classpath/","excerpt":"","text":"java中classpath理解类路径(classpath)​ 默认java虚拟机要从classpath环境变量的路径中搜索class文件去执行，对于java虚拟机来说，这不是类文件，而是类。它只有类路径，而没有文件系统路径。而classpath环境变量正是为java虚拟机提供搜索类路径的环境。注意，虚拟机不会递归搜索classpath定义的路径。（因此，在spring中有classpath*,表示递归classpath定义的路径下的所有路径） java编译器编译.java文件和java虚拟机执行.class文件时的路径和写法不一样。在没有设置任何classpath环境变量的情况下，javac可以编译全路径的.java文件 ​ 要明确的是javac编译器搜索的是文件路径，和环境变量classpath无关。而java虚拟机搜索的是类文件，严格地说是类，搜索路径由环境变量classpath决定，且有先后顺序 (1).何时需要使用-classpath：当你要编译或执行的类引用了其它的类，但被引用类的.class文件不在当前目录下时，就需要通过-classpath来引入类路径 (2).何时需要指定路径：当你要编译的类所在的目录和你执行javac命令的目录不是同一个目录时，就需要指定源文件的路径(CLASSPATH是用来指定.class路径的，不是用来指定.java文件的路径的) 包(package)1）​ 包是类的集合。在java源文件的第一行(不包括注释行或空行)写上package关键字并给定包名，即可将该类文件放到包中。 ​ javac在编译时从路径上搜索文件。例如，将这个Cat.java放到com/longshuai/home下。执行时java虚拟机从classpath搜索要加载的类文件，而加载类的方式是使用”.”连接各类名。所以编译这个文件和java虚拟机执行这个文件时的方法分别是： 12javac com/longshuai/home/Cat.javajava com.longshuai.home.Cat 注意，嵌套的包之间没有任何关系，例如java.util包和java.util.jar包没有任何依赖关系。 2）​ 在某个java源文件中，无法直接使用其他文件中的类，除非要使用的这个类正好能被classpath的路径搜索到。要引用非classpath下的其他类，只能将其添加到classpath或者装入package中，然后引用包中的类。 ​ 导入包时可以在尾部使用星号”“通配导入的所有类，只能在尾部使用”“，因为”“匹配的是类名，而不是包名。也因此，不能在非结尾处使用”“号来表示导入其他包中的类，例如： 12import com.longshuai.home.*; //导入com.longshuai.home包中的所有类import com.longshuai.*; //导入com.longshuai包中所有类，但不会导入com.longshuai.home中类 类搜索机制​ 在java虚拟机搜索类文件时，除了classpath环境变量指定的路径，还会先搜索两个默认的路径:jre/lib和jre/lib/ext下的jar文件中似乎否有待搜索的类。 ​ 例如，当classpath设置为”.;d:\\myjava;d:\\myjar.jar”时，要搜索com.longshuai.com.Cat类文件：(a).先搜索jre/lib和jre/lib/ext下的jar文件;(b).再搜索当前目录下是否有com\\longshuai\\com\\Cat.class;(c).再搜索d:\\myjava\\Cat.class;(d).搜索d:\\myjar.jar文件中是否有com.longshuai.com.Cat类。 如果在某个java源文件中引用了某个类，则在编译时，将通过以下几种方式判断该类是否合理有效： (1).搜索导入的包类中是否包含该类。(2).搜索隐式导入的java.lang包，该包是默认导入的。(3).当前文件中是否定义了该类。(4).按照类路径的搜索规则((a)-(d))搜索其中是否有该类。 JAVA获取classpath路径：ClassLoader 提供了两个方法用于从装载的类路径中取得资源： ​ public URL getResource (String name);​ public InputStream getResourceAsStream (String name); 这里name是资源的类路径，它是相对与“/”根路径下的位置。getResource得到的是一个URL对象来定位资源，而getResourceAsStream取得该资源输入流的引用保证程序可以从正确的位置抽取数据。 但是真正使用的不是ClassLoader的这两个方法，而是Class的 getResource和getResourceAsStream方法，因为Class对象可以从你的类得到（如YourClass.class或 YourClass.getClass()），而ClassLoader则需要再调用一次YourClass.getClassLoader()方法，不过根据JDK文档的说法，Class对象的这两个方法其实是“委托”（delegate）给装载它的ClassLoader来做的，所以只需要使用 Class对象的这两个方法就可以了。 ​ 因此，直接调用 this.getClass().getResourceAsStream(String name) ;获取流，静态化方法中则使用ClassLoader.getSystemResourceAsStream (String name) ; 。 12345678910111213141516171819202122231.this.getClass().getResource（&quot;&quot;） 得到的是当前类class文件的URI目录。不包括自己！如：file：/D：/workspace/jbpmtest3/bin/com/test/2.this.getClass().getResource（&quot;/&quot;） 得到的是当前的classpath的绝对URI路径 。如：file：/D：/workspace/jbpmtest3/bin/3.this.getClass() .getClassLoader().getResource（&quot;&quot;） 得到的也是当前ClassPath的绝对URI路径 。如：file：/D：/workspace/jbpmtest3/bin/4.ClassLoader.getSystemResource（&quot;&quot;） 得到的也是当前ClassPath的绝对URI路径 。如：file：/D：/workspace/jbpmtest3/bin/5.Thread.currentThread().getContextClassLoader ().getResource（&quot;&quot;） 得到的也是当前ClassPath的绝对URI路径 。如：file：/D：/workspace/jbpmtest3/bin/6.ServletActionContext.getServletContext().getRealPath(“/”) Web应用程序 中，得到Web应用程序的根目录的绝对路径。这样，我们只需要提供相对于Web应用程序根目录的路径，就可以构建出定位资源的绝对路径。如：file：/D:/workspace/.metadata/.plugins/org.eclipse.wst.server.core/tmp0/wtpwebapps/WebProject 注意点： 1.尽量不要使用相对于System.getProperty（”user.dir”）当前用户目录的相对路径。这是一颗定时炸 弹，随时可能要你的命。 2.尽量使用URI形式的绝对路径资源。它可以很容易的转变为URI，URL，File对象。 3.尽量使用相对classpath的相对路径。不要使用绝对路径。使用上面ClassLoaderUtil类的public static URL getExtendResource（String relativePath）方法已经能够使用相对于classpath的相对路径定位所有位置的资源。 4.绝对不要使用硬编码的绝对路径。因为，我们完全可以使用ClassLoader类的getResource（””）方法得到当前classpath的绝对路径。如果你一定要指定一个绝对路径，那么使用配置文件，也比硬编码要好得多！ 获得CLASSPATH之外路径的方法：URL base = this.getClass（）.getResource（””）； //先获得本类的所在位置，如/home/popeye/testjava/build/classes/net/ String path = new File（base.getFile（）， “……/……/……/“+name）.getCanonicalPath（）； //就可以得到/home/popeye/testjava/name 另外，如果从ANT启动程序，this.getClass().getResource(“”)取出来的比较怪，直接用JAVA命令行调试就可成功。 PS：以上内容来自转载 在dos下编译Java程序，就要用到classpath这个概念，尤其是在没有设置环境变量的时候。classpath就是存放.class等编译后文件的路径。 在spring中，classpath 和 classpath* 区别： 12classpath：只会到你的class路径中查找找文件;classpath*：不仅包含class路径，还将递归classpath定义的路径下的所有子路径 如何执行指定class文件目录（classpath）如果我们 Java 编译后的class文件不在当前目录，我们可以使用 -classpath 来指定class文件目录： 1C:&gt; java -classpath C:\\java\\DemoClasses HelloWorld 以上命令中我们使用了 -classpath 参数指定了 HelloWorld 的 class 文件所在目录。 如果class文件在jar文件中，则命令如下： 1c:&gt; java -classpath C:\\java\\myclasses.jar com.test.HelloWorld javac： 如果当前你要编译的 java 文件中引用了其它的类(比如说：继承)，但该引用类的 .class 文件不在当前目录下，这种情况下就需要在 javac 命令后面加上 -classpath 参数，通过使用以下三种类型的方法 来指导编译器在编译的时候去指定的路径下查找引用类。 (1).绝对路径：javac -classpath c:/junit3.8.1/junit.jar Xxx.java (2).相对路径：javac -classpath ../junit3.8.1/Junit.javr Xxx.java (3).系统变量：javac -classpath %CLASSPATH% Xxx.java (注意：%CLASSPATH%表示使用系统变量CLASSPATH的值进行查找，这里假设Junit.jar的路径就包含在CLASSPATH系统变量中) 总结： (1).何时需要使用 -classpath：当你要编译或执行的类引用了其它的类，但被引用类的 .class 文件不在当前目录下时，就需要通过 -classpath 来引入类 (2).何时需要指定路径：当你要编译的类所在的目录和你执行 javac 命令的目录不是同一个目录时，就需要指定源文件的路径(CLASSPATH 是用来指定 .class 路径的，不是用来指定 .java 文件的路径的) assembly打包duboo-provider的理解assembly打包的目录结构 ​ bin ​ start.bat ​ ….. ​ conf ​ dubbo.properties ​ lib ​ 所有的jar包 assembly的bin下的start.bat 12345678910111213141516171819202122@echo off &amp; setlocal enabledelayedexpansionset LIB_JARS=&quot;&quot;cd ..\\libfor %%i in (*) do set LIB_JARS=!LIB_JARS!;..\\lib\\%%icd ..\\binif &quot;&quot;%1&quot;&quot; == &quot;&quot;debug&quot;&quot; goto debugif &quot;&quot;%1&quot;&quot; == &quot;&quot;jmx&quot;&quot; goto jmxjava -Xms64m -Xmx1024m -XX:MaxPermSize=64M -classpath ..\\conf;%LIB_JARS% com.alibaba.dubbo.container.Maingoto end:debugjava -Xms64m -Xmx1024m -XX:MaxPermSize=64M -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=n -classpath ..\\conf;%LIB_JARS% com.alibaba.dubbo.container.Maingoto end:jmxjava -Xms64m -Xmx1024m -XX:MaxPermSize=64M -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -classpath ..\\conf;%LIB_JARS% com.alibaba.dubbo.container.Main:endpause java -Xms64m -Xmx1024m -XX:MaxPermSize=64M -classpath ..\\conf;%LIB_JARS% com.alibaba.dubbo.container.Main ​ 根据以上的理解，该命令是执行com.alibaba.dubbo.container.Main 但是该类需要依赖许多其他类，因此需要指定-classpath (..\\conf是一个配置文件，将其加入到 classpath中，%LIB_JARS%是执行com.alibaba.dubbo.container.Main所依赖的所有jar包路径, 也将其加载到classpath中，这样，com.alibaba.dubbo.container.Main才可以正确执行) 注意： ​ 加入echo %LIB_JARS% 测试打印结果 1&quot;&quot;;..\\lib\\aopalliance-1.0.jar;..\\lib\\aspectjweaver-1.8.4.jar;..\\lib\\commons-logging-1.2.jar;..\\lib\\druid-1.0.9.jar;..\\lib\\dubbo-2.5.4.jar;..\\lib\\dubbo-mapper-0.0.1-SNAPSHOT.jar;..\\lib\\dubbo-pojo-0.0.1-SNAPSHOT.jar;..\\lib\\dubbo-user-interface-0.0.1-SNAPSHOT.jar;..\\lib\\dubbo-user-service-0.0.1-SNAPSHOT.jar;..\\lib\\hamcrest-core-1.3.jar;..\\lib\\javassist-3.20.0-GA.jar;..\\lib\\jline-0.9.94.jar;..\\lib\\junit-4.12.jar;..\\lib\\log4j-1.2.16.jar;..\\lib\\mybatis-3.2.8.jar;..\\lib\\mybatis-spring-1.2.2.jar;..\\lib\\mysql-connector-java-5.1.32.jar;..\\lib\\netty-3.2.5.Final.jar;..\\lib\\netty-3.7.0.Final.jar;..\\lib\\slf4j-api-1.6.1.jar;..\\lib\\slf4j-log4j12-1.6.4.jar;..\\lib\\spring-aop-4.1.3.RELEASE.jar;..\\lib\\spring-aspects-4.1.3.RELEASE.jar;..\\lib\\spring-beans-4.1.3.RELEASE.jar;..\\lib\\spring-context-4.1.3.RELEASE.jar;..\\lib\\spring-core-4.1.3.RELEASE.jar;..\\lib\\spring-expression-4.1.3.RELEASE.jar;..\\lib\\spring-jdbc-4.1.3.RELEASE.jar;..\\lib\\spring-tx-4.1.3.RELEASE.jar;..\\lib\\spring-web-4.1.3.RELEASE.jar;..\\lib\\zkclient-0.10.jar;..\\lib\\zookeeper-3.4.8.jar 是所有jar的路径，通过-classpath将其加入到类路径中，这样就可以引用这些jar中的.class或者资源文件 eclipse中执行的classpath分析​ eclipse的项目文件夹有一个.classpath文件，用于描述classpath 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;classpath&gt; &lt;classpathentry kind=&quot;src&quot; path=&quot;src&quot;/&gt; &lt;classpathentry kind=&quot;con&quot; path=&quot;org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8&quot;/&gt; &lt;classpathentry kind=&quot;lib&quot; path=&quot;lib/mysql-connector-java-8.0.11.jar&quot;/&gt; &lt;classpathentry kind=&quot;lib&quot; path=&quot;lib/commons-beanutils-1.9.3.jar&quot;/&gt; &lt;classpathentry kind=&quot;lib&quot; path=&quot;lib/commons-logging-1.2.jar&quot;/&gt; &lt;classpathentry kind=&quot;output&quot; path=&quot;bin&quot;/&gt;&lt;/classpath&gt; 将src目录，以及所引用的jar路径都添加到classpath中，这样才能保证程序正常执行。 总结​ 将一个路径添加到classpath中，则该路径下的目录或者资源可以被直接通过类路径被访问到，例如: ​ hello目录下有test,resource两个文件夹，test中有com/szxy/Test.class，resource中有一个res/index.html, ​ hello ​ test ​ com ​ test ​ Test.class ​ resource ​ res ​ index.html 执行 java -classpath ./test;./resource com.bjsxt.Test，将test和resouce都加载到类路径中， com.szxy.Test类中需要加载这个资源，通过getResourceAsStream(“res/index.html”), 因为类路径是test目录下和resource目录下，因此可以拿到资源res/index.html, 需要注意一点，不能直接getResourceAsStream(“index.html”)，因为类路径加载了不会递归查询，除非将 hello/resource/res也添加到类路径中才可以直接拿到，否则必须从类路径下沿着路径找到资源. 参考： ​ https://www.cnblogs.com/jixp/articles/9349845.html ​ https://www.runoob.com/java/env-classpath.html","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"dubbo使用","slug":"JavaAdvancedTechnology/Dubbo/dubbo使用","date":"2019-08-25T09:46:31.000Z","updated":"2019-08-27T06:02:09.810Z","comments":true,"path":"2019/08/25/JavaAdvancedTechnology/Dubbo/dubbo使用/","link":"","permalink":"http://yoursite.com/2019/08/25/JavaAdvancedTechnology/Dubbo/dubbo使用/","excerpt":"","text":"assembly打包后启动provider分析assembly打包的目录结构 ​ bin ​ start.bat ​ ….. ​ conf ​ dubbo.properties ​ lib ​ 所有的jar包 assembly包的bin下的start.bat（windows下的启动脚本） 12345678910111213141516171819202122@echo off &amp; setlocal enabledelayedexpansionset LIB_JARS=&quot;&quot;cd ..\\libfor %%i in (*) do set LIB_JARS=!LIB_JARS!;..\\lib\\%%icd ..\\binif &quot;&quot;%1&quot;&quot; == &quot;&quot;debug&quot;&quot; goto debugif &quot;&quot;%1&quot;&quot; == &quot;&quot;jmx&quot;&quot; goto jmxjava -Xms64m -Xmx1024m -XX:MaxPermSize=64M -classpath ..\\conf;%LIB_JARS% com.alibaba.dubbo.container.Maingoto end:debugjava -Xms64m -Xmx1024m -XX:MaxPermSize=64M -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=n -classpath ..\\conf;%LIB_JARS% com.alibaba.dubbo.container.Maingoto end:jmxjava -Xms64m -Xmx1024m -XX:MaxPermSize=64M -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -classpath ..\\conf;%LIB_JARS% com.alibaba.dubbo.container.Main:endpause java -Xms64m -Xmx1024m -XX:MaxPermSize=64M -classpath ..\\conf;%LIB_JARS% com.alibaba.dubbo.container.Main ​ 根据以上的理解，该命令是执行com.alibaba.dubbo.container.Main 但是该类需要依赖许多其他类，因此需要指定-classpath (..\\conf是一个配置文件，将其加入到 classpath中，%LIB_JARS%是执行com.alibaba.dubbo.container.Main所依赖的所有jar包路径, 也将其加载到classpath中，这样，com.alibaba.dubbo.container.Main才可以正确执行) 注意： ​ 加入echo %LIB_JARS% 测试打印结果 1&quot;&quot;;..\\lib\\aopalliance-1.0.jar;..\\lib\\aspectjweaver-1.8.4.jar;..\\lib\\commons-logging-1.2.jar;..\\lib\\druid-1.0.9.jar;..\\lib\\dubbo-2.5.4.jar;..\\lib\\dubbo-mapper-0.0.1-SNAPSHOT.jar;..\\lib\\dubbo-pojo-0.0.1-SNAPSHOT.jar;..\\lib\\dubbo-user-interface-0.0.1-SNAPSHOT.jar;..\\lib\\dubbo-user-service-0.0.1-SNAPSHOT.jar;..\\lib\\hamcrest-core-1.3.jar;..\\lib\\javassist-3.20.0-GA.jar;..\\lib\\jline-0.9.94.jar;..\\lib\\junit-4.12.jar;..\\lib\\log4j-1.2.16.jar;..\\lib\\mybatis-3.2.8.jar;..\\lib\\mybatis-spring-1.2.2.jar;..\\lib\\mysql-connector-java-5.1.32.jar;..\\lib\\netty-3.2.5.Final.jar;..\\lib\\netty-3.7.0.Final.jar;..\\lib\\slf4j-api-1.6.1.jar;..\\lib\\slf4j-log4j12-1.6.4.jar;..\\lib\\spring-aop-4.1.3.RELEASE.jar;..\\lib\\spring-aspects-4.1.3.RELEASE.jar;..\\lib\\spring-beans-4.1.3.RELEASE.jar;..\\lib\\spring-context-4.1.3.RELEASE.jar;..\\lib\\spring-core-4.1.3.RELEASE.jar;..\\lib\\spring-expression-4.1.3.RELEASE.jar;..\\lib\\spring-jdbc-4.1.3.RELEASE.jar;..\\lib\\spring-tx-4.1.3.RELEASE.jar;..\\lib\\spring-web-4.1.3.RELEASE.jar;..\\lib\\zkclient-0.10.jar;..\\lib\\zookeeper-3.4.8.jar 是所有jar的路径，通过-classpath将其加入到类路径中，这样就可以jvm就可以加载到这些jar中的.class或者资源文件 linux环境下运行问题问题1:启动provider以下是start.sh部分代码，linux下的执行脚本 12345678910111213141516171819JAVA_OPTS=&quot; -Djava.awt.headless=true -Djava.net.preferIPv4Stack=true &quot;JAVA_DEBUG_OPTS=&quot;&quot;if [ &quot;$1&quot; = &quot;debug&quot; ]; then JAVA_DEBUG_OPTS=&quot; -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=n &quot;fiJAVA_JMX_OPTS=&quot;&quot;if [ &quot;$1&quot; = &quot;jmx&quot; ]; then JAVA_JMX_OPTS=&quot; -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false &quot;fiJAVA_MEM_OPTS=&quot;&quot;BITS=`java -version 2&gt;&amp;1 | grep -i 64-bit`if [ -n &quot;$BITS&quot; ]; then JAVA_MEM_OPTS=&quot; -server -Xmx2g -Xms2g -Xmn256m -XX:PermSize=128m -Xss256k -XX:+DisableExplicitGC -XX:+UseConcMarkSweepGC -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:LargePageSizeInBytes=128m -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=70 &quot;else JAVA_MEM_OPTS=&quot; -server -Xms1g -Xmx1g -XX:PermSize=128m -XX:SurvivorRatio=2 -XX:+UseParallelGC &quot;fiecho -e &quot;Starting the $SERVER_NAME ...\\c&quot;nohup java $JAVA_OPTS $JAVA_MEM_OPTS $JAVA_DEBUG_OPTS $JAVA_JMX_OPTS -classpath $CONF_DIR:$LIB_JARS com.alibaba.dubbo.container.Main &gt; $STDOUT_FILE 2&gt;&amp;1 &amp; 注意： java $JAVA_OPTS $JAVA_MEM_OPTS $JAVA_DEBUG_OPTS $JAVA_JMX_OPTS -classpath $CONF_DIR:$LIB_JARS com.alibaba.dubbo.container.Main &gt; $STDOUT_FILE 2&gt;&amp;1 &amp; 使用了JVM参数，如果配置不当，则会导致服务无法启动，直接jvm错误（产生hs_err_pid8647.log日志文件） 目前不会配置，因此直接删除JVM参数即可,java -classpath $CONF_DIR:$LIB_JARS com.alibaba.dubbo.container.Main &gt; $STDOUT_FILE 2&gt;&amp;1 &amp; 问题2：consumer调用provider​ consumer调用provider总是产生Timeout,原本是以为服务运行时间过长导致的，于是在provider中 的META-INF/spring/application-dubbo.xml配置 12&lt;!-- 设置超时时间 --&gt;&lt;dubbo:provider timeout=&quot;5000&quot;&gt;&lt;/dubbo:provider&gt; 在dubbo-admin中可以看到超时时间被设置为5s，但是还是出现Timeout,不是该问题 以下是报异常的部分代码 root cause: 12345678910111213141516171819202122232425262728293031323334353637383940com.alibaba.dubbo.remoting.TimeoutException: Waiting server-side response timeout. start time: 2019-08-26 19:52:03.221, end time: 2019-08-26 19:52:08.222, client elapsed: 0 ms, server elapsed: 5001 ms, timeout: 5000 ms, request: Request [id=6, version=2.0.0, twoway=true, event=false, broken=false, data=RpcInvocation [methodName=selectUsersAll, parameterTypes=[], arguments=[], attachments=&#123;path=com.bjsxt.dubbo.service.FindUserDubboService, interface=com.bjsxt.dubbo.service.FindUserDubboService, version=0.0.0, timeout=5000&#125;]], channel: /192.168.1.112:48407 -&gt; /192.168.1.113:20880 com.alibaba.dubbo.remoting.exchange.support.DefaultFuture.get(DefaultFuture.java:136) com.alibaba.dubbo.remoting.exchange.support.DefaultFuture.get(DefaultFuture.java:113) com.alibaba.dubbo.rpc.protocol.dubbo.DubboInvoker.doInvoke(DubboInvoker.java:97) com.alibaba.dubbo.rpc.protocol.AbstractInvoker.invoke(AbstractInvoker.java:144) com.alibaba.dubbo.monitor.support.MonitorFilter.invoke(MonitorFilter.java:75) com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:69) com.alibaba.dubbo.rpc.protocol.dubbo.filter.FutureFilter.invoke(FutureFilter.java:54) com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:69) com.alibaba.dubbo.rpc.filter.ConsumerContextFilter.invoke(ConsumerContextFilter.java:48) com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:69) com.alibaba.dubbo.rpc.listener.ListenerInvokerWrapper.invoke(ListenerInvokerWrapper.java:74) com.alibaba.dubbo.rpc.protocol.InvokerWrapper.invoke(InvokerWrapper.java:53) com.alibaba.dubbo.rpc.cluster.support.FailoverClusterInvoker.doInvoke(FailoverClusterInvoker.java:77) com.alibaba.dubbo.rpc.cluster.support.AbstractClusterInvoker.invoke(AbstractClusterInvoker.java:229) com.alibaba.dubbo.rpc.cluster.support.wrapper.MockClusterInvoker.invoke(MockClusterInvoker.java:72) com.alibaba.dubbo.rpc.proxy.InvokerInvocationHandler.invoke(InvokerInvocationHandler.java:52) com.alibaba.dubbo.common.bytecode.proxy1.selectUsersAll(proxy1.java) com.bjsxt.service.impl.UserServiceImpl.selectUserAll(UserServiceImpl.java:42) com.bjsxt.controller.UsersController.findAll(UsersController.java:31) sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) java.lang.reflect.Method.invoke(Method.java:483) org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:221) org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:137) org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:110) org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:777) org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:706) org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85) org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:943) org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:877) org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:966) org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:857) javax.servlet.http.HttpServlet.service(HttpServlet.java:621) org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:842) javax.servlet.http.HttpServlet.service(HttpServlet.java:728) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51) org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88) org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) 问题解决： ​ provider(192.168.1.113)中使用的是192.168.1.103的主机的mysql,而192.168.1.103的防火墙需要打开 ​ 然后重启provider即可. 注意： ​ consumer和provider两台主机需要开放dubbo协议连接的所需端口(连接形成一个channel: /192.168.1.112:52877 -&gt; /192.168.1.113:20880) ​ 1）provider：配置服务端口 ​ linux中开放服务端口，例如20880（或者关闭防火墙，否则consumer启动失败） ​ iptables相关配置： 1234561)iptables -nL --line-number 查看规则，行号2)iptables -D INPUT 6 删除行号为6的规则# 因为最后一行是reject-with icmp-host-prohibited，拒绝所有,因此需要插入到最后一行前面3)iptables -I INPUT 3 -p tcp --dport 8080 -j ACCEPT 添加规则插入到第3行，#注意不要使用service iptables restart,否则规则会到最后一行4)iptables-save 保存即可 ​ 2）consumer: ​ 请求连接并获得回应：channel: /192.168.1.112:37711 -&gt; /192.168.1.113:20880 注意：37711端口没有开放为什么可以得到回应? 12345IPtable第一条规则1 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 state RELATED,ESTABLISHED 这个想要进入的封包是否为刚刚我发出去的回应?如果是刚刚我发出去的回应,那麼就可以予以接受放行.ESTABLISHED：已建立的链接状态.RELATED：该封包为本机发出的封包有关. 192.168.1.112:37711向192.168.1.113:20880请求服务，provider处理完毕，再通过192.168.1.113:20880将结果回应给192.168.1.112:37711。 由于是37711建立的连接，按照iptables的第一条规则所以允许接收，因此consumer的37711这个端口可以不建立iptables放行规则。 Dubbo注册IP混乱的问题windows​ 关闭其他网卡服务，例如虚拟机的vmnet1,vmnet8 linuxa) 通过hostname命令得到机器名b) 通过vim /etc/hosts设置机器名对应的外网IP127.0.0.1 localhost localhost.localdomain外网IP VM_31_182_centos 示例配置: 123127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6192.168.1.112 slave1 consumer启动问题以及远程部署远程部署consumer​ 通过maven插件远程部署consumer(一个web项目)至tomcat，由于 zookeeper 注册中心没有开启， 因此consumer无法从zookeeper获取服务接口信息，初始化会失败，即项目启动失败。 注意： ​ 远程部署需要配置tomcat用户,conf/tomcat-users.xml 123&lt;role rolename=&quot;manager-gui&quot;/&gt;&lt;role rolename=&quot;manager-script&quot;/&gt;&lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager-gui,manager-script&quot;/&gt; 将consumer项目拷贝至tomcat的webapps下注意： ​ 在consumer的项目中，如果使用的某些路径是/,则要将其拷贝至ROOT中 将consumer拷贝至webapps目录下，启动tomcat,如果zookeeper注册中心没有启动， 或者zookeeper启动但是consumer无法获取需要的服务接口信息，都会导致consumer启动 失败.","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"solor全文检索服务","slug":"JavaAdvancedTechnology/Solr/Solr全文检索服务","date":"2019-08-25T09:46:31.000Z","updated":"2019-09-03T03:05:19.949Z","comments":true,"path":"2019/08/25/JavaAdvancedTechnology/Solr/Solr全文检索服务/","link":"","permalink":"http://yoursite.com/2019/08/25/JavaAdvancedTechnology/Solr/Solr全文检索服务/","excerpt":"","text":"全文检索为什么使用全文检索说明​ 没有使用全文检索的时候，大部分会利用WHERE子句匹配LIKE关键词，在庞大的数据字段中搜索某些想要的字，如： select * from test WHERE Notes LIKE ‘%你好%’ ​ 然而这种查询方式非常没有效率，即使在Notes字段建立了一般的索引，帮助也不大，因为SQL SERVER为数据表建立的索引是排序过的数据结构。因此，可以用二分搜索算法来快速寻找数据，但搜索’%你好%’可没有什么顺序可言，因为搜索条件以’%’开头.全文检索则提供完全不同的索引架构，以关键词为基础建立全文检索索引。搭配特有的SQL查询语法，对于大型文本的字词查询更具弹性和效率 例1： 123456我们有一个表大概有50万条数据，其中有一个字段是字符串类型需要实现like 模糊查询，我们使用的是mysql，虽然已经建立了索引，但是由于使用的是%a%模式匹配，很不给力，在大量并发下，数据库会挂掉，或者用户等到抓狂查询结果还不出来，后来想出了一个办法解决了这个问题，每次查询可以控制在15ms左右，效果很是不错。我们采用是全文索引技术：1、使用lucene或者其他可以提供全文索引的nosql数据库，比如tt server或mongodb2、把需要模糊查询的字段的字符串数据进行”全分词“，即把所有可能分词都枚举出来，比如abc,可以分成a,ab,abc,b,bc,c3、把这些分好的term建立索引，如果使用lucene则需要建立一个分词器，能把传入的字符串分解成第2步描述的分词后建立索引，如果使用的是mongodb，则把分好的词存入一个字段并且建立索引，如果使用的tt server，那就简单了，直接建立qgram类型的索引即可，不需要自己去分词，我们最终就是使用tt server解决的问题4、使用各自提供的查询语法进行查询，绝对高效最终采用tt server的qgram方式实现，50多万条数据的模糊查询时间不超过15毫秒，有缓存的情况可能是0ms。 例2：mysql的全文索引与like实现 12345678在数据库使用中，DBA都会告诉大家SQL的LIKE条件为%XXX%号时，由于不能使用索引，当数据量变大时(比如超过百万条)，全表扫描会导致性能很差。 但是在实际业务中，很难避免MySQL全文检索并Like索引的这种需求。比如模糊搜索用户帐号，昵称之类。既然这个需求必须做，但又不可以直接用LIKE。这里我和大家分享一下我们关于这种需求的一种解决方案。当然别人也可能采用过类似的办法，我不是很清楚。所以也用一下“原创”吧。 MySQL数据库很早就支持全文索引，但是全文索引和LIKE语句是不同的。具体点说，全文索引的单位是词，耳LIKE匹配的是字符。当然实际的区别更大，比如“老鼠爱大米”这段文本用全文搜索的话，条件“老鼠爱大米”，“老鼠和大米”，“大米老鼠”，“大米与老鼠”会搜索到内容，但是“爱”，“鼠爱”，“爱大”不会搜索到内容。反之，使用LIKE搜索时，“老鼠和大米”，“大米老鼠”，“大米与老鼠”不会找到内容，而“爱”，“鼠爱”，“爱大”会找到内容。我们这里不讨论两种方式的优劣，根据实际情况每种功能都会有各自的实际需求。比如对于大段文本，全文检索是最好的方法，但是对于姓名，帐号，昵称等很短的通常无意义文本，LIKE会更合适一些。 虽然全文检索和LIKE搜索不同，但是在特殊情况下，可以用全文搜索功能来实现LIKE搜索。具体就是每个字符作为一个词，而且使用双引号来限制词精确匹配(简单点说就是老鼠大米和大米老鼠不同)，这样可以实现LIKE搜索的功能。 来自：https://www.cnblogs.com/bobsoft/archive/2012/10/07/2714545.html 例3： 123456当我们访问购物网站的时候，我们可以根据我们随意所想的内容输入关键字就可以查询出相关的内容，这是怎么做到呢？这些随意的数据不可能是根据数据库的字段查询的，那是怎么查询出来的呢，为什么千奇百怪的关键字都可以查询出来呢？答案就是全文检索工具的实现，luncence采用了词元匹配和切分词。举个例子：北京天安门----luncence切分词：北京 京天 天安 安门 等等这些分词。所以我们搜索的时候都可以检索到。有一种分词器就是IKanalyzer中文分词器，它有细粒度切分和智能切分，即根据某种智能算法。这就使用solr的最大的好处：检索功能的实现。来自：https://blog.csdn.net/jokeylin/article/details/80562148 有数据库为什么要solr​ lucene负责数据存储，而solr只是一个引擎提供搜索和插入而已，跟数据库的解释器一样，有什么好处呢，比如一个数据库有一个字段存了1000个字，你想从这些字里面搜一个词的时候，普通的数据库只会让你使用like去查询，他会遍历每个字去模糊匹配，效率很低，而且有些是无法查询的，当然除了像一些特殊的数据库带有分词，比如postgresql，那lucene做的事情就是分词，然后去匹配分词的词中是否有你想搜的词就好了，当然了，为了提高这种检索效率和内存节省底层做了很复杂的事情，可以这么简单的认为，全文搜索这件事情上数据库是无法满足的 二​ 大型的SQL数据库上很难执行高速的查询。Solr是Apache 下的一个开源项目，使用Java基于Lucene开发的全文检索服务；它是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。用户可以通过http请求，向搜索引擎服务器提交一定格式的XML文件，生成索引；也可以通过Http Get操作提出查找请求，并得到XML格式的返回结果。 ​ 为什么使用solr??????? 第一点原因来自SQL数据库在性能上缺乏亮点。基本上，你需要在你的查询中使用JOIN操作。 第二点原因是文档的天然数据特性：松散的文本文件，这种查询都是需要使用LIKE。然而joins和likes都是性能杀手，在目前的数据库引擎中是不方便的。 所以，很多时候希望找到一种跟SQL完全不同的数据检索方式：倒排索引。 这种数据结构类似与美化过的词典： key是单个的term values是跟term对应的文档列表 这种数据方式可以帮助在大型的数据库上面进行高速查询。 全文检索定义数据分类我们生活中的数据总体分为两种：结构化数据和非结构化数据。 结构化数据：指具有固定格式或有限长度的数据，如数据库中的数据，元数据等。 非结构化数据：指不定长或无固定格式的数据，如邮件，word文档等磁盘上的文件。 非结构化数据查询方法顺序扫描法(Serial Scanning)​ 所谓顺序扫描，比如要找内容包含某一个字符串的文件，就是一个文档一个文档的看，对于每一个文档，从头看到尾，如果此文档包含此字符串，则此文档为我们要找的文件，接着看下一个文件，直到扫描完所有的文件。如利用windows的搜索也可以搜索文件内容，只是相当的慢。 全文检索(Full-text Search)​ 将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之索引。例如：字典。字典的拼音表和部首检字表就相当于字典的索引，对每一个字的解释是非结构化的，如果字典没有音节表和部首检字表，在茫茫辞海中找一个字只能顺序扫描。然而字的某些信息可以提取出来进行结构化处理，比如读音，就比较结构化，分声母和韵母，分别只有几种可以一一列举，于是将读音拿出来按一定的顺序排列，每一项读音都指向此字的详细解释的页数。我们搜索时按结构化的拼音搜到读音，然后按其指向的页数，便可找到我们的非结构化数据——也即对字的解释。这种先建立索引，再对索引进行搜索的过程就叫全文检索(Full-text Search)。虽然创建索引的过程也是非常耗时的，但是索引一旦创建就可以多次使用，全文检索主要处理的是查询，所以耗时间创建索引是值得的。 如何实现全文检索可以使用Lucene实现全文检索。Lucene是apache下的一个开放源代码的全文检索引擎工具包（提供了Jar包，实现全文检索的类库）。它提供了完整的查询引擎和索引引擎，部分文本分析引擎。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便地在目标系统中实现全文检索的功能。注意：Lucene只是一个引擎，只是一个工具包，如果使用Lucene开发全文检索功能，要记住Lucene是不能单独运行的。 全文检索技术的应用场景对于数据量大、数据结构不固定的数据可采用全文检索方式搜索。例如： 使用全文检索技术可以实现搜索引擎（百度、google…），搜索引擎可以搜索互联网上所有的内容（网页、pdf电子书、视频、音乐）。Lucene和搜索引擎的区别：搜索引擎是对外提供全文检索服务，是可以单独运行的。Lucene只是一个工具包不能单独运行，需要在project中加入lucene的jar包，最终project在JVM中运行。使用全文检索技术可以实现站内搜索，站内搜索只能搜索本网站的信息（网页、pdf电子书、视频、音乐、关系数据库中的信息等等），比如：电商网站搜索商品信息，论坛网站搜索网内帖子。 总结全文检索过程分为索引、搜索两个过程： 索引从关系数据库中、互联网上、文件系统采集源数据(要搜索的目标信息)，源数据的来源是很广泛的。将源数据采集到一个统一的地方，要创建索引，将索引创建到一个索引库（文件系统）中，从源数据库中提取关键信息，从关键信息中抽取一个一个词，词和源数据是有关联的。也即创建索引时，词和源数据有关联，索引库中记录了这个关联，如果找到了词就说明找到了源数据（http的网页、pdf电子书等……）。 搜索用户执行搜索（全文检索）编写查询关键字。从索引库中搜索索引，根据查询关键字搜索索引库中的一个一个词。展示搜索的结果。 全文检索实现创建索引​ 对文档索引的过程，将用户要搜索的文档内容进行索引，索引存储在索引库（index）中。这里我们要搜索的文档是磁盘上的文本文件，根据案例描述：凡是文件名或文件内容包括关键字的文件都要找出来，这里要对文件名和文件内容创建索引。 获得原始文档​ 原始文档是指要索引和搜索的内容。原始内容包括互联网上的网页、数据库中的数据、磁盘上的文件等 ​ 从互联网上、数据库、文件系统中等数据源处获取需要搜索的原始信息，这个过程就是信息采集，信息采集的目的是为了对原始内容进行索引。针对不同的源数据，使用不同的技术进行采集获得原始文档： 针对互联网上的数据，使用http协议抓取html网页到本地，生成一个html文件。针对关系数据库中的数据，连接数据库读取表中的数据。针对文件系统中的数据，通过流读取文件系统的文件。 以上技术中使用第一种较多，因为目前全文检索主要搜索数据的来源是互联网，在Internet上采集信息的软件通常称为爬虫或蜘蛛，也称为网络机器人，爬虫访问互联网上的每一个网页，将获取到的网页内容存储起来，所以搜索引擎使用一种爬虫程序抓取网页（ 通过http抓取html网页信息）。Lucene不提供信息采集的类库，需要自己编写一个爬虫程序实现信息采集，也可以通过一些开源软件实现信息采集，以下是一些爬虫项目（了解）： 1234Solr（http://lucene.apache.org/solr），solr是apache的一个子项目，支持从关系数据库、xml文档中提取原始数据。Nutch（http://lucene.apache.org/nutch）, Nutch是apache的一个子项目，包括大规模爬虫工具，能够抓取和分辨web网站数据。jsoup（http://jsoup.org/ ），jsoup是一款Java的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。Heritrix（http://sourceforge.net/projects/archive-crawler/files/），Heritrix是一个由java开发的、开源的网络爬虫，用户可以使用它来从网上抓取想要的资源。其最出色之处在于它良好的可扩展性，方便用户实现自己的抓取逻辑。 创建文档对象分析文档创建索引查询索引用户查询接口创建查询执行查询渲染结果Solr集群配置的一些说明​ 1)安装zookeeper集群，做配置管理 ​ 2)安装四个tomcat,和四个索引库，依旧是一对一(solr的web服务中web.xml配置索引库的绝对路径) ​ 3)上传索引库的配置文件至zookeeper(索引库目录下的collection/conf) ​ 4)修改每一个索引库下的 solr.xml,指定当前实例运行的ip地址及端口号 ​ 5)修改每一台solr的tomcat的bin目录下 catalina.sh文件中加入DzkHost指定zookeeper服务器地址 ​ JAVA_OPTS=”-DzkHost=192.168.70.147:2181,192.168.70.147:2182,192.168.70.14 7:2183” ​ 注意：加入JAVA_OPTS的参数的含义，也就是程序可以读取该键值对配置 12345678910111213141516171819202122JVM自定义参数通过java命令的可选项:-D&lt;name&gt;=&lt;value&gt;来传入JVM，传入的参数作为system的property。因此在程序中可以通过下面的语句获取参数值：System.getProperty(&lt;name&gt;)public class JVMParameter &#123; /** * 运行前设置JVM参数 -Djvm.index=1 * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub String jvmIndex = System.getProperty(&quot;jvm.index&quot;); System.out.println(&quot;jvmIndex=&quot; + jvmIndex); &#125;&#125;运行class命令：java -Djvm.index=1 JVMParameter说明：JVM自定义参数可用来在集群环境区分当前class运行在哪个JVM上，可以达到让某个class只在某个指定的JVM上运行，避免多个JVM同时运行，出现混乱。也可以作为程序读取的配置信息 参考： ​ https://blog.csdn.net/qq_16162981/article/details/70142166 ​ https://blog.csdn.net/yerenyuan_pku/article/details/72582979","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Maven项目构建工具","slug":"Tools/Maven项目构建工具","date":"2019-08-14T15:24:08.000Z","updated":"2019-08-16T10:00:13.477Z","comments":true,"path":"2019/08/14/Tools/Maven项目构建工具/","link":"","permalink":"http://yoursite.com/2019/08/14/Tools/Maven项目构建工具/","excerpt":"","text":"MavenMaven 简介​ Maven 是一个项目管理工具，它包含了一个项目对象模 型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管 理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标 (goal)的逻辑! IDEA使用Maven遇到的坑tomcat插件​ tomcat:run ​ 如果没有在src/main下找到webapp，则就直接启动，因此就算删除webapp目录还是可以启动tomcat 如果找到了webapp目录,就将当前项目发布(并不会在target中生成war包) 使用maven打war包后放入tomcat运行​ 打包时的项目根路径有两种方式： 1）默认从src/main/webapp作为项目根目录 ​ 2）在pom文件中指定 1234567891011&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;!-- 指定web.xml的路径--&gt; &lt;webXml&gt;web\\WEB-INF\\web.xml&lt;/webXml&gt; &lt;!-- 指定jsp、js、css的路径 --&gt; &lt;warSourceDirectory&gt;web&lt;/warSourceDirectory&gt; &lt;/configuration&gt; &lt;/plugin&gt; ​ 注意:打war包可以，但是指定的项目目录不被maven的tomcat插件识别，无法发布比较坑 3）将war包放到到tomcat的webapps目录进行发布 ​ 注意: ​ 路径问题: ​ 引入： ​ 例如：IDEA发布时使用Application context为/, ​ 即使用http://localhost:8080就可以访问项目 ​ 但是，在重定向时路径/表示服务器根路径， ​ 则路径写法：/项目名/需要跳转的路径 ​ 如果写死,项目在需要使用项目名或者不需要使用项目名访问时，访问就会出现问题 ​ 或者是jsp文件中路径 ​ 解决： ​ 项目中最好使用req.getContextPath() + “/login”来得到工程名+路径 ​ 这样在发布时有没有项目名都可以正常运行 ​ jsp文件可以使用基路径来控制:先得到路径，再使用basePath标签 ​","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/tags/tools/"}]},{"title":"tomcat9.0的filter拦截静态资源问题","slug":"Java Web/tomcat9.0的filter拦截静态资源问题","date":"2019-08-13T15:33:08.000Z","updated":"2019-08-14T04:28:33.026Z","comments":true,"path":"2019/08/13/Java Web/tomcat9.0的filter拦截静态资源问题/","link":"","permalink":"http://yoursite.com/2019/08/13/Java Web/tomcat9.0的filter拦截静态资源问题/","excerpt":"","text":"引入tomcat9.0中，servlet-api.jar中的Filter接口有三个方法： ​ init(): public default void init(FilterConfig filterConfig); ​ doFilter(): public void doFilter(ServletRequest request, ServletResponse response,FilterChain chain); ​ destory(): public default void destroy(); init()和destory()有default修饰，也就是说， 可以不实现init()和destory()方法，实现该接口的类会继承这两个方法 无法解决的问题？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？ 定义MyFilter实现Filter接口，重写doFilter()方法，拦截路径/*，这样会拦截所有的资源。 接着，对请求和响应进行设置编码格式,再放行 123456789101112@Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; //设置请求编码格式 request.setCharacterEncoding(&quot;utf-8&quot;); //设置响应编码格式 response.setCharacterEncoding(&quot;utf-8&quot;); //浏览器的解码格式 response.setContentType(&quot;text/html;charset=utf-8&quot;); //放行 chain.doFilter(request, response); &#125; 问题出现: ​ 访问静态资源全部变成document类型 ​ 例如访问一个图片，该图片会以文档的形式被浏览器解析 问题定位: ​ 设置响应编码格式的问题，具体原因 ​ 浏览器解析成text/html格式 ​ response.setContentType(“text/html;charset=utf-8”); ​ 解决: ​ 解决1 ​ tomcat7不会出现该问题 ​ 解决2： ​ 对静态资源，非静态资源进行判断 ​ 如果是静态资源，不设置响应编码格式 ​ 默认会自动设置响应格式 ​ 例如：图片格式Content-Type:image/jpeg;charset=utf-8 ​ 如果是非静态资源，再设置响应编码格式","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"servlet中的请求路径","slug":"Java Web/servlet中的请求路径","date":"2019-08-09T07:23:02.000Z","updated":"2019-08-10T16:04:20.452Z","comments":true,"path":"2019/08/09/Java Web/servlet中的请求路径/","link":"","permalink":"http://yoursite.com/2019/08/09/Java Web/servlet中的请求路径/","excerpt":"","text":"关于servlet配置中 / 和 /*配置为 / ，结果 test、test.do、test.html 都可以请求到，但是test.jsp请求不到 “/‘表示匹配所有请求（其中包含除.jsp和.jspx外的所有后缀）。 如果不配置静态资源，它会把匹配所有请求都当做是对控制器的访问，去掉后缀进行匹配。例如你访问/main.css会变成/main，这也是造成你引入的.css,.js等静态资源无法访问的原因，因为他们都被当做控制器的路径了。 12345&lt;url-pattern&gt;/&lt;/url-pattern&gt;这个/不会覆盖任何其他servlet。它只对所有请求替换servlet容器的内置默认servlet，这与任何其他注册的servlet都不匹配。这通常只在静态资源(CSS/JS/Image/etc)和目录清单上调用。servlet容器的内置默认servlet还能够处理HTTP缓存请求、媒体(音频/视频)流和文件下载恢复。通常，您不希望覆盖默认的servlet，因为否则您就必须处理它的所有任务，这并不简单(JSF实用程序库)OmniFaces有一个开源 例)。因此，这也是servlet的一个糟糕的URL模式。至于为什么JSP页面不访问这个servlet，这是因为servlet容器的内置JSPservlet将被调用，默认情况下，它已经映射到了更具体的URL模式上*.jsp. 配置为 /* ，结果 test、test.do、test.html、test.jsp 都可以请求到，这意味着如果你配置成这个，跳转回jsp页面都会被拦截，所以需要注意 “/*“表示匹配所有请求（包含所有后缀） 这里*.jsp比”/\\“的匹配度低，所以配置后会使.jsp也进入DispatcherServlet,而.jsp既不是控制器路径也不是静态资源，所以就算配了静态资源还是访问不到，所以这个/*的配置不适用于DispatcherServlet,一般用于过滤器来拦截所有资源 123&lt;url-pattern&gt;/*&lt;/url-pattern&gt;这个/*在servlet上覆盖所有其他servlet，包括servlet容器提供的所有servlet，比如默认的servlet和JSP servlet。不管您发出什么请求，它都将在那个servlet中结束。因此，对于servlet来说，这是一个糟糕的URL模式。 通常，/\\在上Filter使用。它可以通过调用FilterChain#doFilter().放行* 参考1：https://www.cnblogs.com/coder-lichao/p/10698996.html /*.do错误Servlet和filter是J2EE开发中常用的技术，使用方便，配置简单，老少皆宜。 估计大多数朋友都是直接配置用，也没有关心过具体的细节，今天遇到一个问题，上网查了servlet的规范才发现，servlet和filter中的url-pattern还是有一些文章在里面的，总结了一些东西，放出来供大家参考，以免遇到问题又要浪费时间。 一、servlet容器对url的匹配过程 当一个请求发送到servlet容器的时候，容器先会将请求的url减去当前应用上下文的路径作为servlet的映射url，比如我访问的是 http://localhost/test/aaa.html，我的应用上下文是test，容器会将http://localhost/test去掉， 剩下的/aaa.html部分拿来做servlet的映射匹配。这个映射匹配过程是有顺序的，而且当有一个servlet匹配成功以后，就不会去理会剩下 的servlet了（filter不同，后文会提到）。其匹配规则和顺序如下： 1. 精确路径匹配。例子：比如servletA 的url-pattern为 /test，servletB的url-pattern为 /* ，这个时候，如果我访问的url为http://localhost/test ，这个时候容器就会先进行精确路径匹配，发现/test正好被servletA精确匹配，那么就去调用servletA，也不会去理会其他的 servlet了。 2. 最长路径匹配。例子：servletA的url-pattern为/test/，而servletB的url-pattern为/test/a/，此 时访问http://localhost/test/a时，容器会选择路径最长的servlet来匹配，也就是这里的servletB. 3. 扩展匹配，如果url最后一段包含扩展，容器将会根据扩展选择合适的servlet.例子：servletA的url-pattern：*.action 4. 如果前面三条规则都没有找到一个servlet，容器会根据url选择对应的请求资源。如果应用定义了一个default servlet，则容器会将请求丢给default servlet（什么是default servlet？后面会讲）。 根据这个规则表，就能很清楚的知道servlet的匹配过程，所以定义servlet的时候也要考虑url-pattern的写法，以免出错。 对于filter，不会像servlet那样只匹配一个servlet，因为filter的集合是一个链，所以只会有处理的顺序不同，而不会出现只选择一个filter.Filter的处理顺序和filter-mapping在web.xml中定义的顺序相同。 二、url-pattern详解 在web.xml文件中，以下语法用于定义映射： 以“/‘开头和以”/*“结尾的是用来做路径映射的 以前缀“*.”开头的是用来做扩展映射的 “是用来定义default servlet映射的。 剩下的都是用来定义详细映射的。比如： /aa/bb/cc.action 所以，为什么定义“/*.action”这样一个看起来很正常的匹配会错？因为这个匹配即属于路径映射，也属于扩展映射，导致容器无法判断。 原文：https://passw0rd-j.iteye.com/blog/2156919","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"java中调用父类方法之super关键字","slug":"JavaSE/java中调用父类方法之super关键字","date":"2019-08-04T15:12:33.000Z","updated":"2019-08-04T15:24:51.360Z","comments":true,"path":"2019/08/04/JavaSE/java中调用父类方法之super关键字/","link":"","permalink":"http://yoursite.com/2019/08/04/JavaSE/java中调用父类方法之super关键字/","excerpt":"","text":"123456789101112131415161718192021222324252627 class Father &#123; String name; int age; public void test() &#123; System.out.println(\"我是父类的test()方法\"); System.out.println(\"父类姓名=\" + this.name + \" 父类年龄=\" + this.age); &#125; &#125; public class Son extends Father &#123; public void test() &#123; super.test(); System.out.println(\"我是子类的test()方法\"); System.out.println(\"子类姓名=\" + this.name + \" 子类年龄=\" + this.age); &#125; public static void main(String[] args) &#123; Son son = new Son(); son.name = \"test\"; son.age = 18; son.test(); &#125; &#125; 理解1： 1）我觉得super.test()只是在说调用父类中的test方法，并不是说用父类对象来调用父类的test方法。而你使用son子对象来调用子类的test方法，此时虽然子类test中有父类的test方法，但是你此时是使用son子对象来调用父类的test方法的，所以父类的test方法里面的this指的是调用该方法的son子对象 2）这里面的super关键词，我觉得就是作为一个对于父类的方法的指示。参考Java核心卷；有些人认为 super 与 this 引用是类似的概念， 实际上，这样比较并不太恰当。这是因为 super 不是一个对象的引用， 不能将 super 赋给另一个对象变量， 它只是一个指示编译器调用超类方法的特殊关键字. 理解2： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Servlets &#123; public void service(String req,String resp)&#123; System.out.println(&quot;Servlets:service:(1)&quot;); if(req.equals(&quot;doGet&quot;))&#123; doGet(); &#125;else if(resp.equals(&quot;doPost&quot;))&#123; doPost(); &#125; &#125; public void doGet()&#123; System.out.println(&quot;Servlets.doGet:(2)&quot;); int i=1/0; &#125; public void doPost() &#123; System.out.println(&quot;Servlets.doPost:(3)&quot;); int i=1/0; &#125;&#125;public class Son extends Servlets&#123; @Override public void service(String req, String resp) &#123; // TODO Auto-generated method stub System.out.println(&quot;Son.service:(4)&quot;); super.service(req, resp); &#125; @Override public void doGet() &#123; // TODO Auto-generated method stub System.out.println(&quot;Son.doGet:(5)&quot;); super.doGet(); &#125; @Override public void doPost() &#123; // TODO Auto-generated method stub System.out.println(&quot;Son.doPost(6)&quot;); super.doPost(); &#125; &#125;//测试类public class Test &#123; public static void main(String[] args) &#123; Son son=new Son(); son.service(&quot;doGet&quot;,&quot;&quot;); &#125;&#125; 打印结果： 12345678910Son.service:(4)Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zeroServlets:service:(1)Son.doGet:(5)Servlets.doGet:(2) at com.servlet_source_test.Servlets.doGet(Servlets.java:14) at com.servlet_source_test.Son.doGet(Son.java:16) at com.servlet_source_test.Servlets.service(Servlets.java:7) at com.servlet_source_test.Son.service(Son.java:9) at com.servlet_source_test.Test.main(Test.java:6) 分析：son对象调用service，service中调用super.service(),父类的service中调用this.doGet()方法，很明显调用的是子类的doGet()方法,该this是son对象， super只是一个指示编译器调用超类方法的特殊关键字.","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"jsp中的注释","slug":"Java Web/jsp中的注释","date":"2019-07-25T15:08:03.000Z","updated":"2019-07-25T15:20:12.327Z","comments":true,"path":"2019/07/25/Java Web/jsp中的注释/","link":"","permalink":"http://yoursite.com/2019/07/25/Java Web/jsp中的注释/","excerpt":"","text":"jsp注释&lt;%– – %&gt; 和 的区别本文为博主原创，未经允许，不得转载： ​ 最近在写jsp页面注释的时候，遇到一个问题，在jsp页面引用的静态属性资源文件时，在浏览器控制台报错，当我把 引用的标签注释掉后，用的是 1&lt;!----&gt; 。然后浏览器仍然报了之前那个的错，当经过查询以后，jsp页面注释代码推荐用 &lt;%—-%&gt;进行注释，两者的区别在于： ​ 用 1&lt;!----&gt; 注释jsp代码只能在客户端进行注释，其在加载的时候，仍然会经过服务器端进行加载解析，当加载解析不到的 时候，就会在浏览器控制台进行报错，且注释掉的代码，在浏览器控制台可以看见。而用&lt;%—-%&gt;进行注释的时候， 会在服务端也进行注释，在解析的时候会解析不到，而注释掉的代码，在浏览器控制台也是不可见的。 1例：&lt;%-- $&#123;1+1&#125;--%&gt;，这个经过解析加载之后，不会发生变化。 而用&lt;!-- $&#123;1+1&#125;--&gt;,这个进过加载和解析之后，会被解析为&lt;!--2--&gt; 来源：https://www.cnblogs.com/zjdxr-up/p/7954470.html","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/tags/jsp/"}]},{"title":"servlet学习","slug":"Java Web/servlet学习","date":"2019-07-22T12:54:03.000Z","updated":"2019-08-07T07:49:46.724Z","comments":true,"path":"2019/07/22/Java Web/servlet学习/","link":"","permalink":"http://yoursite.com/2019/07/22/Java Web/servlet学习/","excerpt":"","text":"Servlet学习Servlet介绍问题： ​ 服务器在接收到浏览器的请求后，会自动调用对应的逻辑代码进行请求 ​ 处理。但是逻辑代码是由程序员编写并放到服务器中，那么服务器怎么知道该怎 ​ 么调用并调用哪个类和哪个方法来进行请求处理。 解决： ​ 程序员在编写代码的时候如果能够按照服务器能够识别的规则进行编写， ​ 浏览器按照指定的规则进行发送请求，那么服务器就可以调用并执行响应的逻辑 ​ 代码进行请求处理了。 实现： ​ Servlet 技术 概念： ​ 狭义的 Servlet 是指 Java 语言实现的一个接口，广义的 Servlet 是 ​ 指任何实现了这个 Servlet 接口的类，一般情况下，人们将 Servlet 理解为后者。 ​ Servlet 运行于支持 Java 的应用服务器中。从原理上讲，Servlet 可以响应任何 ​ 类型的请求，但绝大多数情况下 Servlet 只用来扩展基于 HTTP 协议的 Web 服 务器 特点： ​ 运行在支持 java 的应用服务器上 ​ Servlet 的实现遵循了服务器能够识别的规则，也就是服务器会自动的根据请求调用对应的 servlet 进行请求处理。简单方便，可移植性强 使用： ​ 1、 创建普通的 java 类并继承 HttpServlet ​ 2、 覆写 service 方法 ​ 3、 在 service 方法中书写逻辑代码即可 ​ 4、 在 webRoot 下的 WEB-INF 文件夹下的 web.xml 文件中配配置 servlet ​ Servlet 的 web.xml 配置​ Web.xml 配置的作用： 保护 Servlet。 12345678910111213141516171819202122232425262728293031&lt;!-- 精确配置: &lt;url-pattern&gt;/路径名&lt;/url-pattern&gt; 注意:\"/\"是必须的，该配置项可以配置多个 模糊配置: &lt;url-pattern&gt;*.后缀名&lt;/url-pattern&gt; 注意: 所有以指定的后缀名结尾的请求会调用该servlet进行处理 作用: 进行模块化开发的划分 拦截所有请求: &lt;url-pattern&gt;/*&lt;/url-pattern&gt; 注意: 会拦截所有类型的请求，包括静态资源请求（css,js,图片）和jsp请求 拦截以某个名称开头的路径下的所有请求: &lt;url-pattern&gt;/one/*&lt;/url-pattern&gt; --&gt; &lt;servlet&gt; &lt;servlet-name&gt;my&lt;/servlet-name&gt; &lt;servlet-class&gt;com.szxy.servlet.MyServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;my&lt;/servlet-name&gt; &lt;url-pattern&gt;/my&lt;/url-pattern&gt; &lt;url-pattern&gt;/m&lt;/url-pattern&gt; &lt;!-- 配置2 --&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;!-- 配置3 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 加载时机： ​ 服务器启动的时候会将 webapps 中部署好的项目统一进行加载，并完成对每个项目的 web.xml 文件的加载。 注意： ​ 一个 Servlet 可有拥有多个 url-pattern 配置，但是 一个 url-pattern 配置只能对应一个 Servlet。 Servlet是单例的​ 服务器在接收到浏览器的请求后，会开辟一个线程来处理此次请求， 在线程中调用对应的Servlet进行处理。 服务器调用Servlet处理请求，但是一个Servlet服务器只会创建一个实例化对象，该对象是线程共享的。 ​ Servlet是单例的，只创建一个对象。 ​ Servlet的生命周期 Servlet的生命周期：从第一次被调用到服务器关闭 ​ init():servlet被初始化创建的时候调用 ​ service():处理请求的时候 ​ destory():Servlet对象被销毁的时候（服务器关闭时销毁Servlet对象） 注意： ​ 可以在web.xml中配置 123456&lt;servlet&gt; &lt;servlet-name&gt;LifeServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.szxy.servlet.LifeServlet&lt;/servlet-class&gt; &lt;!-- 配置servlet服务器启动时完成加载和初始化创建 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; 来设置Servlet加载时机为服务器启动（生命周期从服务器开启到服务器关闭） 本质：单例的懒汉式和饿汉式 ​ 注： 12345678910111213在servlet的配置当中，1的含义是：标记容器是否在启动的时候就加载这个servlet。当值为0或者大于0时，表示容器在应用启动时就加载这个servlet；当是一个负数时或者没有指定时，则指示容器在该servlet被选择时才加载。正数的值越小，启动该servlet的优先级越高。如果我们在web.xml中设置了多个servlet的时候，可以使用load-on-startup来指定servlet的加载顺序，服务器会根据load-on-startup的大小依次对servlet进行初始化。不过即使我们将load-on-startup设置重复也不会出现异常，服务器会自己决定初始化顺序。配置load-on-startup后，servlet在startup后立即加载，但只是调用servlet的init()方法，用以初始化该servlet相关的资源。初始化成功后，该servlet可响应web请求；如未配置load-on-startup，容器一般在第一次响应web请求时，会先检测该servlet是否初始化，如未初始化，则调用servlet的init()先初始化，初始化成功后，再响应请求。 PS：一般我们在开发web应用时，都会配置这个参数，有两个好处：1、如果初始化过程失败，则容器会提示启动失败，此时我们能够提前知道相关错误；2、配置该参数相当于将初始化servlet的工作转移到容器启动过程，使得容器只要启动成功后，就可立即响应web请求。--------------------- 作者：saiofo 来源：CSDN 原文：https://blog.csdn.net/u012393192/article/details/79323979 版权声明：本文为博主原创文章，转载请附上博文链接！ Servlet中的方法doGet(HttpServletRequest req, HttpServletResponse resp) 特点： ​ 处理get方式的请求 注意：如果在servlet中没有生命对应的请求处理方法，则会报405 doPost(HttpServletRequest req, HttpServletResponse resp) 特点： ​ 处理post方式的请求 service(HttpServletRequest req, HttpServletResponse resp) 特点： ​ 如果没有重写该方法，父类中调用service()方法进行请求转发（doGet(),doPost()） ​ 如果重写该方法，服务器会执行该方法 注意：tomcat服务器只会调用Servlet中service()方法(Servlet接口中只有service()方法)，如果没有覆写service(),则会调用父类HttpServlet中的service() Servlet 的常见错误总结​ 123456789101112131415161718192021222324Servlet的常见错误： 404错误:资源未找到 原因一：在请求地址中的servlet的别名书写错误。 原因二：虚拟项目名称拼写错误 500错误：内部服务器错误 错误一： java.lang.ClassNotFoundException: com.bjsxt.servlet.ServletMothod 解决： 在web.xml中校验servlet类的全限定路径是否拼写错误。 错误二： 因为service方法体的代码执行错误导致 解决： 根据错误提示对service方法体中的代码进行错误更改。 405错误:请求方式不支持 原因： 请求方式和servlet中的方法不匹配所造成的（调用父类的doGet() 或者doPost()方法） 解决： 尽量使用 service 方法进行请求处理，并且不要再 service 方法中调用父类的service Request 对象​ 问题： ​ 浏览器发起请求到服务器，会遵循HTTP协议将请求数据发送给服务器。 ​ 那么服务器接受到请求的数据改怎么存储呢?不但要存，而且要保证完整性。 ​ 解决： ​ 使用对象进行存储，服务器每接受一个请求，就创建一个对象专门的存 储此次请求的请求数据。 ​ 实现： ​ request 对象 ​ 解释： ​ 服务器接收到浏览器的请求后，会创建一个 Request 对象，对象中 存储了此次请求相关的请求数据。服务器在调用 Servlet 时会将创建的 Request 对象作为实参传递给 Servlet 的方法，比如：service 方法。 ​ 使用： ​ 获取请求头数据 ​ 获取请求行数据 ​ 获取用户数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126package com.szxy.servlet;import java.io.IOException;import java.util.Enumeration;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Request对象学习 * 获取请求数据： * 请求行：请求方式,请求URL,协议 * getMethod(); 返回请求方式 * getRequestURL() 返回请求url * getRequestURI() 返回请求uri * getQueryString() 返回get请求URL中的请求数据 * getScheme() 返回协议 * 请求头：getHeader(String name) * 注意：如果获取的请求头信息不存在则放回null * getHeaderNames() 返回存储请求头键名的枚举集合 * 请求实体： * getParameter(String name) 根据键名获取数据 * 注意: * 键名就是前端页面的表单标签的name属性的值或者其他方式提交的数据的键的名 * 如果没有对应的请求数据，则返回null * getParameterValues(String name) 根据键名获取同名不同的值，返回数组 * 注意：没有对应的键名，返回null * getParameterNames() 返回实体数据中键名的枚举 * 请求中的网络数据 * getRemoteAddr() 获取客户端ip * getRemotePort() 获取客户端的端口号 * getLocalAddr() 获取服务器端的ip * getLocalPort() 获取服务器端的端口 * @author Momentonly * */@WebServlet(&quot;/request&quot;)public class RequestServlet extends HttpServlet&#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求信息 //获取请求行信息 //获取请求方式 String method = req.getMethod(); System.out.println(&quot;请求方式:&quot; + method); //获取请求URL StringBuffer requestURL = req.getRequestURL(); System.out.println(&quot;请求URL:&quot; + requestURL.toString()); //获取请求URI String requestURI = req.getRequestURI(); System.out.println(&quot;请求URI:&quot; + requestURI); //获取get请求URL中的请求数据 String queryString = req.getQueryString(); System.out.println(&quot;获取get请求URL中的数据:&quot; + queryString); //获取协议 String scheme = req.getScheme(); System.out.println(&quot;获取请求协议:&quot; + scheme); //获取请求头信息 //根据键名获取请求头信息(如果不存在则返回null) String header = req.getHeader(&quot;User-Agent&quot;); System.out.println(&quot;获取浏览器版本信息&quot; + header); //获取请求头中键名的枚举 Enumeration&lt;String&gt; headerNames = req.getHeaderNames(); while(headerNames.hasMoreElements())&#123; //获取请求头键名 String name = headerNames.nextElement(); //获取请求头的键名对应的值 System.out.println(name + &quot;:&quot; + req.getHeader(name)); &#125; //获取请求实体数据（用户数据） //根据键名获取数据(如果请求中不存在键则返回null) String uname = req.getParameter(&quot;uname&quot;); String pwd = req.getParameter(&quot;pwd&quot;); System.out.println(&quot;请求实体数据:&quot; + uname + &quot;:&quot; + pwd); //获取同键不同值的实体数据 String[] favs = req.getParameterValues(&quot;fav&quot;); if(favs != null)&#123; //NullPointerException for(String s : favs)&#123; System.out.println(&quot;fav的值为&quot; + s); &#125; &#125; //获取请求实体中键名的枚举 Enumeration&lt;String&gt; names = req.getParameterNames(); while(names.hasMoreElements())&#123; //System.out.println(names.nextElement()); //判断 String name = names.nextElement(); if(&quot;fav&quot;.equals(name))&#123; String[] favs2 = req.getParameterValues(name); if(favs2 != null)&#123; for(String s : favs2)&#123; System.out.println(name + &quot;:&quot; + s); &#125; &#125; &#125;else&#123; String value = req.getParameter(name); System.out.println(name + &quot;:&quot; + value); &#125; &#125; //请求相关的网络数据 //获取客户端信息 String remoteAddr = req.getRemoteAddr(); System.out.println(&quot;客户端ip:&quot; + remoteAddr); //获取客户端的端口号(浏览器) int remotePort = req.getRemotePort(); System.out.println(&quot;客户端的端口号:&quot; + remotePort); //获取服务器主机ip String localAddr = req.getLocalAddr(); System.out.println(&quot;获取服务器ip:&quot; + localAddr); //获取服务器的端口号 int localPort = req.getLocalPort(); System.out.println(&quot;服务器端口号:&quot; + localPort); //处理请求信息 //响应处理结果 &#125;&#125; Response对象问题： ​ 在使用 Request 对象获取了请求数据并进行处理后，处理的结果如何显示到浏览器中呢？ 解决： ​ 使用 Response 对象 解释： ​ 服务器在调用指定的 Servlet 进行请求处理的时候，会给 Servlet 的方法 传递两个实参 request 和 response。 其中 request 中封存了请求相关的请求 数据，而 response 则是用来进行响应的一个对象。 使用： ​ 设置响应行 ​ 设置响应头 ​ 设置响应实体 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.szxy.servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Response对象 * 设置响应行： 协议 状态码 状态消息 * resp.sendError(int status) 自定义响应的状态码 * 设置响应头 * addHeader(String name, String value) 添加响应头信息，同名数据不会覆盖 * setHeader(String name, String value) 设置响应头信息，会覆盖原有信息，如果没有该响应头则添加 * 设置响应实体(处理结果) * resp.getWriter().write(&quot;实体内容&quot;); * 注意： * 实体内容可以分开响应 * * 注意：使用resp对象做出了请求响应，意味着此次请求处理完毕，服务器在响应后会将此次请求相关的req和resp对象销毁 * * @author Momentonly * */@WebServlet(&quot;/response&quot;)public class ResponseServlet extends HttpServlet&#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;ResponseServlet.service()&quot;); //获取请求数据 //处理请求数据 //响应处理结果 //设置响应行 //自定义响应404异常 //resp.sendError(404); //设置响应头 //添加响应头信息 resp.addHeader(&quot;mouse&quot;, &quot;thinkpad&quot;); resp.addHeader(&quot;mouse&quot;, &quot;thinkpad2&quot;); //设置响应头 //resp.setHeader(&quot;Content-Length&quot;, &quot;20&quot;); //resp.setHeader(&quot;mouse&quot;, &quot;two fly&quot;); //resp.setHeader(&quot;mouse&quot;, &quot;two fly2&quot;); //设置响应实体 resp.getWriter().write(&quot;resp object&quot;); resp.getWriter().write(&quot;resp object&quot;); &#125;&#125; 乱码问题​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.szxy.servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * 乱码问题 * 请求乱码（服务器获取的请求数据乱码） * post: * req.setCharacterEncoding(&quot;utf-8&quot;); * get: * 方式一： * String uname = req.getParameter(&quot;uname&quot;); String uname2 = new String(uname.getBytes(&quot;iso-8859-1&quot;),&quot;utf-8&quot;); * 方式二：配置tomcat的server.xml * req.setCharacterEncoding(&quot;utf-8&quot;); * 在tomcat中的server.xml中的Connecgtor标签中增加属性：useBodyEncodingForURI=&quot;true&quot; * 响应乱码（浏览器中显示的服务器响应数据乱码） * service流程 * 设置请求编码格式 * 设置响应编码格式 * 获取请求信息 * 处理请求信息 * 响应处理结果 * @author Momentonly * */@WebServlet(&quot;/code&quot;)public class CodeServlet extends HttpServlet&#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置请求编码格式 req.setCharacterEncoding(&quot;utf-8&quot;); //设置响应编码格式 //resp.setHeader(&quot;ontent-type&quot;,&quot;text/html;charset=utf-8&quot;); resp.setContentType(&quot;text/html;charset=utf-8&quot;); //获取请求数据 System.out.println(req.getMethod()); System.out.println(req.getRequestURI()); String uname = req.getParameter(&quot;uname&quot;); //String uname2 = new String(uname.getBytes(&quot;iso-8859-1&quot;),&quot;utf-8&quot;); //处理请求数据 System.out.println(uname); //响应处理结果 resp.getWriter().write(&quot;请求处理完毕&quot;); &#125;&#125; request中的setCharacterEncoding方法作用是用指定的编码集去覆盖request对象中的默认的”ISO-8859-1”编码集，这样request.getParameter(“”)方法就会用新的编码集去解码 请求转发转发问题： ​ 服务器在接收到浏览器的请求后，仅仅使用一个 Servlet 进行请求处理，会造成不同的 Servlet 逻辑代码冗 ​ 余，Servlet 的职责不明确。 解决： 使用请求转发。 特点： 降低servlet之间的代码冗余 ​ 一次请求转发内的servlet共享此次请求 ​ 浏览器地址栏信息不改变，一次请求 ​ 1req.getRequestDispatcher(&quot;转发的路径&quot;).forward(req, resp); Request对象作用域​ 一次请求 ​ 问题：使用请求转发后，不同的 Servlet 之间怎么进行数据的共享 呢？或者说数据怎么从一个 servlet 流转给另外 一个 Servlet 呢？ 解决：使用 request 对象的作用域 使用： ​ request.setAttribute(object name,Object value); ​ request.getAttribute(Object obj) 作用：解决了一次请求内的不同 Servlet 的数据(请求数据+其他数据)共享问题。 作用域：基于请求转发，一次请求中的所有 Servlet 共享。 注意： ​ 使用 Request 对象进行数据流转，数据只在一次请求内有效。 特点： ​ 服务器创建 ​ 每次请求都会创建 ​ 生命周期一次请求 重定向两次请求 问题： ​ 如果当前的请求，Servlet 无法进行处理怎么办? ​ 如果使用请求转发，造成表单数据重复提交怎么办？ 解决： ​ 使用重定向 使用： ​ response.sendRedirect(“路径”). ​ 本地路径为：uri ​ 网络路径为：定向资源的 URL 信息 特点： ​ 两次请求浏览器地址栏信息改变 ​ 避免因为用户的刷新而造成表单重复提交 Cookie​ 作用：解决了不同请求之间请求数据共享的问题 ​ ​ 特点： ​ 1）如果不设置有效期，则默认存储在浏览器内存中，浏览器关闭即失效 ​ 2）如果不设置有效路径则(Cookie的默认path为当前项目的根路径 ​ 3）如果设置了有效期，则存储到客户端的硬盘里，到期后自动销毁 ​ 4）如果设置了有效路径则只有在该路径下的请求才会附带设置的cookie信息 ​ 注意： ​ c.setPath(“/bjservlet/mm”); ​ 表示/bjservlet/mm以及/bjservlet/mm/* ​ ​ c.setPath(“/bjservlet/mm/“); ​ 表示/bjservlet/mm/* Session问题： ​ Request 对象解决了一次请求内的不同 Servlet 的数据共享问 题，那么一个用户的不同请求的处理需要使 用相同的数据怎么办呢? 解决： ​ 使用 session 技术。 原理： ​ 用户使用浏览器第一次向服务器发送请求，服务器在接受到请 求后，调用对应的 Servlet 进行处理。在处理过程中会给用户创建 一个 session 对象(调用req.getsession()才会创建)，用来存储用户请求处理相关的公共数据，并将 此 session 对象JSESSIONID 以 Cookie 的形式存储在浏览器中(临 时存储，浏览器关闭即失效)。用户在发起第二次请求及后续请求 时，请求信息中会附带 JSESSIONID，服务器在接收到请求后，调用对应的 Servlet 进行请求处理，同时根据 JSESSIONID 返回其对应的 session 对象。 特点：Session 技术是依赖 Cookie 技术的服务器端的数据存储技术。由服务器进行创建 每个用户独立拥有一个 session ​ 默认存储时间为 30 分钟 作用： ​ 解决了一个用户的不同请求的数据共享问题。 使用： ​ 创建 Session 对象 ​ 存储数据到 session 对象 ​ 获取 session 对象 ​ 获取数据从 session 对象 ​ 如果获取 session 中不存在的数据返回 null。 注意： ​ 只要不关闭浏览器，并且 session 不失效的情况下，同一个用 户的任意请求在项目的任意Servlet中获取到 的都是同一个session对象。 作用域： ​ 一次会话 注意： 一个常见的误解是以为session在有客户端访问时就被创建，然而事实是直到某server端程序调用HttpServletRequest.getSession(true)这样的语句时才被创建，注意如果JSP没有显示的使用 &lt;%@page session=”false”%&gt; 关闭session，则JSP文件在编译成Servlet时将会自动加上这样一条语句HttpSession session = HttpServletRequest.getSession(true);这也是JSP中隐含的session对象的来历。 由于session会消耗内存资源，因此，如果不打算使用session，应该在所有的JSP中关闭它。 ServletContext问题： ​ Request 解决了一次请求内的数据共享问题，session 解决了 用户不同请求的数据共享问题，那么不同的用户的数据共享该怎 么办呢？ 解决： ​ 使用 ServletContext 对象 作用： ​ 解决了不同用户的数据共享问题 原理： ​ ServletContext 对象由服务器进行创建，一个项目只有一个对 象。不管在项目的任意位置进行获取得到的都是同一个对象，那 么不同用户发起的请求获取到的也就是同一个对象了，该对象由 用户共同拥有。 特点： ​ 服务器进行创建用户共享 ​ 一个项目只有一个 生命周期： ​ 服务器启动到服务器关闭 作用域： ​ 项目内 使用： ​ 获取 ServletContext 对象 ​ 使用作用域进行共享数据流转 ​ 获取 web.xml 中的全局配置 ​ 获取 webroot 下项目资源流对象 ​ 获取 webroot 下资源绝对路径 ServletConfig问题： ​ 使用 ServletContext 对象可以获取 web.xml 中的全局配置文件， 在 web.xml 中 每个 Servlet 也可以进行单独的配置，那么该怎么获取配置信息呢？ 解决： ​ 使用 ServletConfig 对象作用： ​ ServletConfig 对象是 Servlet 的专属配置对象，每个 Servlet 都单独拥有一个 ServletConfig 对象，用来获取 web.xml 中的配置信息。 使用： ​ 获取 ServletConfig 对象 ​ 获取 web.xml 中 servlet 的配置信息","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"servlet","slug":"servlet","permalink":"http://yoursite.com/tags/servlet/"}]},{"title":"JS中的闭包","slug":"Web/Js中的闭包理解","date":"2019-07-21T09:01:11.000Z","updated":"2019-07-21T09:37:18.713Z","comments":true,"path":"2019/07/21/Web/Js中的闭包理解/","link":"","permalink":"http://yoursite.com/2019/07/21/Web/Js中的闭包理解/","excerpt":"","text":"JS中的闭包闭包就是跨作用域访问变量​ 闭包是指有权访问另外一个函数作用域中的变量的函数.可以理解为(能够读取其他函数内部变量的函数) 测试1123456789var name = 'wangxi'function user () &#123; // var name = 'wangxi' function getName () &#123; console.log(name) &#125; getName()&#125;user() // wangxi ​ 在 getName 函数中获取 name，首先在 getName 函数的作用域中查找 name，未找到，进而在 user 函数的作用域中查找，同样未找到，继续向上回溯，发现在全局作用域中存在 name，因此获取 name 值并打印。这里很好理解，即变量都存在在指定的作用域中，如果在当前作用中找不到想要的变量，则通过作用域链向在父作用域中继续查找，直到找到第一个同名的变量为止（或找不到，抛出 ReferenceError 错误）。这是 js 中作用域链的概念，即子作用域可以根据作用域链访问父作用域中的变量，那如果相反呢，在父作用域想访问子作用域中的变量呢？——这就需要通过闭包来实现。 12345678function user () &#123; var name = 'wangxi' return function getName () &#123; return name &#125;&#125;var userName = user()()console.log(userName) // wangxi ​ 分析代码我们知道，name 是存在于 user 函数作用域内的局部变量，正常情况下，在外部作用域（这里是全局）中是无法访问到 name 变量的，但是通过闭包（返回一个包含变量的函数，这里是 getName 函数），可以实现跨作用域访问变量了（外部访问内部）。因此上面的这种说法完整的应该理解为： ​ 闭包就是跨作用域访问变量 —— 内部作用域可以保持对外部作用域中变量的引用从而使得外部作用域可以访问内部作用域中的变量。 测试212345678910111213141516171819202122232425262728&lt;script&gt; function user()&#123; var a = 1; return function()&#123; console.log(a++); &#125;; &#125; /**** 1)aaa 是将 user() 的运行结果赋值给它，即 return 返回的匿名函数， 此时有一个闭包，则每次调用 aaa 时都访问的同一个 a，aaa() 第一次运行结果为 1，第二次为2 2)bbb 将是将 user 这个函数名赋值给它，则调用 bbb() 后返回一个匿名函数表达式， 即function()&#123;console.log(a++)&#125;; ****/ var aaa = user(); console.log(aaa); //ƒ()&#123;console.log(a++);&#125; console.log(aaa()); //1 undefined aaa(); //2 aaa(); //3 aaa(); //4 var bbb = user; console.log(bbb); //ƒ user()&#123;var a = 1;return function()&#123;console.log(a++);&#125;;&#125; console.log(bbb()); //ƒ()&#123;console.log(a++);&#125; console.log(bbb()()); //1 undefined console.log(bbb()()); //1 undefined &lt;/script&gt; 闭包就是一个引用了父环境的对象，并且从父环境中返回到更高层的环境中的一个对象123456function user () &#123; var name = 'wangxi' return name&#125;var userName = user()console.log(userName) // wangxi 问：这是闭包吗？ 答：当然不是。首先要明白闭包是什么。虽然这里形式上看好像也是在全局作用域下访问了 user 函数内的局部变量 name，但是问题是，user 执行完，name 也随之被销毁了，即函数内的局部变量的生命周期仅存在于函数的声明周期内，函数被销毁，函数内的变量也自动被销毁。 ​ 但是使用闭包就相反，函数执行完，生命周期结束，但是通过闭包引用的外层作用域内的变量依然存在，并且将一直存在，直到执行闭包的的作用域被销毁，这里的局部变量才会被销毁（如果在全局环境下引用了闭包，则只有在全局环境被销毁，比如程序结束、浏览器关闭等行为时才会销毁闭包引用的作用域）。因此为了避免闭包造成的内存损耗，建议在使用闭包后手动销毁。 123456789function user () &#123; var name = 'wangxi' return function getName () &#123; return name &#125;&#125;var userName = user()() // userName 变量中始终保持着对 name 的引用console.log(userName) // wangxiuserName = null // 销毁闭包，释放内存 ​ 为什么 user()() 是两个括号：执行 user() 返回的是 getName 函数，要想获得 name 变量，需要对返回的 getName 函数执行一次，所以是 user()() ​ 分析一下代码：在全局作用域下创建了 userName 变量（爷爷），保存了对 user 函数最终返回结果的引用（即局部变量 name 的值），执行 user()()（爸爸），返回了 name（孙子）,正常情况下，在执行了 user()() 之后，user 的环境（爸爸）应该被清除掉，但是因为返回的结果 name（孙子）引用了爸爸的环境（因为 name 本来就是存在于 user 的作用域内的），导致 user 的环境无法被释放（会造成内存损耗）。 那么【”闭包就是一个引用了父环境的对象，并且从父环境中返回到更高层的环境中的一个对象。”】如何理解？ 我们换个说法：如果一个函数引用了父环境中的对象，并且在这个函数中把这个对象返回到了更高层的环境中，那么，这个函数就是闭包。 解析：getName 函数中引用了 user（父）环境中的对象（变量 name），并且在函数中把 name 变量返回到了全局环境（更高层的环境）中，因此，getName 就是闭包。 JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里123456789var name = 'Schopenhauer'function getName () &#123; console.log(name)&#125;function myName () &#123; var name = 'wangxi' getName()&#125;myName() // Schopenhauer ​ 如果执行 myName() 输出的结果和你想象的不一样，你就要再回去看看上面说的这句话了。 JavaScript 中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里执行 myName，函数内部执行了 getName，而 getName 是在全局环境下定义的，因此尽管在 myName 中定义了变量 name，对getName 的执行并无影响，getName 中打印的依然是全局作用域下的 name。 测试：JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里 1234567891011121314var name = 'Schopenhauer'function getName () &#123; var name = 'Aristotle' var intro = function() &#123; // 这是一个闭包 console.log('I am ' + name) &#125; return intro&#125;function showMyName () &#123; var name = 'wangxi' var myName = getName() //得到intro函数 myName() //执行intro()&#125;showMyName() // I am Aristotle 总结什么是闭包?简单来说，闭包是指可以访问另一个函数作用域变量的函数，一般是定义在外层函数中的内层函数。 为什么需要闭包？局部变量无法共享和长久的保存，而全局变量可能造成变量污染，所以我们希望有一种机制既可以长久的保存变量又不会造成全局污染。 特点 占用更多内存 不容易被释放 何时使用？变量既想反复使用，又想避免全局污染 如何使用? 定义外层函数，封装被保护的局部变量。 定义内层函数，执行对外部函数变量的操作。 外层函数返回内层函数的对象，并且外层函数被调用，结果保存在一个全局的变量中。 原文:https://www.jb51.net/article/126565.htm","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"a标签的href=\"javascript:;\" href=\"javacript:void(0);\" href=\"#\"区别","slug":"Web/JS使用a标签的href","date":"2019-07-19T12:17:11.000Z","updated":"2019-07-19T14:27:24.845Z","comments":true,"path":"2019/07/19/Web/JS使用a标签的href/","link":"","permalink":"http://yoursite.com/2019/07/19/Web/JS使用a标签的href/","excerpt":"","text":"a标签的href=”javascript:;” href=”javacript:void(0);” href=”#”区别在使用标签时，经常会绑定其他事件比如onclick，这时候我们会给标签的href属性赋值为“#”，“javacript:;”，“javacript:void(0);”等。 一、href=”javacript:;” 用这个的话会出现浏览器访问“javascript:;”这个地址的现象，所以任何情况下都不建议使用； 二、href=”javacript:void(0);” 表示点击这个链接后执行一条javascript语句：void(0); 这条语句表示什么也不做，是个空语句。当绑定了onclick()事件并且点击后，页面会停留在原地； 三、href=”#” 这个是HTML的链接用法，意思是跳转到页面顶部，如果想快速地返回到顶部，那么就用这个链接，这种用法叫做锚。 四、如果想使用a标签来对一个函数进行调用，有两种方式： 121)&lt;a href=&quot;javascript:void(0);&quot; onClick=&quot;hello();&quot; &gt;点我&lt;/a&gt;2)&lt;a href=&quot;javascript:hello();&quot; &gt;点我&lt;/a&gt; 所以应该在不同的场景应该选择合适的用法。","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"JS自定义对象","slug":"Web/Js自定义对象","date":"2019-07-19T12:17:11.000Z","updated":"2019-07-19T14:27:09.737Z","comments":true,"path":"2019/07/19/Web/Js自定义对象/","link":"","permalink":"http://yoursite.com/2019/07/19/Web/Js自定义对象/","excerpt":"","text":"关于这个this关键字，也是很多项目中常常被用到的，那么，有人也许会问，干嘛要用this呢，在函数被调用时，直接指明是什么对象在调用不就行了？还整那么个模模糊糊的概念出来干嘛？不过嘛，存在即真理，既然有这么个东西，那也就有他存在的意义，下面来看看吧。 ​ 首先，我们要先回忆一下js函数都有哪几种调用的场合，有如下几种场合： ​ 1、很常规的调用（即直接调用，其实你发现也是全局调用）； ​ 2、作为某个对象的豆哥方法被调用； ​ 3、作为构造函数，用来新建某个新对象（object）； ​ 4、很让人头大的apply调用（在实现部分继承的时候经常这么干）。 好了，一起来看看上述几种情况下this关键字是怎样被玩的出神入化的。 一、纯粹的函数调用 这是函数的最通常用法，属于全局性调用，因此this就代表全局对象Global，那么这里Global很多人又很迷惑了，实则在浏览器环境下，Global也即是window对象，global对象是单体内置对象，即不依赖宿主环境的对象，而window对象依赖浏览器。 看下面这段代码： function test(){ this.name = “dearxiangxiao”; console.log(this.name ); } test(); //dearxiangxiao 感觉还是很神奇的，不知不觉test函数里面定义的属性，在外面也可以读取了？对代码做一些修改，如下： var name = “xiangxiao”; function test(){ this.name = “dearxiangxiao”; } test(); alert(name); // dearxiangxiao 可以看出，在执行完test函数之后，name的值被改变了，原因何在？这里就是这个调用test的对象是Global在作怪，既然test是被全局对象Global调用的，那么this也就指向Global对象了，全局对象的属性，当然可以读取并修改了，没啥错。 二、作为对象方法的调用 函数还可以作为某个对象的方法调用，这时this就指这个上级对象，也来看一段代码： function test(){ console.log(“my name is “+this.name + “ and my profession is “+this.profession); }; var person = {}; person .name= “dearxiangxiao”; person.profession = “projector”; person.interduce= test; person .interduce(); // my name is dearxiangxiao,and my profession is projector 这里很好理解，既然是person在调用test函数，那么理所应当的this指向的是person实体，也就是前面说的调用函数的上一级对象，它的name和profession 属性当然应该被读取出来了。 三、作为构造函数调用 所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象，也来看一段代码，将一中的例子做轻微的修改： var name = “xiangxiao”; function Person(){ this.name = “dearxiangxiao”; } var person1 = new Person(); console.log(name); // xiangxiao console.log(person1.name); // dearxiangxiao 可以看出，this指向的对象是刚刚新建的person1，读取出了它的名称dearxiangxiao，而直接打印name变量，值仍然未变，为之前的xiangxiao。这更加表明this指向person1，而不是Global对象。 四、apply调用 apply()是函数对象的一个方法，它的作用是改变函数的调用对象（实则是将某某对象的某个方法放到另一个好基友对象那里去执行），它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。 关于这个apply，可能大多数人不太喜欢用它，要想调用某个对象直接调用不就好了么？但是应该想到，假如你想调用别人写好的某个方法，某些参数变量却要用到你自己的，怎么办？apply和call就派上用场了，这也是js面向对象思维转换的重要一环，必须理解的（关于apply和call具体详情，请看我的另一篇博文：js面向对象思维转换的一个阶梯：apply和call）。 下面还是来看个例子吧，这里把三中的例子做一些轻微的修改： var name = “xiangxiao”; function test(){ console.log(this.name); } var person1 = new Person(); person1.name = “dearxiangxiao”; person1.interduce = test; person1.interduce.apply(); // 这里输出的四xiangxiao 怎么回事，不是说好了的要改变函数的调用对象么？怎么还是被Global调用了？不急不急，来看看apply后面的括号里，没任何东西，默认没有残数时是全局对象Global，因此，此处也就真的是调用出了Global的name变量。那person1.interduce.apply()怎么理解呢？可以这么理解：将person1实体的interduce方法放到Global对象上去执行。 好了，我们刚刚在前面说了，apply后面括号里的第一个参数，即为this的指向，那么改一改上面的最后一句代码吧，如下： person1.interduce.apply(person1); // 这里输出的就是dearxiangxiao 得到person1的name属性值了，突然冒出个想法，这里person1.interduce.apply(person1) 理解出来貌似很拗口额：将person1实体对象的interduce方法放到person1实体对象上去执行，什么鬼？自己的方法自己直接调用不好么？写成 person1.interduce()就行了噻！！！当然可以，那样更简洁，不过，这就是apply方法的特点所致吧，自己的方法，转一圈回到自己手里被调用了，还给出个冠冕堂皇的解释，哈哈，就不吐槽了，我们还是要看到apply带给我们的诸多好处的。 来源：https://www.cnblogs.com/xiangxiao/p/6822997.html","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"jdk7的try-catch-resource","slug":"JavaSE/jdk7的try-with-resource","date":"2019-07-18T02:08:01.000Z","updated":"2019-07-18T02:32:12.202Z","comments":true,"path":"2019/07/18/JavaSE/jdk7的try-with-resource/","link":"","permalink":"http://yoursite.com/2019/07/18/JavaSE/jdk7的try-with-resource/","excerpt":"","text":"jdk7的try-with-resources​ JDK1.7开始，java引入了 try-with-resources 声明，将 try-catch-finally 简化为 try-catch，这其实是一种语法糖，在编译时会进行转化为 try-catch-finally 语句。新的声明包含三部分：try-with-resources 声明、try 块、catch 块。它要求在 try-with-resources 声明中定义的变量实现了 AutoCloseable 接口，这样在系统可以自动调用它们的close方法，从而替代了finally中关闭资源的功能。 测试12345678910111213141516@Test public void TestForTryWithResources() &#123; try (InputStream inputStream = new FileInputStream(&quot;/test.md&quot;); //InputStream inputStream = TryCatchDemo.class.getResourceAsStream(&quot;/test.md&quot;) BufferedReader bf = new BufferedReader(new InputStreamReader(inputStream)) ) &#123; StringBuilder sb = new StringBuilder(); String tmpString = null; while ((tmpString = bf.readLine()) != null) &#123;//抛出IOException的地方 sb.append(tmpString); &#125; System.out.println(sb.toString()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 它的结构是try(){} 因为括号里头的InputStream ，BufferedReader 都实现了一个AutoCloseable接口，所以无论这段代码是正常执行完，还是有异常往外抛，还是内部代码块发生异常被截获，最终都会按照创建资源的逆顺序，自动关闭资源. 1234567891011121314151617181920212223 @Test public void AutoCloseTest() &#123; try (AutoCloseAbleBean autoCloseable = new AutoCloseAbleBean()) &#123; throw new RuntimeException(&quot;test&quot;);// autoCloseable.dosomething();// return; &#125; catch (Exception e) &#123; e.printStackTrace();// throw new RuntimeException(&quot;test&quot;); &#125;finally &#123; throw new RuntimeException(&quot;test&quot;); &#125; &#125; class AutoCloseAbleBean implements AutoCloseable &#123; @Override public void close() throws Exception &#123; System.out.println(&quot;i am close&quot;); &#125; void dosomething() &#123; System.out.println(&quot;before close&quot;); &#125; &#125; 异常机制的变化​ 它们的异常抛出机制发生了变化。在过去的 try-catch-finally 结构中，我们在finally块中关闭资源通常是这样的： 123456789101112catch (Exception e) &#123; e.printStackTrace(); // 第一处异常处理 &#125; finally &#123; try &#123; if (c != null) &#123; c.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); // 第二处异常处理 &#125; &#125; 异常处理有两种情况： try 块没有发生异常时，直接调用finally块，如果 close 发生异常，就处理。try 块发生异常，catch 块捕捉，进行第一处异常处理，然后调用 finally 块，如果 close 发生异常，就进行第二处异常处理。但是在 try-with-resources 结构中，异常处理也有两种情况（注意，不论 try 中是否有异常，都会首先自动执行 close 方法，然后才判断是否进入 catch 块，建议阅读后面的反编译代码）： try 块没有发生异常时，自动调用 close 方法，如果发生异常，catch 块捕捉并处理异常。try 块发生异常，然后自动调用 close 方法，如果 close 也发生异常，catch 块只会捕捉 try 块抛出的异常，close 方法的异常会在catch 中被压制，但是你可以在catch块中，用 Throwable.getSuppressed 方法来获取到压制异常的数组。 我们可以通过自定义的 AutoCloseable 类来理解这个过程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Main &#123; public static void startTest() &#123; try (MyAutoCloseA a = new MyAutoCloseA(); MyAutoCloseB b = new MyAutoCloseB()) &#123; a.test(); b.test(); &#125; catch (Exception e) &#123; System.out.println(&quot;Main: exception&quot;); System.out.println(e.getMessage()); Throwable[] suppressed = e.getSuppressed(); for (int i = 0; i &lt; suppressed.length; i++) System.out.println(suppressed[i].getMessage()); &#125; &#125; public static void main(String[] args) throws Exception &#123; startTest(); &#125;&#125;/* 输出为： MyAutoCloaseA: test() MyAutoCloseB: on close MyAutoCloseA: on close() Main: exception MyAutoCloaseA: test() IOException MyAutoCloaseB: close() ClassNotFoundException MyAutoCloaseA: close() ClassNotFoundException*/class MyAutoCloseA implements AutoCloseable &#123; public void test() throws IOException &#123; System.out.println(&quot;MyAutoCloaseA: test()&quot;); throw new IOException(&quot;MyAutoCloaseA: test() IOException&quot;); &#125; @Override public void close() throws Exception &#123; System.out.println(&quot;MyAutoCloseA: on close()&quot;); throw new ClassNotFoundException(&quot;MyAutoCloaseA: close() ClassNotFoundException&quot;); &#125;&#125;class MyAutoCloseB implements AutoCloseable &#123; public void test() throws IOException &#123; System.out.println(&quot;MyAutoCloaseB: test()&quot;); throw new IOException(&quot;MyAutoCloaseB: test() IOException&quot;); &#125; @Override public void close() throws Exception &#123; System.out.println(&quot;MyAutoCloseB: on close&quot;); throw new ClassNotFoundException(&quot;MyAutoCloaseB: close() ClassNotFoundException&quot;); &#125;&#125; 通过反编译class文件，可以看到实际的执行过程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public static void startTest() &#123; try &#123; MyAutoCloseA a = new MyAutoCloseA(); Throwable var33 = null; try &#123; MyAutoCloseB b = new MyAutoCloseB(); Throwable var3 = null; try &#123; // 我们定义的 try 块 a.test(); b.test(); &#125; catch (Throwable var28) &#123; // try 块中抛出的异常 var3 = var28; throw var28; &#125; finally &#123; if (b != null) &#123; // 如果 try 块中抛出异常，就将 close 中的异常（如果有）附加为压制异常 if (var3 != null) &#123; try &#123; b.close(); &#125; catch (Throwable var27) &#123; var3.addSuppressed(var27); &#125; &#125; else &#123; // 如果 try 块没有抛出异常，就直接关闭，可能会抛出关闭异常 b.close(); &#125; &#125; &#125; &#125; catch (Throwable var30) &#123; var33 = var30; throw var30; &#125; finally &#123; if (a != null) &#123; if (var33 != null) &#123; try &#123; a.close(); &#125; catch (Throwable var26) &#123; var33.addSuppressed(var26); &#125; &#125; else &#123; a.close(); &#125; &#125; &#125; // 所有的异常在这里交给 catch 块处理 &#125; catch (Exception var32) &#123; // 我们定义的 catch 块 System.out.println(&quot;Main: exception&quot;); System.out.println(var32.getMessage()); Throwable[] suppressed = var32.getSuppressed(); for(int i = 0; i &lt; suppressed.length; ++i) &#123; System.out.println(suppressed[i].getMessage()); &#125; &#125; &#125; 12345我还想补充的是：catch 块中，看不到 try-with-recourse 声明中的变量。try-with-recourse 中，try 块中抛出的异常，在 e.getMessage() 可以获得，而调用 close() 方法抛出的异常在e.getSuppressed() 获得。try-with-recourse 中定义多个变量时，由反编译可知，关闭的顺序是从后往前。 参考来源1.https://www.jianshu.com/p/8e4421aff0a6 2.https://blog.csdn.net/weixin_40255793/article/details/80812961","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"CSS中的transform属性","slug":"Web/CSS中的transform属性","date":"2019-07-10T14:59:11.000Z","updated":"2019-07-15T07:37:44.747Z","comments":true,"path":"2019/07/10/Web/CSS中的transform属性/","link":"","permalink":"http://yoursite.com/2019/07/10/Web/CSS中的transform属性/","excerpt":"","text":"transform属性一、移动 translate用法：transform: translate(45px) 或者 transform: translate(45px, 150px); 参数表示移动距离，单位px， 一个参数时：表示水平方向的移动距离；两个参数时：第一个参数表示水平方向的移动距离，第二个参数表示垂直方向的移动距离。 二、缩放 scale用法：transform: scale(0.5) 或者 transform: scale(0.5, 2); 参数表示缩放倍数； 一个参数时：表示水平和垂直同时缩放该倍率两个参数时：第一个参数指定水平方向的缩放倍率，第二个参数指定垂直方向的缩放倍率。 三、旋转 rotate用法：transform: rotate(45deg); 围绕旋转中心旋转而不变形的转换，rotate()默认旋转中心为图片的中点。共一个参数“角度”，单位deg为度的意思，正数为顺时针旋转，负数为逆时针旋转，上述代码作用是顺时针旋转45度。 四、倾斜 skew用法：transform: skew(30deg) 或者 transform: skew(30deg, 30deg); 参数表示倾斜角度，单位deg 一个参数时：表示水平方向的倾斜角度； 两个参数时：第一个参数表示水平方向的倾斜角度，第二个参数表示垂直方向的倾斜角度。 旋转举例进行旋转时其对应的坐标系会跟随旋转的角度进行变化。 12341.transform:rotateY(90deg) translateZ(200px) ;该操作会将一个div正向旋转90度，（旋转的角度是根据Y轴的垂直面（x向右，y向上，二维）原来的xyz轴也进行正向旋转90度，因此，Z轴的正向会变成向右的方向， 黑色的x,y轴是旋转角度面 122. transform:rotateY(90deg) translateZ(200px) rotateZ(45deg);该操作会在原来的基础上绕Z轴进行旋转 黑色的x,y轴是旋转角度面","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS的学习","slug":"Web/CSS的学习","date":"2019-07-10T14:59:11.000Z","updated":"2019-11-22T10:48:34.264Z","comments":true,"path":"2019/07/10/Web/CSS的学习/","link":"","permalink":"http://yoursite.com/2019/07/10/Web/CSS的学习/","excerpt":"","text":"CSSCSS入门为什么学习CSS(CSS的作用)​ 【1】HTML 虽然可以在一定程度上修饰页面，但是页面的整体还是不够美观 ​ 【2】HTML 进行网页的书写重复的代码比较多，后期的维 护性不好。 什么是CSS(CSS的概念)​ 英文全称：Cascading Style Sheets ​ 层叠样式表（级联样式表） CSS引入​ CSS的引入的三种方式 &lt;!-- CSS引入方式的顺序，就近原则 --&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/css1.css&quot;/&gt; &lt;style&gt; /*p代表标签的名称*/ p{ /*字体颜色*/ color: yellow; /*字体大小*/ font-size: 25px; /*字体加粗*/ font-weight: bold; } &lt;/style&gt; &lt;!-- 外部式（链接式） rel:引入的文件和当前文件的关系 type:引入类型 href:引入文件的 --&gt; &lt;!-- &lt;style&gt; /**导入式(了解即可)*/ @import url(&quot;css/css1.css&quot;); &lt;/style&gt; --&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 1.行内形式 键：值--&gt; &lt;!-- &lt;p style=&quot;color: red;&quot;&gt;我们不一样&lt;/p&gt; --&gt; &lt;!-- 内嵌形式 --&gt; &lt;!-- &lt;p&gt;我们不一样&lt;/p&gt; &lt;p&gt;我们不一样&lt;/p&gt; --&gt; &lt;p&gt;我们不一样&lt;/p&gt; &lt;/body&gt; 外部css 123456789p&#123; /**字体的风格*/ font-family: 宋体; /**字体的样式*/ font-style: italic; color: green;&#125; CSS引入方式的顺序，就近原则，跟随最近的加载的引入 选择器通用选择器/**通用选择器,代表该页面中所有元素*/ *{ color: red; background-color: black; } 元素选择器12345678/**元素选择器*/div&#123; width: 200px; height: 200px; background: blue; /**边框的粗细:1px 边框的风格:solid 边框的颜色*/ border: 1px solid red;&#125; id选择器123456/* id选择器，#后加id名,id的名称保证唯一， id的命名: 由数字、字母、下划线、中划线组成，不能以数字开头*/#div1&#123; background: green;&#125; 类选择器1234/* 类选择器 */.div_1&#123; background: pink;&#125; 选择器的优先级​ id选择器&gt;类选择器&gt;元素选择器&gt;通用选择器权重： 100 10 1 0​ 其他选择器可以使用任意组合（元素选择器，id选择器,类选择器） 后代选择器12345678/**后代选择器:只要包含该标签对象即可*/div span&#123; font-size: 27px; font-family: 宋体; color: green;&#125; ​ 子选择器 ​ 1234/**子选择器：直系子标签*/div&gt;span&#123; color: red;&#125; 兄弟选择器​ 123456789/**兄弟选择器:只会改变下面相邻的元素对象*/ #p_1+p&#123; color: #0000FF;&#125;/**兄弟选择器后面所有的兄弟对象都改变*/#p_1~p&#123; color: red; font-size: 30px;&#125; 伪类选择器1234/**伪类选择器**/a:hover&#123; /*hover:鼠标放上*/ color: red;&#125; 常用的属性常用的属性112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;style&gt; .top&#123; width: 100%; height: 100px; border: 1px solid red; &#125; .top_a&#123; /**字体颜色*/ color: gray; /**字体大小*/ font-size: 12px; /*字体的加粗*/ /* font-weight: bold; */ /**字体的风格*/ /* font-family: 宋体; */ /**字体的样式*/ font-style: italic; /**去除下划线*/ text-decoration: none; &#125; a:hover&#123; color: red; /**下划线展示*/ text-decoration: underline; &#125; .tips&#123; width: 100%; height: 40px; border: 1px dotted indigo; background-color: pink; /**文本居中*/ text-align: center; /**行高： 行高的高度和div外面的高度一致，这时里面的内容就会垂直居中*/ line-height: 40px; &#125; .center&#123; width: 100%; height: 500px; border: 1px solid red; /**设置背景图片*/ background-image: url(&quot;http://img13.360buyimg.com/da/jfs/t1/43308/30/8709/99646/5d22e91dE4a7f5729/6b8ea2cf39afcbd1.jpg&quot;); /**设置背景图片不重复*/ background-repeat: no-repeat; /**调整背景图片的位置 x值 y值*/ background-position: center; /*调整背景图片的大小 宽 高*/ /* background-size: 1200px 500px; */ /**背景颜色 或者使用rgb(255,0,0)*/ background-color: #37cef5; /**rgba()最后的.1是透明度*/ /* background-color: rgba(255,0,0,.1); */ &#125; &lt;/style&gt; &lt;body&gt; &lt;!-- 顶部的位置 --&gt; &lt;div class=&quot;top&quot;&gt; &lt;a href=&quot;&quot; class=&quot;top_a&quot;&gt;登录页面，调查问卷&lt;/a&gt; &lt;/div&gt; &lt;!-- 中间的提示 --&gt; &lt;div class=&quot;tips&quot;&gt; &lt;span&gt;根据网络安全法，为保障您的账号安全，请完成手机号验证&lt;/span&gt; &lt;/div&gt; &lt;!-- 中间位置 --&gt; &lt;div class=&quot;center&quot;&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 常用的属性21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .div_1&#123; width: 200px; height: 200px; background: rgba(255, 0, 0); color: rgba(0,0,255); /**调整透明度（0-1）*/ opacity: 0.4; /**超出：hidden隐藏 auto：自动*/ overflow: hidden; &#125; #span_1&#123; width: 100px; height: 100px; color: red; border: 1px solid red; /**显示： 行内元素转换成块元素 行内元素：inline 块元素:block none：隐藏 */ display: block; &#125; ul&#123; /*向右浮动*/ float: right; &#125; li&#123; /*列表的风格去除*/ list-style: none; /**向左浮动*/ float: left; /*内边距*/ padding-left: 15px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;hao123&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;地图&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;视频&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;贴吧&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;学术&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &lt;!-- 行内元素：多个标签位于同一行 span,font,小标签 块元素：标签可以自动换行 div, h1-h6, ul, p --&gt; &lt;div class=&quot;div_1&quot;&gt; 我们都是div我们都是div我们都是div 我们都是div我们都是div 我们都是div我们都是div 我们都是div我们都是div我们都是div 我们都是div我们都是div 我们都是div我们都是div 我们都是div我们都是div我们都是div 我们都是div我们都是div 我们都是div我们都是div我们都是div我们都是div我们都是div 我们都是div我们都是div 我们都是div我们都是div &lt;/div&gt; &lt;hr /&gt; 01&lt;span id=&quot;span_1&quot;&gt;234&lt;/span&gt;56 &lt;/body&gt;&lt;/html&gt; 定位123456789101112131415161718192021222324252627282930313233343536373839/** 绝对定位 absolute:定位离开之后释放的之前的位置 基于外层父级标签 相对定位 relative:定位离开之后不释放之前的位置 基于之前的位置来说 固定定位 fixed:始终是居于浏览器的左上角的定位， 适合做广告 默认定位 static:初始的定位位置 */ .div_1&#123; width: 200px; height: 200px; background-color: red; /* 绝对定位 */ /* position: absolute; top: 300px; left: 300px; */ /* 相对定位 */ /* position: relative; top: 300px; left: 300px; */ /**固定定位*/ position: fixed; top: 150px; left: 150px; /**置于底层*/ z-index: -1; &#125; .div_2&#123; width: 200px; height: 200px; background-color: green; /**相对定位：基于之前的位置*/ /* position: relative; top: 300px; left: 300px; */ &#125; &lt;/style&gt; 盒子模型12345678910111213141516171819202122232425262728293031323334353637383940&lt;style type=&quot;text/css&quot;&gt; /**清除body和html标签的边距**/ body,html&#123; margin: 0px; padding: 0px; &#125; .div_1&#123; width: 300px; height: 300px; background-color: red; /* 内边距 真实div与border之间的距离 30px是上下的距离，50px是指左右的距离 指定四个值：上右下左 padding-left: 30px;在一个方向加 */ /* padding: 30px 50px; */ /* padding-left: 30px; */ /* 外边距 给盒子进行定位*/ /* margin: 50px; */ /* margin-left: 100px; margin-top: 70px; */ margin-bottom: 40px; margin-right: 40px; &#125; .div_2&#123; width: 300px; height: 300px; background-color: green; /* 外边距 垂直的方向会取较大的值 */ margin-top: 70px; /* 外边距 水平方向会合并 */ margin-left: 50px; &#125; div&#123; float: left; &#125; &lt;/style&gt; CSS3新增选择器伪类选择器，伪对象选择器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;style type=&quot;text/css&quot;&gt; /* 获取class名称是div_1下面的第一个子元素 */ .div_1&gt;p:first-child&#123; color: red; &#125; .div_1&gt;p:last-child&#123; color: blueviolet; &#125; /**获得具体的某一个子元素*/ /* .div_1&gt;p:nth-child(4)&#123; color: brown; &#125; */ /* 单双行 even:双 odd:单*/ /* .div_1&gt;p:nth-child(even)&#123; background-color: red; &#125; .div_1&gt;p:nth-child(odd)&#123; background-color: green; &#125; */ /* 获得空的元素对象 */ .div_1&gt;p:empty&#123; height: 50px; background-color: #8A2BE2; &#125; /* 获得焦点执行的样式 */ /* input:focus&#123; width: 300px; height: 300px; &#125; */ input:checked&#123; width: 20px; height: 20px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;div_1&quot;&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;4&lt;/p&gt; &lt;p&gt;5&lt;/p&gt; &lt;/div&gt; &lt;hr /&gt; &lt;input type=&quot;text&quot; /&gt; &lt;hr /&gt; 男:&lt;input type=&quot;radio&quot; name=&quot;sex&quot;/&gt; 女:&lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt; &lt;/body&gt; 属性选择器12345678910111213141516171819202122232425262728293031323334353637383940&lt;style type=&quot;text/css&quot;&gt; /* 属性选择器 可以操作任意有属性的标签*/ /* input[type=text]&#123; width: 300px; height: 30px; &#125; */ /* 属性 ^用fom开头的 $用结尾 */ input[name^=fom]&#123; width: 300px; height: 30px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 选择器的种类 1)基础选择器 * id class 标签 ..... 2)关系选择器 &gt; + ~ ....... 3)伪类选择器 hover ......... 4)伪对象选择器 before after ....... 4)属性选择器 input[type=text] ...... --&gt; &lt;p&gt; 账号：&lt;input type=&quot;text&quot; name=&quot;fom_zh&quot;/&gt; &lt;/p&gt; &lt;p&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;fom_pwd&quot;/&gt; &lt;/p&gt; &lt;p&gt; 邮箱：&lt;input type=&quot;email&quot; name=&quot;fom_email&quot;/&gt; &lt;/p&gt; &lt;p&gt; 年龄：&lt;input type=&quot;number&quot; name=&quot;age&quot; /&gt; &lt;/p&gt; &lt;/body&gt; 新增属性​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475body&#123; background-color: pink; &#125; .cen&#123; width: 200px; height: 200px; background-color: red; /* 阴影 参数值：水平偏移 垂直偏移 模糊度(值越大越模糊) 颜色 */ box-shadow: 0px 0px 70px red; /* 调用动画 */ /* animation: 1s aj infinite; */ &#125; .lef&#123; /**倒圆角指令*/ border-radius: 100px; /* 左上右下 右上左下 */ /* border-radius: 10px 60px; */ /**左上 右上 右下 左下*/ /* border-radius: 10px 20px 30px 40px; */ position: absolute; top: 200px; left: 200px; animation: 1s aj1 infinite; &#125; .rig&#123; border-radius: 100px; position: absolute; top: 200px; left: 341px; animation: 1s aj1 infinite; &#125; .c&#123; /* 旋转角度 */ transform: rotate(45deg); position: absolute; top: 269px; left: 271px; /* background-color: black; */ animation: 1s aj2 infinite; &#125; div:hover&#123; /* 放大的倍数 */ /* transform: scale(1.3); */ /* translate（水平位移 垂直位移） */ /* transform: translate(0px,-50px); box-shadow: 0px 0px 70px red; */ /* skew：2d旋转 */ /* transform: skew(45deg); */ &#125; /**C3中的动画*/ @keyframes aj1&#123; /* 过程 */ /* form&#123;&#125; to&#123;&#125; */ /* 百分比指定 */ 0%&#123;transform: scale(1);&#125; 50%&#123;transform: scale(1.1);&#125; 100%&#123;transform: scale(1);&#125; &#125; @keyframes aj2&#123; /* 需要旋转 */ 0%&#123;transform: scale(1) rotate(45deg);&#125; 50%&#123;transform: scale(1.1) rotate(45deg);&#125; 100%&#123;transform: scale(1) rotate(45deg);&#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 给class起两个名字 --&gt; &lt;div class=&quot;cen lef&quot;&gt;&lt;/div&gt; &lt;div class=&quot;cen c&quot;&gt;&lt;/div&gt; &lt;div class=&quot;cen rig&quot;&gt;&lt;/div&gt; &lt;/body&gt;","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"JavaScript的学习","slug":"Web/JavaScript的学习","date":"2019-07-10T14:59:11.000Z","updated":"2019-07-21T09:44:43.634Z","comments":true,"path":"2019/07/10/Web/JavaScript的学习/","link":"","permalink":"http://yoursite.com/2019/07/10/Web/JavaScript的学习/","excerpt":"","text":"JavaScript的学习JavaScript的简介为什么学习JavaScript​ 1、html+css 只是可以实现静态的页面无法实现动态的效 果 ​ 2、表单的校验 ​ 3、背景图片的更换 ​ 4、操作节点的信息 ​ 5、 小游戏的开发 ​ ………………… JavaScript的概念​ JavaScript 一种直译式脚本语言，是一种动态类型、弱类型、 基于原型的语言，内置支持类型 JavaScript的组成​ 1.ECMAScript：JavaScript的核心 ​ 2.文档对象模型（DOM）：DOM（文档对象模型）是 HTML 和XML 的应用程序接口（API）。DOM 将把整个页面规划成由节点层级构成的文档 3.浏览器对象模型（BOM）对浏览器窗口进行访问和操作 JavaScript的特点1.脚本语言 ​ 脚本语言是一种简单的程序，是由一些ASCII字符构 成，可以使用任何一种文本编辑器编写。一些程序语言（如C、C++、Java等）都必须经过编译，将源 代码编译成二进制的可执行文件之后才能运行，而 脚本语言不需要事先编译，只要有一个与其相适应 的解释器就可以执行。  脚本语言是指在web浏览器内有解释器解释执行的 编程语言，每次运行程序的时候，解释器会把程序 代码翻译成可执行的格式。 2、基于对象的语言 ​  面向对象有三大特点（封装，继承，多态）却一不 可。 ​  通常“基于对象”是使用对象，但是无法利用现有的对象模板产生新的对象类型，也就是说“基于对象” 没有继承的特点。没有了继承的概念也就无从谈论“多态” 3、事件驱动： ​  在网页中执行了某种操作的动作，被称为“事 件”(Event)，比如按下鼠标、移动窗口、选择菜单 等都可以视为事件。当事件发生后，可能会引起相 应的事件响应。 4、简单性 ​  变量类型是采用弱类型，并未使用严格的数据类型。 var a,b,c; a=123; b=“abc”; a=b; 5、安全性 ​  JavaScript不能访问本地的硬盘，不能将数据存入 到服务器上，不能对网络文档进行修改和删除，只 能通过浏览器实现信息浏览或动态交互 6、跨平台性 ​  JavaScript依赖于浏览器本身，与操作平台无关， 只要计算机安装了支持JavaScript 的浏览器（装有 JavaScript解释器），JavaScript 程序就可以正确执行。 ​  缺点 ​  各种浏览器支持JavaScript的程度是不一样的，支 持和不完全支持JavaScript的 浏览器在浏览同一 个带有JavaScript脚本的网页时，效果会有一定的 差距，有时甚至会显示不出来。 JS的声明和引入123456789101112&lt;!-- JS引入的方式1 --&gt; &lt;script type=&quot;text/javascript&quot;&gt; /* 网页中的弹框 */ alert(&quot;js的引入方式1&quot;) &lt;/script&gt; &lt;!-- JS引入的方式2 type:引入文件的类型 src:引入文件的路径 charset:指定文件编码方式 --&gt; &lt;!-- 注意：引入JS的时候千万不要二合一 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/test.js&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script &gt; ​","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"HTML的学习","slug":"Web/HTML的学习","date":"2019-07-08T12:27:11.000Z","updated":"2019-07-15T02:21:20.192Z","comments":true,"path":"2019/07/08/Web/HTML的学习/","link":"","permalink":"http://yoursite.com/2019/07/08/Web/HTML的学习/","excerpt":"","text":"HTML入门为什么学习 HTML？需求：（生活中遇到问题） 随着技术的发展，信息量的增大网页的数据信息没有办 法完美的、漂亮的展现到用户的面前。 意义:(作用)： HTML是一种专门对网页信息进行规范化展示的语言。 把网页的信息格式化展现的语言 什么是HTML？ HTML(Hyper Text Markup Language)：超文本标记语言 超文本：文本信息 、图片、声音、视频、超链接等 标记：标签的体现 HTML中的标签Head标签的子标签12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 搜索引擎优化 --&gt; &lt;meta name=\"author\" content=\"朱自清,张三\" /&gt; &lt;meta name=\"description\" content=\"盼望着盼望着东风来了\" /&gt; &lt;meta name=\"keywords\" content=\"东风,盼望\"/&gt; &lt;!-- 自动刷新网页(5s后刷新) --&gt; &lt;meta http-equiv=\"refresh\" content=\"5;https://www.baidu.com\" /&gt; &lt;!-- 禁止网页缓存 --&gt; &lt;meta http-equiv=\"Pragma\" content=\"no-cache\"/&gt; &lt;meta http-equiv=\"Cache-Control\" content=\"no-cache\" /&gt; &lt;meta http-equiv=\"expires\" content=\"0\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; meta标签的组成meta标签共有两个属性，它们分别是http-equiv属性和name属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。 1、name属性 name属性主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。 meta标签的name属性语法格式是： 1&lt;meta name=&quot;参数&quot; content=&quot;具体的参数值&quot;&gt; 其中name属性主要有以下几种参数： A、Keywords(关键字) 说明：keywords用来告诉搜索引擎你网页的关键字是什么。 举例： 1&lt;meta name=&quot;keywords&quot; content=&quot;science,education,culture,politics,ecnomics，relationships,entertaiment,human&quot;&gt; B、description(网站内容描述) 说明：description用来告诉搜索引擎你的网站主要内容。 举例： 1&lt;meta name=&quot;description&quot; content=&quot;Thispageisaboutthemeaningofscience,education,culture.&quot;&gt; C、robots(机器人向导) 说明：robots用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引。 content的参数有all,none,index,noindex,follow,nofollow。默认是all。 举例： 1&lt;meta name=&quot;robots&quot; content=&quot;none&quot;&gt; D、author(作者) 说明：标注网页的作者 举例： 1&lt;meta name=&quot;author&quot; content=&quot;root,root@xxxx.com&quot;&gt; 2、http-equiv属性 http-equiv顾名思义，相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。 meta标签的http-equiv属性语法格式是： 1&lt;meta http-equiv=&quot;参数&quot; content=&quot;参数变量值&quot;&gt;； 其中http-equiv属性主要有以下几种参数： A、Expires(期限) 说明：可以用于设定网页的到期时间。一旦网页过期，必须到服务器上重新传输。 用法： 1&lt;meta http-equiv=&quot;expires&quot; content=&quot;Fri,12Jan200118:18:18GMT&quot;&gt; 注意：必须使用GMT的时间格式。 B、Pragma(cache模式) 说明：禁止浏览器从本地计算机的缓存中访问页面内容。 用法： 1&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt; 注意：这样设定，访问者将无法脱机浏览。 C、Refresh(刷新) 说明：自动刷新并指向新页面。 用法：&lt; 1metahttp-equiv=&quot;Refresh&quot;content=&quot;2;URL=http://www.jb51.net&quot;&gt; 注意后面的引号，分别在秒数的前面和网址的后面) 注意：其中的2是指停留2秒钟后自动刷新到URL网址。 D、Set-Cookie(cookie设定) 说明：如果网页过期，那么存盘的cookie将被删除。 用法：&lt; 1meta http-equiv=&quot;Set-Cookie&quot; content=&quot;cookievalue=xxx;expires=Friday,12-Jan-200118:18:18GMT；path=/&quot;&gt; 注意：必须使用GMT的时间格式。 E、Window-target(显示窗口的设定) 说明：强制页面在当前窗口以独立页面显示。 用法：&lt;metahttp-equiv=”Window-target”content=”_top”&gt; 注意：用来防止别人在框架里调用自己的页面。 F、content-Type(显示字符集的设定) 说明：设定页面使用的字符集。 用法：&lt;metahttp-equiv=”content-Type”content=”text/html;charset=gb2312”&gt; G、content-Language（显示语言的设定） 用法：&lt;metahttp-equiv=”Content-Language”content=”zh-cn”/&gt; H、Cache-Control指定请求和响应遵循的缓存机制。Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、on ly-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。各个消息中的指令含义如下Public指示响应可被任何缓存区缓存Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效no-cache指示请求或响应消息不能缓存no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。 Meta标签使用技巧Meta标签是用来描述网页属性的一种语言，标准的Meta标签可以便于搜索引擎排序，提高搜索引擎网站权重排名。要想网站做的更符合搜索引擎标准就必须了解meta标签，下面由Seoer惜缘于大家讲讲meta标签含义与使用方法： 1、META标签的keywords 写法为：&lt;metaname=”Keywords”content=”信息参数”/&gt; meat标签的Keywords的的信息参数，代表说明网站的关键词是什么。 2、META标签的Description &lt;metaname=”Description”content=”信息参数”/&gt; meta标签的Description的信息参数，代表说明网站的主要内容，概况是什么。 3、META标签的http-equiv=Content-Typecontent=”text/html http-equiv=Content-Type代表的是HTTP的头部协议，提示浏览器网页的信息， &lt;metahttp-equiv=”Content-Type”content=”text/html;charset=信息参数”/&gt; meta标签的charset的信息参数如GB2312时，代表说明网站是采用的编码是简体中文； meta标签的charset的信息参数如BIG5时，代表说明网站是采用的编码是繁体中文； meta标签的charset的信息参数如iso-2022-jp时，代表说明网站是采用的编码是日文； meta标签的charset的信息参数如ks_c_5601时，代表说明网站是采用的编码是韩文； meta标签的charset的信息参数如ISO-8859-1时，代表说明网站是采用的编码是英文； meta标签的charset的信息参数如UTF-8时，代表世界通用的语言编码； 4、META标签的generator &lt;metaname=”generator”content=”信息参数”/&gt; meta标签的generator的信息参数，代表说明网站的采用的什么软件制作。 5、META标签的author &lt;metaname=”author”content=”信息参数”&gt; meta标签的author的信息参数，代表说明网页版权作者信息。 6、META标签的http-equiv=”Refresh” &lt;Metahttp-equiv=”Refresh”Content=”时间;Url=网址参数”&gt; meta标签的Refresh代表多少时间网页自动刷新，加上Url中的网址参数就代表，多长时间自动链接其他网址。 7、META标签的HTTP-EQUIV=”Pragma”CONTENT=”no-cache” &lt;METAHTTP-EQUIV=”Pragma”CONTENT=”no-cache”&gt;代表禁止浏览器从本地计算机的缓存中访问页面内容,这样设定，访问者将无法脱机浏览。 8、META标签的COPYRIGHT &lt;METANAME=”COPYRIGHT”CONTENT=”信息参数”&gt; meta标签的COPYRIGHT的信息参数，代表说明网站版权信息。 9、META标签的http-equiv=”imagetoolbar” &lt;metahttp-equiv=”imagetoolbar”content=”false”/&gt; 指定是否显示图片工具栏，当为false代表不显示，当为true代表显示。 10、META标签的Content-Script-Type &lt;Metahttp-equiv=”Content-Script-Type”Content=”text/javascript”&gt; W3C网页规范，指明页面中脚本的类型。 11、META标签的revisit-after &lt;METAname=”revisit-after”CONTENT=”7days”&gt; revisit-after代表网站重访,7days代表7天，依此类推。 12、META标签的Robots&lt;metaname=”Robots”contect=”信息参数”&gt; Robots代表告诉搜索引擎机器人抓取哪些页面 其中的属性说明如下: 信息参数为all：文件将被检索，且页面上的链接可以被查询； 信息参数为none：文件将不被检索，且页面上的链接不可以被查询； 信息参数为index：文件将被检索； 信息参数为follow：页面上的链接可以被查询； 信息参数为noindex：文件将不被检索，但页面上的链接可以被查询； 信息参数为nofollow：文件将被检索，但页面上的链接不可以被查询； 基本标签标题标签1234&lt;!--标题标签 h1-h6 自动的加粗加黑 会自动的换行align:调整标签的位置 （默认是left） --&gt;【新时代·幸福美丽新边疆】西藏：代代接力守护绿色家园&lt;h1 align=&quot;right&quot;&gt;【新时代·幸福美丽新边疆】&lt;/h1&gt; &lt;h2&gt;【新时代·幸福美丽新边疆】&lt;/h2&gt; &lt;h3&gt;【新时代·幸福美丽新边疆】&lt;/h3&gt; &lt;h4&gt;【新时代·幸福美丽新边疆】&lt;/h4&gt; &lt;h5&gt;【新时代·幸福美丽新边疆】&lt;/h5&gt; &lt;h6&gt;【新时代·幸福美丽新边疆】&lt;/h6&gt; 分割线标签12345&lt;!--分割线标签 width：宽度 500px:像素 color:颜 色 align:位置（默认center） size:垂直方向的大小 --&gt; p段落标签1&lt;!--p段落标签 br:换行 &amp;nbsp;空格--&gt; 预文本标签123&lt;!--预文本标签 按照我们指定的格式输出 （灵活 性比较的大）--&gt; 小标签123456789101112131415161718&lt;!-- 下划线标签 --&gt;&lt;u&gt;北京尚学堂&lt;/u&gt;&lt;!-- 斜体标签 --&gt;&lt;i&gt;北京尚学堂&lt;/i&gt;&lt;!-- 加粗加黑 --&gt;&lt;b&gt;北京尚学堂&lt;/b&gt;&lt;!-- 删除线标签 --&gt;&lt;del&gt;北京尚学堂&lt;/del&gt;&lt;!-- 上标标签 --&gt;2&lt;sup&gt;3&lt;/sup&gt;&lt;!-- 下标标签 --&gt;log&lt;sub&gt;10&lt;/sub&gt;&lt;!-- 放大字体 --&gt;&lt;big&gt;北京尚学堂&lt;/big&gt;&lt;!-- 字体标签 font:指定字体的风格--&gt;&lt;font color=&quot;red&quot; size=&quot;25px&quot; face=&quot;宋体&quot;&gt;北京尚学堂&lt;/font&gt;&lt;!-- --&gt;&lt;span &gt;北京尚学堂&lt;/span&gt; 列表标签12345678910111213141516171819202122232425&lt;!-- 列表标签 1.有序列表 2.无序列表 3.自定义列表 作用: 1.树形菜单 2.导航栏的布局 3. ... --&gt; &lt;!--有序列表--&gt; &lt;ol type = &quot;I&quot;&gt; &lt;li&gt;javase&lt;/li&gt; &lt;li&gt;javaee&lt;/li&gt; &lt;li&gt;javame&lt;/li&gt; &lt;/ol&gt; &lt;!-- 无序列表 --&gt; &lt;ul&gt; &lt;li&gt;javase&lt;/li&gt; &lt;li&gt;javaee&lt;/li&gt; &lt;li&gt;javame&lt;/li&gt; &lt;/ul&gt; &lt;!-- 自定义列表 --&gt; &lt;dl&gt; &lt;dt&gt;java&lt;/dt&gt; &lt;dd&gt;javase&lt;/dd&gt; &lt;dd&gt;javaee&lt;/dd&gt; &lt;dd&gt;javame&lt;/dd&gt; &lt;/dl&gt; 跑马灯标签12&lt;!-- 跑马灯标签 direction:方向 scrollamount：移动像素--&gt; &lt;marquee direction=&quot;right&quot; scrollamount=&quot;40px&quot;&gt;北京尚学堂&lt;/marquee&gt; 超链接标签超链接标签的作用（不会自动换行） 【1】实现不同页面之间的跳转 href:指定跳转到目标资源的位置 target：打开网页的方式 【2】实现锚点功能 1234567&lt;!--跳转到本地的资源位置--&gt;&lt;a href=&quot;02body中常用小标签.html&quot;target=&quot;_blank&quot;&gt;02小标签测试&lt;/a&gt;&lt;!--跳转到网络的位置--&gt;&lt;a href=&quot;http://www.bjsxt.com&quot;&gt;北京尚学堂&lt;/a&gt;锚点功能&lt;a href=&quot;#bottom&quot; name=&quot;top&quot;&gt;返回底部&lt;/a&gt; &lt;a href=&quot;#top&quot; name=&quot;bottom&quot;&gt;返回顶部&lt;/a&gt; 图片标签img (不会自动的换行) src:引入图片的位置{相对路径、绝对路径、网络路径 } title：图片的标题 原始 宽和高 400px 260px 200px 130px border:图片的边框 alt：图片无法正常显示的时候显示的属性 align:图片的位置 ，必须有参照物 123456789101112131415161718&lt;!--相对路径--&gt;&lt;img src=&quot;img/2.jpg&quot; /&gt;&lt;!--绝对路径--&gt;&lt;imgsrc=&quot;C:\\\\Users\\\\my\\\\Documents\\\\HBuilderProjects\\\\01HTML\\\\img\\\\1.jpg&quot; /&gt;&lt;!--网络路径--&gt;&lt;img src=&quot;https://www.baidu.com/img/bd_logo1.png&quot;/&gt;&lt;p&gt;6666&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;img/1.jpg&quot; title=&quot;图片&quot; width=&quot;200px&quot;height=&quot;200px&quot; border=&quot;2px&quot; alt=&quot;图片显示错误&quot;align=&quot;right&quot;/&gt;&lt;/a&gt;8888&lt;/p&gt; 表格标签hbuilder的快捷键：table&gt;tr3&gt;th3 :声明3行3列的表格 ，再按下table table表格的自适应能力 (align=”center”) width=”300px” height=”300px” cellpadding：内容和单 元格的距离 cellspacing：单元格和单元格的距离 tr:指定height行高属性，行td:指定width的列宽属性，普通列 th:标题列，自动的居中，加黑效果 colspan:列合并 rowspan：行合并 bgcolor：背景颜色 表单标签https://www.baidu.com/s？键1=值1&amp;键2=值2 action：表单提交的位置 method（get/post）：表单提交的方式 GET: (1)参数会依附于url地址之后 (2)利用get方式提交数据，数据的长度有限制 (3)利用get方式提交数据，是不安全的 Post (1)请求不会依附于地址， (2)利用post处理参数不受限制 (3)post提交数据比较安全 12345678910111213141516171819202122232425262728293031323334&lt;form&gt; &lt;!-- 普通文本框 value：默认值， --&gt; 账号:&lt;input type=\"text\" name=\"zh\" value=\"123\"/&gt;&lt;br/&gt; 密码:&lt;input type=\"password\" name=\"pwd\" value=\"123\" /&gt;&lt;br/&gt; &lt;!-- 单选框(指定同一个name属性) value值 checked,默认值--&gt; 男: &lt;input type=\"radio\" name=\"sex\" value=\"0\"/&gt; 女: &lt;input type=\"radio\" name=\"sex\" value=\"1\" checked=\"checked\"/&gt; &lt;!-- 多选框 --&gt; 抽烟: &lt;input type=\"checkbox\" checked=\"checked\"/&gt; 喝酒: &lt;input type=\"checkbox\" checked=\"checked\"/&gt; 烫头: &lt;input type=\"checkbox\" /&gt;&lt;br /&gt; &lt;!-- 多行文本框 --&gt; 个人介绍:&lt;textarea rows=\"15\" cols=\"20\" &gt;你好&lt;/textarea&gt;&lt;br/&gt; &lt;!-- 文件选择 --&gt; &lt;input type=\"file\" name=\"file\" /&gt; &lt;!-- 隐藏框 --&gt; &lt;input type=\"hidden\" name=\"sno\" value=\"20180607\" /&gt; &lt;!-- 下拉框 --&gt; &lt;select name=\"ch\"&gt; &lt;!-- 1,2,3，value是保存在数据库中的 --&gt; &lt;option value=\"1\"&gt;中国&lt;/option&gt; &lt;option value=\"2\"&gt;美国&lt;/option&gt; &lt;!-- selected,默认勾选的属性 --&gt; &lt;option value=\"3\" selected=\"selected\"&gt;日本&lt;/option&gt; &lt;/select&gt; &lt;!-- 提交按钮 --&gt; &lt;input type=\"submit\" value=\"提交\" /&gt;&lt;br/&gt; &lt;!-- 清除按钮,清空写好的内容，回归默认的值 --&gt; &lt;input type=\"reset\" value=\"清除\" /&gt; &lt;!-- 普通按钮 --&gt; &lt;input type=\"button\" value=\"普通按钮\"/&gt;&lt;/form&gt; div标签div本身是没有任何的含义 div：作用就是把网页进行模块化的划分 123456789101112131415&lt;!-- div本身没有任何的含义 div作用就是把网页进行模块化的划分 --&gt; &lt;!-- 头部模块 --&gt; &lt;div class=&quot;top&quot;&gt;&lt;/div&gt; &lt;!-- 中间提示 --&gt; &lt;div class=&quot;tips&quot;&gt;&lt;/div&gt; &lt;!-- 中间的展现 --&gt; &lt;div class=&quot;center&quot;&gt; &lt;div class=&quot;login&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 底部模块 --&gt;&lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt; HTML5增强的form表单标签123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;p&gt; &lt;!-- 邮箱 --&gt; 邮箱：&lt;input type=\"email\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;!-- 数字 只支持字母e，科学计数法--&gt; 年龄:&lt;input type=\"number\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;!-- 滑动器 --&gt; 滑动器:&lt;input type=\"range\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;!-- 搜索 --&gt; 搜索:&lt;input type=\"search\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;!-- 日期 --&gt; 日期:&lt;input type=\"date\" /&gt; 日期:&lt;input type=\"week\" /&gt; 日期:&lt;input type=\"month\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;!-- 颜色 --&gt; 颜色:&lt;input type=\"color\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;!-- 网址 --&gt; 网址:&lt;input type=\"url\" /&gt; &lt;/p&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;input type=\"reset\" value=\"重置\" /&gt; &lt;/form&gt; &lt;hr /&gt; &lt;!-- h5中的增强属性 placeholder: autofocus:自动获得焦点 max:最大值 min:最小值 maxlength:最大长度 minlength:最小长度 --&gt; &lt;form&gt; &lt;p&gt; 账号:&lt;input type=\"text\" placeholder=\"手机号/邮箱/账号\" autofocus/&gt; &lt;/p&gt; &lt;p&gt; 密码:&lt;input type=\"password\" maxlength=\"4\" minlength=\"2\" /&gt; &lt;/p&gt; &lt;p&gt; 最大值:&lt;input type=\"number\" max=\"130\" min=\"0\"/&gt; &lt;/p&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;input type=\"reset\" value=\"重置\" /&gt; &lt;/form&gt; 结构标签12345678910style中引用header&#123; height: 100px; width: 100%; background-color: red;&#125;body中引用&lt;!-- 头部模块 --&gt; &lt;header&gt;&lt;/header&gt; 音频视频标签12345678910111213141516&lt;!-- 音频标签，control:控制条 --&gt; &lt;audio src=&quot;img/1.mp3&quot; controls=&quot;controls&quot;&gt; 该网页不支持媒体标签 &lt;/audio&gt; &lt;audio&gt; &lt;source src=&quot;img/1.mp3&quot;&gt;&lt;/source&gt; &lt;source src=&quot;img/1.ogg&quot;&gt;&lt;/source&gt; 该网页不支持媒体标签 &lt;/audio&gt; &lt;!-- 视频标签 --&gt; &lt;video src=&quot;&quot; controls=&quot;controls&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;&lt;/video&gt; &lt;video&gt; &lt;source src=&quot;&quot;&gt;&lt;/source&gt; &lt;/video&gt; &lt;!-- 多媒体,支持视频音频，自动播放 --&gt; &lt;embed src=&quot;img/1.mp3&quot;&gt;&lt;/embed&gt; 其他标签12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;figure&gt; &lt;img src=&quot;img/2.jpg&quot; /&gt; &lt;figcaption&gt;动漫图片&lt;/figcaption&gt; &lt;/figure&gt; &lt;!-- &lt;dl&gt; &lt;dd&gt; &lt;img src=&quot;img/2.jpg&quot; /&gt; &lt;/dd&gt; &lt;dd&gt; IT程序员 &lt;/dd&gt; &lt;/dl&gt; --&gt; &lt;!-- 展示详细信息 --&gt; &lt;details&gt; &lt;summary&gt;显示详细信息&lt;/summary&gt; &lt;p&gt;中国&lt;/p&gt; &lt;!-- mark标记 --&gt; &lt;mark&gt;中国2&lt;/mark&gt; &lt;p&gt;日本&lt;/p&gt; 美国 &lt;/details&gt; &lt;!-- 刻度 , max,min最大最小值， value默认值， low,high自己定义的最小值，最大值--&gt; &lt;meter max=&quot;100&quot; min=&quot;0&quot; value=&quot;100&quot; low=&quot;20&quot; high=&quot;80&quot;&gt;&lt;/meter&gt; &lt;!-- 进度条 --&gt; &lt;progress max=&quot;100&quot; value=&quot;40&quot;&gt;&lt;/progress&gt; &lt;!-- datalist 中描述了其可能的值 --&gt; &lt;datalist id=&quot;city&quot;&gt; &lt;option value=&quot;IBM&quot;&gt;IBM&lt;/option&gt; &lt;option value=&quot;ORACLE&quot;&gt;ORACLE&lt;/option&gt; &lt;/datalist&gt; &lt;input type=&quot;text&quot; list=&quot;city&quot; /&gt; &lt;!-- 画布标签 --&gt; &lt;canvas id=&quot;mycat&quot;&gt;&lt;/canvas&gt; &lt;script&gt; var ca = document.getElementById(&quot;mycat&quot;); var te = ca.getContext(&quot;2d&quot;); //背景颜色 te.fillStyle = &quot;#FF0000&quot;; //绘制图形的大小 te.fillRect(0,0,80,100); &lt;/script&gt;","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"SQL使用","slug":"DataBase/Oracle/SQL使用","date":"2019-07-01T04:55:01.000Z","updated":"2019-12-06T07:53:57.626Z","comments":true,"path":"2019/07/01/DataBase/Oracle/SQL使用/","link":"","permalink":"http://yoursite.com/2019/07/01/DataBase/Oracle/SQL使用/","excerpt":"","text":"SQLSQL语言基础SQL 语言定义 SQL，Structured Query Language 结构化查询语言 SQL 是所有关系型数据库的操作的标准语言 SQL 是非过程化语言-只需要告诉做什么，不需要关注怎么做 SQL 的用途 数据库数据的增删改查操作(GRUD) 数据库对象（用户，表格，序列，索引)的创建，修改和删除操作 用户权限/角色的授予和取消 事务 (Transaction) SQL 语言的分类a) DQL ，Data Query Language ，执行查询 select b) DML,Data Manipulation Language，执行增删改的任务 insert delete update c) DLL,Data Definition Language ,用于操作数库对象 add，modify，drop d) DCL,Data Control Language，用于操作用户权限，grant， revoke(撤与) e) TCL, Transaction Control Language, 事务控制语言 commit，rollback 关系数据库基本概念 关系：整个二维表 关系名：表格名称 元组：行数据(记录) 属性：列数据(字段) 属性名：列名称(字段名) 主键：唯一确定元组的属性组(关键字) 域：属性的取值范围 函数函数的分类​ 单行函数：这些函数仅对单个行进行运算，并且每行返回一个结果 ​ 多行函数（聚合函数）：这些函数能够操纵成组的行，每个行组给出一个结果，这些函数 ​ 也被称为组函数 单行函数的使用字符函数​ 数值函数​ 日期函数​ 转换函数​ 隐式转换 ​ 显示转换 ​ to_char（num or date,format） ​ to_number（char, format） ​ to_date（char, format） 通用(其他)函数​ NVL(EXP1, EXP2) ​ 如果exp1的值为null，则返回exp2的值，否则返回exp1的值 ​ NVL2(EXP1, EXP2, EXP3) ​ 如果exp1的值为null，则返回exp2的值，否则返回exp3的值 ​ NULLIF(expr1, expr2) ​ 比较两个表达式，如果相等，返回空，如果不相等，返回第一个表达式，第一个表达式不能为空 ​ expr1是对于expr2的被比较原值 ​ expr2是对于expr1的被比较原值(如果它不等于expr1,expr1被返回) ​ COALESCE(expr1, expr2, …expm) ​ expr1 如果非空，返回该表达式 ​ expr2 如果第一个表达式为空并且该表达式非空，返回该表达式 ​ expm 如果前面的表达式都为空，返回该表达式 ​ DECODE(VALUE,IF1,THEN1,IF2,THEN2,……,ELSE) ​ 如果value的值为if1，则返回then1的值，如果value的值为if2,则返回then2的值，……，否则返回else值 ​ 示例: ​ select REGION_ID, decode(REGION_ID, 1, ‘1号’, 2, ‘2号’, 3, ‘3号’, ‘错误’) from REGIONS ​ …… 多行函数的使用​ 多表查询内连接​ 内连接基本与自然连接相同，不同之处在于自然连接的是同名属性列的连接，而内连接则不要求两属性列同名，可以用using或on来指定某两列字段相同的连接条件。 自然连接​ 自然连接是一种特殊的等值连接，他要求两个关系表中进行连接的必须是相同的属性列（名字相同），无须添加连接条件，并且在结果中消除重复的属性列。 外连接左外连接​ 左外连接是在两表进行连接，只把左表要舍弃的保留在结果集中，右表对应的列上填null。 右外连接​ 右外连接是在两表进行连接，只把右表要舍弃的保留在结果集中，左表对应的列上填null。 全外连接​ 全外连接是在两表进行连接，只把左表和右表要舍弃的都保留在结果集中，相对应的列上填null。 ​","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://yoursite.com/tags/Oracle/"}]},{"title":"Oracle","slug":"DataBase/Oracle/oracle的用户","date":"2019-07-01T04:55:01.000Z","updated":"2019-07-01T05:01:12.267Z","comments":true,"path":"2019/07/01/DataBase/Oracle/oracle的用户/","link":"","permalink":"http://yoursite.com/2019/07/01/DataBase/Oracle/oracle的用户/","excerpt":"","text":"Oracle用户和登录sys和system1)【sys】所有 oracle 的数据字典的基表和视图都存放在 sys 用户中，这些基表和视图对于 oracle 的运行是至关重要的，由数据库自己维护，任何用户都不能手动更改。 sys 用户拥有 dba ， sysdba ， sysoper 等角色或权限，是 oracle 权限最高的用户。 2)【 system 】 用户用于存放次一级的内部数据，如 oracle 的一些特性或工具的管理信息。 system 用户拥有普通 dba 角色权限。 以normal,sysdba,sysopra身份登录normal 是普通用户 sysdba 拥有最高的系统权限，登陆后是 syssysoper 主要用来启动、关闭数据库， sysoper 登陆后用户是 public 注意:sys只能以sysdba身份登录","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://yoursite.com/tags/Oracle/"}]},{"title":"git提交github仓库","slug":"Config/git提交github仓库","date":"2019-06-28T15:12:26.000Z","updated":"2019-07-08T06:53:16.875Z","comments":true,"path":"2019/06/28/Config/git提交github仓库/","link":"","permalink":"http://yoursite.com/2019/06/28/Config/git提交github仓库/","excerpt":"","text":"git提交github仓库提交1) 本地新建一个文件夹res,作为项目根目录 2) 打开git,进入res, 3) git init 在项目根目录执行git init命令 4)建立远程仓库连接: (use ssh) ​ git remote add origin git@github.com:Momentonly/Java.git ​ git remote add origin git@github.com:账号名/仓库名.git ` 5)查看git状态: git status 6)git add -A 自动添加全部要上传到仓库的文件 7)git commit -m ‘注释’ 8) git push -u origin master 从远程分支拉取master分支并与本地master分支合并。 拉取1)git pull origin master:master 从远程分支拉取master分支并与本地master分支合并。 注意：当发现远程仓库已经有内容并提示先执行git pull，将内容进行合并后再上传，在执行git pull的时候，或者会出现 123456789There is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details git pull &lt;remote&gt; &lt;branch&gt;If you wish to set tracking information for this branch you can do so with: git branch --set-upstream-to=origin/&lt;branch&gt; master 也就是指定当前工作目录工作分支，跟远程的仓库，分支之间的链接关系。然后按照提示输入git branch --set-upstream-to=origin/master master与master分支关联，完成后再执行 git pull 和 git push,","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"log4j的配置","slug":"DataBase/MyBatis/Log4j的配置","date":"2019-06-25T00:50:30.000Z","updated":"2019-06-25T00:53:37.718Z","comments":true,"path":"2019/06/25/DataBase/MyBatis/Log4j的配置/","link":"","permalink":"http://yoursite.com/2019/06/25/DataBase/MyBatis/Log4j的配置/","excerpt":"","text":"log4jEclipse的log4j.properties配置 rootCategory以前的配置，不推荐使用 123456789101112131415161718192021# Set root category priority to INFO and its only appender to CONSOLE. #只打印到控制台，并设置日志级别# log4j.rootCategory=DEBUG, CONSOLE #打印到控制台，日志文件，并设置日志级别为DEBUGlog4j.rootCategory=DEBUG, CONSOLE, LOGFILE # CONSOLE is set to be a ConsoleAppender using a PatternLayout. #控制台的输出格式log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout #指定输出的信息格式 %m:message,%n:换行,%c:class,追踪产生日志的类#%l,包名类名方法名，第几行出现问题,log4j.appender.CONSOLE.layout.ConversionPattern=- %m %c %l%d&#123;yyyy-MM-dd HH:mm:ss&#125;%n # LOGFILE is set to be a File appender using a PatternLayout. #日志文件的输出格式log4j.appender.LOGFILE=org.apache.log4j.FileAppender log4j.appender.LOGFILE.File=d:/test.log log4j.appender.LOGFILE.Append=true log4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayout log4j.appender.LOGFILE.layout.ConversionPattern=- %m %l%n 详细配置详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#配置根日志优先级，及输出位置#语法：log4j.rootLogger = [debug],apppenderName1,appenderName2...log4j.rootLogger = debug,stdout,D #上面定义了两个输出位置名：stdout与D，现分别配置：#配置stdout为调试窗口输出:log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.out#指定了一个模式表达式的布局log4j.appender.stdout.layout=org.apache.log4j.PatternLayout#设置该模式表达式log4j.appender.stdout.layout.ConversionPattern=[%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n#说明：#[%-5p]:%p设置输出日志优先级，&apos;-&apos;表示左对齐，5表示日志优先级所占字符个数的宽度，取5是为了保持一致。如：[DEBUG]#%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125;,指定了打印日志时间与时间格式，SSS表示？#%l: 输出日志事件的发生位置，见第四部分。%n，输出换行符。%m，输出日志事件发生的方法名。#配置D为输出日志到文件：log4j.appender.D=org.apache.log4j.FileAppenderlog4j.appender.D.File=D:\\\\Program_software\\\\Apache7_0_75\\\\webapps\\\\testLog.loglog4j.appender.D.layout=org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern=[%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n####################################################################———————————配置详细说明，共四部分——————————##一、配置log4j.rootLogger#语法：log4j.rootLogger = [debug],apppenderName1,appenderName2...#如：log4j.rootLogger = debug,stdout#二、配置Appeder——输出位置#语法：log4j.appender.appenderName = fully.qualified.name.of.appender.class#完全合法的appenderName 有几类选择#1、控制台：org.apache.log4j.ConsoleAppender#对应选项：#Threshold=WARN:指定日志消息的输出最低层次#ImmediateFlush=true:默认日志立即打印#Target=System.err:默认情况下使用System.out 输出控制台#2、文件：org.apache.log4j.FileAppender#对应选项：#Threshold=WARN:指定日志消息输出最低层次#ImmediateFlush=true:默认日志立即打印#File=mylog.txt:指定输出路径，可以是任何路径#Append=false：默认值是true，为false则覆盖#3、周期产生日志文件：org.apache.log4j.DailyRollingFileAppender#对应选项：#Threshold=WARN:指定日志消息输出最低层次#ImmediateFlush=true:默认日志立即打印#File=a.log:指定消息输出到a.log文件，默认是从web服务器的根路径开始#Append=false：默认为true#DatePattern=&apos;.&apos;yyyy-ww:每周滚动一次文件，即每周产生一个新的文件。#也可指定周期：#&apos;.&apos;yyyy-MM:每月#&apos;.&apos;yyyy-ww:每周#&apos;.&apos;yyyy-MM-dd:每天#&apos;.&apos;yyyy-MM-dd-a：每天两次#&apos;.&apos;yyyy-MM-dd-HH：每小时#&apos;.&apos;yyyy-MM-dd-HH-mm：每分钟#4、指定文件尺寸大小产生日志文件：org.apache.log4j.RollingFileAppender#对应选项：#Threshold=WARN:指定日志消息输出最低层次#ImmediateFlush=true:默认日志立即打印#File=a.log：指定日志文件#Append=false：默认为true#MaxFileSize=100KB：单位可以是KB|MB|GB，日志文件达到最大时，将会自动滚动，即将原来的内容移到mylog.log.1文件#MaxBackupIndex=2：指定可以产生滚动文件的最大数#5、将日志以流格式发送到任意指定的地方：org.apache.log4j.WriterAppender#例如：#log4j.appender.R=org.apache.log4j.DailyRollingFileAppender #log4j.appender.R.File=D:\\\\eclipsespace\\\\testSSH\\\\WebContent\\\\WEB-INF\\\\testlog.log #三、配置日志信息的格式布局(layout)#layout负责格式化Appender 的输出#语法：#log4j.appender.appenderName.layout=fully.qualified.name.of.layout.class#有效的layout类名字有以下几种：#1、org.apache.log4j.HTMLLayout（以HTML表格形式布局） #该选项有以下几种： #LocationInfo=true:默认值是false,输出java文件名称和行号 #Title=my app file: 默认值是 Log4J Log Messages. #2、org.apache.log4j.PatternLayout（可以灵活地指定布局模式） #该选项有以下几种： #ConversionPattern=%m%n :指定怎样格式化指定的消息 #其中%m%n等符号所代表的含义如下： (有问题，暂不管)#－X号: X信息输出时左对齐； #%p: 输出日志信息优先级，即DEBUG，INFO，WARN，ERROR，FATAL, #%d: 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d&#123;yyy MMM dd HH:mm:ss,SSS&#125;，输出类似：2002年10月18日 22：10：28，921 #%r: 输出自应用启动到输出该log信息耗费的毫秒数 #%c: 输出日志信息所属的类目，通常就是所在类的全名 #%t: 输出产生该日志事件的线程名 #%l: 输出日志事件的发生位置，相当于%C.%M(%F:%L)的组合,包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10) #%x: 输出和当前线程相关联的NDC(嵌套诊断环境),尤其用到像java servlets这样的多客户多线程的应用中。 #%%: 输出一个&quot;%&quot;字符 #%F: 输出日志消息产生时所在的文件名称 #%L: 输出代码中的行号 #%m: 输出代码中指定的消息,产生的日志具体信息 #%n: 输出一个回车换行符，Windows平台为&quot;\\r\\n&quot;，Unix平台为&quot;\\n&quot;输出日志信息换行 #可以在%与模式字符之间加上修饰符来控制其最小宽度、最大宽度、和文本的对齐方式。如： #%20c：指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，默认的情况下右对齐。 #%-20c:指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，&quot;-&quot;号指定左对齐。 #%.30c:指定输出category的名称，最大的宽度是30，如果category的名称大于30的话，就会将左边多出的字符截掉，但小于30的话也不会有空格。 #%20.30c:如果category的名称小于20就补空格，并且右对齐，如果其名称长于30字符，就从左边交远销出的字符截掉。 # 如：%-4r %-5p %d&#123;yyyy-MM-dd HH:mm:ssS&#125; %c %m%n [TEST] %p [%t] %C.%M(%L) | %m%n #3、org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串） #4、org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息） #四、其他#指定包名下的日志级别#语法：log4j.logger.包名=日志级别#如：#log4j.logger.com.neusoft =DEBUG #指定com.neusoft包下的所有类的等级为DEBUG。 #log4j.logger.com.opensymphony.oscache=ERROR #log4j.logger.net.sf.navigator=ERROR #这两句是把这两个包下出现的错误的等级设为ERROR，如果项目中没有配置EHCache，则不需要这两句。 #log4j.logger.org.apache.commons=ERROR #log4j.logger.org.apache.struts=WARN ## #这两句是struts的包。作者：Liekkas_BX 来源：CSDN 原文：https://blog.csdn.net/qq_19865749/article/details/70306971 版权声明：本文为博主原创文章，转载请附上博文链接！","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"log4j","slug":"log4j","permalink":"http://yoursite.com/tags/log4j/"}]},{"title":"数据源和连接池","slug":"DataBase/MyBatis/数据源和连接池","date":"2019-06-22T05:24:30.000Z","updated":"2019-06-22T06:51:34.022Z","comments":true,"path":"2019/06/22/DataBase/MyBatis/数据源和连接池/","link":"","permalink":"http://yoursite.com/2019/06/22/DataBase/MyBatis/数据源和连接池/","excerpt":"","text":"数据源（1）数据源是一种数据库对编程提供的一个接口，每个数据源对应一个数据库。（2）连接池只是存放数据库连接对象的一个缓冲池，需要数据连接的时候从缓冲池中取就行了。（3）连接池可以管理数据源。 ​ 用TCP来连接你的应用程序与数据库是一件昂贵的事情（很费时的事情），开发者可以通过用连接池来反复的使用数据库的连接。比起每次请求都用TCP来连一次数据库，连接池只有在不存在有效的连接时才新建一个TCP连接。当关闭一个连接的时候，它会被放到池中，它仍然会保持与数据库的连接，这样就可以减少与数据库的TCP连接次数。​ 数据源是指数据的来源，比如数据库。连接池是指这样一个“池子”，池子中的每个东西都是连接数据源的一个“连接”，这样别人想连接数据源的时候可以从这个“池子”里取，用完以后再放回来供以后其他想使用的人使用。我们一般说的数据源指的就是数据库～ 数据源是指数据的来源的概括，包含了数据库位置 和 数据库类型等信息，实际上是一种数据连接的抽象。 也可以说，你要得到的信息存放的地方的概括（包括 存放信息的数据库类型、数据库的地址等等信息的概括） c3p0,dbcp,druid配置数据源也可以说是对整个数据库连接参数的配置（包括各种配置，以及连接池的管理）","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"}]},{"title":"mytabis的学习","slug":"DataBase/MyBatis/mytabis的学习","date":"2019-06-22T03:07:30.000Z","updated":"2019-06-30T09:19:55.388Z","comments":true,"path":"2019/06/22/DataBase/MyBatis/mytabis的学习/","link":"","permalink":"http://yoursite.com/2019/06/22/DataBase/MyBatis/mytabis的学习/","excerpt":"","text":"接口绑定方案MyBatis中，提供了一套接口绑定方案，程序员可以提供一个接口，然后提供对应接口的一个mapper.xml文件。 MyBatis会自动将接口和xml文件进行绑定，实际上就是MyBatis会根据接口和对应的xml文件创建接口的实现类。 可以得到实现类的对象。 实现: 映射文件的命名和接口的命名一致 映射文件的namespace写接口的全限定路径 Mapper接口与Mapper.xml放在同一个包下 mybatis如何通过接口查找对应的mapper.xml及方法执行详解链接:https://www.jb51.net/article/116402.htm mybatis中接口文件Mapper和接口配置文件Mapper.xml不在同一个目录下1：只有单独的Mybatis没有Spring的情况下 a:首先修改*Mapper.xml中的namespace 1&lt;mapper namespace=&quot;cn.gsm.mkm.dao.UserMapper&quot;&gt; 指定到你的*Mapper接口 b:在mybatis总配置文件中指定扫描目标 &lt;mappers&gt; &lt;mapper resource=&quot;cn/gsm/mkm/mapper/UserMapper.xml&quot;&gt;&lt;/mapper&gt; &lt;package name=&quot;cn.gsm.mkm.dao.UserMapper&quot;&gt;&lt;/package&gt;&lt;!-- 指定具体文件--&gt; &lt;/mappers&gt; 需要注意，这样配置必须指定具体的文件。否则dom4j解析会报错SAXParseException。 通过接口绑定解决多参数的传递1)接口中定义方法 1User selByUP(String username, String password); 映射文件中提供对应的标签. 此时, SQL语句中获取方式 有两种, 通过#{index}或#{param+数字}的方式. 12345&lt;select id=*&quot;selByUP&quot;* resultType=*&quot;user&quot;*&gt; select * from t_user where username=#&#123;0&#125; and password=#&#123;1&#125; &lt;/select&gt; 2) 接口中定义方法, 参数中使用@Param 注解设定参数名用 于在 SQL 语句中使用. 1User selByUP(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password); 映射文件中提供对应的标签. 此时, SQL语句中获取方式 有两种, 通过#{参数名称}或#{param+数字}的方式. 1234567&lt;select id=*&quot;selByUP&quot;* resultType=*&quot;user&quot;*&gt; select * from t_user where username=#&#123;username&#125; and password=#&#123;password&#125; &lt;/select&gt; 动态SQL根据条件的不同, SQL 语句也会随之动态的改变. MyBatis 中, 提供了一组标签用于实现动态 SQL. if标签用于进行条件判断, test 属性用于指定判断条件. 为了拼接 条件, 在 SQL 语句后强行添加 1=1 的恒成立条件. 1234567891011121314151617&lt;select id=*&quot;sel&quot;* resultType=*&quot;user&quot;*&gt; select * from t_user where 1=1 &lt;if test=*&quot;username != null and username != &apos;&apos;&quot;*&gt; and username=#&#123;username&#125; &lt;/if&gt; &lt;if test=*&quot;password != null and password != &apos;&apos;&quot;*&gt; and password=#&#123;password&#125; &lt;/if&gt; &lt;/select&gt; if标签中的test属性中取值直接写别名，不能用索引或者param+数字取值，也不用#{别名} 12345&lt;!-- 5.判断字符串是否等于特定字符(比如此处的user) --&gt;&lt;if test=&apos;stringParam != null and stringParam == &quot;user&quot;&apos;&gt;&lt;/if&gt;&lt;if test=&quot;stringParam != null and stringParam != &apos;user&apos;&quot;&gt;&lt;/if&gt; &lt;!-- 如果要用这个写法要 --&gt;&lt;if test=&quot;stringParam != null and stringParam != &apos;user&apos;.toString()&quot;&gt;&lt;/if&gt; where 标签用于管理 where 子句. 有如下功能: a)如果没有条件, 不会生成 where 关键字 b)如果有条件, 会自动添加 where 关键字 c)如果第一个条件中有 and, 去除之 1234567891011&lt;select id=&quot;sel&quot; resultType=&quot;user&quot;&gt;select * from t_user&lt;where&gt; &lt;if test=&quot;username != null and username != &apos;&apos;&quot;&gt; and username=#&#123;username&#125; &lt;/if&gt; &lt;if test=&quot;password != null and password != &apos;&apos;&quot;&gt; and password=#&#123;password&#125; &lt;/if&gt;&lt;/where&gt;&lt;/select&gt; choose,when,otherwise标签这是一套标签, 功能类似于 switch…case…default when只成立一个 12345678910111213141516171819&lt;select id=*&quot;sel&quot;* resultType=*&quot;user&quot;*&gt; select * from t_user &lt;where&gt; &lt;choose&gt; &lt;!-- when 只成立一个--&gt; &lt;when test=*&quot;username != null and username != &apos;&apos;&quot;*&gt; and username = #&#123;username&#125; &lt;/when&gt; &lt;when test=*&quot;password != null and password != &apos;&apos;&quot;*&gt; and password = #&#123;password&#125; &lt;/when&gt; &lt;otherwise&gt; and 1=1 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; Set标签用于维护 update 语句中的 set 子句. 功能如下: a)满足条件时, 会自动添加 set 关键字 b)会去除 set 子句中多余的逗号 c)不满足条件时, 不会生成 set 关键字 Trim标签用于在前后添加或删除一些内容 a)prefix, 在前面添加内容 b)prefixOverrides, 从前面去除内容 c)suffix, 向后面添加内容 d)suffixOverrides, 从后面去除内容 1234567891011121314&lt;update id=*&quot;updUser&quot;* parameterType=*&quot;user&quot;*&gt; update t_user &lt;!-- prefix: 前缀, 表示向前面添加内容 prefixOverrides: 从前面删除内容 suffix: 后缀, 表示向后面添加内容 suffixOverrides: 从后面删除内容 --&gt; &lt;trim prefix=*&quot;set&quot;* prefixOverrides=*&quot;user&quot;* suffix=*&quot;hahaha&quot;* suffixOverrides=*&quot;,&quot;*&gt; username=#&#123;username&#125;, &lt;/trim&gt; where id=#&#123;id&#125; &lt;/update&gt; bind标签用于对数据进行再加工, 用于模糊查询 12345678910&lt;select id=&quot;sel&quot; resultType=&quot;user&quot;&gt; select * from t_user &lt;where&gt; &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt; &lt;!-- 处理username，将值处理后依旧赋值给username --&gt; &lt;bind name=&quot;username&quot; value=&quot;&apos;%&apos; + username + &apos;%&apos;&quot;/&gt; and username like #&#123;username&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; foreach标签用于在 SQL 语句中遍历集合参数, 在 in 查询中使用 a)collection: 待遍历的集合 b)open: 设置开始符号 c)item: 迭代变量 d)separator: 项目分隔符 e)close: 设置结束符号 12345678910&lt;select id=&quot;selIn&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt;select * from t_user where id in&lt;!--collection=&quot;list&quot; 指定集合是list--&gt;&lt;foreach collection=&quot;list&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;item=&quot;item&quot;&gt;#&#123;item&#125;&lt;/foreach&gt;&lt;/select&gt;//接口中起别名listList&lt;User&gt; selIn(@Param(&quot;list&quot;) List&lt;Integer&gt; list); sql,include标签1234567891011121314151617&lt;sql&gt;用于提取 SQL 语句, &lt;include&gt;用于引用 SQL 语句&lt;sql id=&quot;mySql&quot;&gt;id, username, password&lt;/sql&gt; &lt;select id=&quot;selIn&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt; select &lt;!--引用提取的sql语句--&gt; &lt;include refid=&quot;mySql&quot;/&gt; from t_user where id in &lt;foreach collection=&quot;list&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot; item=&quot;item&quot;&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; MyBatis的缓存机制a)缓存用于提高查询的效率. b)MyBatis的缓存是使用SQL标签的. 执行相同的标签可以使用缓缓存. c) MyBatis 中有两种缓存机制. 注意:缓存的查询通过id标识，即同一个sql语句(namespace+id) 一级缓存a)默认开启. 线程级别的缓存, SqlSession 的缓存 b)在一个 SqlSession 生命周期中有效. SqlSession 关闭, 缓存清空.sqlSession对象级别的 二级缓存a)进程级别的缓存, SqlSessionFactory 的缓存 b)在一个 SqlSessionFactory 生命周期中有效.可以在多个 SqlSession 生命中期中共享. c)默认关闭, 需要使用的时候, 要为某个命名空间开启二级 缓存(在 mapper.xml 中配置\\&lt;cache>. 12&lt;!-- 开启二级缓存, 要求实体类进行序列化 --&gt;&lt;cache /&gt; 12&lt;!--readOnly只读，实体类可以不实现序列化接口--&gt;&lt;cache readOnly=&quot;true&quot;&gt;&lt;/cache&gt; 解决列名和属性名不一致问题如果查询时使用 resultType 属性, 表示采用 MyBatis 的 Auto-Mapping(自动映射)机制, 即相同的列名和属性名会自 动匹配. 因此, 当数据库表的列名和类的属性名不一致时, 会导致查不到数据. 解决该问题可以有两种方式: 列别名查询时, 可以通过列别名的方式将列名和属性名保持一致, 继续使用自动映射, 从而解决该问题. 但是较为麻烦. 123&lt;select id=&quot;selAll&quot; resultType=&quot;user&quot;&gt;select id id1, username username1, password password2 from t_user&lt;/select&gt; 使用\\&lt;resultMap>\\&lt;resultMap>用于自定义映射关系, 可以由程序员自主制定 列名和属性名的映射关系. 一旦使用 resultMap, 表示不再 采用自动映射机制. 1234567891011&lt;!--type实体类，id标识该resultMap--&gt;&lt;resultMap type=*&quot;user&quot;* id=*&quot;umap&quot;*&gt; &lt;!-- id用于映射主键 --&gt; &lt;id column=*&quot;id&quot;* property=*&quot;id1&quot;* /&gt; &lt;!-- 非主键使用result映射 --&gt; &lt;result column=*&quot;username&quot;* property=*&quot;username1&quot;* /&gt; &lt;result column=*&quot;password&quot;* property=*&quot;password1&quot;* /&gt; &lt;/resultMap&gt; &lt;select id=*&quot;selAll&quot;* resultMap=*&quot;umap&quot;*&gt; select * from t_user &lt;/select&gt; 多表查询resultMap的N+1方式实现多表查询（多对一）resultMap中的association属性用于关联一个对象 1） property: 指定要关联的属性名 2） select: 设定要继续引用的查询, namespace+id 3） column: 查询时需要传递的列 12345678910111213141516&lt;resultMap type=&quot;Student&quot; id=&quot;stumap&quot;&gt; &lt;!-- id用于映射主键 --&gt; &lt;id column=&quot;s_id&quot; property=&quot;id&quot;/&gt; &lt;!-- 非主键使用result映射 --&gt; &lt;result column=&quot;s_name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;s_age&quot; property=&quot;age&quot;/&gt; &lt;result column=&quot;s_gender&quot; property=&quot;gender&quot;/&gt; &lt;result column=&quot;s_c_id&quot; property=&quot;cid&quot;/&gt; &lt;!-- 用于关联一个对象 property:Student实体类中的属性 select:调用一个查询方法 column:使用哪一列的值作为参数传递到select调用的查询方法 注意:column使用数据库列名s_c_id --&gt; &lt;association property=&quot;clazz&quot; select=&quot;com.szxy.mapper.ClazzMapper.selById&quot; column=&quot;s_c_id&quot;&gt;&lt;/association&gt; &lt;/resultMap&gt; 关联查询a)在 StudentMapper.xml 中定义多表连接查询 SQL 语句, 一 次性查到需要的所有数据, 包括对应班级的信息. b)通过resultMap定义映射关系, 并通过association指 定对象属性的映射关系. 可以把association看成一个resultMap使用. javaType 属性表示当前对象, 可以写 全限定路径或别名. 12345678910111213141516171819202122&lt;!-- 关联查询 --&gt; &lt;resultMap type=&quot;Student&quot; id=&quot;smap&quot;&gt; &lt;id column=&quot;sid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;sname&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;s_age&quot; property=&quot;age&quot;/&gt; &lt;result column=&quot;s_gender&quot; property=&quot;gender&quot;/&gt; &lt;result column=&quot;s_c_id&quot; property=&quot;cid&quot;/&gt; &lt;!-- property:Student类的属性名 javaType:是一个类型，Clazz的类型,可以当做association的返回值类型 --&gt; &lt;association property=&quot;clazz&quot; javaType=&quot;Clazz&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;c_name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;c_room&quot; property=&quot;room&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=&quot;selAll&quot; resultMap=&quot;smap&quot;&gt; select s_id sid,s_name sname,s_age, s_gender,s_c_id cid,c_name cname,c_room from t_student s left join t_class c on s.s_c_id = c_id &lt;/select&gt; resultMap的N+1方式实现多表查询（一对多）​ 提供 ClazzMapper 和 StudentMapper, ClazzMapper 查询所有 班级信息, StudentMapper 根据班级编号查询学生信息. 在 ClazzMapper 中使用\\&lt;collection>设置装配. a)\\&lt;collection>用于关联一个集合  property: 指定要关联的属性名  select: 设定要继续引用的查询, namespace+id  column: 查询时需要传递的列 1234567891011&lt;!-- N+1多对一查询 --&gt; &lt;resultMap type=&quot;Clazz&quot; id=&quot;cmap&quot;&gt; &lt;id column=&quot;c_id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;c_name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;c_room&quot; property=&quot;room&quot;/&gt; &lt;!-- 关联一个集合 --&gt; &lt;collection property=&quot;stus&quot; select=&quot;com.szxy.mapper.StudentMapper.selByCid&quot; column=&quot;c_id&quot;&gt;&lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;selAll&quot; resultMap=&quot;cmap&quot;&gt; select * from t_class &lt;/select&gt; resultMap的关联方式实现多表查询（一对多）a)在 ClazzMapper.xml 中定义多表连接查询 SQL 语句, 一次 性查到需要的所有数据, 包括对应学生的信息. b)通过\\&lt;resultMap>定义映射关系, 并通过\\&lt;collection>指 定集合属性泛型的映射关系. 可以把\\&lt;collection>看成一 个\\&lt;resultMap>使用. ofType 属性表示集合的泛型, 可以 写全限定路径或别名. 注:colletion关联一个集合 1）property: Clazz类中的stus属性名 2)javaType: Clazz类中的stus属性的类型 3)ofType:stus属性是List集合，指定泛型 12345678910111213141516171819202122&lt;!-- 关联查询（多对一） --&gt; &lt;resultMap type=&quot;Clazz&quot; id=&quot;clzmap&quot;&gt; &lt;id column=&quot;cid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;cname&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;croom&quot; property=&quot;room&quot;/&gt; &lt;!-- 关联一个集合 ofType:集合的泛型 --&gt; &lt;collection property=&quot;stus&quot; javaType=&quot;list&quot; ofType=&quot;Student&quot;&gt; &lt;id column=&quot;sid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;sname&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;sage&quot; property=&quot;age&quot;/&gt; &lt;result column=&quot;sgender&quot; property=&quot;gender&quot;/&gt; &lt;result column=&quot;cid&quot; property=&quot;cid&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;selAll2&quot; resultMap=&quot;clzmap&quot;&gt; select c.c_id cid,c.c_name cname, c_room croom,s.s_id sid, s.s_name sname,s.s_age sage,s.s_gender sgender from t_class c left join t_student s on c.c_id = s.s_c_id &lt;/select&gt; 通过Auto-Mapping实现多表查询（多对一）a)通过 MyBatis 的 Auto-Mapping 机制及数据库查询时的别 名结合, 可以方便的实现多表查询. b)SQL 语句中, 别名出现特殊符号时, 必须进行处理. MySQL 可以使用()符号, Oracle 可以使用(“”)符号. 123456789&lt;!-- AutoMapping 将别名使用属性名.属性来进行自动映射 --&gt; &lt;select id=&quot;selAutoMapping&quot; resultType=&quot;Student&quot;&gt; select s_id id,s_name name,s_age age,s_gender gender,s_c_id cid,s_c_id `clazz.id`,c_name `clazz.name`,c_room `clazz.room` from t_student s left JOIN t_class c on s.s_c_id = c.c_id &lt;/select&gt; 注解开发a)注解是用于描述代码的代码. 例如: @Test(用于描述方法 进行 junit 测试), @Override(用于描述方法的重写), @Param(用于描述属性的名称) b)注解的使用风格: @xxx(属性), 使用前必须先导包 c)使用注解一般用于简化配置文件. 但是, 注解有时候也不 是很友好(有时候反而更麻烦), 例如动态 SQL. d)关于注解的属性  属性的设定方式是: 属性名=属性值 e)关于属性值的类型  基本类型和 String, 可以直接使用双引号的形式  数组类型, name={值 1, 值 2, …}; 如果数组元素只有 一个, 可以省略大括号  对象类型, name=@对象名(属性)  如果属性是该注解的默认属性, 而且该注解只配置这 一个属性, 可以将属性名省略 f)注解和配置文件可以配合使用 1234567891011@Select(&quot;select * from t_student&quot;) List&lt;Student&gt; selAll(); @Insert(value = &#123;&quot;insert into t_student values(default,#&#123;name&#125;,#&#123;age&#125;,#&#123;gender&#125;,#&#123;cid&#125;)&quot;&#125;) int insStu(Student student); @Update(value = &#123;&quot;update t_student set s_age = #&#123;age&#125; where s_id = #&#123;0&#125;&quot;&#125;) int updStu(int id, @Param(&quot;age&quot;)int age); @Delete(&quot;delete from t_student where s_id = #&#123;0&#125;&quot;) int delStu(int id); 其他注解 1234567@Results: 类似于&lt;resultMap&gt; @Result: 类似于&lt;resultMap&gt;的子标签 @One: 类似于&lt;association&gt; @Many: 类似于&lt;collection&gt; @One 1234567891011121314 //N+1查询@Select(&quot;select * from t_student&quot;)@Results(value = &#123; @Result(column = &quot;s_id&quot;, property = &quot;id&quot;,id = true), @Result(column = &quot;s_name&quot;, property = &quot;name&quot;), @Result(column = &quot;s_age&quot;, property = &quot;age&quot;), @Result(column = &quot;s_gender&quot;, property = &quot;gender&quot;), @Result(column = &quot;s_c_id&quot;, property = &quot;cid&quot;), @Result(property = &quot;clazz&quot;, one = @One(select = &quot;com.szxy.mapper.ClazzMapper.selById&quot;), column = &quot;s_c_id&quot; )&#125;)List&lt;Student&gt; sel(); @Many 1234567891011@Select(&quot;select * from t_class&quot;) @Results(value = &#123; @Result(column = &quot;c_id&quot;, property = &quot;id&quot;, id = true), @Result(column = &quot;c_name&quot;, property = &quot;name&quot;), @Result(column = &quot;c_room&quot;, property = &quot;room&quot;), @Result(property = &quot;stus&quot;, many = @Many(select = &quot;com.szxy.mapper.StudentMapper.selByCid&quot;), column = &quot;c_id&quot; ) &#125;) List&lt;Clazz&gt; selClz(); MyBatis运行原理运行过程中涉及到的类或接口1)Resources(C) 用于加载 MyBatis 核心配置文件 2)XMLConfigBuilder(C) 用于解析 xml 文件(核心配置文件) 3) Configuration(C) 用于存放 xml 文件解析后的结果 4)DefaultSqlSessionFactory(C) 是 SqlSessionFactory(I)的 实 现 类 , 创 建 时 需 要 使 用 Configuration 对象 5) SqlSession(I) 是 MyBatis 操作的核心 6)DefaultSqlSession(C) 是 SqlSession 接口的实现类 7) TransactionFactory(I) 用于生产 Transaction 对象 8) Transaction(I) 用于表示操作数据库的事务对象 9)Executor(I) 是 MyBatis 的核心执行器, 类似于 jdbc 中的 Statement, 常 用的实现类是 SimpleExecutor 描述​ 当Mybatis运行开始时，先要通过Resources加载核心配置文件，之后使用XmlConfigBuilder对配置文件进行 解析，将解析结果封装为Configuration对象。接着，使用Configuration对象构建一个DefaultSqlSessionFactory 对象，至此，SqlSession工厂构建完成。 ​ 接下来，通过工厂对象调用openSession方法创建SqlSession对象。在这个过程中，需要通过TransactionFactory 生产一个Transaction对象，并且，还需要创建核心执行器Executor对象。之后，通过这些对象来创建DefaultSqlSession对象，至此，SqlSession对象创建成功。 ​ 之后，通过SqlSession对象执行相应的操作。如果执行成功，调用commit()方法提交事务；如果失败，调用rollback()方法进行事务回滚。最后，调用close()方法关闭SqlSession资源，以上，就是MyBatis的运行原理。","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"}]},{"title":"mysql配置","slug":"Linux/mysql配置","date":"2019-06-20T14:35:59.000Z","updated":"2020-02-20T12:02:47.571Z","comments":true,"path":"2019/06/20/Linux/mysql配置/","link":"","permalink":"http://yoursite.com/2019/06/20/Linux/mysql配置/","excerpt":"","text":"mysql配置配置远程访问1.查看表 12345678use mysql;select host,user from user; host | user |+-----------+-----------+| % | root || localhost | mysql.sys || localhost | root | host是主机，root表示主机可以登录的用户，%表示所有主机，但不包括localhost 2.如果没有%,root 12grant all privileges on 库名.表名 to &apos;用户名&apos;@&apos;IP地址&apos; identified by &apos;密码&apos; with grant option;flush privileges; 库名:要远程访问的数据库名称,所有的数据库使用“*”表名:要远程访问的数据库下的表的名称，所有的表使用“*”用户名:要赋给远程访问权限的用户名称IP地址:可以远程访问的电脑的IP地址，所有的地址使用“%” 3.如果配置所有ip可以远程登录root 1234567GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos; WITH GRANT OPTION; 所有的地址都可以使用root用户，密码为123456远程访问所有的数据库和表GRANT ALL PRIVILEGES ON testdb.* TO &apos;lxh&apos;@&apos;172.16.52.225&apos; IDENTIFIED BY &apos;lxh&apos; WITH GRANT OPTION;IP为172.16.52.225的电脑可以使用lxh用户，密码为lxh远程访问数据库testdb的所有表 注意需要注意mysql的配置文件中的bindaddress 的参数和skip-networking 配置 bindaddress : 设定哪些ip地址被配置，使得mysql服务器只回应哪些ip地址的请求),最好注释掉该参数或设置成为127.0.0.1以外的值 skip-networking : 如果设置了该参数项，将导致所有TCP/IP端口没有被监听,也就是说出了本机，其他客户端都无法用网络连接到本mysql服务器，所以应该注释掉该参数 mysql修改密码如果MySQL数据库用户的密码设置过于简单，数据库在用户登录后会提示重置密码，并且不接受简单的密码。 提示需要重置密码： ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement. 1ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;; 以上操作后又遇到新问题：ERROR 1819 (HY000): Your password does NOT satisfy the CURRENT policy requirements。 这是因为密码不符合mysql的密码策略检查 先设置复杂密码 1ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;Aa123456*&apos;; flush privileges; mysql初始密码策略 1SHOW VARIABLES LIKE &apos;validate_password%&apos;; 使用以下两个设置简单密码策略 set global validate_password_policy=0; set global validate_password_length=1; 再设置简单密码 ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘123456’; flush privileges; mysql出现访问拒绝ERROR 1045 (28000): Access denied for user ‘root‘@’localhost’ (using password: YES) 解决： 1)修改mysql配置文件，跳过权限检查 ​ vim /etc/my.cnf ​ 加入 ​ skip-grant-tables ​ 重启mysql服务 2)修改密码 ​ use mysql; ​ update user set authentication_string=password(123456) where user=’root’; ​ flush privileges; 3)注释掉 ​ #skip-grant-tables ​ 重启mysql服务","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"hostname和hosts的区别","slug":"Linux/hostname和etchosts的区别","date":"2019-06-20T06:43:59.000Z","updated":"2019-07-16T07:44:29.011Z","comments":true,"path":"2019/06/20/Linux/hostname和etchosts的区别/","link":"","permalink":"http://yoursite.com/2019/06/20/Linux/hostname和etchosts的区别/","excerpt":"","text":"很多人一提到更改hostname首先就想到修改/etc/hosts文件，认为hostname的配置文件就是/etc/hosts。其实不是的。hosts文件的作用相当于DNS，提供IP地址hostname的对应。早期的互联网计算机少，单机hosts文件里足够存放所有联网计算机。不过随着互联网的发展，这就远远不够了。于是就出现了分布式的DNS系统。由DNS服务器来提供类似的IP地址到域名的对应。Linux系统在向DNS服务器发出域名解析请求之前会查询/etc/hosts文件，如果里面有相应的记录，就会使用hosts里面的记录。由此，/etc/hosts于设置hostname是没直接关系的，仅仅当你要在本机上用新的hostname来映射自己的IP时候才会用到/etc/hosts文件。两者没有必然的联系。redhat的hostname的配置文件是/etc/sysconfig/network. /etc/hosts内容摘录如下： #Do not remove the following line, or various programs #that require network functionality will fail. 192.168.1.102 localhost.localdomain localhost127.0.0.1 localhost.localdomain localhost::1 localhost6.localdomain6 localhost6对以上内容的解释作用：hosts 文件是用来把主机名字映射到IP地址的方法，这种方法比较简单。但这种映射只是本地映射，也就是说每台机器都是独立的，所有的计算机都不能相互通过hostname来访问。格式： 一般情况下hosts的内容关于主机名(hostname)的定义，每行为一个主机，每行由三部份组成，每个部份由空格隔开。其中#号开头的行做说明，不被系统解释。 第一部份：网络IP地址； 第二部份：主机名.域名，注意主机名和域名之间有个半角的点，比如 localhost.localdomain 第二部份：主机名(主机名别名） ，其实就是主机名；注释：1）127.0.0.1 是回环地址，比如我们不想让局域网的其它机器看到我们测试的网络程序，就可以用回环地址来测试。2）为什么需要定义域名呢？其实理解也简单，比如我们有三台主机，每台做不同的事，一台做MAIL服务器，一台做FTP服务器，一台做SMB服务器，所以我们就可以这样来设计hostname； 127.0.0.1 localhost.localdomain localhost 192.168.1.2 ftp 192.168.1.3 mail.localdomain mail 192.168.1.4 smb.localdomin smb把这上面这个配置文件的内容分别写入每台机器的/etc/hosts内容中，这样这三台局域网的机器就可以通过hostname来访问了。也就是，在局域网中，主机名也是可以解析到IP上的，相当于DNS域名解析。对于主机名的修改有两种方式:hostname和/etc/sysconfig/network [sql] view plaincopyprint?[root@think ~]# hostnamethin[root@think ~]# hostname think[root@think ~]# hostnamethink 通过hostname 这个kernel变量来设置主机名只是临时的，下次重启系统时，此主机名将不会存在.hostname也可用于显示:hostname -i。如果要永久修改RedHat hostname，就修改/etc/sysconfig/network文件，将里面的HOSTNAME这一行修改成HOSTNAME=NEWNAME，其中NEWNAME就是你要设置的hostname。 2./hosts文件可以帮助解决哪些问题2.1 远程登录linux主机过慢问题 有时客户端想远程登录一台linux主机，但每次登录输入密码后都会等很长一段时间才会进入，这是因为linux主机在返回信息时需要解析ip，如果在linux主机的hosts文件事先加入客户端的ip地址，这时再从客户端远程登录linux就会变很快。 注：这里所说的远程登录不仅仅是ssh，还可能是mysql远程登录，或是文件共享的查询等。 2.2 双机互连 当两台主机只是双机互连时，这时两台主机都需要设置自己的ip，同时在对方的hosts文件里加入自己的ip和主机名。 注：不同发行版的主机名称对应文件可以通过man host那么进行查阅 3.关于FQDN FQDN：(Fully Qualified Domain Name)完全合格域名/全称域名，是指主机名加上全路径，全路径中列出了序列中所有域成员。全域名可以从逻辑上准确地表示出主机在什么地方，也可以说全域名是主机名的一种完全表示形式。从全域名中包含的信息可以看出主机在域名树中的位置。DNS解析流程：首先查找本机HOSTS表，有的直接使用表中定义，没有查找网络连接中设置的DNS 服务器由他来解析。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"jdbc中的execute()返回值","slug":"DataBase/JDBC/jdbc中的execute()返回值","date":"2019-06-20T05:54:47.000Z","updated":"2019-06-22T06:51:51.725Z","comments":true,"path":"2019/06/20/DataBase/JDBC/jdbc中的execute()返回值/","link":"","permalink":"http://yoursite.com/2019/06/20/DataBase/JDBC/jdbc中的execute()返回值/","excerpt":"","text":"jdbc中的execute()返回值表示不同的操作 true表示查询 false表示更新或者删除","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"}]},{"title":"centos7配置dhcp和静态Ip","slug":"Linux/centos7配置DHCP和静态IP","date":"2019-06-20T05:19:59.000Z","updated":"2019-08-25T13:39:13.841Z","comments":true,"path":"2019/06/20/Linux/centos7配置DHCP和静态IP/","link":"","permalink":"http://yoursite.com/2019/06/20/Linux/centos7配置DHCP和静态IP/","excerpt":"","text":"cd /etc/sysconfig/network-scripts/ vi ifcfg-eth0 TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=static DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=eth0 UUID=85a5000d-dbaa-4a2a-8075-0df5562bf331 DEVICE=eth0 ONBOOT=yes IPADDR=192.168.1.166 NETMASK=255.255.255.0 GATEWAY=192.168.1.1 DNS1=8.8.8.8 DNS2=114.114.114.114 DNS3=223.6.6.6 1.静态IPBOOTPROTO=static #设置static IPADDR=192.168.1.166 #静态ip NETMASK=255.255.255.0 #子网掩码 GATEWAY=192.168.1.1 #网关 2.DHCP​ 12345BOOTPROTO=dhcp #设置dhcp#注释掉配置的静态ip部分#IPADDR=192.168.1.166 #NETMASK=255.255.255.0#GATEWAY=192.168.1.1 配置完成后重启网络 systemctl restart network","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"centos7安装缺少命令","slug":"Linux/安装centos7缺少命令问题","date":"2019-06-20T05:19:59.000Z","updated":"2019-07-16T07:45:09.684Z","comments":true,"path":"2019/06/20/Linux/安装centos7缺少命令问题/","link":"","permalink":"http://yoursite.com/2019/06/20/Linux/安装centos7缺少命令问题/","excerpt":"","text":"没有 ifconfig 、netstat命令： 1yum install -y net-tools 没有命令补全，tab补全命令： 1yum install -y bash-completion 没有killall命令： 1yum install -y psmisc","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"centos7修改网卡名","slug":"Linux/centos7修改网卡名","date":"2019-06-20T03:26:31.000Z","updated":"2019-06-20T05:14:57.104Z","comments":true,"path":"2019/06/20/Linux/centos7修改网卡名/","link":"","permalink":"http://yoursite.com/2019/06/20/Linux/centos7修改网卡名/","excerpt":"","text":"用ifconfig查看网卡名称为ens33，现在要将它修改成eth0 1)编辑配置文件/etc/sysconfig/network-scripts/ifcfg-ens33 将DEVICE=ens33修改成DEVICE=eth0 将NAME=ens33修改成NAME=eth0 保存并退出 2)重命名该配置文件。 [root@remote network-scripts]# cd /etc/sysconfig/network-scripts/ [root@remote network-scripts]# mv ifcfg-ens33 ifcfg-eth0 3)编辑/etc/default/grub并加入“net.ifnames=0 biosdevname=0 ” 示例:GRUB_CMDLINE_LINUX=”crashkernel=auto net.ifnames=0 biosdevname=0 rhgb quiet” 保存并退出 4)运行命令grub2-mkconfig -o /boot/grub2/grub.cfg 来重新生成GRUB配置并更新内核参数 5)使用reboot命令重启操作系统 注意:重启后查看ifcfg-eth0,dhcp可能被修改为static,如果没有配置静态ip网络会出错","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"数据库元数据MetaData","slug":"DataBase/JDBC/数据库元数据MetaDate","date":"2019-06-19T01:19:47.000Z","updated":"2019-06-22T06:52:17.759Z","comments":true,"path":"2019/06/19/DataBase/JDBC/数据库元数据MetaDate/","link":"","permalink":"http://yoursite.com/2019/06/19/DataBase/JDBC/数据库元数据MetaDate/","excerpt":"","text":"本篇介绍数据库方面的元数据（MetaData）的有关知识。元数据在建立框架和架构方面是特别重要的知识，再下一篇我们仿造开源数据库工具类DbUtils就要使用数据库的元数据来创建自定义JDBC框架。 在我们前面使用JDBC来处理数据库的接口主要有三个，即Connection，PreparedStatement和ResultSet这三个，而对于这三个接口，还可以获取不同类型的元数据，通过这些元数据类获得一些数据库的信息。 元数据(MetaData)，即定义数据的数据。打个比方，就好像我们要想搜索一首歌(歌本身是数据)，而我们可以通过歌名，作者，专辑等信息来搜索，那么这些歌名，作者，专辑等等就是这首歌的元数据。因此数据库的元数据就是一些注明数据库信息的数据。 ① 由Connection对象的getMetaData()方法获取的是DatabaseMetaData对象。 ② 由PreparedStatement对象的getParameterMetaData ()方法获取的是ParameterMetaData对象。 ③由ResultSet对象的getMetaData()方法获取的是ResultSetMetaData对象。 一、DatabaseMetaDataDatabaseMetaData是由Connection对象通过getMetaData方法获取而来，主要封装了是对数据库本身的一些整体综合信息，例如数据库的产品名称，数据库的版本号，数据库的URL，是否支持事务等等，能获取的信息比较多，具体可以参考DatabaseMetaData的API文档。 以下有一些关于DatabaseMetaData的常用方法： ·getDatabaseProductName：获取数据库的产品名称 ·getDatabaseProductName：获取数据库的版本号 ·getUserName：获取数据库的用户名 ·getURL：获取数据库连接的URL ·getDriverName：获取数据库的驱动名称 ·driverVersion：获取数据库的驱动版本号 ·isReadOnly：查看数据库是否只允许读操作 ·supportsTransactions：查看数据库是否支持事务 例1： 简单地获取一些常用的数据库综合信息。 二、ParameterMetaData ParameterMetaData是由PreparedStatement对象通过getParameterMetaData方法获取而来，主要是针对PreparedStatement对象和其预编译的SQL命令语句提供一些信息，比如像”insert into account(id,name,money) values(?,?,?)”这样的预编译SQL语句，ParameterMetaData能提供占位符参数的个数，获取指定位置占位符的SQL类型等等，功能也比较多，这里不列举完，详细请看有关ParameterMetaData的API文档。 以下有一些关于ParameterMetaData的常用方法： ·getParameterCount：获取预编译SQL语句中占位符参数的个数 在我看来，ParameterMetaData对象能用的只有获取参数个数的getParameterCount()方法。 注意：ParameterMetaData许多方法MySQL并不友好支持，比如像获取指定参数的SQL类型的getParameterType方法，如果数据库驱动连接URL只是简单的“jdbc:mysql://localhost:3306/jdbcdemo”那么MyEclipse会抛出SQLException异常，必须要将URL修改为“jdbc:mysql://localhost:3306/jdbcdemo?generateSimpleParameterMetadata=true”才行。但是像getParameterType等等与其他的方法也没多好用，因为如下面的例子，这些方法好像只会将所有的参数认为是字符串(VARCHAR)类型。 因为我们的SQL语句为”insert into user(id,name,age) values(?,?,?)”，而我们所有利用ParameterMetaData查询的信息除了参数个数以外，都是查询第一个参数的信息，也就是“id”列，而这个“id”列我们创建时是int整型的，但是利用ParameterMetaData的查询结果都是显示为字符串类型，因此我对ParameterMetaData的功能产生了怀疑。 因此在以后使用参数元数据ParameterMetaData尽量只要使用其getParamterCount()方法获取参数个数，对于该对象其他方法请慎用。 三、ResultSetMetaData ResultSetMetaData是由ResultSet对象通过getMetaData方法获取而来，主要是针对由数据库执行的SQL脚本命令获取的结果集对象ResultSet中提供的一些信息，比如结果集中的列数、指定列的名称、指定列的SQL类型等等，可以说这个是对于框架来说非常重要的一个对象。关于该结果集元数据对象的其他具体功能和方法请查阅有关ResultSetMetaData的API文档。 以下有一些关于ResultSetMetaData的常用方法： ·getColumnCount：获取结果集中列项目的个数 ·getColumnType：获取指定列的SQL类型对应于Java中Types类的字段 ·getColumnTypeName：获取指定列的SQL类型 ·getClassName：获取指定列SQL类型对应于Java中的类型(包名加类名)","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"JDBC操作数据库","slug":"DataBase/JDBC/JDBC操作数据库","date":"2019-06-17T14:35:47.000Z","updated":"2019-06-22T06:51:44.412Z","comments":true,"path":"2019/06/17/DataBase/JDBC/JDBC操作数据库/","link":"","permalink":"http://yoursite.com/2019/06/17/DataBase/JDBC/JDBC操作数据库/","excerpt":"","text":"","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"}]},{"title":"java中的时间类型和mysql中的时间类型","slug":"DataBase/JDBC/java中的时间类型和mysql中的时间类型","date":"2019-06-17T14:35:47.000Z","updated":"2019-07-22T02:04:31.401Z","comments":true,"path":"2019/06/17/DataBase/JDBC/java中的时间类型和mysql中的时间类型/","link":"","permalink":"http://yoursite.com/2019/06/17/DataBase/JDBC/java中的时间类型和mysql中的时间类型/","excerpt":"","text":"java中的时间类型和mysql中的时间类型mysql创建表并插入数据12345678910CREATE TABLE `time_test` ( `id` int(11) NOT NULL AUTO_INCREMENT, `dt` datetime DEFAULT NULL, `d` date DEFAULT NULL, `t` time DEFAULT NULL, `ts` timestamp(3) NULL DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;INSERT INTO `time_test` VALUES (&apos;1&apos;, &apos;2019-06-06 10:05:06&apos;, &apos;2019-06-06&apos;, &apos;03:03:55&apos;, &apos;2019-07-19 15:29:37.999&apos;); time_test表的查询结果 12id dt d t ts1 2019-06-06 10:05:06 2019-06-06 03:03:55 2019-07-19 15:29:37.999 JDBC解析结果集12345678910while(res.next())&#123; //date System.out.println(new Date(res.getDate(\"d\").getTime())); //time System.out.println(res.getTime(\"t\")); //datetime System.out.println(new Date(res.getTimestamp(\"dt\").getTime())); //timestamp（mysql中的timestamp需要3个长度，否则无法保存毫秒值） System.out.println(res.getTimestamp(\"ts\"));&#125; 分析：java.util.Date: 年月日，时分秒 ​ java.sql.Date: 年月日 ​ java.sql.Time: 时分秒 ​ java.sql.Timestamp: 年月日，时分秒 ，毫秒 ​ mysql中的数据类型是datetime,jdbc中使用res.getTimestamp(“列名”)来获取，再转换成java.util.Date()，可以得 到（年月日，时分秒），否则，如果使用res.getDate(“列名”)，再转换成java.util.Date则丢失 时分秒（res.getDate()返回java.sql.Date(),只能精确到年月日） 注意：mysql中的timestamp需要3个长度，否则无法保存毫秒值","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"}]},{"title":"关于时间插入MYSQL数据库少8个小时的问题","slug":"DataBase/JDBC/关于时间插入MYSQL数据库少8个小时的问题","date":"2019-06-17T14:35:47.000Z","updated":"2019-07-22T01:49:47.929Z","comments":true,"path":"2019/06/17/DataBase/JDBC/关于时间插入MYSQL数据库少8个小时的问题/","link":"","permalink":"http://yoursite.com/2019/06/17/DataBase/JDBC/关于时间插入MYSQL数据库少8个小时的问题/","excerpt":"","text":"指定连接参数（时区）1serverTimezone=Asia/Shanghai 修改mysql时区12set global time_zone = &apos;+8:00&apos;; ##修改mysql全局时区为北京时间，即我们所在的东8区flush privileges; #立即生效","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"}]},{"title":"mysql注释的三种写法","slug":"DataBase/JDBC/mysql注释的三种写法","date":"2019-06-17T08:07:47.000Z","updated":"2019-06-22T06:52:09.230Z","comments":true,"path":"2019/06/17/DataBase/JDBC/mysql注释的三种写法/","link":"","permalink":"http://yoursite.com/2019/06/17/DataBase/JDBC/mysql注释的三种写法/","excerpt":"","text":"MySql--三种注释写法 需要特别注意 -- 这种注释后面要加一个空格 #DELETE FROM SeatInformation /DELETE FROM SeatInformation /– DELETE FROM SeatInformation","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"properties文件的读取","slug":"Java Web/properties文件的读取","date":"2019-06-17T02:00:38.000Z","updated":"2019-06-17T02:06:02.317Z","comments":true,"path":"2019/06/17/Java Web/properties文件的读取/","link":"","permalink":"http://yoursite.com/2019/06/17/Java Web/properties文件的读取/","excerpt":"","text":"Java 开发中，需要将一些易变的配置参数放置再 XML 配置文件或者 properties 配置文件中。然而 XML 配置文件需要通过 DOM 或 SAX 方式解析，而读取 properties 配置文件就比较容易。 读取方式1、基于ClassLoder读取配置文件 ​ 注意：该方式只能读取类路径下的配置文件，有局限但是如果配置文件在类路径下比较方便。 2、基于 InputStream 读取配置文件 ​ 注意：该方式的优点在于可以读取任意路径下的配置文件 代码实现db.properties 12user=rootpwd=123 123456789101112131415161718192021222324252627282930313233343536package jdbc.com.szxy.properties;import java.io.File;import java.io.FileInputStream;import java.io.InputStream;import java.util.Properties;/** * 读取properties文件测试 * @author Momentonly */public class ProPertiesTest &#123; public static void main(String[] args) throws Exception &#123; /** * 基于ClassLoder读取配置文件 */ Properties pro1 = new Properties(); //获取资源的输入流,类路径下 InputStream is1 = ProPertiesTest.class.getClassLoader().getResourceAsStream(\"db.properties\"); //读取输入流 pro1.load(is1); // System.out.println(pro1.getProperty(\"user\")); System.out.println(pro1.getProperty(\"pwd\")); /** * 基于 InputStream 读取配置文件 */ Properties pro2 = new Properties(); //获取资源的输入流，相对路径或者绝对路径 InputStream is2 = new FileInputStream(new File(\"src/db.properties\")); pro2.load(is2); System.out.println(pro2.getProperty(\"user\")); System.out.println(pro2.getProperty(\"pwd\")); &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"Linux常用命令2","slug":"Linux/Linux常用命令2","date":"2019-06-16T08:56:55.000Z","updated":"2019-08-18T03:05:24.350Z","comments":true,"path":"2019/06/16/Linux/Linux常用命令2/","link":"","permalink":"http://yoursite.com/2019/06/16/Linux/Linux常用命令2/","excerpt":"","text":"1.scp -r root@39.104.111.122:/usr/local/ /usr/local ​ 将远程39.104.111.122的/usr/local下的文件拷贝到本机/usr/local目录下 ​ -r 复制目录 2.scp -r /usr/local root@39.104.111.122:/usr/local/ ​ 上传本地/usr/local目录到远程39.104.111.122的/usr/local目录 3.du -sh : 查看当前目录总共占的容量。而不单独列出各子项占用的容量 4.du -sh file:查看指定文件的大小 5.userdel -r 用户名 删除一个用户 6.passwd 用户名 修改密码 7.finger 查看登录的终端 8.last 用户名 查看登录记录 9.w -s 查看登录的终端用户 10.ls -lharts 查看文件详细信息 11.pwd 查看当前的路径 12.pgrep 进程名 查看进程的pid 13.ps -ef|grep 进程名 查看进程的pid 14.killall -9 bash 杀掉所有登录的bash 注:killall [参数][进程名] 用来杀掉同名的所有进程 15.&amp;和&amp;&amp;&amp;表示该命令后台执行。 例如执行：ping 192.168.1.* &amp; 表示后台不停的执行ping命令，即便你强制中断掉该线程，它仍然会不停的输出结果。除非你将该线程kill掉。 &amp;&amp;表示并行执行前后命令。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"手写服务器总结","slug":"Java Web/手写服务器总结","date":"2019-06-16T07:23:02.000Z","updated":"2019-06-16T14:16:50.731Z","comments":true,"path":"2019/06/16/Java Web/手写服务器总结/","link":"","permalink":"http://yoursite.com/2019/06/16/Java Web/手写服务器总结/","excerpt":"","text":"手写服务器总结搭建框架​ ………………… 实现编写web.xml123456789101112&lt;!--servlet处理请求--&gt;&lt;servlet&gt; &lt;!--LoginServlet别名:login --&gt; &lt;servlet-name&gt;login&lt;/servlet-name&gt; &lt;servlet-class&gt;com.szxy.httpserver.servlet.LoginServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!--浏览器的请求路径--&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;login&lt;/servlet-name&gt; &lt;url-pattern&gt;/login&lt;/url-pattern&gt; &lt;url-pattern&gt;/log&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; ​ 实体类保存解析xml中的信息 ​ Entity类:servlet-name,servlet-class ​ Mapping类:servlet-name,url-pattern 解析xmldom4j解析xml​ Entity:servlet-name,servlet-class ​ Entity通过String name，String clazz两个成员变量保存web.xml中的\\servlet-name,servlet-class ​ Mapping:servlet-name,url-pattern， ​ Mapping通过String name，和List urlPattern集合两个成员变量保存web.xml中的\\servlet-name,url-pattern， ServletContext类​ 上下文，是一个容器，描述Entity与Mapping之间的关系 该类的成员变量 12private Map&lt;String, String&gt; servlet; //key是servlet-name,value是servlet-classprivate Map&lt;String, String&gt; mapping; //key是url-pattern,value是servlet-name WebApp类​ 1）将Entity和Mapping中的servlet-name,servlet-class,url-pattern,servlet-name ​ 保存到ServletContext类的成员变量中。 ​ 请求路径作为key,获取servlet-name值，获取servlet-name ​ servlet-name作为key,获取servlet的 全路径名(包名+类名) ​ 1） 反射创建Servlet ​ 可以通过全路径名反射创建Servlet对象 1234567//根据url的key获取servlet-name的值 String servletName = context.getMapping().get(url);//根据servlet-name得到对应的servlet-class String servletClass = context.getServlet().get(servletName); //完整的包名和类名//使用反射创建Servlet对象 Class&lt;?&gt; clazz = Class.forName(servletClass); servlet = (Servlet) clazz.newInstance(); servlet建立抽象类Servlet12345678public abstract class Servlet &#123; public void service(Request req, Response rep)throws Exception&#123; this.doGet(req, rep); this.doPost(req, rep); &#125; public abstract void doGet(Request req, Response rep) throws Exception; public abstract void doPost(Request req, Response rep) throws Exception;&#125; 处理请求的Servlet继承Servlet例：登录LoginServlet 12345678910111213141516171819202122public class LoginServlet extends Servlet&#123;@Overridepublic void doGet(Request req, Response rep) throws Exception &#123; // TODO Auto-generated method stub //获取请求参数 String name = req.getParater(\"username\"); String pwd = req.getParater(\"pwd\"); if(\"bjsxt\".equals(name) &amp;&amp; \"123\".equals(pwd))&#123; //调用响应中的print方法 rep.println(name + \"登录成功\"); &#125;else&#123; rep.println(\"账号或者密码不正确\"); &#125; &#125;@Overridepublic void doPost(Request req, Response rep) throws Exception &#123; // TODO Auto-generated method stub &#125;&#125; 封装Request对象(浏览器的请求)​ 通过输入流获取浏览器的请求信息，然后根据HTTP协议，进行请求信息的处理 从请求信息中获取请求方式，路径，参数， 例：GET请求和POST请求的信息 1234567891011121314151617181920212223GET /log?username=bj&amp;pwd=123&amp;hobby=ball HTTP/1.1Host: localhost:8888Connection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.90 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9POST /log HTTP/1.1Host: localhost:8888Connection: keep-aliveContent-Length: 30Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Origin: nullContent-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.90 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9username=bj&amp;pwd=123&amp;hobby=ball 请求参数的乱码问题 处理中文，因为浏览器对中文进行了编码，因此需要解码服务器端获取到发过来的请求参数默认使用ISO8859-1进行解码操作，中文一定有乱码问题 12//value是请求参数，code是编码return URLDecoder.decode(value, code);//decode(keyValues[1].trim(), &quot;utf-8&quot;) 封装Response对象(服务器的响应)1.严格根据HTTP协议封装响应信息 123456789//响应头//协议，状态码，描述headInfo.append(&quot;HTTP1.1&quot;).append(BLANK).append(code).append(BLANK).append(&quot;&quot;);headInfo.append(CRLF);headInfo.append(&quot;Content-Type:text/html;charset=utf-8&quot;).append(CRLF);headInfo.append(&quot;Content-Length:&quot;+length).append(CRLF);headInfo.append(CRLF);//响应正文content.append(“&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;登录响应&lt;/title&gt;&lt;/head&gt;&lt;body&gt;登录成功&lt;/body&gt;&lt;/html&gt;”).append(CRLF); 2.响应正文可以调用Response类中的println(String info)进行设置 ​ content.append(info).append(CRLF); 封装分发器Dispatcher​ Dispatcher是一个请求与响应,并实现了Runnable接口 ​ 通过客户端连接的对象client,初始化Request和Response对象 12req = new Request(client.getInputStream());rep = new Response(client.getOutputStream()); run()方法实现 1.根据请求信息获取路径， 2.根据路径通过反射创建servlet 3.调用servlet的service()方法处理请求 4.rep.pushToClient(code);//响应，将封装后的Response信息发送给客户端 12345678910111213141516171819public void run() &#123; // TODO Auto-generated method stub //根据不同的url创建指定的servlet对象 Servlet servlet = WebApp.getServlet(req.getUrl()); if(servlet == null)&#123; this.code = 404; //路径找不到 &#125;else&#123; //调用service方法 try &#123; servlet.service(req, rep); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); this.code = 500; &#125; &#125; rep.pushToClient(code); IOCloseUtil.closeAll(client); &#125; ServerSocket服务器​ 创建一个ServelSocket对象，监听8888端口 1server = new ServerSocket(port); ​ 循环接收客户端请求，接收到请求，创建一个线程代理Dispatcher对象处理请求 12345678while(!isShutDown)&#123; //1)监听 Socket client = server.accept(); //创建线程类的对象 Dispatcher dis = new Dispatcher(client); //创建代理，启动线程 new Thread(dis).start();&#125; 解决浏览器请求的icon该请求是浏览器默认发送的:http://localhost:8888/favicon.ico 解决： ​ 1.在web.xml中配置路径 12345678&lt;servlet&gt; &lt;servlet-name&gt;favicon&lt;/servlet-name&gt; &lt;servlet-class&gt;com.szxy.httpserver.servlet.FaviconServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;favicon&lt;/servlet-name&gt; &lt;url-pattern&gt;/favicon.ico&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 2.创建FaviconServlet类继承Servlet ​","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"sublime的package control","slug":"Config/sublime的package control","date":"2019-06-15T07:13:46.000Z","updated":"2019-07-08T06:53:06.768Z","comments":true,"path":"2019/06/15/Config/sublime的package control/","link":"","permalink":"http://yoursite.com/2019/06/15/Config/sublime的package control/","excerpt":"","text":"sublime的package control​ preferences-&gt;package control出现There are no packages available for installation错误 据说是IPv6的原因，如果我们的Intent服务提供者（ISP）不支持IPv6就会引发上述错误，原文如下：This error is happened with IPv6 problem. If your Internet Service Provider (ISP) does not support for IPv6 you got this error. 从上面的描述可以知道首先需要获取sublime.wbond.net网站的IPv4地址，然后修改hosts文件就行了。 C:\\Windows\\System32\\drivers\\etc 修改hosts 50.116.34.243 sublime.wbond.net 50.116.34.243 packagecontrol.io Package control的install packageSublime包管理package control 打开install package报错 There are no packages available for installation 本地下载一个channel_v3.json文件:https://github.com/SuCicada/channel_v3.json 放入本地任意目录，然后打开sublime中的Preferences-&gt;package settings-&gt;package control-&gt;settings user 配置 “channels”: [ “H:\\SoftwarePro\\Sublime Text 3\\channel_v3.json” ], 保存重启","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"sublime","slug":"sublime","permalink":"http://yoursite.com/tags/sublime/"}]},{"title":"ThreadLocal的使用","slug":"JavaSE/ThreadLocal的使用","date":"2019-06-13T09:37:18.000Z","updated":"2019-06-22T07:02:46.818Z","comments":true,"path":"2019/06/13/JavaSE/ThreadLocal的使用/","link":"","permalink":"http://yoursite.com/2019/06/13/JavaSE/ThreadLocal的使用/","excerpt":"","text":"ThreadLocal的使用1.说明​ ThreadLocal 直译为“本地线程”，其实它就是一容器，用于 存放线程的局部变量 ​ 能够保持每一个线程里面的值是相应的，说明这些值已经达到了线程私有的目的。 ​ 当你在一个类中使用 static 成员变量时，一定要问自己这个 static 成员变量需要考虑“线程安全吗？” ​ （也就是说 多个线程需要自己独立的 static 成员变量吗？）如果需要那就需要使用 ThreadLocal。 ​ 作用:为解决多线程程序的并发问题 2.实现机制​ 首先获取当前线程，在获取当前线程的ThreadLocalMap ​ 每个Thread对象内部都维护了一个ThreadLocalMap这样一个ThreadLocal的Map，可以存放若干个 ThreadLocal。 123/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null; ​ 当我们在调用get()方法的时候，先获取当前线程，然后获取到当前线程的ThreadLocalMap对象，如果非空，那么取出ThreadLocal的value，否则进行初始化，初始化就是将initialValue的值set到ThreadLocal中。","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"}]},{"title":"Linux常用命令1","slug":"Linux/Linux常用命令1","date":"2019-06-12T05:51:55.000Z","updated":"2019-06-12T05:54:21.711Z","comments":true,"path":"2019/06/12/Linux/Linux常用命令1/","link":"","permalink":"http://yoursite.com/2019/06/12/Linux/Linux常用命令1/","excerpt":"","text":"文件 &amp; 目录操作（16 个） ls ● ls -a 查看所有文件，包含隐藏文件 ● ls -l 简写 ll，查看详细信息 ● ls -h 文件大小以易读的方式显示 cd ● cd ../ 返回上级目录 ● cd ~ 前往家目录 ● cd - 返回上一次所在目录 cp ● cp -r 复制目录及目录下文件 find ● find / -name ‘target’ 查询根目录下面文件名为 target 的文件 mkdir ● mkdir -p /tmp/test 递归创建目录 mv ● mv -f source destination 强制 pwd ● pwd 显示当前路径 rm ● rm -rf / 强制删除根目录及目录下的文件，就是我们通常所说的删库跑路 touch ● touch target 创建 target 文件，若文件存在则改变文件时间戳 tree ● tree 功能是以树形结构显示目录下的内容 basename ● basename /tmp/1 显示文件名 dirname ● dirname /tmp/1 显示路径 chattr ● chattr +i /tmp/1 加 i 属性，防止文件被修改 lsattr ● lsattr /tmp/1 查看文件的扩展属性 file ● file /tmp/1 显示文件类型 md5 ● md5 /tmp/1 显示文件 MD5 值 查看文件 &amp; 内容处理（18 个） cat ● cat -n 显示行号 ● cat file1 file2 打开文件 1 和 2 more ● more file1 逐页显示 less ● less file1 也是逐页显示，与 more 方向相反 head ● head -n file 显示文件头 n 行 tail ● tail -n file 显示文件尾 n 行 ● tailf file 实时显示文件尾 10 行，常用于跟踪日志信息 cut ● who|cut -b 1-3,5 输出每行的 1 至 3 个字节和第 5 个字节 ● who|cut -c -3 输出每行的 1 至 3 个字符 ● who|cut -c 3- 输出每行的第 3 个字符到行尾 ● who|cut -d ‘ ‘ -f 1 以空格为分隔符，输出第一个域 split ● split -b 10k date.file 将文件分割为 10k 的多个子文件 ● split -b 10k date.file split_file 指定子文件前缀为 split_file paste ● psate file1 file2 file3 将 3 个文件按列合并 sort ● sort -n 按照数值大小排序 ● sort -r 倒序排序 ● sort -t 指定分隔符 ● sort -u 忽略相同行 uniq ● uniq -c 显示出现次数，只有相邻的才算重复 ● uniq -d 只显示重复的行 ● unqi -u 只显示不重复的行 wc ● wc -l 显示列数 diff ● diff file1 file2 比较两个文件差异 rev ● rev file 反向输出文件内容 grep ● grep ‘target’ file 过滤输出文件中包含 target 的行 ● grep -v ‘target’ file 过滤输出文件中不包含 target 的行 ● grep -c ‘target’ file 过滤输出文件中包含 target 的行数 ● grep -i ‘target’ file 忽略大小写 ● egrep ‘[1-9]|a’ file 过滤输出正则匹配到的行 ● seq 10 | grep “5” -A 3 显示匹配某个结果之后的 3 行 ● seq 10 | grep “5” -B 3 显示匹配某个结果之前的 3 行 ● seq 10 | grep “5” -C 3 显示匹配某个结果的前三行和后三行 join ● join file1 file2 将两个文件中，指定栏位内容相同的行连接起来 tr ● cat text | tr ‘\\t’ ‘ ‘ 将制表符替换成空格 vim 三种模式： ● 编辑模式（命令模式） ● 输入模式 ● 末行模式 模式的转换 编辑 -&gt; 输入 i: 在当前光标所在字符的前面，转为输入模式； a: 在当前光标所在字符的后面，转为输入模式； o: 在当前光标所在行的下方，新建一行，并转为输入模式； I：在当前光标所在行的行首，转换为输入模式 A：在当前光标所在行的行尾，转换为输入模式 O：在当前光标所在行的上方，新建一行，并转为输入模式； 输入 -&gt; 编辑 ESC 编辑 -&gt; 末行： : 末行 -&gt; 编辑： ESC,ESC 打开文件 vim +# :打开文件，并定位于第#行 vim +：打开文件，定位至最后一行 vim +/PATTERN : 打开文件，定位至第一次被PATTERN匹配到的行的行首 关闭文件 :q 退出 :wq 保存并退出 :q! 不保存并退出 :w 保存 :w! 强行保存 移动光标（编辑模式） 逐字符移动 h: 左 l: 右 j: 下 k: 上 #h: 移动#个字符 以单词为单位移动 w: 移至下一个单词的词首 e: 跳至当前或下一个单词的词尾 b: 跳至当前或前一个单词的词首 #w: 移动#个单词 行内跳转 0: 绝对行首 ^: 行首的第一个非空白字符 $: 绝对行尾 行间跳转 #G：跳转至第#行 gg: 第一行 G：最后一行 翻屏 Ctrl+f: 向下翻一屏 Ctrl+b: 向上翻一屏 Ctrl+d: 向下翻半屏 Ctrl+u: 向上翻半屏 删除单个字符 x: 删除光标所在处的单个字符 #x: 删除光标所在处及向后的共#个字符 删除命令: d dd: 删除当前光标所在行 #dd: 删除包括当前光标所在行在内的#行； 撤消编辑操作 u：撤消前一次的编辑操作 #u: 直接撤消最近#次编辑操作 连续u命令可撤消此前的n次编辑操作 撤消最近一次撤消操作：Ctrl+r 查找 /PATTERN ?PATTERN n 下一个 N 上一个 文件压缩 &amp; 解压缩（3 个） tar ● tar zxvf FileName.tar.gz 解压 ● tar zcvf FileName.tar.gz DirName 压缩 zip ● zip -r html.zip/home/html 递归压缩 unzip ● unzip test.zip -d /tmp 解压到指定目录下 信息显示（11 个） uname ● uname -a 显示系统全部信息 hostname ● hostname 显示主机名 dmesg ● dmesg 显示开机信息 uptime ● uptime 显示系统运行时间及负载 stat ● stat 显示文件的状态信息 du ● du -sh 显示路径下所有文件大小 ● du -sh local 显示路径下 local 目录文件大小 ● du -sh * 显示路径下所有目录文件大小 df ● df -h 显示系统磁盘空间的使用情况 top ● top 实时显示系统资源使用情况 free ● free -m 以 M 为单位查看系统内存 date ● date +”%Y-%m-%d” 2019-05-28 ● date -d “1 day ago” +”% Y-% m-% d” 输出昨天日期 ● date -d “+1 day” +% Y% m% d 显示前一天的日期 ● date -d “-1 day” +% Y% m% d 显示后一天的日期 ● date -d “-1 month” +% Y% m% d 显示上一月的日期 ● date -d “+1 month” +% Y% m% d 显示下一月的日期 ● date -d “-1 year” +% Y% m% d 显示前一年的日期 ● date -d “+1 year” +% Y% m% d 显示下一年的日期 cal ● cal 日历信息 搜索文件（4 个） which ● which pwd 显示命令路径 find ● find /-name ‘target’ 查询根目录下面文件名为 target 的文件 whereis ● whereis php 查找二进制命令 locate ● locate target 从数据库 (/var/lib/mlocate/mlocate.db) 查找目标文件，使用 updatedb 更新库 进程管理（11 个） jobs ● jobs 查看当前有多少在后台运行的命令 bg ● bg 1 将一个在后台暂停的命令，继续执行，1 为作业号 ● （ctrl+z）可以挂起程序，返回作业号 fg ● fg 1 将后台中的命令调至前台继续运行 ，1 为作业号 kill ● kill 进程号 杀进程 ● kill -9 进程号 强杀进程 ● killall ● killall php 通过进程名字杀进程 ● killall -9 php 通过进程名字强杀进程 pkill ● 用法同上 crontab ● crontab -l 查看定时任务 ● crontab -e 编辑定时任务 ● crontab -l -u user1 查看 user1 定时任务，只有 root 才有权限 ● crontab -e -u user1 编辑 user1 定时任务，只有 root 才有权限 ps ● ps -ef 查看进程，显示 UID,PPIP,C 与 STIME，每个程序所使用的环境变量栏位 ● ps -axu 查看所有进程，并显示属于用户 pstree ● pstree -p 显示当前所有进程的进程号和进程 id 树 ● pstree -a 显示所有进程的所有详细信息树 nohup ● nohup command &amp; 退出账户时不挂断程序，仍在后台运行 pgrep ● pgrep -l httpd 查找 http 相关的进程号 用户管理（7 个） useradd ● useradd boy -u 888 建立一个新用户账户，并设置 ID ● useradd –g sales jack –G company,employees ● -g：加入主要组 -G：加入次要组 usermod ● usermod -G staff newuser2 将 newuser2 添加到组 staff 中 ● usermod -l newuser1 newuser 修改 newuser 的用户名为 newuser1 ● usermod -L newuser1 锁定账号 newuser1 ● usermod -U newuser1 解除对 newuser1 的锁定 userdel ● userdel -f user1 强制删除用户 ● userdel -r user1 删除用户的同时，删除与用户相关的所有文件 groupadd ● groupadd -g 1000 group1 建立一个新组，并设置组 ID 加入系统 passwd ● passwd user1 修改 user1 密码 ● passwd -l user1 锁住密码 ● passwd -d user1 删除密码 su ● su root 切换身份 sudo ● sudo command 已管理员身份运行命令 网络操作（11 个） telnet ● telnet 127.0.0.1 登录远程主机 ssh ● ssh root@127.0.0.1 -p22 登录远程主机 scp ● scp local_file remote_username@remote_ip:remote_folder 本地拷贝到远程 ● scp remote_username@remote_ip:remote_folder local_file 远程拷贝到本地 wget ● wget url 下载一个文件 ● wget –limit-rate=300k url 限速下载 ● wget -c url 断点续传 ● wget -b url 后台下载 ping ● ping www.baidu.com -c 2 收到两个包就结束 route ● route 显示当前路由 ifconfig ● ifconfig 查看、配置、启用或禁用网络接口 ifup ● ifup eth0 开启 eth0 网卡 ● ifdown ● ifdown eth0 关闭 eth0 网卡 netstat ● netstat -at 列出所有 tcp 端口 ● netstat -au 列出所有 udp 端口 ● netstat -l 只显示监听端口 ss ● ss -t -a 显示所有 tcp 链接 ● ss -l 显示处于监听状态的套接字 磁盘 &amp; 文件系统（7 个） mount ● mount /dev/hda1 /mnt 将 /dev/hda1 挂载到 /mnt 目录下 ● umount ● umount -v /mnt/mymount/ 卸载 /mnt/mymount/ fsck ● fsck -y /dev/hda2 检查并修复 Linux 文件系统 dumpe2fs ● dumpe2fs /dev/hda1 查看文件系统信息 dump ● ‍dump -0u -f /tmp/homeback.bak /home 将 /home 目录所有内容备份到 /tmp/homeback.bak 文件中，备份层级为 0 并在 /etc/dumpdates 中记录相关信息 fdisk ● fdisk /dev/sdb 输入 m 列出可以执行的命令 输入 p 列出磁盘目前的分区情况 输入 d 然后选择分区，删除现有分区 输入 print 查看分区情况，确认分区已经删除 输入 n 建立新的磁盘分区 输入 w 最后对分区操作进行保存 mkfs ● mkfs -t ext3 /dev/sda6 将 sda6 分区格式化为 ext3 格式 系统权限（3 个） chmod ● chmod 777 file1 修改 file1 文件权限为 777 ● chmod u+x,g+w file1 为 file1 设置自己可以执行，组员可以写入的权限 chown ● chown -R root /usr/meng 修改将目录 /usr/meng 及其下面的所有文件、子目录的文件主改成 root chgrp ● chgrp -R mengxin /usr/meng 将 /usr/meng 及其子目录下的所有文件的用户组改为 mengxin 关机重启（5 个） shutdown ● shutdown -h now 立即关机 ● shutdown +5 “System will shutdown after 5 minutes” 指定 5 分钟后关机，同时送出警告信息给登入用户 halt ● halt -p 关闭系统后关闭电源 ● halt -d 关闭系统，但不留下纪录 poweroff ● poweroff -f 强制关闭操作系统 logout ● logout 退出当前登录的 Shell exit ● exit 退出当前登录的 Shell 其他（6 个） echo ● echo ‘hello’ 打印字符串、变量 print ● printf ‘hell0’ 格式化输出字符串 rpm ● rpm -ivh your-package.rpm 安装 rpm 包 ● rpm -Uvh your-package.rpm 升级 rpm 包 ● rpm -e package 卸载 ● rpm -qa 列出所有安装过的包 ● rpm -ql 包名 rpm 包中的文件安装到那里去 yum ● yum install php 安装 php ● yum remove php 卸载 php clear ● clear 清屏 history ● history 10 最近使用的 10 条历史命令","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"c语言二维数组传递一维数组参数","slug":"C/c语言二维数组传递一维数组参数","date":"2019-06-09T07:46:09.000Z","updated":"2019-06-09T07:49:01.642Z","comments":true,"path":"2019/06/09/C/c语言二维数组传递一维数组参数/","link":"","permalink":"http://yoursite.com/2019/06/09/C/c语言二维数组传递一维数组参数/","excerpt":"","text":"123456789101112131415161718#include&lt;stdio.h&gt;void test(int a[]);int main()&#123; int a[2][2]; a[0][0] = 0; a[0][1] = 1; a[1][0] = 2; a[1][1] = 3; //printf(\"%d,%d,%d,%d\",a[0][0],a[0][1],a[1][0],a[1][1]); test(a[0]); //传递一维数组 test(a[1]); return 0;&#125;void test(int a[])&#123; printf(\"%d,%d\\n\",a[0],a[1]);&#125; 打印 : 0,1 ​ 2,3","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"IDEA的工作区间","slug":"Tools/IDEA的工作区间","date":"2019-06-05T15:09:08.000Z","updated":"2019-10-07T08:08:10.957Z","comments":true,"path":"2019/06/05/Tools/IDEA的工作区间/","link":"","permalink":"http://yoursite.com/2019/06/05/Tools/IDEA的工作区间/","excerpt":"","text":"IDEA中的项目概念与eclipse是不同的，IDEA的项目等同于eclipse中的workspace。Idea的module等同于eclipse中的project。所以我们要实现在一个项目导入多个module。 具体操作如下： File–&gt;Project Structure Import Module，然后选中自己要导入的项目即可 作者：wzz87来源：CSDN原文：https://blog.csdn.net/wzz87/article/details/80234880版权声明：本文为博主原创文章，转载请附上博文链接！","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/tags/tools/"}]},{"title":"重启eclipse color theme失效的解决办法","slug":"Config/Eclipse主题重启失效","date":"2019-06-02T09:22:09.000Z","updated":"2019-07-08T06:53:36.362Z","comments":true,"path":"2019/06/02/Config/Eclipse主题重启失效/","link":"","permalink":"http://yoursite.com/2019/06/02/Config/Eclipse主题重启失效/","excerpt":"","text":"重启eclipse color theme失效的解决办法** 1、在eclipse菜单栏 选择 windows &gt; Perferences； 2、找到Oomph &gt; Setup Task &gt; Perference Recorder选项； 3、将上方的Record Into勾选上，点恢复默认值(Restore Defaults)再应用(apply)-确定(Ok) 4.重启Eclipse主题生效 注：Perference Recorder可以同步Eclipse的配置参数","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"eclipse","slug":"eclipse","permalink":"http://yoursite.com/tags/eclipse/"}]},{"title":"C中的void与void*类型","slug":"C/C中的oid类型与void指针类型","date":"2019-04-24T00:38:14.000Z","updated":"2019-04-24T00:48:20.093Z","comments":true,"path":"2019/04/24/C/C中的oid类型与void指针类型/","link":"","permalink":"http://yoursite.com/2019/04/24/C/C中的oid类型与void指针类型/","excerpt":"","text":"c中的void表示不确定类型1.void类型​ int main(void)表示不可传递参数 ​ void类型不能定义变量 2. void*类型​ void*类型可与任意类型进行强制转换 1234int* p = NULL;*p = 10;void* v = (void *)p; //将int*类型的p强制转换为void*类型int k = *(int *)v; //将void*类型的v强制转换为int*类型 注：void类型强转后的类型需要与原来的类型保持一致*","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Java中serialVersionUID的解释及两种生成方式的区别","slug":"JavaSE/Java中serialVersionUID的解释及两种生成方式的区别","date":"2019-04-07T15:26:33.000Z","updated":"2019-06-22T07:02:25.250Z","comments":true,"path":"2019/04/07/JavaSE/Java中serialVersionUID的解释及两种生成方式的区别/","link":"","permalink":"http://yoursite.com/2019/04/07/JavaSE/Java中serialVersionUID的解释及两种生成方式的区别/","excerpt":"","text":"serialVersionUID作用： 序列化时为了保持版本的兼容性，即在版本升级时反序列化仍保持对象的唯一性。有两种生成方式： 一个是默认的1L，比如：private static final long serialVersionUID = 1L; 一个是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段，比如： private static final long serialVersionUID = xxxxL;关于其定义，可参考JDK文档：http://download.oracle.com/javase/1.5.0/docs/api/java/io/Serializable.html 在Eclipse中，提供两种方式让我们快速添加SerialVersionUid。 add default serial version ID：Adds a default serial version ID to the selected typeUse this option to add a user-defined ID in combination with custom serialization code if the type did undergo structural change since its first release. add generated serial version ID：Adds a generated serial version ID to the selected typeUse this option to add a compiler-generated ID if the type didnot undergo structural change since its first release. 一种就是1L，一种是生成一个很大的数，这两种有什么区别呢？ 看上去，好像每个类的这个类不同，似乎这个SerialVersionUid在类之间有某种关联。其实不然，两种都可以，从JDK文档也看不出这一点。我们只要保证在同一个类中，不同版本根据兼容需要，是否更改SerialVersionUid即可。 对于第一种，需要了解哪些情况是可兼容的，哪些根本就不兼容。 参考文档：http://java.sun.com/j2se/1.4/pdf/serial-spec.pdf 在可兼容的前提下，可以保留旧版本号，如果不兼容，或者想让它不兼容，就手工递增版本号。 1-&gt;2-&gt;3….. 第二种方式，是根据类的结构产生的hash值。增减一个属性、方法等，都可能导致这个值产生变化。我想这种方式适用于这样的场景： 开发者认为每次修改类后就需要生成新的版本号，不想向下兼容，操作就是删除原有serialVesionUid声明语句，再自动生成一下。 个人认为，一般采用第一种就行了，简单。第二种能够保证每次更改类结构后改变版本号，但还是要手工去生成，并不是修改了类，会提示你要去更新这个SerialVersionUid，所以虽然看上去很cool，实际上让人很迷惑。 参考： 1.一篇较好的关于serialVesionUid的说明： http://www.mkyong.com/java-best-practices/understand-the-serialversionuid/","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"java类初始化顺序","slug":"JavaSE/Java类初始化顺序","date":"2019-03-13T09:20:20.000Z","updated":"2020-04-06T09:10:52.006Z","comments":true,"path":"2019/03/13/JavaSE/Java类初始化顺序/","link":"","permalink":"http://yoursite.com/2019/03/13/JavaSE/Java类初始化顺序/","excerpt":"","text":"Java的类初始化顺序123456789101112131415161718192021222324252627282930313233343536373839404142package com.szxy;/** * * @author Administrator * */public class InitClassTest &#123; public static void main(String[] args) &#123; new B(); &#125;&#125;class A&#123; static A a = new A(); //1) static&#123; System.out.println(\"A:static\"); //2) &#125; C c = new C(); //5) &#123; //6) System.out.println(\"A:not static\"); &#125; public A() &#123; //7) System.out.println(\"A:constructor\"); &#125;&#125;class B extends A &#123; static&#123; System.out.println(\"B:static\"); //3) &#125; static B b = new B(); //4) &#123; //8) System.out.println(\"B:not static\"); &#125; public B() &#123; //9) System.out.println(\"B:constructor\"); &#125;&#125;class C&#123; public C() &#123; System.out.println(\"C\"); &#125;&#125; console打印 123456789101112131415C //1)A:not static //1)A:constructor //1)A:static //2)B:static //3)C //4)A:not static //4)A:constructor //4)B:not static //4)B:constructor //4)C //5)A:not static //6)A:constructor //7)B:not static //8)B:constructor //9) 根据打印结果：父类静态变量（静态代码块）-&gt; 子类静态变量（静态代码块） ​ -&gt; 父类成员变量（非静态代码块）-&gt; 父类构造方法 -&gt;子类成员变量（非静态代码块） ​ -&gt; 子类构造方法 ps：静态变量和静态代码块属于平级，谁在前谁先初始化； ​ 非静态代码块和成员变量属于平级，谁在前谁先初始化","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"性能测试工具locust","slug":"Python/性能测试工具locust","date":"2019-03-13T08:20:20.000Z","updated":"2019-06-22T06:49:27.911Z","comments":true,"path":"2019/03/13/Python/性能测试工具locust/","link":"","permalink":"http://yoursite.com/2019/03/13/Python/性能测试工具locust/","excerpt":"","text":"An open source load testing tool. 一个开源性能测试工具。 define user behaviour with python code, and swarm your system with millions of simultaneous users. 使用Python代码来定义用户行为。用它可以模拟百万计的并发用户访问你的系统。 1.安装Python2.安装Locustpip install locust 3.安装成功，CMD敲入命令验证。​ locust –help 4.创建load_test.py文件，通过Python编写性能测试脚本。123456789101112from locust import HttpLocust, TaskSet, taskclass UserBehavior(TaskSet): @task(1) def indesx(self): self.client.get(\"/\")class WebsiteUser(HttpLocust): task_set = UserBehavior min_wait = 3000 max_wait = 6000 创建UserBehavior()类继承TaskSet类，为用户行为类。 ​ 创建index() 方法表示一个行为。用@task() 装饰该方法为一个任务。1表示一个Locust实例被挑选执行的权重，数值越大，执行频率越高。在当前UserBehavior()行为下只有一个index()任务，所以，这里的权重设置为几，并无影响。 WebsiteUser()类用于设置性能测试。 task_set ：指向一个定义了的用户行为类。 min_wait ：用户执行任务之间等待时间的下界，单位：毫秒。 max_wait ：用户执行任务之间等待时间的上界，单位：毫秒。 5.命令行切换到性能测试脚本所在的目录，启动性能测试：1locust -f load_test.py --host=https://www.baidu.com ​ load_test.py 为测试脚本，https://www.baidu.com 为测试的网站。 ​ 打开浏览器访问：http://127.0.0.1:8089或者http://localhost:8089 ps:在pycharm中运行脚本 123if __name__ == '__main__':import osos.system(\"locust -f load_test.py --host=https://www.baidu.com\")","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"java的Package","slug":"JavaSE/java的Package","date":"2019-03-03T04:35:23.000Z","updated":"2019-06-22T07:01:48.575Z","comments":true,"path":"2019/03/03/JavaSE/java的Package/","link":"","permalink":"http://yoursite.com/2019/03/03/JavaSE/java的Package/","excerpt":"","text":"Java的Package没有包含关系 例如： com.szxy和com.szxy.test import com.szxy.*，则只能用com.szxy目录下的类 import com.szxy.test.*,则只能用com.szxy.test目录下的类","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"带标签的break和continue","slug":"JavaSE/带标签的break和continue","date":"2019-03-02T05:00:20.000Z","updated":"2019-06-22T07:09:16.364Z","comments":true,"path":"2019/03/02/JavaSE/带标签的break和continue/","link":"","permalink":"http://yoursite.com/2019/03/02/JavaSE/带标签的break和continue/","excerpt":"","text":"1.不带标签的break和continue break：跳出当前的循环 continue:跳出本次循环 2.带标签的break和continuebreak label:跳出到label，并且不再执行该循环。即跳出label标签下的所有循环 12345678label: for(int i = 0; i &lt; 10; i++) &#123; for(int j = 0; j &lt; 10; j++) &#123; if(i == 5) &#123; break label; &#125; System.out.println(i + \"\\t\" + j); &#125; &#125; continue label:跳出到label,继续执行该label标签后的循环。 12345678label: for(int i = 0; i &lt; 10; i++) &#123; for(int j = 0; j &lt; 10; j++) &#123; if(i == 5) &#123; continue label; &#125; System.out.println(i + \"\\t\" + j); &#125; &#125;","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java 内部类中使用局部变量必须是final","slug":"JavaSE/Java 内部类中使用局部变量必须是final(jdk1.8之前)","date":"2019-02-24T10:22:33.000Z","updated":"2019-06-22T07:01:28.426Z","comments":true,"path":"2019/02/24/JavaSE/Java 内部类中使用局部变量必须是final(jdk1.8之前)/","link":"","permalink":"http://yoursite.com/2019/02/24/JavaSE/Java 内部类中使用局部变量必须是final(jdk1.8之前)/","excerpt":"","text":"注：jdk1.8新特性，Java 内部类中使用局部变量可以不用final修饰 在java中， 方法的内部类可以访问方法中的局部变量，但必须用final修饰才能访问。原因：1.当方法被调用运行完毕之后，局部变量就已消亡了。但内部类对象可能还存在， 直到没有被引用时才会消亡。此时就会出现一种情况，就是内部类要访问一个不存在的局部变量。 2.解决这一问题的办法就是使用final修饰局部变量，通过将final局部变量”复制”一份,复制品直接作为方法内部类中的数据成员，这事方法内部类访问的其实是这个局部变量的复制品！ 而且，由于被final修饰的变量赋值后不能再修改，所以就保证了复制品与原始变量的一致。 3.原因二的功能能实现的原因是：Java采用了一种copy local variable(复制局部变量)的方式来实现，也就是说把定义为final的局部变量拷贝过来用，而引用的也可以拿过来用，只是不能重新赋值。从而造成了可以access local variable(访问局部变量)的假象，而这个时候由于不能重新赋值，所以一般不会造成不可预料的事情发生。 使用final修饰符不仅会保持对象的引用不会改变, 而且编译器还会持续维护这个对象在回调方法中的生命周期. 所以这才是final变量和final参数的根本意义. 作者：姚瑶大坏蛋2007来源：CSDN原文：https://blog.csdn.net/tongnuxie/article/details/50111485版权声明：本文为博主原创文章，转载请附上博文链接！","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"JavaIO流中InputStream中的read()方法返回int","slug":"JavaSE/javaIO流中的InputStream中的read()方法返回int","date":"2019-02-17T07:20:20.000Z","updated":"2019-06-22T07:01:37.529Z","comments":true,"path":"2019/02/17/JavaSE/javaIO流中的InputStream中的read()方法返回int/","link":"","permalink":"http://yoursite.com/2019/02/17/JavaSE/javaIO流中的InputStream中的read()方法返回int/","excerpt":"","text":"public abstract int read()throws IOExceptior从输入流中读取数据的下一个字节。返回0到255范围内的int字节值。如果因为已经到达流末尾而没有可用的字节,则返回值-1,数据可用、检测到流末尾或者抛出异常前,此方法一直阻塞。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.io.*;class MyBufferedInputStream//自定义BuffereedInputStream类&#123; //装饰设计模式 private InputStream in; private byte[] buffer=new byte[1024]; private int count=0; private int pos=0; MyBufferedInputStream(InputStream in)//构造器 &#123; this.in=in; &#125; //模拟read方法 public int Myread()throws IOException &#123; if(count==0) &#123; count=in.read(buffer); //计数器记录通过public int read(byte[] b)方法存 //到数组缓冲区的数据的总字节数 pos=0;//如果计数器为0，则位置指针归零 if(count&lt;0) return -1; &#125; byte b=buffer[pos]; pos++; count--; //return b&amp;255; return b&amp;0xff;//关键在此，为什么要返回b和0xff的与呢？ &#125; //重写close方法 public void Myclose()throws IOException &#123; in.close(); &#125;&#125;class Demo&#123; //为了代码简洁，这里直接抛IO异常了，正确的做法是try，catch。 public static void main(String[] args)throws IOException &#123; long start=System.currentTimeMillis(); Copy(); long end=System.currentTimeMillis(); System.out.println(&quot;runtime:&quot;+(end-start)+&quot;ms&quot;);//获取运行时间 &#125; public static void Copy()throws IOException//拷贝功能封装在Copy方法体里面 &#123; MyBufferedInputStream mb=new MyBufferedInputStream(new FileInputStream(&quot;3.mp3&quot;)); BufferedOutputStream bo=new BufferedOutputStream(new FileOutputStream(&quot;copy_1.mp3&quot;)); int ch=0; while((ch=mb.Myread())!=-1) bo.write(ch); bo.close(); mb.Myclose(); &#125;&#125; 为什么myread方法返回的是b和0xff的与呢？ read方法返回int的原因: 首先我们知道，mp3文件全部为二进制数据组成的。这就有一个问题，如果恰好read方法读取的字节是1111-1111（即byte型的-1）怎么办？这时候返回的是-1.那这样的话Copy方法中的while循环就会停止，也就没有复制。 解决方法： 我们伟大的程序员采取了一个办法.那就是返回int型 1111-1111如果变成int型的话，应该是int型的-1，即11111111-11111111-11111111-11111111， 我们将int型的-1和0xff &amp;一下， 11111111 11111111 -11111111 -11111111 &amp;00000000-00000000-00000000-11111111（int型的255） 00000000-00000000-00000000-11111111 这样返回的就是有效字节了，而且不会出现-1的情况。 read方法做了一个类型提升，其实write方法每次也是强转，将int型的数据再转换为byte，这样获取的还是有效字节。 作者：rowandjj来源：CSDN原文：https://blog.csdn.net/chdjj/article/details/8577861版权声明：本文为博主原创文章，转载请附上博文链接！","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"JAVA中类、实例与Class对象","slug":"JavaSE/JAVA中类、实例与Class对象","date":"2019-01-26T12:20:33.000Z","updated":"2019-06-22T07:02:33.476Z","comments":true,"path":"2019/01/26/JavaSE/JAVA中类、实例与Class对象/","link":"","permalink":"http://yoursite.com/2019/01/26/JavaSE/JAVA中类、实例与Class对象/","excerpt":"","text":"类​ 类是面向对象编程语言的一个重要概念，它是对一项事物的抽象概括，可以包含该事物的一些属性定义，以及操作属性的方法。面向对象编程中，我们都是以类来编码。 实例简单理解，就是new，就是对类的实例化，创建这个类对应的实际对象，类只是对事物的描述，而实例化就相当于为这个描述新开辟了一块内存，可以改变这块区域里的各种属性（成员变量），当然，也可以实例化多块区域，只是不同的对象而已。 Class注意这里C大写了，与类概念区分开，在java里，Class是一个实实在在的类，在包 java.lang 下，有这样一个Class.java文件，它跟我们自己定义的类一样，是一个实实在在的类，Class对象就是这个Class类的实例了。在Java里，所有的类的根源都是Object类，而Class也不例外，它是继承自Object的一个特殊的类，它内部可以记录类的成员、接口等信息，也就是在Java里，Class是一个用来表示类的类。Class是一个实实在在的类，可以为它创建实例，也就是本文后面提到的Class对象，也看叫做Class实例）。 java提供了下面几种获取到类的Class对象的方法： 1) 利用对象实例调用getClass()方法获取该对象的Class实例； ​ Class c=对象.getClass(); ​ 2) 使用Class类的静态方法forName(“包名+类名”)，用类的名字获取一个Class实例 ​ Class c=Class.forName(“包名+类名”); ​ 3)运用 类名.class 的方式来获取Class实例； ​ Class c = 类名.class 我们知道java世界是运行在JVM之上的，我们编写的类代码，在经过编译器编译之后，会为每个类生成对应的.class文件，这个就是JVM可以加载执行的字节码。运行时期间，当我们需要实例化任何一个类时，JVM会首先尝试看看在内存中是否有这个类，如果有，那么会直接创建类实例；如果没有，那么就会根据类名去加载这个类，当加载一个类，或者当加载器(class loader)的defineClass()被JVM调用，便会为这个类产生一个Class对象（一个Class类的实例），用来表达这个类，该类的所有实例都共同拥有着这个Class对象，而且是唯一的。 总结 在java里，类只是信息描述的，写明了有哪些内部属性及接口，你可以理解为是定义了一套规则；而Class对象在java里被用来对类的情况进行表述的一个实例，也就是是类的实际表征，可以理解为是对规则的图表化，这样JVM才能直观的看懂，可以看做是一个模版；而类的实例化对象，就是通过模版，开辟出的一块内存进行实际的使用。","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"关于XML文档的xmlns、xmlns:xsi和xsi:schemaLocation","slug":"Java Web/关于XML文档的xmlns、xmlnsxsi和xsischemaLocation","date":"2019-01-22T08:30:23.000Z","updated":"2020-04-12T07:55:37.240Z","comments":true,"path":"2019/01/22/Java Web/关于XML文档的xmlns、xmlnsxsi和xsischemaLocation/","link":"","permalink":"http://yoursite.com/2019/01/22/Java Web/关于XML文档的xmlns、xmlnsxsi和xsischemaLocation/","excerpt":"","text":"xmlns摘要：相信很多人和我一样，在编写Spring或者Maven或者其他需要用到XML文档的程序时，通常都是将这些XML文档头拷贝过来，并没有理解其中元素 （比如xmlns，xmlns:xsi，xsi:schemaLocation）的真正含义，不知道哪些元素是多余的，也不知道为什么要加那些元素。这样当有 时候网上Copy的XML头有错的时候自己却不知道怎么下手。我也是这样的，于是今天花了点时间好好的理解了一下这些元素及其用法，现整理与此，在此谢谢 各位前辈的经验，如有总结的不对或者不好的地方，欢迎留言提出各位的宝贵意见。 话不多说，先来一段Spring的XML样本，相信大家都很眼熟： 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;context:component-scan base-package=\"xxx.xxx.controller\" /&gt; &lt;context:annotation-config/&gt; &lt;mvc:default-servlet-handler/&gt; &lt;mvc:annotation-driven/&gt; &lt;mvc:resources mapping=\"/images/**\" location=\"/images/\" /&gt; &lt;bean id=\"xxx\" class=\"xxx.xxx.xxx.Xxx\"&gt; &lt;property name=\"xxx\" value=\"xxxx\"/&gt; &lt;/bean&gt;&lt;/beans&gt; ​ 这 个文档中，根元素\\&lt;beans/>就不用说了，接下来是xmlns。那么什么是xmlns呢？xmlns其实是XML Namespace的缩写，可译为“XML命名空间”，但个人觉得，翻译后的名字反而不好理解，所以我们就叫它为XML Namespace吧。 ​ 为什么需要xmlns？​ 考虑这样两个XML文档：表示HTML表格元素的\\&lt;table/>： 123456&lt;table&gt; &lt;tr&gt; &lt;td&gt;Apples&lt;/td&gt; &lt;td&gt;Bananas&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; ​ 和描述一张桌子的： 12345&lt;table&gt; &lt;name&gt;African Coffee Table&lt;/name&gt; &lt;width&gt;80&lt;/width&gt; &lt;length&gt;120&lt;/length&gt;&lt;/table&gt; ​ 假如这两个 XML 文档被一起使用，由于两个文档都包含带有不同内容和定义的 \\&lt;table> 元素，就会发生命名冲突。XML 解析器是无法确定如何处理这类冲突。为了解决上述问题，xmlns就产生了。 ​ 如何是用xmlns？​ 很简单，使用语法： xmlns:namespace-prefix=”namespaceURI”。其中namespace-prefix为自定义前缀，只要在这个XML文档中保证前缀不重复即可；namespaceURI是这个前缀对应的XML Namespace的定义。例如， 1xmlns:context=&quot;http://www.springframework.org/schema/context&quot; ​ 这一句定义了一个http://www.springframwork.org/schema/context的Namespace（这和Java类中的包的声明很相似），并将其和前缀context绑定。所以上面的Spring XML文档中会有这么一句： 1&lt;context:component-scan base-package=&quot;xxx.xxx.controller&quot;/&gt; ​ 这里的\\&lt;component-scan/>元素就来自别名为context的XML Namespace，也就是在http://www.springframework.org/schema/context中定义的。 ​ 我们还可以将前缀定义为abc： 1xmlns:abc=&quot;namespaceURI&quot; ​ 这样再使用这个namespaceURI中的元素时，需要以abc为前缀，例如：abc:xxx/。再拿上面的例子解释怎么使用xmlns： 123456&lt;!-- 这里xmlns:h=&quot;url1&quot;表示这个table是用h作为标记，table的写法在url1中定义 --&gt;&lt;h:table xmlns:h=&quot;url1&quot;&gt; &lt;h:tr&gt; &lt;h:td&gt;Apples&lt;/h:td&gt; &lt;h:td&gt;Bananas&lt;/h:td&gt; &lt;/h:tr&gt;&lt;/h:table&gt; ​ 和： 12345&lt;!-- 这里xmlns:f=&quot;url2&quot;表示这个table是用f作为标记，table的写法在url2中定义 --&gt;&lt;f:table xmlns:f=&quot;url2&quot;&gt; &lt;f:name&gt;African Coffee Table&lt;/f:name&gt; &lt;f:width&gt;80&lt;/f:width&gt; &lt;f:length&gt;120&lt;/f:length&gt;&lt;/f:table&gt; ​ 后者与前者仅仅使用不同前缀，我们为 \\&lt;table> 标签添加了一个 xmlns 属性，这样就为前缀赋予了一个与某个命名空间相关联的限定名称。此时再把它们放在一起，XML解析器就不会报错了。 ​ 注意：当xmlns被定义在元素的开始标签中（如这里的&lt;f:table/&gt;）时，所有带有相同前缀的子元素都会与同一个Namespace相关联（即&lt;f:table/&gt;里面的&lt;f:name/&gt;和&lt;f:width/&gt;也会使用url2定义的写法）。 ​ xmlns和xmlns:xsi有什么不同？​ xmlns表示默认的Namespace。例如Spring XML文档中的 1xmlns=&quot;http://www.springframework.org/schema/beans&quot; ​ 这一句表示该文档默认的XML Namespace为http://www.springframwork.org/schema/beans。**对于默认的Namespace中的元素，可以不使用前缀**。例如Spring XML文档中的 123&lt;bean id=&quot;xxx&quot; class=&quot;xxx.xxx.xxx.Xxx&quot;&gt; &lt;property name=&quot;xxx&quot; value=&quot;xxxx&quot;/&gt;&lt;/bean&gt; ​ xmlns:xsi表示使用xsi作为前缀的Namespace，当然前缀xsi需要在文档中声明。 xsi:schemaLocation有何作用？​ xsi:schemaLocation属性其实是Namespace为http://www.w3.org/2001/XMLSchema-instance里的schemaLocation属性，正是因为我们一开始声明了 1xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; ​ 这里才写作xsi:schemaLocation（当然一般都使用这个前缀）。它定义了XML Namespace和对应的 XSD（Xml Schema Definition）文档的位置的关系。它的值由一个或多个URI引用对组成，两个URI之间以空白符分隔（空格和换行均可）。第一个URI是定义的 XML Namespace的值，第二个URI给出Schema文档的位置，Schema处理器将从这个位置读取Schema文档，该文档的targetNamespace必须与第一个URI相匹配。例如： 12xsi:schemaLocation=&quot;http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot; ​ 这里表示Namespace为http://www.springframework.org/schema/context的Schema的位置为[http://www.springframework.org/schema/context/spring-context.xsd](http://www.springframework.org/schema/context/spring-context.xsd?spm=5176.100239.blogcont40353.18.KFHYwA&amp;file=spring-context.xsd)。这里我们可以打开这个Schema的位置，下面是这个文档的开始部分： 12345678&lt;xsd:schema xmlns=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:beans=&quot;http://www.springframework.org/schema/beans&quot; xmlns:tool=&quot;http://www.springframework.org/schema/tool&quot; &lt;!-- 这里的targetNamespace和上方xsi:schemaLocation中的第一个URI匹配 --&gt; targetNamespace=&quot;http://www.springframework.org/schema/context&quot; elementFormDefault=&quot;qualified&quot; attributeFormDefault=&quot;unqualified&quot;&gt; ​ xmlns=”http://www.w3.org/2001/XMLSchema&quot; ​ 表示当前xml文件是一个schema约束文件（这个属性的值是确定的，不能改变，这个就是一个标志） targetNamespace=”http://www.springframework.org/schema/context&quot; ​ 定义schema地址，被约束文件可以通过这个地址引入使用 xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance&quot; - 表示这是一个被约束的xml文件（标志） - :xsi 这个是别名，为了区分下面的xmlsn属性 xmlns=”http://www.springframework.org/schema/context&quot; - 这个就是引入schema文件，这个值就是schema的地址（包名） xsi:schemaLocation=”http://www.example.org/1 1.xsd” - schema地址 空格 schema路径 ​ 有了上面的说明后，再去理解开始的Spring XML文档，一定会有不一样的感觉！ ​ 最后再次感谢各位前辈的宝贵经验。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"XML","slug":"XML","permalink":"http://yoursite.com/tags/XML/"}]},{"title":"Java多线程之this与Thread.currentThread()的区别","slug":"JavaSE/Java多线程this与Thread.currentThread()的区别","date":"2019-01-18T12:11:44.000Z","updated":"2019-12-26T13:45:08.550Z","comments":true,"path":"2019/01/18/JavaSE/Java多线程this与Thread.currentThread()的区别/","link":"","permalink":"http://yoursite.com/2019/01/18/JavaSE/Java多线程this与Thread.currentThread()的区别/","excerpt":"","text":"this是当前代码所处的对象的线程，Thread.currentThread()是运行当前代码的线程。 12345678910111213141516171819202122232425262728293031public class CountOperate extends Thread&#123; public CountOperate() &#123; System.out.println(\"CountOperate.CountOperate()\"); System.out.println(\"Thread-currentThread.getName()\"+Thread.currentThread().getName()); System.out.println(\"Thread-currentThread.isAlive()\"+Thread.currentThread().isAlive()); System.out.println(\"this.getName()\"+this.getName()); System.out.println(\"this.isAlive()\"+this.isAlive()); System.out.println(\"Thread-currentThread==this\"+(Thread.currentThread()==this)); System.out.println(\"CountOperate.CountOperate()\"); &#125; @Override public void run() &#123; System.out.println(\"CountOperate.run()\"+Thread.currentThread().getName()); System.out.println(\"Thread-currentThread.getName()\"+Thread.currentThread().getName()); System.out.println(\"Thread-currentThread.isAlive()\"+Thread.currentThread().isAlive()); System.out.println(\"this.getName()\"+this.getName()); System.out.println(\"this.isAlive()\"+this.isAlive()); System.out.println(\"Thread-currentThread==this\"+(Thread.currentThread()==this)); System.out.println(\"CountOperate.run()\"); &#125; public static void main(String[] args) &#123; CountOperate c=new CountOperate(); c.start(); Thread t1=new Thread(c); System.out.println(\"main t1.isAlive()\"+t1.isAlive()); t1.setName(\"t1\"); t1.start(); System.out.println(\"main t1.isAlive()\"+t1.isAlive()); &#125;&#125; 打印的log 123456789101112131415161718192021222324252627//-----------------------------------------------CountOperate.CountOperate() //new CountOperate()的构造函数Thread-currentThread.getName()main //jvm创建一个进程，默认有一个线程调用mainThread-currentThread.isAlive()true this.getName()Thread-0 //当前new的CountOperate()对象的线程this.isAlive()falseThread-currentThread==thisfalseCountOperate.CountOperate()//------------------------------------------------main t1.isAlive()false //t1没有调用start()方法main t1.isAlive()true //t1调用过start()方法//------------------------------------------------CountOperate.run()Thread-0 //c.start()调用run()Thread-currentThread.getName()Thread-0Thread-currentThread.isAlive()truethis.getName()Thread-0 //this当前线程this.isAlive()trueThread-currentThread==thistrueCountOperate.run()//------------------------------------------------CountOperate.run()t1 Thread-currentThread.getName()t1 //Thread t1=new Thread(参数),Thread-currentThread.isAlive()true //t1是new的Thread，与传递的参数无关this.getName()Thread-0 //传过来的c对象参数，当执行t1.start(),this.isAlive()false //会调用c的run()方法Thread-currentThread==thisfalseCountOperate.run() 根据打印的Log可以知道调用CountOperate构造函数的是main线程，因此打印出 Thread.currentThread().getName()=mainThread.currentThread().isAlive()=true而此时还没有启动CountOperate子线程所以打印出this.getName=Thread-0this.isAlive()=false 此时this代表的是CountOperate对象实例，所以Thread.currentThread()==this :false 这里比较让人疑惑的是“this.getName() = Thread-0”，这个Thread-0是什么东西？？？通过查看Thread源码发现，在Thread类的构造方法中，会自动给name赋值，赋值代码： 123public Thread() &#123; init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0); &#125; 然后执行到:Thread t1 = new Thread(c);System.out.println(“main begin t1 isAlive=” + t1.isAlive());t1.setName(“t1”);t1.start(); 打印：Thread-currentThread.getName()t1Thread-currentThread.isAlive()trueThread.currentThread()==this :falsethis.getName()=Thread-0this.isAlive()=false说明此时的this和Thread.currentThread()指向不是同一个线程实例 也就是说，this指向的还是new CountOperate()创建的那个线程实例，而不是new Thread(thread)创建的那个实例即t1。查看源代码可以知道 123public Thread(Runnable target) &#123; init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0); &#125; 实际上new Thread(thread)会将thread应用的对象绑定到一个pravite变量target上，在t1被执行的时候即t1.run()被调用的时候，它会调用target.run()方法，也就是说它是直接调用thread对象的run方法，再确切的说，在run方法被执行的时候，this.getName()实际上返回的是target.getName()，而Thread.currentThread().getName()实际上是t1.getName()。","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java理解  子类成员变量与父类成员变量同名   方法的重写","slug":"JavaSE/成员变量的同名和方法的重写","date":"2019-01-17T14:53:34.000Z","updated":"2019-06-22T07:09:01.165Z","comments":true,"path":"2019/01/17/JavaSE/成员变量的同名和方法的重写/","link":"","permalink":"http://yoursite.com/2019/01/17/JavaSE/成员变量的同名和方法的重写/","excerpt":"","text":"1.子类父类成员变量同名1.子类的成员变量与父类成员变量同名时,在子类中父类成员变量被”隐藏”2.要想访问与父类的同名的成员变量, 两种方法 ①: 在子类中是用 super ②:将该变量强转成父类的类 3.对象是什么类型的(不是new的那个类型), 成员变量是什么类型. 2.子类对父类方法的重写子类的方法与父类的方法重名时(我们讲得是重写的情况, 方法名一致, 形参一致, 与返回值无关)叫做重写(覆盖), 顾名思义, 把父类的方法重写了. 所以怎么转换, 都是子类的方法.","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java和mysql的时间类型","slug":"JavaSE/java和mysql的时间类型","date":"2018-12-30T02:49:33.000Z","updated":"2019-07-19T11:41:05.966Z","comments":true,"path":"2018/12/30/JavaSE/java和mysql的时间类型/","link":"","permalink":"http://yoursite.com/2018/12/30/JavaSE/java和mysql的时间类型/","excerpt":"","text":"java.util.Date是不能直接插入数据库中的，虽然它包含了日期和时分秒。 java.sql.Date可以直接插入数据库，但是它只有日期而没有时间； java.sql.Time可以直接插入数据库，但是它只有时间，没有日期 Java.util.Date需要转换为Java.sql.Date,常规的方式转换过来只可以得到年月日，如若要取得时分秒，可以用Java.sql.Date类的子类Timestamp 参照这个就行了，这个对应注入类型。===========java注入数据库==========java类型 mysql类型 成功与否date date yesdate time nodate timestamp nodate datetime no time date notime time yestime timestamp notime datetime no timestamp date yestimestamp time yestimestamp timestamp yestimestamp datetime yes==========end java注入数据库========总规律，如果A完全包含B，则A可以向B注入数据，否则报错 ==========从数据库提取到java ==========mysql类型 java类型 成与否date date yesdate time yes ————–缺少的部分使用历元date timestamp yes ————–缺少的部分使用历元 time date yes ————–缺少的部分使用历元time time yestime timestamp yes ————–缺少的部分使用历元 timestamp date yestimestamp time yestimestamp timestamp yes datetime date yesdatetime time yesdatetime timestamp yes==========end 从数据库提取到java=======不会出错，缺少的部分使用历元，而不是当前日期时间 注意：看看数据库，发现毫秒数没了。再看看数据库的表字段属性，发现timestamp的长度设置为0。问题就出在这了，只需要把timestamp字段的长度设置为3，就可以保存毫秒数了。","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"String.split()分割字符串用法","slug":"JavaSE/字符串分割split","date":"2018-12-30T02:49:33.000Z","updated":"2019-06-22T07:10:51.566Z","comments":true,"path":"2018/12/30/JavaSE/字符串分割split/","link":"","permalink":"http://yoursite.com/2018/12/30/JavaSE/字符串分割split/","excerpt":"","text":"split方法的参数是一个正则表达式，因此遇到正则表达式中的元字符需要进行转义，而java中的特殊字符也需要转义，因此，分隔的字符既是java特殊字符也是元字符就需要二次转义才能正确分割字符串。 1.public string[] split(string regex)这里的参数的名称是 regex ，也就是 regular expression （正则表达式）。这个参数并不是一个简单的分割用的字符，而是一个正则表达式，它对一些特殊的字符可能会出现你预想不到的结果，比如测试下面的代码： （1） 用竖线 | 分隔字符串，你将得不到预期的结果 ​ String[] aa = “aaa|bbb|ccc”.split(“|”); //String[] aa = “aaa|bbb|ccc”.split(“\\\\|”); 这样才能得到正确的结果 for (int i = 0 ; i &lt;aa.length ; i++ ) { System.out.println(“–”+aa); } （2）用竖 * 分隔字符串运行将抛出java.util.regex.PatternSyntaxException异常，用加号 + 也是如此。 ​ String[] aa = “aaabbbccc”.split(“*“); //String[] aa = “aaa|bbb|ccc”.split(“\\\\*”); 这样才能得到正确的结果 for (int i = 0 ; i &lt;aa.length ; i++ ) { System.out.println(“–”+aa);} （3）显然，+ 不是有效的模式匹配规则表达式，用”\\\\“ “\\\\+”转义后即可得到正确的结果。 （4） “|” 分隔串时虽然能够执行，但是却不是预期的目的，”\\\\|”转义后即可得到正确的结果。 （5）还有如果想在串中使用”\\“字符，则也需要转义.首先要表达”aaaa\\bbbb”这个串就应该用”aaaa\\\\bbbb”,如果要分隔就应该这样才能得到正确结果： String[] aa = “aaa\\\\bbb\\\\bccc”.split(“\\\\\\\\“); （6） 还有就是点号”.”，也要首先转义才能得到正确的结果。 2、public String[] split(String regex,int limit)​ 根据匹配给定的正则表达式来拆分此字符串。 此方法返回的数组包含此字符串的每个子字符串，这些子字符串由另一个匹配给定的表达式的子字符串终止或由字符串结束来终止。数组中的子字符串按它们在此字符串中的顺序排列。如果表达式不匹配输入的任何部分，则结果数组只具有一个元素，即此字符串。 3.”|”作为连字符的使用如果在一个字符串中有多个分隔符，可以用”|作为连字符，比如：”acount=? and uu =? or n=?”,把三个都分隔出来，可以用 “acount=? and uu =? or n=?”.split(“and|or”);","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"保存和获取cookie中的中文信息","slug":"Java Web/对cookie中的中文处理","date":"2018-12-29T02:46:17.000Z","updated":"2019-03-13T08:21:01.712Z","comments":true,"path":"2018/12/29/Java Web/对cookie中的中文处理/","link":"","permalink":"http://yoursite.com/2018/12/29/Java Web/对cookie中的中文处理/","excerpt":"","text":"1.保存cookie问题： 出现500错误 解决：设置字符编码 Cookie cookie=new Cookie(“test”,URLEncoder.encode(“中文”,”utf-8”)); 2.获取cookie 问题：出现乱码 解决：设置字符解码 System.out.println(“cookie:”+cookies[i].getName()+”:”+URLDecoder.decode(cookies[i].getValue()))；","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"乱码","slug":"乱码","permalink":"http://yoursite.com/tags/乱码/"}]},{"title":"请求转发与重定向的理解","slug":"Java Web/请求转发与重定向","date":"2018-12-28T08:37:58.000Z","updated":"2020-03-25T09:42:31.611Z","comments":true,"path":"2018/12/28/Java Web/请求转发与重定向/","link":"","permalink":"http://yoursite.com/2018/12/28/Java Web/请求转发与重定向/","excerpt":"","text":"forward（转发）是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,因为这个跳转过程实在服务器实现的，并不是在客户端实现的所以客户端并不知道这个跳转动作，所以它的地址栏还是原来的地址. redirect（重定向）是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL. 区别： 转发是服务器行为，重定向是客户端行为。 1 )请求转发只能将请求转发给同一个WEB应用中的组件，而重定向还可以重新定向到同一站点不同应用程序中的资源，甚至可以定向到一绝对的URL。 2)重定向可以看见目标页面的URL，转发只能看见第一次访问的页面URL，以后的工作都是有服 务器来做的。 3) 请求响应调用者和被调用者之间共享相同的request对象和response对象，重定向调用者和被调用者属于两个独立访问请求和响应过程。 4)请求重定向：不加/是相对于本servlet所在请求的目录，加“/”表示端口号后面的根目录 http：//localhost:8080/ 请求转发：不加/是相对于本servlet，加/表示web应用的根目录http：//localhost:8080/Test/ ———path”/“路径——— —–只要是需要通过浏览器发送请求的地方（比如html代码，sendRedirect方法等）“/“一般代表虚拟主机根目录，即相当于端口号之后的“/”，例：http：//localhost:8080/ ——服务器程序内部跳转，“/”一般代表本web应用的根目录，如请求转发。例：http：//localhost:8080/Test/","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"servlet的乱码问题","slug":"Java Web/sevlet中的乱码","date":"2018-12-28T02:00:47.000Z","updated":"2019-08-01T10:03:57.995Z","comments":true,"path":"2018/12/28/Java Web/sevlet中的乱码/","link":"","permalink":"http://yoursite.com/2018/12/28/Java Web/sevlet中的乱码/","excerpt":"","text":"1.post请求1）jsp等页面编码格式1pageEncoding=&quot;UTF-8&quot; 设置JSP编译成Servlet时使用的编码。 2）设置请求信息的的解码格式1req.setCharacterEncoding(&quot;utf-8&quot;); 用指定的编码集去覆盖request对象中的默认的”ISO-8859-1”编码集 3）设置响应信息的编码格式1resp.setCharacterEncoding(&quot;utf-8&quot;); 设置服务器的响应编码 4）设置浏览器的解码格式1resp.setContentType(&quot;text/html;charset=utf-8&quot;); 浏览器对服务器响应进行解码 2.get请求​ 同post请求所有要求再加上（配置tomcat） 1） 配置tomcat的server.xml​ 在 &lt;Connector connectionTimeout=”20000” port=”8080” ​ protocol=”HTTP/1.1” redirectPort=”8443”/&gt; ​ 中加入 useBodyEncodingForURI=”true” ​ &lt;Connector connectionTimeout=”20000” port=”8080” ​ protocol=”HTTP/1.1” redirectPort=”8443” ​ useBodyEncodingForURI=”true”/&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"乱码","slug":"乱码","permalink":"http://yoursite.com/tags/乱码/"}]},{"title":"修改Hexo主题","slug":"Config/修改Hexo主题","date":"2018-10-12T10:51:13.000Z","updated":"2019-07-08T06:52:53.920Z","comments":true,"path":"2018/10/12/Config/修改Hexo主题/","link":"","permalink":"http://yoursite.com/2018/10/12/Config/修改Hexo主题/","excerpt":"","text":"1.获取主题cd themes 再将yilia主题clone至themes文件夹中 git clone https://github.com/litten/hexo-theme-yilia.git yilia 2.配置：修改hexo根目录下的_config.yml theme:yilia 3.更新:12cd themes/yiliagit pull 4.发布12hexo cleanhexo d -g","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/tags/tools/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-10-11T14:51:01.594Z","updated":"2018-10-11T14:51:01.594Z","comments":true,"path":"2018/10/11/hello-world/","link":"","permalink":"http://yoursite.com/2018/10/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}