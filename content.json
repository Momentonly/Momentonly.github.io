{"meta":{"title":"Momentonly","subtitle":null,"description":null,"author":"Moment Only","url":"http://yoursite.com"},"pages":[{"title":"","date":"2019-07-13T02:34:24.788Z","updated":"2018-12-31T06:06:59.363Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"123layout: categoriestitle: categories ---"},{"title":"","date":"2019-07-13T02:34:38.979Z","updated":"2018-12-31T06:06:40.300Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"123layout: tagstitle: tags ---"}],"posts":[{"title":"Spring3.1的缓存机制","slug":"Spring/Spring3.1的缓存机制","date":"2020-06-10T13:20:59.000Z","updated":"2020-06-09T15:26:15.188Z","comments":true,"path":"2020/06/10/Spring/Spring3.1的缓存机制/","link":"","permalink":"http://yoursite.com/2020/06/10/Spring/Spring3.1的缓存机制/","excerpt":"","text":"Spring3.1的缓存机制一 Spring 3.1 新增了一种全新的缓存机制，这种缓存机制与Spring容器无缝地整合在一起，可以对容器中的任意Bean或Bean的方法增加缓存。Spring的缓存机制非常灵活，它可以对容器中的任意Bean或的Bean的任意方法进行缓存，因此这种缓存机制可以在Java EE应用的任何层次上进行缓存。 提示 ： 与Hibernate SessionFactory级别的二级缓存相比，Spring 缓存的级别更高，SPring缓存可以在控制组件或业务逻辑组件级别进行缓存，这样应用完全无须重复调用底层的DAO组件的方法。 Spring 缓存同样不是一种具体的缓存实现方案，它底层同样需要依赖EhCache、Guava等具体的缓存实现。但这也正是Spring缓存机制的优势，应用程序只要面向Spring缓存API编程，应用底层的缓存实现可以在不同的缓存实现之间自由切换，应用程序无须任何改变，只要对配置文件略作修改即可。 二Spring从3.1开始定义了org.springframework.cache.Cache和org.springframework.cache.CacheManager接口来统一不同的缓存技术；并支持使用JCache（JSR-107）注解简化我们开发； Cache接口为缓存的组件规范定义，包含缓存的各种操作集合； Cache接口下Spring提供了各种xxxCache的实现；如RedisCache，EhCacheCache ,ConcurrentMapCache等； 每次调用需要缓存功能的方法时，Spring会检查检查指定参数的指定的目标方法是否已经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取。 使用Spring缓存抽象时我们需要关注以下两点； 1、确定方法需要被缓存以及他们的缓存策略 2、从缓存中读取之前缓存存储的数据 ：几个重要概念&amp;缓存注解| 名称 | 解释 || ————– | ———————————————————— || Cache | 缓存接口，定义缓存操作。实现有：RedisCache、EhCacheCache、ConcurrentMapCache等 || CacheManager | 缓存管理器，管理各种缓存（cache）组件 || @Cacheable | 主要针对方法配置，能够根据方法的请求参数对其进行缓存 || @CacheEvict | 清空缓存 || @CachePut | 保证方法被调用，又希望结果被缓存。 与@Cacheable区别在于是否每次都调用方法，常用于更新 || @EnableCaching | 开启基于注解的缓存 || keyGenerator | 缓存数据时key生成策略 || serialize | 缓存数据时value序列化策略 || @CacheConfig | 统一配置本类的缓存注解的属性 | @Cacheable/@CachePut/@CacheEvict 主要的参数 | 名称 | 解释 || —————————— | ———————————————————— || value | 缓存的名称，在 spring 配置文件中定义，必须指定至少一个 例如： @Cacheable(value=”mycache”) 或者 @Cacheable(value={”cache1”,”cache2”} || key | 缓存的 key，可以为空，如果指定要按照 SpEL 表达式编写， 如果不指定，则缺省按照方法的所有参数进行组合 例如： @Cacheable(value=”testcache”,key=”#id”) || condition | 缓存的条件，可以为空，使用 SpEL 编写，返回 true 或者 false， 只有为 true 才进行缓存/清除缓存 例如：@Cacheable(value=”testcache”,condition=”#userName.length()&gt;2”) || unless | 否定缓存。当条件结果为TRUE时，就不会缓存。 @Cacheable(value=”testcache”,unless=”#userName.length()&gt;2”) || allEntries (@CacheEvict ) | 是否清空所有缓存内容，缺省为 false，如果指定为 true， 则方法调用后将立即清空所有缓存 例如： @CachEvict(value=”testcache”,allEntries=true) || beforeInvocation (@CacheEvict) | 是否在方法执行前就清空，缺省为 false，如果指定为 true， 则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法 执行抛出异常，则不会清空缓存 例如： @CachEvict(value=”testcache”，beforeInvocation=true) | 三：SpEL上下文数据Spring Cache提供了一些供我们使用的SpEL上下文数据，下表直接摘自Spring官方文档： | 名称 | 位置 | 描述 | 示例 || ————- | ———- | ———————————————————— | ———————- || methodName | root对象 | 当前被调用的方法名 | #root.methodname || method | root对象 | 当前被调用的方法 | #root.method.name || target | root对象 | 当前被调用的目标对象实例 | #root.target || targetClass | root对象 | 当前被调用的目标对象的类 | #root.targetClass || args | root对象 | 当前被调用的方法的参数列表 | #root.args[0] || caches | root对象 | 当前方法调用使用的缓存列表 | #root.caches[0].name || Argument Name | 执行上下文 | 当前被调用的方法的参数，如findArtisan(Artisan artisan),可以通过#artsian.id获得参数 | #artsian.id || result | 执行上下文 | 方法执行后的返回值（仅当方法执行后的判断有效，如 unless cacheEvict的beforeInvocation=false） | #result | 注意： 1.当我们要使用root对象的属性作为key时我们也可以将“#root”省略，因为Spring默认使用的就是root对象的属性。 如 1@Cacheable(key = &quot;targetClass + methodName +#p0&quot;) 2.使用方法参数时我们可以直接使用“#参数名”或者“#p参数index”。 如： 12@Cacheable(value=&quot;users&quot;, key=&quot;#id&quot;)@Cacheable(value=&quot;users&quot;, key=&quot;#p0&quot;) SpEL提供了多种运算符 | 类型 | 运算符 || ———- | ———————————————- || 关系 | &lt;，&gt;，&lt;=，&gt;=，==，!=，lt，gt，le，ge，eq，ne || 算术 | +，- ，* ，/，%，^ || 逻辑 | &amp;&amp;，||，!，and，or，not，between，instanceof || 条件 | ?: (ternary)，?: (elvis) || 正则表达式 | matches || 其他类型 | ?.，?[…]，![…]，^[…]，$[…] | 参考：https://www.cnblogs.com/xiang--liu/p/9720344.html Springboot自动配置缓存详细原理： 1）、查看自动配置类：CacheAutoConfiguration 2）、断点跟踪可知默认配置了： org.springframework.boot.autoconfigure.cache.GenericCacheConfiguration org.springframework.boot.autoconfigure.cache.JCacheCacheConfiguration org.springframework.boot.autoconfigure.cache.EhCacheCacheConfiguration org.springframework.boot.autoconfigure.cache.HazelcastCacheConfiguration org.springframework.boot.autoconfigure.cache.InfinispanCacheConfiguration org.springframework.boot.autoconfigure.cache.CouchbaseCacheConfiguration org.springframework.boot.autoconfigure.cache.RedisCacheConfiguration org.springframework.boot.autoconfigure.cache.CaffeineCacheConfiguration org.springframework.boot.autoconfigure.cache.GuavaCacheConfiguration org.springframework.boot.autoconfigure.cache.SimpleCacheConfiguration【默认】 org.springframework.boot.autoconfigure.cache.NoOpCacheConfiguration 默认SimpleCacheConfiguration生效 3）、给容器中注册了一个CacheManager：ConcurrentMapCacheManager； 4）、获取和创建ConcurrentMapCache类型的缓存组件，他的作用将数据保存在ConcurrentMap中； 5）、 运行流程： ​ 方法运行之前，先去查询Cache（缓存组件），按照cacheNames指定的名字获取，（CacheManager先获取相应的缓存），第一次获取缓存如果没有Cache组件会自动创建； ​ 去Cache中查找缓存的内容，使用一个key，默认就是方法的参数，key是按照某种策略生成的，默认是使用keyGenerator生成的，默认使用SimpleKeyGenerator生成key，SimpleKeyGenerator生成key的默认策略：如果没有参数：key=new SimpleKey()；如果有一个参数：key=参数的值；如果有多个参数：key=new SimpleKey(params)；​ 没有查到缓存就调用目标方法，将目标方法返回的结果，放进缓存中，@Cacheable标注的方法执行之前先来检查缓存中有没有这个数据，默认按照参数的值作为key去查询缓存，如果没有就运行方法并将结果放入缓存，以后再来调用就可以直接使用缓存中的数据。 原文链接：https://blog.csdn.net/xm393392625/article/details/88625681","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring4的泛型注入","slug":"Spring/Spring4的泛型注入","date":"2020-06-09T12:50:59.000Z","updated":"2020-06-08T16:34:34.162Z","comments":true,"path":"2020/06/09/Spring/Spring4的泛型注入/","link":"","permalink":"http://yoursite.com/2020/06/09/Spring/Spring4的泛型注入/","excerpt":"","text":"spring4的泛型注入测试1 创建两个实体User和Role12345public class User &#123;&#125; public class Role &#123;&#125; 2 baseDao抽取泛型基础curd12345public class BaseDao&lt;T&gt; &#123; public void save(T entity)&#123; System.out.println(&quot;Save:&quot; + entity); &#125;&#125; 3 两个实现类UserDao 和 RoleDao1234567@Repositorypublic class RoleDao extends BaseDao&lt;Role&gt;&#123;&#125; @Repositorypublic class UserDao extends BaseDao&lt;User&gt;&#123;&#125; 4 baseService123456789public class BaseService&lt;T&gt; &#123; @Autowired private BaseDao&lt;T&gt; dao;//这里会自动根据实际类型传入User或Role public void addNew(T entity)&#123; System.out.println(&quot;addNew by &quot; + dao); dao.save(entity); &#125;&#125; 5 UserService 和RoleService12345678@Servicepublic class RoleService extends BaseService&lt;Role&gt;&#123;&#125; //若注解没有指定 bean 的 id, 则类名第一个字母小写即为 bean 的 id@Servicepublic class UserService extends BaseService&lt;User&gt;&#123;&#125; 6 测试类12345678910public static void main(String[] args) &#123; ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;beans-annotation.xml&quot;); UserService userService = (UserService) ctx.getBean(&quot;userService&quot;); userService.addNew(new User()); RoleService roleService = (RoleService) ctx.getBean(&quot;roleService&quot;); roleService.addNew(new Role()); &#125; 参考：https://www.cnblogs.com/linhp/p/5881778.html spring注入泛型原理问spring4的泛型依赖注入是什么原理？ Dao 1234567public class BaseDao&lt;T&gt; &#123; public void add()&#123;&#125;&#125;@Repositorypublic class EmpDao extends BaseDao&lt;Employee&gt;&#123; &#125; Service 1234567891011public class BaseService&lt;T&gt; &#123; @Autowired protected BaseDao&lt;T&gt; baseDao; &#125;@Servicepublic class EmpService extends BaseService&lt;Employee&gt;&#123; public void add()&#123; System.out.println(baseDao) &#125;&#125; 测试 1234ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;spring-config6.xml&quot;);EmpService empService = ctx.getBean(EmpService.class);empService.add();//输出 dao.impl.EmpDao@214b199c 获取EmpService spring自动匹配到了 EmpDao 但是！如果再添加一个 泛型 类型为Employee的bean，问题就来了。 12@Repository public class EmpDao2 extends BaseDao&lt;Employee&gt;&#123; &#125; 添加第二个BaseDao的子类 泛型也为 Employee，再次测试出了如下异常: 1expected single matching bean but found 2: empDao,empDao2 可以肯定的一点是，Spring 是通过 泛型参数 来匹配EmpDao 与 EmpService的。但是sping是如何动态获取泛型类型的？泛型为何没有被擦除？ 答如果用Pom等机制，可以把依赖的源代码下载下来，然后可以直接在 spring 的库中设置断点，来调试 spring 代码，如果足够耐心，逐行执行一次，就可以初见端倪了。 代码编写完了，command ＋ o 找到 DefaultListableBeanFactory，他在 spring bean 这个包中 定位到 findAutowireCandidates，可以在这里卡一个断点，然后debug运行你的程序。该方法负责找到匹配的 bean 注入到 service中。其中有如下代码负责过滤掉最开始找到的 candidates 12345for (String candidate : candidateNames) &#123; if (!isSelfReference(beanName, candidate) &amp;&amp; isAutowireCandidate(candidate, descriptor)) &#123; addCandidateEntry(result, candidate, descriptor, requiredType); &#125;&#125; 其中函数 isAutowireCandidate 往里面找 1234567public boolean isAutowireCandidate(BeanDefinitionHolder bdHolder, DependencyDescriptor descriptor) &#123; if (!super.isAutowireCandidate(bdHolder, descriptor)) &#123; // If explicitly false, do not proceed with any other checks... return false; &#125; return checkGenericTypeMatch(bdHolder, descriptor);&#125; 看到这里有范型检查相关的内容，再往深入找，会看到这段代码 1234567891011121314151617if (checkGenerics) &#123; // Recursively check each generic ResolvableType[] ourGenerics = getGenerics(); ResolvableType[] typeGenerics = other.as(ourResolved).getGenerics(); if (ourGenerics.length != typeGenerics.length) &#123; return false; &#125; if (matchedBefore == null) &#123; matchedBefore = new IdentityHashMap&lt;&gt;(1); &#125; matchedBefore.put(this.type, other.type); for (int i = 0; i &lt; ourGenerics.length; i++) &#123; if (!ourGenerics[i].isAssignableFrom(typeGenerics[i], matchedBefore)) &#123; return false; &#125; &#125;&#125; 所以 spring 其实是利用反射机制，获取类型的范型的，然后做了比较返回了合适的 bean 进行注入的。 参考：https://www.zhihu.com/question/268195272","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"服务熔断与服务降级","slug":"SpringCloud/服务熔断与服务降级","date":"2020-06-08T09:14:59.000Z","updated":"2020-06-08T09:26:33.783Z","comments":true,"path":"2020/06/08/SpringCloud/服务熔断与服务降级/","link":"","permalink":"http://yoursite.com/2020/06/08/SpringCloud/服务熔断与服务降级/","excerpt":"","text":"服务熔断与服务降级服务降级​ 当请求超时，资源不足等情况发生时进行服务降级处理，不调用真是服务逻辑，而是使用快速失败fallback方式直接调用本地的一个方法返回托底数据，保证服务链条的完整，避免服务雪崩。 服务熔断​ 一定时间内，异常请求比例(请求超时，网络故障，服务异常等)达到阈值时，启动熔断器，熔断器一旦启动，则会停止调用具体服务逻辑，而是通过fallcack快速返回托底数据，保证服务链的完整。 开启熔断​ 在固定时间窗口内，接口调用超时比率达到一个阈值，会开启熔断。进入熔断状态后，后续对该服务接口的调用不再经过网络，直接执行本地的默认方法，达到服务降级的效果。 熔断回复​ 熔断不可能是永久的。当经过了规定时间之后，服务将从熔断状态回复过来，再次接受调用方的远程调用。 SpringCloud HystrixSpring Cloud Hystrix是基于Netflix的开源框架Hystrix实现，该框架实现了服务熔断、线程隔离等一系列服务保护功能。 对于熔断机制的实现，Hystrix设计了三种状态： 熔断关闭状态（Closed）服务没有故障时，熔断器所处的状态，对调用方的调用不做任何限制。 熔断开启状态（Open）在固定时间窗口内（Hystrix默认是10秒），接口调用出错比率达到一个阈值（Hystrix默认为50%），会进入熔断开启状态。进入熔断状态后，后续对该服务接口的调用不再经过网络，直接执行本地的fallback方法。 半熔断状态（Half-Open）在进入熔断开启状态一段时间之后（Hystrix默认是5秒），熔断器会进入半熔断状态。所谓半熔断就是尝试恢复服务调用，允许有限的流量调用该服务，并监控调用成功率。如果成功率达到预期，则说明服务已恢复，进入熔断关闭状态；如果成功率仍旧很低，则重新进入熔断关闭状态。 三个状态的转化关系 ​ close ​ 调用成功率达标，进入close状态 调用失败率达到阈值，进入open状态 ​ half-open 熔断一段时间 &lt;— open ​ —&gt; 调用成功率不达标","categories":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/categories/SpringCloud/"}],"tags":[{"name":"SpringCloud","slug":"SpringCloud","permalink":"http://yoursite.com/tags/SpringCloud/"}]},{"title":"spring中的BeanPostProcessor接口","slug":"Spring/spring中的BeanPostProcessor接口","date":"2020-06-01T07:50:59.000Z","updated":"2020-06-02T07:09:02.625Z","comments":true,"path":"2020/06/01/Spring/spring中的BeanPostProcessor接口/","link":"","permalink":"http://yoursite.com/2020/06/01/Spring/spring中的BeanPostProcessor接口/","excerpt":"","text":"spring bean的装载过程简略赏析https://www.cnblogs.com/foreveravalon/p/7152021.html spring中的BeanPostProcessor接口","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring加载classpath与classpath*的过程","slug":"Spring/Spring加载classpath与classpath星的过程","date":"2020-05-27T05:45:59.000Z","updated":"2020-05-27T14:42:20.764Z","comments":true,"path":"2020/05/27/Spring/Spring加载classpath与classpath星的过程/","link":"","permalink":"http://yoursite.com/2020/05/27/Spring/Spring加载classpath与classpath星的过程/","excerpt":"","text":"Spring加载classpath与classpath*的过程1234567891011121314151617181.无论是classpath还是classpath*都可以加载整个classpath下（包括jar包里面）的资源文件。2.classpath只会返回第一个匹配的资源，查找路径是优先在项目中存在资源文件，再查找jar包。3.文件名字包含通配符资源(如果spring-.xml，spring.xml)， 如果根目录为&quot;&quot;， classpath加载不到任何资源而classpath*则可以加载到classpath中可以匹配的目录中的资源，但是不能加载到jar包中的资源 第1，2点比较好表理解，大家可以自行测试，第三点表述有点绕，举个例，现在有资源文件结构如下： src/main/resources META-INF aaa notice.txt notice.txt notice.txt classpath:notice*.txt 加载不到资源 classpath*:notice*.txt 加载到resource根目录下notice.txt classpath:META-INF/notice*.txt 加载到META-INF下的一个资源（classpath是加载到匹配的第一个资源，就算删除classpath下的notice.txt，他仍然可以加载jar包中的notice.txt） classpath:META-*/notice*.txt 加载不到任何资源 classpath*:META-INF/notice*.txt 加载到classpath以及所有jar包中META-INF目录下以notice开头的txt文件 classpath*:META-*/notice*.txt 只能加载到classpath下 META-INF目录的notice.txt 有一些错误： 123classpath:META-INF/notice*.txt 可能什么也加载不到classpath*:META-*/notice*.txt 加载到classpath以及所有jar包中META-INF目录下以notice开头的txt文件 ​ 原文链接：https://blog.csdn.net/n447194252/article/details/76664053 关于classpath与classpath*的一些测试1234测试结果：1、classpath在使用时，第一级路径无法使用通配符，如classpath:general*.properties或者classpath:general*/general*.properties是无法获取到的2、在我将general.properties拆成两个文件后，classpath同样可以获取两个文件，读取到全部内容，不知道是不是我测的方法有问题，这方面没感觉出来说是只能获取到第一个文件的限制3、classpath比classpath*快，明确位置比通配符快。 对于2的说明： 应该是相同类路径下的相同名称的资源只能获取第一个，这个测试4中general.properties一个放在general下，一个放在general1下，虽然名称相同，但是不是同一路径了 原文链接：https://blog.csdn.net/n447194252/article/details/76664053 对于classpath与classpath*的一些理解一般由PathMatchingResourcePatternResolver类的getResources解析 1new PathMatchingResourcePatternResolver().getResources(locationPattern); getResources()方法 12345678910111213141516171819202122232425262728293031@Override public Resource[] getResources(String locationPattern) throws IOException &#123; Assert.notNull(locationPattern, &quot;Location pattern must not be null&quot;); // classpath*:前缀 if (locationPattern.startsWith(CLASSPATH_ALL_URL_PREFIX)) &#123; // a class path resource (multiple resources for same name possible) if (getPathMatcher().isPattern(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length()))) &#123; // a class path resource pattern return findPathMatchingResources(locationPattern); &#125; else &#123; // all class path resources with the given name return findAllClassPathResources(locationPattern.substring(CLASSPATH_ALL_URL_PREFIX.length())); &#125; &#125; // classpath:前缀 else &#123; // Generally only look for a pattern after a prefix here, // and on Tomcat only after the &quot;*/&quot; separator for its &quot;war:&quot; protocol. int prefixEnd = (locationPattern.startsWith(&quot;war:&quot;) ? locationPattern.indexOf(&quot;*/&quot;) + 1 : locationPattern.indexOf(&apos;:&apos;) + 1); if (getPathMatcher().isPattern(locationPattern.substring(prefixEnd))) &#123; // a file pattern return findPathMatchingResources(locationPattern); &#125; else &#123; // a single resource with the given name return new Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;; &#125; &#125; &#125; findPathMatchingResources()方法匹配模式路径 12345678910111213141516171819202122232425262728293031protected Resource[] findPathMatchingResources(String locationPattern) throws IOException &#123; String rootDirPath = determineRootDir(locationPattern); String subPattern = locationPattern.substring(rootDirPath.length()); //根路径资源 Resource[] rootDirResources = getResources(rootDirPath); Set&lt;Resource&gt; result = new LinkedHashSet&lt;&gt;(16); for (Resource rootDirResource : rootDirResources) &#123; rootDirResource = resolveRootDirResource(rootDirResource); URL rootDirUrl = rootDirResource.getURL(); if (equinoxResolveMethod != null &amp;&amp; rootDirUrl.getProtocol().startsWith(&quot;bundle&quot;)) &#123; URL resolvedUrl = (URL) ReflectionUtils.invokeMethod(equinoxResolveMethod, null, rootDirUrl); if (resolvedUrl != null) &#123; rootDirUrl = resolvedUrl; &#125; rootDirResource = new UrlResource(rootDirUrl); &#125; if (rootDirUrl.getProtocol().startsWith(ResourceUtils.URL_PROTOCOL_VFS)) &#123; result.addAll(VfsResourceMatchingDelegate.findMatchingResources(rootDirUrl, subPattern, getPathMatcher())); &#125; else if (ResourceUtils.isJarURL(rootDirUrl) || isJarResource(rootDirResource)) &#123; result.addAll(doFindPathMatchingJarResources(rootDirResource, rootDirUrl, subPattern)); &#125; else &#123; result.addAll(doFindPathMatchingFileResources(rootDirResource, subPattern)); &#125; &#125; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Resolved location pattern [&quot; + locationPattern + &quot;] to resources &quot; + result); &#125; return result.toArray(new Resource[0]); &#125; 结论1classpath*:可以获取同一路径同一名字的多个资源 classpath:可以获取同一路径同一名字的一个资源 结论2当使用classpath:时，后面的路径不能紧接通配符路径 例如： 1classpath:**/*.xml classpath:spri*/*.xml spring的解析类在解析时会将路径其分成两部分（根路径+包含通配符路径） 1classpath: 和 **/*.xml classpath: 和 spri*/*.xml 并且getResources()方法中的 return new Resource[] {getResourceLoader().getResource(locationPattern)}; getResourceLoader().getResource(locationPattern) 进入DefaultResourceLoader类的getResource()方法 123456789101112131415161718192021222324252627282930@Override public Resource getResource(String location) &#123; Assert.notNull(location, &quot;Location must not be null&quot;); for (ProtocolResolver protocolResolver : getProtocolResolvers()) &#123; Resource resource = protocolResolver.resolve(location, this); if (resource != null) &#123; return resource; &#125; &#125; if (location.startsWith(&quot;/&quot;)) &#123; return getResourceByPath(location); &#125; // 截取了classpath: else if (location.startsWith(CLASSPATH_URL_PREFIX)) &#123; return new ClassPathResource(location.substring(CLASSPATH_URL_PREFIX.length()), getClassLoader()); &#125; else &#123; try &#123; // Try to parse the location as a URL... URL url = new URL(location); return (ResourceUtils.isFileURL(url) ? new FileUrlResource(url) : new UrlResource(url)); &#125; catch (MalformedURLException ex) &#123; // No URL -&gt; resolve as resource path. return getResourceByPath(location); &#125; &#125; &#125; classpath:被截取，返回的根路径为””, 这样就获取不到任何资源 结论3问题关于类路径下META-INF文件夹，使用前缀classpath:以及通配符获取不到资源 例如路径： 1classpath:META-INF/*.xml 获取不到META-INF下的mapper.xml 解决：可以在META-INF中添加一个目录，例如classpath:META-INF/mapper/*.xml就可以了 调试分析： findPathMatchingResources()方法中的有一句 1URL rootDirUrl = rootDirResource.getURL(); 遇到rootDirResource是META-INF时，会获取一个根路径下的一个jar包路径 (file:/C:Program%20Files/Java/jdk1.8.0_161/jre/lib/ext/jfxrt.jar!/META-INF/) 在该jar路径下META-INF下查找mapper.xml当然查找不到 分析classpath:使用路径匹配，获取的资源只有一个。 getResources()方法中的classpath:分支获取根路径资源的方法 1return new Resource[] &#123;getResourceLoader().getResource(locationPattern)&#125;; 可以看出，虽然new了一个数组Resource，但是实际数组中只有一个根路径资源， 因此，相同目录下使用classpath:与路径匹配获取的资源只有一个 并且findPathMatchingResources()方法中 1234for (Resource rootDirResource : rootDirResources) &#123; rootDirResource = resolveRootDirResource(rootDirResource); URL rootDirUrl = rootDirResource.getURL(); ... 根据rootDirResource.getURL()获取一个URL路径 Resource实现类ClassPathResource中getURL()方法， 执行了return this.classLoader.getResource(this.path);返回了一个URL 示例： 1234567@Test public void test5()&#123; URL mapper = this.getClass().getClassLoader().getResource(&quot;META-INF/mappers/&quot;); System.out.println(mapper.getPath()); URL metainf = this.getClass().getClassLoader().getResource(&quot;META-INF/&quot;); System.out.println(metainf.getPath()); &#125; 打印： 12file:/E:/maven/maven-repository/com/szxy/szxy-spring-boot-autoconfigure/1.0-SNAPSHOT/szxy-spring-boot-autoconfigure-1.0-SNAPSHOT.jar!/META-INF/mappers/file:/C:/Program%20Files/Java/jdk1.8.0_161/jre/lib/ext/jfxrt.jar!/META-INF/ 然而，这两个jar下虽然有对应的目录URL,但并不是我们想要匹配的jar,因此，匹配不到任何资源 结论​ 1)使用classpath:获取资源，注意匹配目录不要与其他jar包中的重复，因为其根路径资源只加载 一个，如果通过根路径获取了另一个不含有资源的jar包(只是具有相同的类路径)，则无法获取资源。 123例： classpath:META-INF/*.txt 路径分割成根路径META-INF和模式路径*.txt 许多jar包下都有META-INF目录，但是只会加载一个jar包去匹配资源而忽略其他jar包，因此可能导致需要的资源没有加载 ​ 2）获取单一资源，可以直接写完整的路径名进行匹配 3 ) classpath:如果具有相同路径相同名称的资源，则只加载一个 ​","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"spring中一些使用分析链接","slug":"Spring/spring中一些使用分析链接","date":"2020-05-25T10:07:59.000Z","updated":"2020-06-03T06:28:33.473Z","comments":true,"path":"2020/05/25/Spring/spring中一些使用分析链接/","link":"","permalink":"http://yoursite.com/2020/05/25/Spring/spring中一些使用分析链接/","excerpt":"","text":"spring中一些使用分析链接Spring系列之FactoryBean（一）https://blog.csdn.net/zknxx/article/details/79572387 关于Spring加载classpath与classpath*的过程剖析https://blog.csdn.net/zl3450341/article/details/9306983# https://www.cnblogs.com/EasonJim/p/6709314.html spring常用的4种加载资源的前缀https://blog.csdn.net/hulei19900322/article/details/75200356 Spring开启Aop注解@EnableAspectJAutoProxyhttps://blog.csdn.net/a3959678/article/details/100042832 https://www.iteye.com/blog/jag522-2115923 https://www.cnblogs.com/foreveravalon/p/8653832.html 完全读懂Spring框架之AOP实现原理https://my.oschina.net/guangshan/blog/1797461 详解Spring中Bean的this调用导致AOP失效的原因https://my.oschina.net/guangshan/blog/1807721","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"关于xml和注解","slug":"JavaSE/关于xml和注解","date":"2020-05-24T15:09:08.000Z","updated":"2020-05-23T16:29:36.607Z","comments":true,"path":"2020/05/24/JavaSE/关于xml和注解/","link":"","permalink":"http://yoursite.com/2020/05/24/JavaSE/关于xml和注解/","excerpt":"","text":"关于XML和注解回答1​ 最初引入配置文件的原因是为了降低耦合、方便修改等。在缺少元数据信息的过去，指定哪个类哪个方法用来做什么，或者指定ORM框架的实体映射等，只能通过人工手动编写。最初的Java可不像Ruby on Rails这种框架可以做到约定大于配置。如果把配置信息硬编码在代码里，那势必是每天都要大量改动代码，从而堆积大量样板代码，这些样板代码可读性很差，会和项目中很多的类发生耦合，而改动代码就要编译、重新封包部署，会非常影响工作效率。特别是如果将某个配置过的类删掉，那么如果不在配置代码里去掉对这个类的引用，那么必定编译无法通过。而配置文件的话，捕获一下ClassNotFound异常然后忽略这段配置就可以了。所以在过去，使用某种格式的配置文件，当然xml居多，来配置Java项目的各个组件是十分正常的。 ​ 不过配置文件也是存在弊端的，首先最大的问题就是配置文件是不参与编译的，这也意味着无法享受静态语言编译检查带来的好处。配置文件是否起作用，甚至格式是否正确，只能在将项目跑起来的时候，才能进行排除。如果是比较隐晦的错误，也会给开发人员带来很多困扰。再者，尽管XML等配置文件的可读性理论上是良好的，但如果其内容过于繁杂，甚至堆积成山，那么对于维护人员来说也是一件非常痛苦的事情。 不过事情在Java引入注解之后得到了很大的改变。注解是可以给类、接口、方法、成员变量、参数上附加元信息的新功能。有了它的标记，再也不用将一大堆类、方法创建完了还要在XML里罗列一遍，配置文件的体积得到了极大地瘦身。回到刚刚的问题，之所以最初不用Java代码作为配置文件，主要是因为这些代码需要经常性改动，会导致配置代码和项目产生耦合，且频繁编译，替换也不方便。但有了注解之后，直接扫描注解就能获得足够多的配置信息，样板代码消失了，配置文件本身其实很少会发生变化了，这样以来，用XML还是用Java代码做配置，其实问题都不大了。而且用代码的话，可以享受IDE的语法提示，确保不容易写错，对自己的配置到底会怎样被框架使用也会了解的更深刻一点，嗯，一点儿而已。 ​ 甚至，包括Servlet 3.0和Spring Framework都重新引入了基于代码配置的功能。没错儿，题主，现在的Java，不仅不是需要使用XML之类的配置文件，而是真的有很多框架是可以用Java代码做配置文件的。我现在开Spring项目，连web.xml和applicationContext.xml之类的配置文件都没有，统统是使用代码进行配置的。其他框架不敢保证，但是Servlet3.0和Spring的配置，都是可以在XML和Java代码两者之间随意转换的。不存在某种写法只能在特定的配置手段中使用的问题。 ​ 使用代码作为配置文件除了可以享受IDE语法高亮提示和静态编译除错的好处之外，还有一个好处是对于需要根据复杂情景灵活提供配置的时候，代码的灵活性是配置文件无法比拟的。比如使用随机数、使用if-else、调用远程服务器提供配置信息等，即使XML能配出来，也是相当麻烦，绝对比使用代码要多出很多行来的。 ​ 以上是Java项目配置文件发展的历史，以及各自的利弊及适用场景。其实无论XML也好，Java代码也好，在现在Java项目中都是OK的。不过如果需要更加灵活的配置，还是更加推荐使用Java代码的方式。现在这种方式也是愈发主流，甚至Gradle这种项目配置，都使用脚本语言了。当然，我的水平有限，也有可能个人理解中也有很多谬误，欢迎指正交流。 回答2最早最早的程序都是写死的，也就是说用语言本身来写“配置”。这是第一阶段。 但程序员们很快发现要改点什么就得重新编译程序，很不方便，于是把一些可可能会变的东西写到配置文件中，配置文件通常是文本文件，ini或者xml之类的。ini相对功能较简单，xml则比较复杂。这是第二阶段。 后来配置越来越多，配置文件变得复杂起来，为了让xml尽可能不写错（xml的错误不能在编译期检查出），还使用了dtd，schema等对xml进行验证。程序员们甚至想一切皆配置，所有程序按功能完全模块化，以后改什么动动配置即可，看起来很美好……这是第三阶段。 但配置的复杂也是个大问题，后来程序员们又发现，这么复杂的配置掌握起来其实也很困难，并不比写代码简单多少，错误还不能在编译期看出，且有些东西确实万年不变的，干嘛要配置呢？于是又返璞归真的开始宣传“零配置”，利用一些新的语言特性，如“注解”（annotation），将配置“写死”在程序中……这是第四阶段。 第五阶段，其实我瞎编的，就是配置文件还是要，只不过只保留了最必要的部分，大多“配置”都写死了。 来自：https://www.zhihu.com/question/271390057","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"springboot中yml属性的注入.md","slug":"SpringBoot/springboot中yml属性的注入","date":"2020-05-24T14:20:20.000Z","updated":"2020-05-25T05:24:07.482Z","comments":true,"path":"2020/05/24/SpringBoot/springboot中yml属性的注入/","link":"","permalink":"http://yoursite.com/2020/05/24/SpringBoot/springboot中yml属性的注入/","excerpt":"","text":"springboot中yml文件yml语法1234567891011121314151617181920212223k:(空格)v :表示一对键值对(空格必须有);以空格的缩进来控制层级关系;只要是左对齐的一列数据，就是同一层级，几个空格不重要。属性和值是大小写敏感。字面量：普通值(数字、字符串、布尔) 字符串默认不用加上单引号或者双引号。 &quot;&quot;: 双引号，不会自动转义字符串里面的特殊字符串；特殊字符会作为本身想表示的意思。 name: &quot;zhangsan \\n lisi&quot; -》输出：zhangsan 换行 lisi &apos;&apos;: 单引号，会自动转义字符串里面的特殊字符串；下面的 \\ 自动转义成了 \\\\ name: &quot;zhangsan \\n lisi&quot; -》输出：zhangsan \\n lisi对象(List、Map、键值对形式)k:v: 在下一行写对象的属性和值；注意缩进 对象还是 k: v 的方式 friends: lastName: zhangsan age: 20行内写法： friends: &#123;lastName: zhangsan, age: 18&#125;数组(List、Set)用 -值表示数组中的元素pets: - cat - dog - pig行内写法: pets: [cat,dog,pig]; 测试实体配置此处省略了get,set,toString方法 1234567891011121314@ConfigurationProperties(prefix = &quot;com.yml.test&quot;)public class Person &#123; private String name; private Integer age; private Boolean boss; private Date birth; private Map&lt;String, Object&gt; maps; private List&lt;Object&gt; lists; private Dog dog; public static class Dog&#123; private String name; private Integer age; &#125;&#125; 测试yml配置1234567891011121314com: yml: test: name: hello age: 20 boss: true birth: 1999/05/20 maps: &#123;hello: hello, world: world&#125; lists: - 11111 - 22222 dog: name: tom age: 2 开启配置12345@Configuration@EnableConfigurationProperties(&#123;Person.class&#125;)配置类&#123;&#125; 读取配置信息并打印1Person&#123;name=&apos;hello&apos;, age=20, boss=true, birth=Thu May 20 00:00:00 CST 1999, maps=&#123;hello=hello, world=world&#125;, lists=[11111, 22222], dog=Dog&#123;name=&apos;tom&apos;, age=2&#125;&#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"SpringBoot中的SCI接口","slug":"SpringBoot/SpringBoot中的SCI接口","date":"2020-05-23T11:12:59.000Z","updated":"2020-05-23T14:08:49.650Z","comments":true,"path":"2020/05/23/SpringBoot/SpringBoot中的SCI接口/","link":"","permalink":"http://yoursite.com/2020/05/23/SpringBoot/SpringBoot中的SCI接口/","excerpt":"","text":"servlet3.0使用Java SPI机制​ Servlet3.0环境下ServletContainerInitializer(简称SCI)接口的使用. SCI定义​ 12345// 完整命名: javax.servlet.ServletContainerInitializerpublic interface ServletContainerInitializer &#123; public void onStartup(Set&lt;Class&lt;?&gt;&gt; c, ServletContext ctx) throws ServletException; &#125; SCI概述ServletContainerInitializer 是 Servlet 3.0 新增的一个接口，主要用于在容器启动阶段通过编程风格注册Filter, Servlet以及Listener，以取代通过web.xml配置注册。这样就利于开发内聚的web应用框架.我们以SpringMVC举例, servlet3.0之前我们需要在web.xml中依据Spring的规范新建一堆配置。这样就相当于将框架和容器紧耦合了。而在3.x后注册的功能内聚到Spring里，Spring-web就变成一个纯粹的即插即用的组件，不用依据应用环境定义一套新的配置。 SCI原理1）ServletContainerInitializer接口的实现类通过java SPI声明自己是ServletContainerInitializer 的provider. 2）容器启动阶段依据java spi获取到所有ServletContainerInitializer的实现类，然后执行其onStartup方法. 3）另外在实现ServletContainerInitializer时还可以通过@HandlesTypes注解定义本实现类希望处理的类型，容器会 将当前应用中所有这一类型（继承或者实现）的类放在ServletContainerInitializer接口的集合参数c中传递进来。 如果不定义处理类型，或者应用中不存在相应的实现类，则集合参数c为空. 4）这一类实现了 SCI 的接口，如果做为独立的包发布，在打包时，会在JAR 文件的 META-INF/services/javax.servlet.ServletContainerInitializer 文件中进行注册。 容器在启动时，就会扫描所有带有这些注册信息的类(@HandlesTypes(WebApplicationInitializer.class)这里就是加载WebApplicationInitializer.class类)进行解析，启动时会调用其 onStartup方法——也就是说servlet容器负责加载这些指定类, 而ServletContainerInitializer的实现者(例如Spring-web中的SpringServletContainerInitializer对接口ServletContainerInitializer的实现中,是可以直接获取到这些类的) 与类加载的区别​ 类加载是根据限定的名称去加载，并没有相关的标准去加载未知的内容.​ 而SCI(全称 ServletContainerInitializer)则是根据约定的标准，扫描META-INF中包含注册信息的 class 并在启动阶段调用其onStartup. SpringMVC中的应用通过查看ServletContainerInitializer继承层级, 可以发现spring-web中的SpringServletContainerInitializer正是实现了ServletContainerInitializer接口； 123456789101112131415161718192021222324252627282930313233343536373839404142@HandlesTypes(WebApplicationInitializer.class)public class SpringServletContainerInitializer implements ServletContainerInitializer &#123; @Override public void onStartup(Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext) throws ServletException &#123; List&lt;WebApplicationInitializer&gt; initializers = new LinkedList&lt;WebApplicationInitializer&gt;(); // webAppInitializerClasses 就是servlet3.0规范中为我们收集的 WebApplicationInitializer 接口的实现类的class // 从webAppInitializerClasses中筛选并实例化出合格的相应的类 if (webAppInitializerClasses != null) &#123; for (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123; // Be defensive: Some servlet containers provide us with invalid classes, // no matter what @HandlesTypes says... if (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp; WebApplicationInitializer.class.isAssignableFrom(waiClass)) &#123; try &#123; initializers.add((WebApplicationInitializer) waiClass.newInstance()); &#125; catch (Throwable ex) &#123; throw new ServletException(&quot;Failed to instantiate WebApplicationInitializer class&quot;, ex); &#125; &#125; &#125; &#125; if (initializers.isEmpty()) &#123; servletContext.log(&quot;No Spring WebApplicationInitializer types detected on classpath&quot;); return; &#125; // 这行代码说明我们在实现WebApplicationInitializer可以通过继承Ordered, PriorityOrdered来自定义执行顺序 AnnotationAwareOrderComparator.sort(initializers); servletContext.log(&quot;Spring WebApplicationInitializers detected on classpath: &quot; + initializers); // 迭代每个initializer实现的方法 for (WebApplicationInitializer initializer : initializers) &#123; initializer.onStartup(servletContext); &#125; &#125;&#125; 1）SpringServletContainerInitializer 由支持Servlet3.0+的Servlet容器实例化并调用. 2）Servlet容器还会查询classpath下SpringServletContainerInitializer类上修饰的@HandlesTypes注解所标注的 WebApplicationInitializer接口的实现类. 这一步也是容器帮我们完成的. 3）SpringServletContainerInitializer通过实现ServletContainerInitializer将自身并入到Servlet容器的生命周期中, 并通过自身定义的WebApplicationInitializer将依赖于Spring框架的系统初始化需求与Servlet容器解耦. 即依赖于spring的系统可以通过实现WebApplicationInitializer来实现自定义的初始化逻辑. 而不需要去实现ServletContainerInitializer Tomcat调用SCI的时机​ 现在还有一个疑问, 就是 ServletContainerInitializer 的调用时机?, 因为servlet容器除了会回调SCI之外, 还有回调诸如servlet, listener等. 搞清楚这些先后顺序可以帮助我们快速定位和理解某些奇怪的问题. ​ 这里我们就以Tomcat举例, 以下逻辑总结于Tomcat7.x, 有兴趣的读者可以去StandardContext类中对startInternal的实现中(第5608行 —— 第5618行, 这也是Tomcat中唯一的调用ServletContainerInitializers接口的onStartup方法的位置)求证下: 1）解析web.xml2）往ServletContext实例中注入 context-param 参数3）回调Servlet3.0的ServletContainerInitializers接口实现类4）触发 Listener 事件(beforeContextInitialized, afterContextInitialized); 这里只会触发 ServletContextListener 类型的 5）初始化 Filter, 调用其init方法 6）加载 启动时即加载的servlet 原文链接：https://blog.csdn.net/lqzkcx3/article/details/78507169 springBoot打成war在外部容器的启动Springboot在使用外部容器运行时 需要写一个初始化类继承SpringBootServletInitializer 123456public class OasysServletInitializer extends SpringBootServletInitializer &#123; @Override protected SpringApplicationBuilder configure(SpringApplicationBuilder builder) &#123; return builder.sources(OasysApplication.class); &#125;&#125; SpringBootServletInitializer实现了WebApplicationInitializer接口，而实现了WebApplicationInitializer的类会被servlet容器扫描，并且调用onStartup()方法。 123public abstract class SpringBootServletInitializer implements WebApplicationInitializer &#123; ...&#125; Springboot提供的SCI接口ServletContextInitializer接口123456789101112131415161718192021222324252627282930313233343536373839package org.springframework.boot.web.servlet;import javax.servlet.ServletContainerInitializer;import javax.servlet.ServletContext;import javax.servlet.ServletException;import org.springframework.web.SpringServletContainerInitializer;import org.springframework.web.WebApplicationInitializer;/** * Interface used to configure a Servlet 3.0+ &#123;@link ServletContext context&#125; * programmatically. Unlike &#123;@link WebApplicationInitializer&#125;, classes that implement this * interface (and do not implement &#123;@link WebApplicationInitializer&#125;) will &lt;b&gt;not&lt;/b&gt; be * detected by &#123;@link SpringServletContainerInitializer&#125; and hence will not be * automatically bootstrapped by the Servlet container. * &lt;p&gt; * This interface is designed to act in a similar way to * &#123;@link ServletContainerInitializer&#125;, but have a lifecycle that&apos;s managed by Spring and * not the Servlet container. * &lt;p&gt; * For configuration examples see &#123;@link WebApplicationInitializer&#125;. * * @author Phillip Webb * @since 1.4.0 * @see WebApplicationInitializer */@FunctionalInterfacepublic interface ServletContextInitializer &#123; /** * Configure the given &#123;@link ServletContext&#125; with any servlets, filters, listeners * context-params and attributes necessary for initialization. * @param servletContext the &#123;@code ServletContext&#125; to initialize * @throws ServletException if any call against the given &#123;@code ServletContext&#125; * throws a &#123;@code ServletException&#125; */ void onStartup(ServletContext servletContext) throws ServletException;&#125; 注释： 1）接口用于以编程方式配置Servlet 3.0+ {@link ServletContext context}。 2）实现这个接口(并且没有实现{@link WebApplicationInitializer})的类不会被{@link SpringServletContainerInitializer}检测到，因此不会被Servlet容器自动引导。 3）这个接口的作用类似于{@link ServletContainerInitializer}，但是它的生命周期是由Spring管理的，而不是由Servlet容器管理的。 接口使用在springboot中注册一个servlet可以使用这种方式 1234@Beanpublic ServletRegistrationBean registrationBean() &#123; ...&#125; ServletRegistrationBean extends DynamicRegistrationBean DynamicRegistrationBean extends RegistrationBean RegistrationBean implements ServletContextInitializer, Ordered 通过继承结构可以看出，是通过实现Springboot提供的SCI接口（调用该接口的onStartup()）来完成的。 关于该接口的一些想法及猜测1)实现了该接口的类必须通过@Bean等方式注册进spring容器中，才能被springboot发现从而调用其onStartup() 2)servlet 3动态加载servlet的机制只能在上下文ServletContext加载时对Servlet，Filter,,Listener进行注册。 当springboot打包成war包放入外部容器中时，外部容器启动springboot项目入口是实现WebApplicationInitializer接口的SpringBootServletInitializer类，SpringBootServletInitializer实例执行onStartup方法的时候会通过createRootApplicationContext方法来执行run方法，接下来的过程就同以jar包形式启动的应用的run过程一样了，在内部会创建IOC容器并返回，只是以war包形式的应用在创建IOC容器过程中，不再创建Servlet容器了。 因此整个启动过程都是在ServletContext加载时进行的，使用Springboot提供的SCI接口注册Servlet的Bean也会被springboot发现从而被调用onStartup()方法完成servlet注册(且该Bean是由spring容器管理的，并不会被servlet容器发现)。 3） springboot的内置容器启动和外置容器启动 ​ 内置容器： ​ jar包: ​ 执行SpringBootApplication的run方法,启动IOC容器,然后创建嵌入式Servlet容器 ​ 外置容器： ​ war包: ​ 先是启动Servlet服务器,服务器启动Springboot应用(springBootServletInitizer),然后启动IOC容器","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"SpringBoot数据库连接池.md","slug":"SpringBoot/SpringBoot数据库连接池","date":"2020-05-22T09:20:20.000Z","updated":"2020-05-24T14:35:38.771Z","comments":true,"path":"2020/05/22/SpringBoot/SpringBoot数据库连接池/","link":"","permalink":"http://yoursite.com/2020/05/22/SpringBoot/SpringBoot数据库连接池/","excerpt":"","text":"Springboot连接池springboot 2.0 默认连接池​ springboot 2.0 使用Hikari连接池（号称java平台最快的，替换druid） ​ 1.性能方面 hikari&gt;druid&gt;tomcat-jdbc&gt;dbcp&gt;c3p0 。hikari的高性能得益于最大限度的避免锁竞争。 ​ 2.druid功能最为全面，sql拦截等百功能，统计数据较为度全面，具有良好的扩展性。 关于springboot连接池配置​ 自动配置类 ​ 1234567891011public class DataSourceAutoConfiguration &#123; @Configuration(proxyBeanMethods = false) @Conditional(PooledDataSourceCondition.class) @ConditionalOnMissingBean(&#123; DataSource.class, XADataSource.class &#125;) @Import(&#123; DataSourceConfiguration.Hikari.class, DataSourceConfiguration.Tomcat.class, DataSourceConfiguration.Dbcp2.class, DataSourceConfiguration.Generic.class, DataSourceJmxConfiguration.class &#125;) protected static class PooledDataSourceConfiguration &#123; &#125;&#125; 连接池Bean的创建配置类中 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889abstract class DataSourceConfiguration &#123; @SuppressWarnings(&quot;unchecked&quot;) protected static &lt;T&gt; T createDataSource(DataSourceProperties properties, Class&lt;? extends DataSource&gt; type) &#123; return (T) properties.initializeDataSourceBuilder().type(type).build(); &#125; /** * Tomcat Pool DataSource configuration. */ @Configuration(proxyBeanMethods = false) @ConditionalOnClass(org.apache.tomcat.jdbc.pool.DataSource.class) @ConditionalOnMissingBean(DataSource.class) @ConditionalOnProperty(name = &quot;spring.datasource.type&quot;, havingValue = &quot;org.apache.tomcat.jdbc.pool.DataSource&quot;, matchIfMissing = true) static class Tomcat &#123; @Bean @ConfigurationProperties(prefix = &quot;spring.datasource.tomcat&quot;) org.apache.tomcat.jdbc.pool.DataSource dataSource(DataSourceProperties properties) &#123; org.apache.tomcat.jdbc.pool.DataSource dataSource = createDataSource(properties, org.apache.tomcat.jdbc.pool.DataSource.class); DatabaseDriver databaseDriver = DatabaseDriver.fromJdbcUrl(properties.determineUrl()); String validationQuery = databaseDriver.getValidationQuery(); if (validationQuery != null) &#123; dataSource.setTestOnBorrow(true); dataSource.setValidationQuery(validationQuery); &#125; return dataSource; &#125; &#125; /** * Hikari DataSource configuration. */ @Configuration(proxyBeanMethods = false) @ConditionalOnClass(HikariDataSource.class) @ConditionalOnMissingBean(DataSource.class) @ConditionalOnProperty(name = &quot;spring.datasource.type&quot;, havingValue = &quot;com.zaxxer.hikari.HikariDataSource&quot;, matchIfMissing = true) static class Hikari &#123; @Bean @ConfigurationProperties(prefix = &quot;spring.datasource.hikari&quot;) HikariDataSource dataSource(DataSourceProperties properties) &#123; HikariDataSource dataSource = createDataSource(properties, HikariDataSource.class); if (StringUtils.hasText(properties.getName())) &#123; dataSource.setPoolName(properties.getName()); &#125; return dataSource; &#125; &#125; /** * DBCP DataSource configuration. */ @Configuration(proxyBeanMethods = false) @ConditionalOnClass(org.apache.commons.dbcp2.BasicDataSource.class) @ConditionalOnMissingBean(DataSource.class) @ConditionalOnProperty(name = &quot;spring.datasource.type&quot;, havingValue = &quot;org.apache.commons.dbcp2.BasicDataSource&quot;, matchIfMissing = true) static class Dbcp2 &#123; @Bean @ConfigurationProperties(prefix = &quot;spring.datasource.dbcp2&quot;) org.apache.commons.dbcp2.BasicDataSource dataSource(DataSourceProperties properties) &#123; return createDataSource(properties, org.apache.commons.dbcp2.BasicDataSource.class); &#125; &#125; /** * Generic DataSource configuration. */ @Configuration(proxyBeanMethods = false) @ConditionalOnMissingBean(DataSource.class) @ConditionalOnProperty(name = &quot;spring.datasource.type&quot;) static class Generic &#123; @Bean DataSource dataSource(DataSourceProperties properties) &#123; return properties.initializeDataSourceBuilder().build(); &#125; &#125;&#125; 最后一个Generic是使用其他的连接池，如ali的Druid连接池，通过spirng.datasource.type指定。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"spring中的@Import注解","slug":"Spring/spring中的@Import注解","date":"2020-05-22T07:45:59.000Z","updated":"2020-05-22T16:54:43.940Z","comments":true,"path":"2020/05/22/Spring/spring中的@Import注解/","link":"","permalink":"http://yoursite.com/2020/05/22/Spring/spring中的@Import注解/","excerpt":"","text":"Spring中@Import注解的作用和使用参考：https://blog.csdn.net/panchao888888/article/details/82882279","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"键盘缓冲区","slug":"C/键盘缓冲区","date":"2020-05-19T00:38:14.000Z","updated":"2020-05-19T14:52:44.380Z","comments":true,"path":"2020/05/19/C/键盘缓冲区/","link":"","permalink":"http://yoursite.com/2020/05/19/C/键盘缓冲区/","excerpt":"","text":"scanf 为毛要敲回车？——输入输出缓冲区，键盘缓冲区scanf 从输入流缓冲区里 读取数值，如果输入缓冲区内已有数值，它就可以取用，如果缓冲区里 没有数值，或数的个数不足，scanf 就要等待。 这是第一点。 第2点，那么 缓冲区里 的数 从何而来？答：是从键盘缓冲区里来。键盘缓冲区 的数据 只有当 遇到 回车键 时 才 送到 输入流缓冲区，否则 留在 键盘 缓冲区里，没到 输入流缓冲区里去。 键盘缓冲区：键盘的内部有一块微处理器，它控制着键盘的全部工作，比如主机加电时键盘的自检、扫描，扫描码的缓冲以及与主机的通讯等等。当一个键被按下时，微处理器便根据其位置，将字符信号转换成二进制码，传给主机和显示器。如果操作人员的输入速度很快或CPU正在进行其它的工作，就先将键入的内容送往内存中的键盘缓冲区，等CPU空闲时再从缓冲区中取出暂存的指令分析并执行。 12345678910111213#include &lt;stdio.h&gt;int main(void)&#123; char a; int n; //n代表scanf每次接收多少个。 while(1) &#123; n=scanf(&quot;%c&quot;,&amp;a); printf(&quot;%d&quot;,a); printf(&quot;--------------------------------%d\\n&quot;,n); &#125; return 0;&#125; 实验结果说明：scanf会接收缓冲区的字符，当接受完之后，我敲回车，控制台就会出现一次换行符。说明敲一次回车，就是传递一个换行符到输入流缓冲区，然后scanf接收这个换行符，并输出。 原文链接：https://blog.csdn.net/shine_journey/article/details/38958763 输入流的read()读取文件没内容时返回-1，读取键盘没内容时为什么就阻塞，没有返回值？123456789101112131415161718192021222324//读取取文件输入流：fos.txt内容为a public static void method3()throws IOException&#123; FileInputStream in=new FileInputStream(&quot;fos.txt&quot;); System.out.println(in.read()); System.out.println(in.read()); System.out.println(in.read()); System.out.println(in.read()); /* 结果为：97 -1 -1 -1 （读取文件内容a输出97后，文件输入流未有可读内容，返回-1并未进行阻塞） */ &#125; //读取键盘输入流 public static void method4()throws IOException&#123; InputStream in=System.in; System.out.println(in.read()); System.out.println(in.read()); System.out.println(in.read()); System.out.println(in.read()); /* 开始（此时键盘输入流未有可读内容）进行阻塞，键入1后 输出49 13 10 （window的回车为&apos;/r/n&apos;）再次进行阻塞（此时键盘输入流未有可读内容） 结果为：1 49 13 10 */ &#125; 回答：因为文件有没有内容可以直接判断，键盘不等待的话，你怎么知道用户多久以后才会输入？ 原文链接：https://www.zhihu.com/question/303794055","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"SpringAop与AspectJ是什么","slug":"Spring/SpringAop与AspectJ是什么","date":"2020-04-22T13:45:59.000Z","updated":"2020-06-03T06:29:03.965Z","comments":true,"path":"2020/04/22/Spring/SpringAop与AspectJ是什么/","link":"","permalink":"http://yoursite.com/2020/04/22/Spring/SpringAop与AspectJ是什么/","excerpt":"","text":"SpringAop与AspectJ是什么理解1 根据我看spring官方文档的理解（不出意外是最正确的答案）： ①选择spring的AOP还是AspectJ? spring确实有自己的AOP。功能已经基本够用了，除非你的要在接口上动态代理或者方法拦截精确到getter和setter。这些都是写奇葩的需求，一般不使用。 ②在使用AOP的时候，你是用xml还是注解的方式（@Aspect）？1）如果使用xml方式，不需要任何额外的jar包。2）如果使用@Aspect方式，你就可以在类上直接一个@Aspect就搞定，不用费事在xml里配了。但是这需要额外的jar包（ aspectjweaver.jar）。因为spring直接使用AspectJ的注解功能，注意只是使用了它 的注解功能而已。并不是核心功能 ！！！ 注意到文档上还有一句很有意思的话：文档说到 是选择spring AOP还是使用full aspectJ？什么是full aspectJ？如果你使用”full aspectJ”。就是说你可以实现基于接口的动态代理，等等强大的功能。而不仅仅是aspectj的 注-解-功-能 ！！！ 如果用full AspectJ。比如说Load-Time Weaving的方式 还 需要额外的jar包 spring-instrument.jar 当然，无论是使用spring aop还是 aspectj都需要aspectjweaver.jar spring-aop.jar这两个jar包。 参考:https://blog.csdn.net/maerrrr/article/details/78860420 理解2区别 AspectJ AspectJ是一个面向切面的框架，它扩展了Java语言。AspectJ定义了AOP语法，所以它有一个专门的编译器用来生成遵守Java字节编码规范的Class文件。 spring aop Spring提供了四种类型的Aop支持* 基于经典的SpringAOP* 纯POJO切面* @ASpectJ注解驱动的切面* 注入式AspectJ切面（其实与Spring并无多大的关系，这个就是使用AspectJ这个框架实现Aop编程） 基于经典的SpringAop 其使用ProxyFactoryBean创建:增强（通知）的类型有：前置通知：org.springframework.aop.MethodBeforeAdvice后置通知：org.springframework.aop.AfterReturningAdvice环绕通知：org.aopalliance.intercept.MethodInterceptor异常通知：org.springframework.aop.ThrowsAdvice 联系 我们借助于Spring Aop的命名空间可以将纯POJO转换为切面，实际上这些POJO只是提供了满足切点的条件时所需要调用的方法，但是，这种技术需要XML进行配置，不能支持注解。 所以spring借鉴了AspectJ的切面，以提供注解驱动的AOP，本质上它依然是Spring基于代理的AOP，只是编程模型与AspectJ完全一致，这种风格的好处就是不需要使用XML进行配置。 使用@Aspect方式，你就可以在类上直接一个@Aspect就搞定，不用费事在xml里配了。但是这需要额外的jar包（ aspectjweaver.jar）。因为spring直接使用AspectJ的注解功能，注意只是使用了它 的注解功能而已，并不是核心功能 。SpringAop的底层技术依然是Jdk动态代理和Cglib。 理解3 AOP(Aspect OrientedProgramming, 面向切面/方面编程) 旨在从业务逻辑中分离出来横切逻辑【eg:性能监控、日志记录、权限控制等】，提高模块化，即通过AOP解决代码耦合问题，让职责更加单一。 运用技术： SpringAOP使用了两种代理机制，一种是基于JDK的动态代理，另一种是基于CGLib的动态代理，之所以需要两种代理机制，很大程度上是因为JDK本身只提供基于接口的代理，不支持类的代理。 切面植入的方法： 1、编译期织入 2、类装载期织入 3、动态代理织入----&gt;在运行期为目标类添加增强生成子类的方式，Spring AOP采用动态代理织入切面 流行的框架： AOP现有两个主要的流行框架，即Spring AOP和Spring+AspectJ 二者的区别： 1、织入的时期不同 Spring Aop采用的动态织入，而Aspectj是静态织入。静态织入：指在编译时期就织入，即：编译出来的class文件，字节码就已经被织入了。动态织入又分静动两种，静则指织入过程只在第一次调用时执行；动则指根据代码动态运行的中间状态来决定如何操作，每次调用Target的时候都执行。有不清楚的同学，可以自己补下基础的代理知识 2、从使用对象不同 Spring AOP的通知是基于该对象是SpringBean对象才可以，而AspectJ可以在任何Java对象上应用通知。 Spring AOP：如果你想要在通过this对象调用的方法上应用通知，那么你必须使用currentProxy对象，并调用其上的相应方法;于此相似，如果你想要在某对象的方法上应用通知，那么你必须使用与该对象相应的Spring bean AspectJ：使用AspectJ的一个间接局限是，因为AspectJ通知可以应用于POJO之上，它有可能将通知应用于一个已配置的通知之上。对于一个你没有注意到这方面问题的大范围应用的通知，这有可能导致一个无限循环。 Spring AOP不同于大多数其他AOP框架。Spring AOP的目的并不是为了提供最完整的AOP实现（虽然Spring AOP具有相当的能力）；而是为了要帮助解决企业应用中的常见问题，提供一个AOP实现与Spring IOC之间的紧密集成。由于Spring AOP是容易实现的，如果你计划在Spring Beans之上将横切关注点模块化，Spring的这一目标将是要点之一。但同样的目标也可能成为一个限制，如果你用的是普通的Java对象而不是Spring beans,并基于此将横切关注点模块化的话。另一方面，AspectJ可用于基于普通Java对象的模块化，但在实施之前需要良好的关于这个主题的知识。 参考：https://blog.csdn.net/a128953ad/article/details/50509437 理解4(推荐查看)Spring AOP and AspectJ 现在，一起来讨论Spring AOP and AspectJ，跨越多指标，如能力和目标、织入方式、内部结构、连接点和简单性。 Capabilities and Goals 简而言之，Spring AOP和AspectJ有不同的目标。Spring AOP旨在通过Spring IoC提供一个简单的AOP实现，以解决编码人员面临的最常出现的问题。这并不是完整的AOP解决方案，它只能用于Spring容器管理的beans。 另一方面，AspectJ是最原始的AOP实现技术，提供了玩这个的AOP解决方案。AspectJ更为健壮，相对于Spring AOP也显得更为复杂。值得注意的是，AspectJ能够被应用于所有的领域对象。 Weaving AspectJ and Spring AOP使用了不同的织入方式，这影响了他们在性能和易用性方面的行为。AspectJ使用了三种不同类型的织入： 编译时织入：AspectJ编译器同时加载我们切面的源代码和我们的应用程序，并生成一个织入后的类文件作为输出。 编译后织入：这就是所熟悉的二进制织入。它被用来编织现有的类文件和JAR文件与我们的切面。 加载时织入：这和之前的二进制编织完全一样，所不同的是织入会被延后，直到类加载器将类加载到JVM。 更多关于AspectJ的信息，请见head on over to this article。 AspectJ使用的是编译期和类加载时进行织入，Spring AOP利用的是运行时织入。 运行时织入，在使用目标对象的代理执行应用程序时，编译这些切面（使用JDK动态代理或者CGLIB代理）。 如果我们分析本节所有的论点，我们就会开始明白，没有绝对的一个框架比另一个框架更好。简而言之，选择很大程度上取决我们的需求： 框架：如果应用程序不使用Spring框架，那么我们别无选择，只能放弃使用Spring AOP的想法，因为它无法管理任何超出spring容器范围的东西。 但是，如果我们的应用程序完全是使用Spring框架创建的，那么我们可以使用Spring AOP，因为它很直接便于学习和应用。 灵活性：鉴于有限的连接点支持，Spring AOP并不是一个完整的AOP解决方案，但它解决了程序员面临的最常见的问题。 如果我们想要深入挖掘并利用AOP达到其最大能力，并希望获得来自各种可用连接点的支持，那么AspectJ是最佳选择。 性能：如果我们使用有限的切面，那么性能差异很小。 但是，有时候应用程序有数万个切面的情况。 在这种情况下，我们不希望使用运行时织入，所以最好选择AspectJ。 已知AspectJ比Spring AOP快8到35倍。 共同优点：这两个框架是完全兼容的。 我们可以随时利用Spring AOP，并且仍然使用AspectJ来获得前者不支持的连接点。 参考：https://www.cnblogs.com/Irving/p/9739889.html 理解5Spring AOP 在纯 Java 中实现 不需要单独的编译过程 只能使用运行时织入 功能不强-仅支持方法级编织 只能在由 Spring 容器管理的 bean 上实现 仅支持方法执行切入点 代理是由目标对象创建的, 并且切面应用在这些代理上 比 AspectJ 慢多了 AspectJ 使用 Java 编程语言的扩展实现 除非设置 LTW，否则需要 AspectJ 编译器 (ajc) 运行时织入不可用。支持编译时、编译后和加载时织入 更强大 - 可以编织字段、方法、构造函数、静态初始值设定项、最终类/方法等…。 可以在所有域对象上实现 支持所有切入点 在执行应用程序之前 (在运行时) 前, 各方面直接在代码中进行织入 更好的性能 原文链接：https://blog.csdn.net/weixin_42181142/article/details/101212351 问题1 我们知道JDK的动态代理是针对接口的，在运行期生成代理类。 CGLIB动态代理 是可以针对接口与普通类(继承方式),底层使用ASM框架生成字节码完成代理功能 我在网上查资料说AspectJ是静态代理 在编译期间就生成了class文件完成了代理。这点容易理解一种编译的技术。那么我的问题是 问题一123Spring的AOP为什么需要引入aspectjrt-1.6.8.jar与aspectjweaver-1.6.8.jar这两个包?如果是接口直接使用JDK的动态代理,如果是普通类则用cglib不就完了吗?这是我的第一个问题问题二 第二个问题是Spring使用aspectjrt-1.6.8.jar与aspectjweaver-1.6.8.jar包 那么是编译期代理 还是 运行期代理 求详细解释 参考：https://www.iteye.com/problems/98151 问题2AspectJ是Eclipse基金组织的开源项目，它是Java语言的一个AOP实现，是最早、功能比较强大的AOP实现之一，对整套AOP机制都有较好的实现，很多其他语言的AOP实现也借鉴或者采纳了AspectJ中的很多设计。在Java领域，AspectJ中的很多语法结构基本上已经成为AOP领域的标准。 要知道的是，AspectJ框架和Spring框架实现AOP的方式是不一样的，AspectJ是在编译时进行增强，所以它有一个专门的编译器ajc来生成遵守Java字节码编码规范的Class文件。而Spring采用的是动态代理的方式，它并不需要有一个专门的编译器。故也称AspectJ为静态AOP实现，而Spring AOP为动态AOP实现。 AspectJ主要包含两个部分：第一个部分定义了如何表达、定义AOP编程中的语法规范；第二个部分是工具部分，包括编译器、调试工具等。 虽然 AspectJ 很强大，但是跟 lombok不兼容，在编译期间会打架，谁也不认识谁，所以还是放弃吧，老老实实用 AOP 问题3基于Aspect Spring AOP 开发Spring AOP 与ApectJ 的目的一致，都是为了统一处理横切业务，但与AspectJ不同的是，Spring AOP 并不尝试提供完整的AOP功能(即使它完全可以实现)，Spring AOP 更注重的是与Spring IOC容器的结合，并结合该优势来解决横切业务的问题，因此在AOP的功能完善方面，相对来说AspectJ具有更大的优势，同时,Spring注意到AspectJ在AOP的实现方式上依赖于特殊编译器(ajc编译器)，因此Spring很机智回避了这点，转向采用动态代理技术的实现原理来构建Spring AOP的内部机制（动态织入），这是与AspectJ（静态织入）最根本的区别。在AspectJ 1.5后，引入@Aspect形式的注解风格的开发，Spring也非常快地跟进了这种方式，因此Spring 2.0后便使用了与AspectJ一样的注解。请注意，Spring 只是使用了与 AspectJ 5 一样的注解，但仍然没有使用 AspectJ 的编译器，底层依是动态代理技术的实现，因此并不依赖于 AspectJ 的编译器 原文链接：https://blog.csdn.net/javazejian/article/details/56267036 对于AspectJ的使用Aspect是实现AOP编程的一种具体实现 编译时织入，利用ajc编译器替代javac编译器，直接将源文件(java或者aspect文件)编译成class文件并将切面织入进代码。 编译后织入，利用ajc编译器向javac编译期编译后的class文件或jar文件织入切面代码。 加载时织入(LTW)，不使用ajc编译器，利用aspectjweaver.jar工具，使用java agent代理在类加载期将切面织入进代码。 使用LTW方式(加载时编织)前两种织入方法都依赖于ajc的编译工具，LTW却通过java agent机制在内存中操作类文件，可以不需要ajc的支持做到 动态织入 不过，这里有一个挺有意思的问题，我们知道编译期一定会编译AnnoAspect类，那么这时候通过切面语法我们就可以找到他要处理的App类，这大概就是编译阶段织入的大概流程。但是如果在类加载期处理的话，当类加载到App类的时候，我们并不知道这个类需要被AnnoAspect处理。。。因此为了实现LTW，我们肯定要有个配置文件，来告诉类加载器，某某某切面需要优先考虑，他们很可能会影响其他的类。 为了实现LTW，我们需要在资源目录下配置META-INF/aop.xml文件，来告知类加载器我们当前注册的切面。 在上面的项目中，我们其实只需要创建src/main/resources/META-INF/aop.xml： ​ 参考:https://blog.csdn.net/whatigame/article/details/103173308 编织方式1.1 LTW与不同的切面织入时机AOP——面向切面编程,通过为目标类织入切面的方式,实现对目标类功能的增强。按切面被织如到目标类中的时间划分,主要有以下几种: 1.运行期织入这是最常见的,比如在运行期通过为目标类生成动态代理的方式实现AOP就属于运行期织入,这也是Spring AOP中的默认实现,并且提供了两种创建动态代理的方式:JDK自带的针对接口的动态代理和使用CGLib动态创建子类的方式创建动态代理。 2.编译期织入使用特殊的编译器在编译期将切面织入目标类,这种比较少见,因为需要特殊的编译器的支持。 3.类加载期织入通过字节码编辑技术在类加载期将切面织入目标类中,这是本篇介绍的重点。它的核心思想是:在目标类的class文件被JVM加载前,通过自定义类加载器或者类文件转换器将横切逻辑织入到目标类的class文件中,然后将修改后class文件交给JVM加载。这种织入方式可以简称为LTW(LoadTimeWeaving)。 1.2 JDK实现LTW的原理可以使用JKD的代理功能让代理器访问到JVM的底层组件,借此向JVM注册类文件转换器,在类加载时对类文件的字节码进行转换。具体而言,java.lang.instrument包下定义了ClassFileTransformer接口,该接口的作用如下面的注释所描述 123* An agent provides an implementation of this interface in order* to transform class files.* The transformation occurs before the class is defined by the JVM. 可以通过实现该接口,并重写如下抽象方法自定义类文件转换规则 1234567byte[]transform( ClassLoader loader, String className, Class&lt;?&gt; classBeingRedefined, ProtectionDomain protectionDomain, byte[] classfileBuffer) throws IllegalClassFormatException; classfileBuffer是原始类文件对应的字节码数组,返回的byte[]为转化后的字节码数组,如果返回null,则表示不进行字节码处理。 而java.lang.instrument包下的Instrumentation接口则可以将我们自定义的ClassTransFormer向JVM内部的组件进行注册 12voidaddTransformer(ClassFileTransformer transformer); 在实际使用中,可以通过JVM的-javaagent代理参数在启动时获取JVM内部组件的引用,将ClassFileTransformer实例注册到JVM中,JVM在加载Class文件时,会先调用这个ClassTransformer的transform()方法对Class文件的字节码进行转换,比如织入切面中定义的横切逻辑,实现AOP功能。 参考：https://www.cnblogs.com/takumicx/p/10150344.html 装载方式编译期织入、装载期织入、运行时织入 AOP 实现的关键就在于 AOP 框架自动创建的 AOP 代理，AOP 代理则可分为静态代理和动态代理两大类，其中静态代理是指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；而动态代理则在运行时借助于 JDK 动态代理、CGLIB 等在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。 静态代理分为：编译时织入（特殊编译器实现）、类加载时织入（特殊的类加载器实现）。 动态代理有 ： jdk动态代理（基于接口来实现）、CGlib（基于类实现）。 编译期织入：指在Java编译期间，采用特殊的编译器，将切面织入到java类中； 类加载期织入：指通过特殊的类加载器，在类字节码加载到JVM时，织入切面 运行期织入：采用cglib或者jdk动态代理进行切面织入 aspectj的三种织入： 编译期：把aspect类（aop切面）和目标类放在一起用ajc编译器编译 后编译期：目标类可能已经被打成了一个jar包，这个时候也可以用ajc命令将jar再织入一次 类加载期(Load-Time Weaving)： 在JVM加载类字节码文件时，做字节码替换 其中前两个时间点，可以理解为静态织入，因为在class文件生成后，就已经织入好了。类加载期织入，可以理解为“动态织入”（注意不同于java动态代理的“动态”）,因为这个类替换是在jvm加载类的时候完成的 原文链接：https://blog.csdn.net/wenbingoon/article/details/22888619 Spring到底有没有用到AspectJ的实现(结论)如何判断是织入还是代理这个问题很有意思，也是非常容易被搞混的，尤其是在讨论spring aop的时候。我们知道spring里有很多基于动态代理的设计，而我们知道动态代理也可以被用作面向切面的编程，但是spring aop本身却支持aspectj的切面语法，而且spring-aop这个包也引用了aspectj，我们知道aspectj是通过织入的方式来实现aop的。。。那么 spring aop究竟是通过织入还是代理来实现aop的呢？ 没错就是动态代理其实spring aop还是通过 动态代理来实现aop的，即使不去看他的源码，我们也可以通过简单的实验来得到这个结论。 根据aspectj的使用方式，我们知道，如果要向代码中织入切面，那么我们要么采用ajc编译，要么使用aspectjweaver的agent代理。但是spring既没有依赖任何aspectjtools的相关jar包，虽然依赖了aspectjweaver这个包，但是并没有添加agent代理。当然，也存在一种可能就是spring利用aspectjweaver这个包自己实现了动态织入，但是从可复用的角度讲，spring真的会自己重新造轮子？如果真的重新造了那为啥不脱离aspectj彻底重新造，而是用一半造一半呢？ 而且，我们知道用织入和用动态代理有一个很大的区别，如果使用织入的话，那么调业务对象的getClass()方法获得的类名就是这个类本身实现的类名；但是如果使用动态代理的话，调用getClass()方法获得的类名就是动态代理类的类名了。做一个简单的实验我们就可以发现，如果我们使用spring aop来对某一个service进行切面处理，那么调用getClass()方法获得的结果就是： 1com.mythsman.test.Myservice$$EnhancerBySpringCGLIB$$3afc9148 显然，虽然spring aop采用了aspectj语法来定义切面，但是在实现切面逻辑的时候还是采用CGLIB来进行动态代理的方法。 强行织入？当然，如果我们想，我们也可以强行采用织入的方式，不过我们就不能将切面类注册为spring的bean，并且采用ajc插件编译或者java agent在类加载时织入。 参考：https://blog.csdn.net/whatigame/article/details/103173308 额外说明emmm 在使用spring-test包测试时，也就是整合junit进行测试 结果使用xml配置的事务出错，原因是找不到aspectjweaver包下的一些类，添加aspectj包即可 (但是项目正常启动时可以不添加aspectjweaver包的)，，，，，不知道这个测试包怎么。。。 12345678910111213141516171819...Caused by: java.lang.IllegalStateException: Failed to introspect Class [org.springframework.aop.aspectj.AspectJExpressionPointcut] from ClassLoader [sun.misc.Launcher$AppClassLoader@18b4aac2] at org.springframework.util.ReflectionUtils.getDeclaredMethods(ReflectionUtils.java:659) at org.springframework.util.ReflectionUtils.doWithMethods(ReflectionUtils.java:556) at org.springframework.util.ReflectionUtils.doWithMethods(ReflectionUtils.java:541) at org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor.determineCandidateConstructors(AutowiredAnnotationBeanPostProcessor.java:245) ... 60 moreCaused by: java.lang.NoClassDefFoundError: org/aspectj/weaver/reflect/ReflectionWorld$ReflectionWorldException at java.lang.Class.getDeclaredMethods0(Native Method) at java.lang.Class.privateGetDeclaredMethods(Class.java:2701) at java.lang.Class.getDeclaredMethods(Class.java:1975) at org.springframework.util.ReflectionUtils.getDeclaredMethods(ReflectionUtils.java:641) ... 63 moreCaused by: java.lang.ClassNotFoundException: org.aspectj.weaver.reflect.ReflectionWorld$ReflectionWorldException at java.net.URLClassLoader.findClass(URLClassLoader.java:381) at java.lang.ClassLoader.loadClass(ClassLoader.java:424) at sun.misc.Launcher$AppClassLoader.loadClass(Launcher.java:338) at java.lang.ClassLoader.loadClass(ClassLoader.java:357) ... 67 more","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"关于获取Log实例的参数问题","slug":"Logging/关于获取Log实例的参数问题","date":"2020-04-20T00:50:30.000Z","updated":"2020-04-21T05:52:17.978Z","comments":true,"path":"2020/04/20/Logging/关于获取Log实例的参数问题/","link":"","permalink":"http://yoursite.com/2020/04/20/Logging/关于获取Log实例的参数问题/","excerpt":"","text":"关于Logorg.apache.commons.logging​ 使用日志一般需要获取一个Log对象,在类中声明一个私有属性Log ​ private static Log log = LogFactory.getLog(Test.class); org.apache.commons.logging.LogFactory​ 部分代码分析： 通过静态方法来选择日志实现，默认是LogApi.JUL（JUL:java.util.logging） 123456789101112131415161718192021222324252627282930313233public abstract class LogFactory &#123; private static LogApi logApi = LogApi.JUL; static &#123; ClassLoader cl = LogFactory.class.getClassLoader(); try &#123; // Try Log4j 2.x API cl.loadClass(&quot;org.apache.logging.log4j.spi.ExtendedLogger&quot;); logApi = LogApi.LOG4J; &#125; catch (ClassNotFoundException ex1) &#123; try &#123; // Try SLF4J 1.7 SPI cl.loadClass(&quot;org.slf4j.spi.LocationAwareLogger&quot;); logApi = LogApi.SLF4J_LAL; &#125; catch (ClassNotFoundException ex2) &#123; try &#123; // Try SLF4J 1.7 API cl.loadClass(&quot;org.slf4j.Logger&quot;); logApi = LogApi.SLF4J; &#125; catch (ClassNotFoundException ex3) &#123; // Keep java.util.logging as default &#125; &#125; &#125; //枚举属性 private enum LogApi &#123;LOG4J, SLF4J_LAL, SLF4J, JUL&#125; &#125; ​ ​ ​ getLog中的参数测试测试所用日志maven依赖1234567891011121314151617181920212223242526272829&lt;!-- junit测试 --&gt;&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt;&lt;/dependency&gt;&lt;!-- https://mvnrepository.com/artifact/commons-logging/commons-logging --&gt;&lt;dependency&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.6.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.6.6&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt;&lt;/dependency&gt; 测试类12345678910111213141516171819package log;import org.apache.commons.logging.Log;import org.apache.commons.logging.LogFactory;/** * 关于日志的测试 * 本次测试使用的commons-logging作为日志门面 * 如果有Log4j，commons-logging的LogFactory初始化静态方法会自动选择日志实现 * LogFactory中的枚举属性:private enum LogApi &#123;LOG4J, SLF4J_LAL, SLF4J, JUL&#125; * JUL: java.util.logging(JDK自带的Logging其实是一个鸡肋，竟然没有debug的日志级别,没测试过) * log4j:只要我们在项目中添加了log4j的jar包，那么commons-logging就会自动切到log4j的日志输出。 * log4j必须要有log4j.properties * @author Momentonly * @date 2020/4/20 */public class LogTest &#123;&#125; log4j的配置文件12345678910# Global logging configurationlog4j.rootLogger=DEBUG, stdout#设置包级别的日志#log4j.logger.log=DEBUG# Console output...log4j.appender.stdout=org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.layout=org.apache.log4j.PatternLayoutlog4j.appender.stdout.layout.ConversionPattern=%5p [%t] %l - %m%n 测试方法1getLog传递一个本类的Class对象 123456789//获取一个日志对象 private static Log log = LogFactory.getLog(LogTest.class); @Test public void test1()&#123; log.debug(&quot;debug()...&quot;); log.info(&quot;start...&quot;); log.warn(&quot;end.&quot;); &#125; 打印: DEBUG [main] log.LogTest.test1(LogTest.java:26) - debug()… INFO [main] log.LogTest.test1(LogTest.java:27) - start… WARN [main] log.LogTest.test1(LogTest.java:28) - end. 测试方法2getLog传递一个字符串参数 123456789//获取一个日志对象 private static Log log = LogFactory.getLog(&quot;这是一个测试类&quot;); @Test public void test2()&#123; log.debug(&quot;debug()...&quot;); log.info(&quot;start...&quot;); log.warn(&quot;end.&quot;); &#125; 打印： DEBUG [main] log.LogTest.test2(LogTest.java:32) - debug()… INFO [main] log.LogTest.test2(LogTest.java:33) - start… WARN [main] log.LogTest.test2(LogTest.java:34) - end. 测试方法3​ getLog传递任意一个Class参数 123456789//获取一个日志对象 private static Log log = LogFactory.getLog(Object.class); @Test public void test3()&#123; log.debug(&quot;debug()...&quot;); log.info(&quot;start...&quot;); log.warn(&quot;end.&quot;); &#125; 打印： DEBUG [main] log.LogTest.test3(LogTest.java:25) - debug()… INFO [main] log.LogTest.test3(LogTest.java:26) - start… WARN [main] log.LogTest.test3(LogTest.java:27) - end. 测试1,2,3方法总结​ 发现打印结果的追踪类并没有因为getLog的参数不同而发生改变 测试方法4修改log4j配置文件，关闭日志 1log4j.rootLogger=OFF, stdout 测试方法 123456789//获取一个日志对象 private static Log log = LogFactory.getLog(Object.class); @Test public void test4()&#123; log.debug(&quot;debug()...&quot;); log.info(&quot;start...&quot;); log.warn(&quot;end.&quot;); &#125; 没有任何输出 测试方法5修改log4j配置文件 123log4j.rootLogger=OFF, stdout#设置包级别的输出log4j.logger.java.lang=DEBUG 测试方法 123456789//获取一个日志对象 private static Log log = LogFactory.getLog(Object.class); @Test public void test5()&#123; log.debug(&quot;debug()...&quot;); log.info(&quot;start...&quot;); log.warn(&quot;end.&quot;); &#125; 打印： 123DEBUG [main] log.LogTest.test5(LogTest.java:25) - debug()... INFO [main] log.LogTest.test5(LogTest.java:26) - start... WARN [main] log.LogTest.test5(LogTest.java:27) - end. 测试4,5方法总结getLog中的参数不会使调用该日志的类(追踪类)发生改变 但是，该参数是Class对象，可以设置包，类，方法级别来定义log4j的输出 (例如在mybatis中通过日志打印sql就设置包级别为你的接口包就可以，但是 打印的日志追踪类却不是你的接口实现类) log4j2Log4j2简介 log4j2是log4j 1.x 的升级版，2015年5月，Apache宣布log4j1.x 停止更新。最新版为1.2.17。 log4j2参考了logback的一些优秀的设计，并且修复了一些问题，因此带来了一些重大的提升，主要有： 1、异常处理：在logback中，Appender中的异常不会被应用感知到，但是在log4j2中，提供了一些异常处理机制。 2、性能提升：log4j2相较于log4j 1和logback都具有很明显的性能提升。 3、自动重载配置：参考了logback的设计，提供自动刷新参数配置，可以动态的修改日志的级别而不需要重启应用。 4、无垃圾机制，log4j2在大部分情况下，都可以使用其设计的一套无垃圾机制，避免频繁的日志收集导致的jvm gc。 测试引入依赖 1234567891011&lt;!--添加log4j2相关jar包--&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.7&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.7&lt;/version&gt;&lt;/dependency&gt; 配置文件： 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;configuration status=&quot;error&quot;&gt; &lt;!--先定义所有的appender --&gt; &lt;appenders&gt; &lt;!--这个输出控制台的配置 --&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;!-- 控制台只输出level及以上级别的信息（onMatch），其他的直接拒绝（onMismatch） --&gt; &lt;ThresholdFilter level=&quot;trace&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;!-- 这个都知道是输出日志的格式 --&gt; &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt; &lt;/Console&gt; &lt;!--文件会打印出所有信息，这个log每次运行程序会自动清空，由append属性决定，这个也挺有用的，适合临时测试用 --&gt; &lt;!--append为TRUE表示消息增加到指定文件中，false表示消息覆盖指定的文件内容，默认值是true --&gt; &lt;File name=&quot;log&quot; fileName=&quot;D:/logs/log4j2.log&quot; append=&quot;false&quot;&gt; &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt; &lt;/File&gt; &lt;!--添加过滤器ThresholdFilter,可以有选择的输出某个级别以上的类别 onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;意思是匹配就接受,否则直接拒绝 --&gt; &lt;File name=&quot;ERROR&quot; fileName=&quot;D:/logs/error.log&quot;&gt; &lt;ThresholdFilter level=&quot;error&quot; onMatch=&quot;ACCEPT&quot; onMismatch=&quot;DENY&quot;/&gt; &lt;PatternLayout pattern=&quot;%d&#123;yyyy.MM.dd &apos;at&apos; HH:mm:ss z&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt; &lt;/File&gt; &lt;!--这个会打印出所有的信息，每次大小超过size，则这size大小的日志会自动存入按年份-月份建立的文件夹下面并进行压缩，作为存档 --&gt; &lt;RollingFile name=&quot;RollingFile&quot; fileName=&quot;D:/logs/web.log&quot; filePattern=&quot;logs/$$&#123;date:yyyy-MM&#125;/web-%d&#123;MM-dd-yyyy&#125;-%i.log.gz&quot;&gt; &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd &apos;at&apos; HH:mm:ss z&#125; %-5level %class&#123;36&#125; %L %M - %msg%xEx%n&quot;/&gt; &lt;SizeBasedTriggeringPolicy size=&quot;2MB&quot;/&gt; &lt;/RollingFile&gt; &lt;/appenders&gt; &lt;!--然后定义logger，只有定义了logger并引入的appender，appender才会生效 --&gt; &lt;loggers&gt; &lt;root level=&quot;trace&quot;&gt; &lt;appender-ref ref=&quot;RollingFile&quot;/&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;appender-ref ref=&quot;ERROR&quot; /&gt; &lt;appender-ref ref=&quot;log&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt;&lt;/configuration&gt; 测试类 1234567891011121314151617181920import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger; public class log4j2Test &#123; private static Logger logger= LogManager.getLogger(LogManager.ROOT_LOGGER_NAME); public static void main(String[] args) &#123; for(int i=0;i&lt;3;i++)&#123; // 记录trace级别的信息 logger.trace(&quot;log4j2日志输出：This is trace message.&quot;); // 记录debug级别的信息 logger.debug(&quot;log4j2日志输出：This is debug message.&quot;); // 记录info级别的信息 logger.info(&quot;log4j2日志输出：This is info message.&quot;); // 记录error级别的信息 logger.error(&quot;log4j2日志输出：This is error message.&quot;); &#125; &#125;&#125; log4j2配置说明log4j 2.x版本不再支持像1.x中的.properties后缀的文件配置方式，2.x版本常用.xml后缀的文件进行配置，除此之外还包含.json和.jsn配置文件 log4j2虽然采用xml风格进行配置，依然包含三个组件,分别是 Logger(记录器)、Appender(输出目的地)、Layout(日志布局)。 XML配置文件解析 1、根节点Configuration有两个属性:status和monitorinterval,有两个子节点:Appenders和Loggers(表明可以定义多个Appender和Logger). 12status用来指定log4j本身的打印日志的级别.monitorinterval为log4j 2.x新特点自动重载配置。指定自动重新配置的监测间隔时间，单位是s,最小是5s。 2、Appenders节点，常见的有三种子节点:Console、File、RollingFile 123Console节点用来定义输出到控制台的Appender.File节点用来定义输出到指定位置的文件的Appender.RollingFile节点用来定义超过指定大小自动删除旧的创建新的的Appender. 通过在子节点中加入\\进行日志布局 ;) 12345678%c 输出所属类的全名，可写为 %c&#123;Num&#125; ,Num类名输出的范围 如：&quot;com.sun.aaa.classB&quot;,%C&#123;2&#125;将使日志输出输出范围为：aaa.classB%d 输出日志时间其格式为 可指定格式 如 %d&#123;HH:mm:ss&#125;等%l 输出日志事件发生位置，包括类目名、发生线程，在代码中的行数%n 换行符%m 输出代码指定信息，如info(“message”),输出message%p 输出日志的优先级，即 FATAL ,ERROR 等%r 输出从启动到显示该条日志信息所耗费的时间（毫秒数）%t 输出产生该日志事件的线程名 ;) 3、Loggers节点，常见的有两种:Root和Logger. Root节点用来指定项目的根日志，如果没有单独指定Logger，那么就会默认使用该Root日志输出 Logger节点用来单独指定日志的形式，比如要为指定包下的class指定不同的日志级别等。 logback log4j log4j2 性能实测 可见在同步日志模式下, Logback的性能是最糟糕的 而log4j2的性能无论在同步日志模式还是异步日志模式下都是最佳的 参考：https://www.cnblogs.com/LemonFive/p/10737658.html","categories":[{"name":"Logging","slug":"Logging","permalink":"http://yoursite.com/categories/Logging/"}],"tags":[{"name":"log","slug":"log","permalink":"http://yoursite.com/tags/log/"}]},{"title":"浏览器跨域","slug":"Web/浏览器跨域","date":"2020-04-16T12:55:11.000Z","updated":"2020-04-17T07:33:29.253Z","comments":true,"path":"2020/04/16/Web/浏览器跨域/","link":"","permalink":"http://yoursite.com/2020/04/16/Web/浏览器跨域/","excerpt":"","text":"跨域跨域的本质浏览器有一个很重要的概念——同源策略(Same-Origin Policy)。所谓同源是指，域名，协议，端口相同。不同源的客户端脚本(javascript、ActionScript)在没明确授权的情况下，不能读写对方的资源。 ​ 但是，form表单提交，img,script标签没有跨域问题，但ajax提交存在跨域问题。 浏览器的策略本质是：一个域名下面的JS，没有经过允许是不能读取另外一个域名的内容，但是浏览器不阻止你向另外一个域名发送请求。 所以form表单提交没有跨域问题，提交form表单到另外一个域名，原来页面是无法获取新页面的内容，或者说form提交后不需要返回，但是ajax是需要返回的。 而ajax是想要读取响应内容，浏览器是不允许你这么做的。 世界本无跨域，是浏览器不允许js访问别的域，但是浏览器却没有限制自己，img标签和script标签都是可以加载其他域的图片或者js文件。这不就是jsonp的跨域嘛，利用浏览器的历史兼容性。 浏览器的安全策略限制的是js脚本，并不限制src，form表单提交之类的请求。就是说form表单提交不存在安全问题，ajax提交跨域存在安全问题。 参考：https://www.cnblogs.com/tangjiao/p/9951477.html 解决跨域方案jsonpjsonp原理​ 我们知道，img,script,这种标签如果有相应的src，那么便会发起一个htttp请求来请求相应的资源,如果有script标签对应的路径是一个js文件，那么在下载完毕这个js之后会马上执行 12&lt;script type=&quot;text/javascript&quot; src=&quot;www.somewhere.com/test.js&quot;&gt;&lt;/script&gt;&lt;!--此时会发起一个请求来获取test.js，下载完成之后会立即执行test.js--&gt; 假设我们需要从’www.localhost.com’发起一个获取数据的请求’www.somewhere.com/getdata’,如果有我们以ajax来发起请求，那么由于浏览器同源保护策略的限制，该请求的返回值不会被浏览器所接受，这就是跨域问题。但是script这种标签会发起一个get请求，并且这个请求是不受同源策略限制的，如果有我们将’www.somewhere.com/getdata’以script标签来发送变成如下请求方式，那么是不是就不会有跨域问题了 12 12 12&lt;script type=&quot;text/javascript&quot; src=&quot;www.somewhere.com/getdata&quot;&gt;&lt;/script&gt;&lt;!--需要这样一个script来发起get请求--&gt; 答案是肯定的，这也是jsonp跨域的原理(因此也只能是get请求)。 jsonp的缺点 只能发送get请求。因为script只能发送get请求 需要后台配合。此种请求方式应该前后端配合，将返回结果包装成callback(result)的形式。 参考：https://www.cnblogs.com/willing-shang/p/6719875.html json的一些实践参考：https://blog.csdn.net/zezezuiaiya/article/details/79158548 CORS规范化的跨域请求解决方案，安全可靠。 优势： 在服务端进行控制是否允许跨域，可自定义规则 支持各种请求方式 缺点： 会产生额外的请求 参考：https://www.jianshu.com/p/98d4bc7565b2 httpclient服务端代理​ 通过服务端使用httpclient代理发送请求解决跨域（因为跨域是浏览器的限制）","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"跨域","slug":"跨域","permalink":"http://yoursite.com/tags/跨域/"}]},{"title":"Springmvc注解驱动","slug":"Spring/springmvc注解驱动","date":"2020-04-15T07:45:59.000Z","updated":"2020-04-15T10:51:58.541Z","comments":true,"path":"2020/04/15/Spring/springmvc注解驱动/","link":"","permalink":"http://yoursite.com/2020/04/15/Spring/springmvc注解驱动/","excerpt":"","text":"Springmvc注解驱动注解驱动的解析​ 通过查看 spring-webmvc-xxx.jar 下的spring.handlers文件可以发现 mvc前缀的标签都是由 MvcNamespaceHandler 来进行解析的。 spring.handlers 1http\\://www.springframework.org/schema/mvc=org.springframework.web.servlet.config.MvcNamespaceHandler 12345678910111213141516171819public class MvcNamespaceHandler extends NamespaceHandlerSupport &#123; @Override public void init() &#123; registerBeanDefinitionParser(&quot;annotation-driven&quot;, new AnnotationDrivenBeanDefinitionParser()); registerBeanDefinitionParser(&quot;default-servlet-handler&quot;, new DefaultServletHandlerBeanDefinitionParser()); registerBeanDefinitionParser(&quot;interceptors&quot;, new InterceptorsBeanDefinitionParser()); registerBeanDefinitionParser(&quot;resources&quot;, new ResourcesBeanDefinitionParser()); registerBeanDefinitionParser(&quot;view-controller&quot;, new ViewControllerBeanDefinitionParser()); registerBeanDefinitionParser(&quot;redirect-view-controller&quot;, new ViewControllerBeanDefinitionParser()); registerBeanDefinitionParser(&quot;status-controller&quot;, new ViewControllerBeanDefinitionParser()); registerBeanDefinitionParser(&quot;view-resolvers&quot;, new ViewResolversBeanDefinitionParser()); registerBeanDefinitionParser(&quot;tiles-configurer&quot;, new TilesConfigurerBeanDefinitionParser()); registerBeanDefinitionParser(&quot;freemarker-configurer&quot;, new FreeMarkerConfigurerBeanDefinitionParser()); registerBeanDefinitionParser(&quot;groovy-configurer&quot;, new GroovyMarkupConfigurerBeanDefinitionParser()); registerBeanDefinitionParser(&quot;script-template-configurer&quot;, new ScriptTemplateConfigurerBeanDefinitionParser()); registerBeanDefinitionParser(&quot;cors&quot;, new CorsBeanDefinitionParser()); &#125;&#125; 通过查看其内部唯一的方法 init() 的实现可以确定 &lt;mvc:annotation-driven /&gt; 的解析工作是由 AnnotationDrivenBeanDefinitionParser 类全权负责的。其实现了BeanDefinitionParser接口 唯一的parse()方法 123456789101112131415161718192021222324252627282930class AnnotationDrivenBeanDefinitionParser implements BeanDefinitionParser &#123; public static final String HANDLER_MAPPING_BEAN_NAME = RequestMappingHandlerMapping.class.getName(); public static final String HANDLER_ADAPTER_BEAN_NAME = RequestMappingHandlerAdapter.class.getName(); //....省略其他属性 public BeanDefinition parse(Element element, ParserContext parserContext) &#123; //.....省略代码 //此处注册组件 parserContext.registerComponent(new BeanComponentDefinition(handlerMappingDef, HANDLER_MAPPING_BEAN_NAME)); //注册RequestMappingHandlerMapping parserContext.registerComponent(new BeanComponentDefinition(handlerAdapterDef, HANDLER_ADAPTER_BEAN_NAME)); //注册REquestMappingHandlerAdapter parserContext.registerComponent(new BeanComponentDefinition(uriCompContribDef, uriCompContribName)); parserContext.registerComponent(new BeanComponentDefinition(exceptionResolver, methodExceptionResolverName)); parserContext.registerComponent(new BeanComponentDefinition(statusExceptionResolver, statusExResolverName)); parserContext.registerComponent(new BeanComponentDefinition(defaultExceptionResolver, defaultExResolverName)); parserContext.registerComponent(new BeanComponentDefinition(mappedCsInterceptorDef, mappedInterceptorName)); // Ensure BeanNameUrlHandlerMapping (SPR-8289) and default HandlerAdapters are not &quot;turned off&quot; MvcNamespaceUtils.registerDefaultComponents(parserContext, source); parserContext.popAndRegisterContainingComponent(); return null; &#125;&#125; 观察该类对所继承接口的实现可以发现: ​ 向SpringMVC容器中注册了 ContentNegotiationManagerFactoryBean​ 向SpringMVC容器中注册了 RequestMappingHandlerMapping (间接实现了HandlerMapping接口), order为0​ 向SpringMVC容器中注册了 RequestMappingHandlerAdapter (间接实现了HandlerAdapter接口，直接实现了 InitializingBean接口，关于这个接口的实现，参见本人的另外一篇博客)​ 向SpringMVC容器中注册了 MappedInterceptor​ 向SpringMVC容器中注册了 ExceptionHandlerExceptionResolver (间接实现了HandlerExceptionResolver接口), order为0​ 向SpringMVC容器中注册了 ResponseStatusExceptionResolver (间接实现了HandlerExceptionResolver接口), order为1​ 向SpringMVC容器中注册了 DefaultHandlerExceptionResolver (间接实现了HandlerExceptionResolver接口), order为2 RequestMappingHandlerMapping继承结构public class RequestMappingHandlerMapping extends RequestMappingInfoHandlerMapping ​ public abstract class RequestMappingInfoHandlerMapping extends AbstractHandlerMethodMapping ​ public abstract class AbstractHandlerMethodMapping\\&lt;T> extends AbstractHandlerMapping implements InitializingBean 初始化初始化接口​ 该类实现了InitializingBean接口，因此初始化bean时会调用afterPropertiesSet()方法 1234567891011121314public interface InitializingBean &#123; /** * Invoked by a BeanFactory after it has set all bean properties supplied * (and satisfied BeanFactoryAware and ApplicationContextAware). * &lt;p&gt;This method allows the bean instance to perform initialization only * possible when all bean properties have been set and to throw an * exception in the event of misconfiguration. * @throws Exception in the event of misconfiguration (such * as failure to set an essential property) or if initialization fails. */ void afterPropertiesSet() throws Exception;&#125; InitializingBean接口为bean提供了初始化方法的方式，它只包括afterPropertiesSet方法，凡是继承该接口的类，在初始化bean的时候都会执行该方法。 补充说明： 1、Spring为bean提供了两种初始化bean的方式，实现InitializingBean接口，实现afterPropertiesSet方法，或者在配置文件中通过init-method指定，两种方式可以同时使用。 2、实现InitializingBean接口是直接调用afterPropertiesSet方法，比通过反射调用init-method指定的方法效率要高一点，但是init-method方式消除了对spring的依赖。 3、如果调用afterPropertiesSet方法时出错，则不调用init-method指定的方法。 参考：https://www.cnblogs.com/weiqihome/p/8922937.html 具体实现接口1）public abstract class AbstractHandlerMethodMapping该类实现了InitializingBean的afterPropertiesSet()方法 AbstractHandlerMethodMapping—&gt;afterPropertiesSet() 1234@Override public void afterPropertiesSet() &#123; initHandlerMethods(); &#125; 调用了initHandlerMethods(); 2）AbstractHandlerMethodMapping–&gt;initHandlerMethods(); 123456789101112131415161718192021222324252627282930313233343536373839/** * Scan beans in the ApplicationContext, detect and register handler methods. * @see #isHandler(Class) * @see #getMappingForMethod(Method, Class) * @see #handlerMethodsInitialized(Map) */ protected void initHandlerMethods() &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Looking for request mappings in application context: &quot; + getApplicationContext()); &#125;//获取容器中的bean名 String[] beanNames = (this.detectHandlerMethodsInAncestorContexts ? BeanFactoryUtils.beanNamesForTypeIncludingAncestors(obtainApplicationContext(), Object.class) : obtainApplicationContext().getBeanNamesForType(Object.class));//遍历 for (String beanName : beanNames) &#123; if (!beanName.startsWith(SCOPED_TARGET_NAME_PREFIX)) &#123; Class&lt;?&gt; beanType = null; try &#123; //根据bean名获取该bean的类型(Class) beanType = obtainApplicationContext().getType(beanName); &#125; catch (Throwable ex) &#123; // An unresolvable bean type, probably from a lazy bean - let&apos;s ignore it. if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Could not resolve target class for bean with name &apos;&quot; + beanName + &quot;&apos;&quot;, ex); &#125; &#125; // isHandler在AbstractHandlerMethodMapping&lt;T&gt;类中抽象方法; //判断是否是一个Handler if (beanType != null &amp;&amp; isHandler(beanType)) &#123; //检测Handler中的方法 detectHandlerMethods(beanName); &#125; &#125; &#125; handlerMethodsInitialized(getHandlerMethods()); &#125; 3）String[] beanNames获取容器中的bean名称,然后对bean进行遍历 4）isHandler()方法 RequestMappingHandlerMapping类对父类AbstractHandlerMethodMapping\\&lt;T>类的实现 RequestMappingHandlerMapping——–&gt;isHandler 12345@Overrideprotected boolean isHandler(Class&lt;?&gt; beanType) &#123; return (AnnotatedElementUtils.hasAnnotation(beanType, Controller.class) || AnnotatedElementUtils.hasAnnotation(beanType, RequestMapping.class));&#125; 分析： ​ 判断该Bean是否属于Handler ​ 判断依据：是否有Controller注解 ，或者是否有RequestMapping注解 返回一个boolean类型 5）如果是一个Handler,则执行 ————- detectHandlerMethods(beanName) AbstractHandlerMethodMapping–&gt;detectHandlerMethods(beanName) 12345678910111213141516171819202122232425262728293031/** * Look for handler methods in a handler. * @param handler the bean name of a handler or a handler instance */ protected void detectHandlerMethods(final Object handler) &#123; Class&lt;?&gt; handlerType = (handler instanceof String ? obtainApplicationContext().getType((String) handler) : handler.getClass()); if (handlerType != null) &#123; final Class&lt;?&gt; userType = ClassUtils.getUserClass(handlerType); Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType, (MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123; try &#123; //获取映射方法 return getMappingForMethod(method, userType); &#125; catch (Throwable ex) &#123; throw new IllegalStateException(&quot;Invalid mapping on handler class [&quot; + userType.getName() + &quot;]: &quot; + method, ex); &#125; &#125;); if (logger.isDebugEnabled()) &#123; logger.debug(methods.size() + &quot; request handler methods found on &quot; + userType + &quot;: &quot; + methods); &#125; for (Map.Entry&lt;Method, T&gt; entry : methods.entrySet()) &#123; Method invocableMethod = AopUtils.selectInvocableMethod(entry.getKey(), userType); T mapping = entry.getValue(); registerHandlerMethod(handler, invocableMethod, mapping); &#125; &#125; &#125; 该方法检测Handler（一个Controller）中的方法并进行注册 该方法主要代码分析：（没有详细分析，下次分析） ​ 1）获取userType中的映射方法放入Map集合中 12345678910Map&lt;Method, T&gt; methods = MethodIntrospector.selectMethods(userType, (MethodIntrospector.MetadataLookup&lt;T&gt;) method -&gt; &#123; try &#123; return getMappingForMethod(method, userType); &#125; catch (Throwable ex) &#123; throw new IllegalStateException(&quot;Invalid mapping on handler class [&quot; + userType.getName() + &quot;]: &quot; + method, ex); &#125; &#125;); ​ ​ getMappingForMethod(method, userType)； //返回一个请求映射信息 ​ 1）userType为我们自定义的, 被@Controller注解所修饰的类.​ 2）method为 java.lang.reflect.Method 类型, 为我们所自定义的userType类型中的方法.​ 3）该getMappingForMethod方法也是抽象的, 交由RequestMappingHandlerMapping类来实现. 12345678910111213protected RequestMappingInfo getMappingForMethod(Method method, Class&lt;?&gt; handlerType) &#123; // 抽取该方法上注解的@RequestMapping RequestMappingInfo info = createRequestMappingInfo(method); if (info != null) &#123; // 抽取handlerType(即我们自定义的Controller类)上注解的@RequestMapping RequestMappingInfo typeInfo = createRequestMappingInfo(handlerType); if (typeInfo != null) &#123; // 合并两个RequestMapping的信息(controller路径+method) info = typeInfo.combine(info); &#125; &#125; return info; &#125; createRequestMappingInfo() 1234567891011121314151617protected RequestMappingInfo createRequestMappingInfo( RequestMapping requestMapping, @Nullable RequestCondition&lt;?&gt; customCondition) &#123; RequestMappingInfo.Builder builder = RequestMappingInfo /* 这里说明我们是可以在配置@RequestMapping时, 使用spel表达式的; 例如@RequestMapping(&quot;/yuyue/$&#123;url.mh&#125;/login&quot;) */ .paths(resolveEmbeddedValuesInPatterns(requestMapping.path())) .methods(requestMapping.method()) .params(requestMapping.params()) .headers(requestMapping.headers()) .consumes(requestMapping.consumes()) .produces(requestMapping.produces()) .mappingName(requestMapping.name()); if (customCondition != null) &#123; builder.customCondition(customCondition); &#125; return builder.options(this.config).build(); &#125; 2）注册获取到的映射方法 12345for (Map.Entry&lt;Method, T&gt; entry : methods.entrySet()) &#123; Method invocableMethod = AopUtils.selectInvocableMethod(entry.getKey(), userType); T mapping = entry.getValue(); registerHandlerMethod(handler, invocableMethod, mapping);&#125; registerHandlerMethod(handler, invocableMethod, mapping); ​ 1）andler为传入的bean name​ 2）method为 java.lang.reflect.Method 类型, 为我们所自定义的userType类型中的方法.​ 3）mappings.get(method)为我们使用getMappingForMethod 构造的RequestMappingInfo 实例 AbstractHandlerMethodMapping——-&gt;registerHandlerMethod() 123protected void registerHandlerMethod(Object handler, Method method, T mapping) &#123; this.mappingRegistry.register(mapping, handler, method); &#125; AbstractHandlerMethodMapping———&gt;register() 1234567891011121314151617181920212223242526272829303132333435public void register(T mapping, Object handler, Method method) &#123; this.readWriteLock.writeLock().lock(); try &#123; HandlerMethod handlerMethod = createHandlerMethod(handler, method); assertUniqueMethodMapping(handlerMethod, mapping); if (logger.isInfoEnabled()) &#123; logger.info(&quot;Mapped \\&quot;&quot; + mapping + &quot;\\&quot; onto &quot; + handlerMethod); &#125; //mappin与hanlderMethod映射 this.mappingLookup.put(mapping, handlerMethod); List&lt;String&gt; directUrls = getDirectUrls(mapping); for (String url : directUrls) &#123; //url与mapping映射 this.urlLookup.add(url, mapping); &#125; String name = null; if (getNamingStrategy() != null) &#123; name = getNamingStrategy().getName(handlerMethod, mapping); addMappingName(name, handlerMethod); &#125; CorsConfiguration corsConfig = initCorsConfiguration(handler, method, mapping); if (corsConfig != null) &#123; this.corsLookup.put(handlerMethod, corsConfig); &#125; this.registry.put(mapping, new MappingRegistration&lt;&gt;(mapping, handlerMethod, directUrls, name)); &#125; finally &#123; this.readWriteLock.writeLock().unlock(); &#125; &#125; //属性：private final Map&lt;T, HandlerMethod&gt; mappingLookup = new LinkedHashMap&lt;&gt;(); this.mappingLookup.put(mapping, handlerMethod); mapping:映射路径(例如：/login) handlerMethod: 包含了bean和方法信息 ​ 抽取出来RequestMappingInfo 信息 注册到 LinkedHashMap&lt;RequestMappingInfo,HandlerMethod&gt;类型的全局字段handlerMethods //属性：private final MultiValueMap&lt;String, T&gt; urlLookup = new LinkedMultiValueMap&lt;&gt;(); this.urlLookup.add(url, mapping); url:浏览器请求路径(例如：/login) mapping:映射方法路径(“例如: /login”) 将映射关系注册到urlLookup全局变量中 总结1)context:component-scan 默认是将所有@Component注解的类扫描进容器; ​ @Controller自身就是被@Component修饰的 2）mvc:annotation-driven的解析工作是由 AnnotationDrivenBeanDefinitionParser 类全权负责的。3）AnnotationDrivenBeanDefinitionParser会向SpringMVC容器中注册了 RequestMappingHandlerMapping (间接实现了HandlerMapping接口), order为04）查看RequestMappingHandlerMapping 类的继承链就会发现, 其祖先类 AbstractHandlerMethodMapping 实现了 InitializingBean5）而对InitializingBean的实现中, 会回调AbstractHandlerMethodMapping–&gt;initHandlerMethods()的实现，其中的isHandler()方法中有对@Controller,@RequestMapping注解的扫描 参考：https://blog.csdn.net/lqzkcx3/article/details/78159708","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Log日志的使用","slug":"Logging/Log日志的使用","date":"2020-04-15T07:20:03.000Z","updated":"2020-04-20T00:47:31.495Z","comments":true,"path":"2020/04/15/Logging/Log日志的使用/","link":"","permalink":"http://yoursite.com/2020/04/15/Logging/Log日志的使用/","excerpt":"","text":"Log的使用slf4j与commons-logging只是一个日志门面，实际还是要依赖真正的日志库log4j，虽然slf4j和commons-loggins自带了日志库，但是毕竟log4j才是最强大的。 commons-logging与Log4j为什么同时使用commons-logging和Log4j?为什么不仅使用其中之一？​ Commons-loggin的目的是为“所有的Java日志实现”提供一个统一的接口，它自身的日志功能平常弱（只有一个简单的SimpleLog?），所以一般不会单独使用它。Log4j的功能非常全面强大，是目前的首选。我发现几乎所有的Java开源项目都会用到Log4j，但我同时发现，所有用到Log4j的项目一般也同时会用到commons-loggin。我想，大家都不希望自己的项目与Log4j绑定的太紧密吧。另外一个我能想到的“同时使用commons-logging和Log4j”的原因是，简化使用和配置。 Commons-logging能帮我们做什么？​ 提供一个统一的日志接口，简单了操作，同时避免项目与某个日志实现系统紧密a耦合很贴心的帮我们自动选择适当的日志实现系统（这一点非常好！）它甚至不需要配置 这里看一下它怎么“‘很贴心的’帮我们‘自动选择’‘适当的’日志实现系统”：1) 首先在classpath下寻找自己的配置文件commons-logging.properties，如果找到，则使用其中定义的Log实现类； 2)如果找不到commons-logging.properties文件，则在查找是否已定义系统环境变量org.apache.commons.logging.Log，找到则使用其定义的Log实现类； 12建立一个叫 ：CATALINA_OPTS 的环境变量 给他的值 ： - Dorg.apache.commons.logging.Log = org.apache.commons.logging.impl.SimpleLog - Dorg.apache.commons.logging.simplelog.defaultlog = warn 3) 否则，查看classpath中是否有Log4j的包，如果发现，则自动使用Log4j作为日志实现类； 4) 否则，使用JDK自身的日志实现类（JDK1.4以后才有日志实现类）； 5) 否则，使用commons-logging自己提供的一个简单的日志实现类SimpleLog； 可见，commons-logging总是能找到一个日志实现类，并且尽可能找到一个“最合适”的日志实现类。我说它“很贴心”实际上是因为： 1、可以不需要配置文件；2、自动判断有没有Log4j包，有则自动使用之；3、最悲观的情况下也总能保证提供一个日志实现（SimpleLog）。 可以看到，commons-logging对编程者和Log4j都非常友好。 ​ 为了简化配置commons-logging，一般不使用commons-logging的配置文件，也不设置与commons-logging相关的系统环境变量，而只需将Log4j的Jar包放置到classpash中就可以了。这样就很简单地完成了commons-logging与Log4j的融合。如果不想用Log4j了怎么办？只需将classpath中的Log4j的Jar包删除即可。就这么简单！ 参考： https://www.cnblogs.com/tv151579/archive/2013/01/20/2868846.html Common-loggin说明​ 严格的说，commons-logging不是一个日志控件，没有日志功能，它只是统一了JDK Logging与Log4j的API，并把日志功能交给JDK Loggings或者是log4j。对于不能确定日志方式的系统，commons-logging是一个不错的选择，Spring，Hibernate，Struts等使用的都是commons-logging log4j和sfl4j和lobback到底有什么区别SLF4J：即简单日志门面（Simple Logging Facade for Java），不是具体的日志解决方案，它只服务于各种各样的日志系统。SLF4J是一个用于日志系统的简单Facade，允许最终用户在部署其应用时使用其所希望的日志系统(Log4j logback)。 在使用SLF4J的时候，不需要在代码中或配置文件中指定你打算使用那个具体的日志系统，SLF4J提供了统一的记录日志的接口，只要按照其提供的方法记录即可，最终日志的格式、记录级别、输出方式等通过具体日志系统的配置来实现，因此可以在应用中灵活切换日志系统。 log4j：没什么好说的，就是一个打日志，并且有日志系统 logback和log4j是非常相似的，Logback的内核重写了，在一些关键执行路径上性能提升10倍以上。而且logback不仅性能提升了，初始化内存加载也更小。说白了也是个日志系统，存储日志 原文链接：https://blog.csdn.net/u012954706/article/details/79572028 Spring自带的日志(JCL)JCL原理​ JCL，全称为”Jakarta Commons Logging”，也可称为”Apache Commons Logging”。 ​ JCL这个日志框架跟Log4J，Java Logging API等日志框架不同。JCL采用了设计模式中的“适配器模式”，它对外提供统一的接口，然后在适配类中将对日志的操作委托给具体的日志框架，比如Log4J,Java Logging API等。 在JCL中对外有两个统一的接口，分别是Log和LogFactory。 spring使用JCLLogging是spring中唯一强制的外部依赖，spring中默认使用的日志是commons-logging，简称JCL，这里说的强制性，是因为在spring-core这个模块中引入了该依赖。不过，引入了该依赖，也无需做任何其他的配置，它是`日志门面. spring-jcl-xxx.jar下的 org.apache.commons.logging包中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125/* * Copyright 2002-2017 the original author or authors. * * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); * you may not use this file except in compliance with the License. * You may obtain a copy of the License at * * http://www.apache.org/licenses/LICENSE-2.0 * * Unless required by applicable law or agreed to in writing, software * distributed under the License is distributed on an &quot;AS IS&quot; BASIS, * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. * See the License for the specific language governing permissions and * limitations under the License. */package org.apache.commons.logging;import java.io.Serializable;import java.util.logging.LogRecord;import org.apache.logging.log4j.Level;import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.spi.ExtendedLogger;import org.apache.logging.log4j.spi.LoggerContext;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.slf4j.spi.LocationAwareLogger;/** * A minimal incarnation of Apache Commons Logging&apos;s &#123;@code LogFactory&#125; API, * providing just the common &#123;@link Log&#125; lookup methods. This is inspired * by the JCL-over-SLF4J bridge and should be source as well as binary * compatible with all common use of the Commons Logging API (in particular: * with &#123;@code LogFactory.getLog(Class/String)&#125; field initializers). * * &lt;p&gt;This implementation does not support Commons Logging&apos;s original provider * detection. It rather only checks for the presence of the Log4j 2.x API * and the SLF4J 1.7 API in the Spring Framework classpath, falling back to * &#123;@code java.util.logging&#125; if none of the two is available. In that sense, * it works as a replacement for the Log4j 2 Commons Logging bridge as well as * the JCL-over-SLF4J bridge, both of which become irrelevant for Spring-based * setups as a consequence (with no need for manual excludes of the standard * Commons Logging API jar anymore either). Furthermore, for simple setups * without an external logging provider, Spring does not require any extra jar * on the classpath anymore since this embedded log factory automatically * delegates to &#123;@code java.util.logging&#125; in such a scenario. * * &lt;p&gt;&lt;b&gt;Note that this Commons Logging variant is only meant to be used for * infrastructure logging purposes in the core framework and in extensions.&lt;/b&gt; * It also serves as a common bridge for third-party libraries using the * Commons Logging API, e.g. Apache HttpClient, Castor and HtmlUnit, bringing * them into the same consistent arrangement without any extra bridge jars. * * &lt;p&gt;&lt;b&gt;For logging need in application code, prefer direct use of Log4j 2.x * or SLF4J or &#123;@code java.util.logging&#125;.&lt;/b&gt; Simply put Log4j 2.x or Logback * (or another SLF4J provider) onto your classpath, without any extra bridges, * and let the framework auto-adapt to your choice. * * @author Juergen Hoeller (for the &#123;@code spring-jcl&#125; variant) * @since 5.0 */public abstract class LogFactory &#123; private static LogApi logApi = LogApi.JUL; static &#123; ClassLoader cl = LogFactory.class.getClassLoader(); try &#123; // Try Log4j 2.x API cl.loadClass(&quot;org.apache.logging.log4j.spi.ExtendedLogger&quot;); logApi = LogApi.LOG4J; &#125; catch (ClassNotFoundException ex1) &#123; try &#123; // Try SLF4J 1.7 SPI cl.loadClass(&quot;org.slf4j.spi.LocationAwareLogger&quot;); logApi = LogApi.SLF4J_LAL; &#125; catch (ClassNotFoundException ex2) &#123; try &#123; // Try SLF4J 1.7 API cl.loadClass(&quot;org.slf4j.Logger&quot;); logApi = LogApi.SLF4J; &#125; catch (ClassNotFoundException ex3) &#123; // Keep java.util.logging as default &#125; &#125; &#125; &#125; /** * Convenience method to return a named logger. * @param clazz containing Class from which a log name will be derived */ public static Log getLog(Class&lt;?&gt; clazz) &#123; return getLog(clazz.getName()); &#125; /** * Convenience method to return a named logger. * @param name logical name of the &lt;code&gt;Log&lt;/code&gt; instance to be returned */ public static Log getLog(String name) &#123; switch (logApi) &#123; case LOG4J: return Log4jDelegate.createLog(name); case SLF4J_LAL: return Slf4jDelegate.createLocationAwareLog(name); case SLF4J: return Slf4jDelegate.createLog(name); default: // Defensively use lazy-initializing delegate class here as well since the // java.logging module is not present by default on JDK 9. We are requiring // its presence if neither Log4j nor SLF4J is available; however, in the // case of Log4j or SLF4J, we are trying to prevent early initialization // of the JavaUtilLog adapter - e.g. by a JVM in debug mode - when eagerly // trying to parse the bytecode for all the cases of this switch clause. return JavaUtilDelegate.createLog(name); &#125; &#125; ........ 通过尝试加载log4j,slf4j等日志来创建Log接口的实现类","categories":[{"name":"Logging","slug":"Logging","permalink":"http://yoursite.com/categories/Logging/"}],"tags":[{"name":"log","slug":"log","permalink":"http://yoursite.com/tags/log/"}]},{"title":"设计模式简介","slug":"Design Pattern/设计模式参考简介","date":"2020-04-13T11:41:09.000Z","updated":"2020-04-13T11:52:37.434Z","comments":true,"path":"2020/04/13/Design Pattern/设计模式参考简介/","link":"","permalink":"http://yoursite.com/2020/04/13/Design Pattern/设计模式参考简介/","excerpt":"","text":"设计模式简介​ 设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。 ​ 设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。 设计模式的类型​ 根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式 - 可复用的面向对象软件元素） 中所提到的，总共有 23 种设计模式。这些模式可以分为三大类：创建型模式（Creational Patterns）、结构型模式（Structural Patterns）、行为型模式（Behavioral Patterns）。当然，我们还会讨论另一类设计模式：J2EE 设计模式。 序号 模式 &amp; 描述 包括 1 创建型模式 这些设计模式提供了一种在创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。 工厂模式（Factory Pattern）抽象工厂模式（Abstract Factory Pattern）单例模式（Singleton Pattern）建造者模式（Builder Pattern）原型模式（Prototype Pattern） 2 结构型模式 这些设计模式关注类和对象的组合。继承的概念被用来组合接口和定义组合对象获得新功能的方式。 适配器模式（Adapter Pattern）桥接模式（Bridge Pattern）过滤器模式（Filter、Criteria Pattern）组合模式（Composite Pattern）装饰器模式（Decorator Pattern）外观模式（Facade Pattern）享元模式（Flyweight Pattern）代理模式（Proxy Pattern） 3 行为型模式 这些设计模式特别关注对象之间的通信。 责任链模式（Chain of Responsibility Pattern）命令模式（Command Pattern）解释器模式（Interpreter Pattern）迭代器模式（Iterator Pattern）中介者模式（Mediator Pattern）备忘录模式（Memento Pattern）观察者模式（Observer Pattern）状态模式（State Pattern）空对象模式（Null Object Pattern）策略模式（Strategy Pattern）模板模式（Template Pattern）访问者模式（Visitor Pattern） 4 J2EE 模式 这些设计模式特别关注表示层。这些模式是由 Sun Java Center 鉴定的。 MVC 模式（MVC Pattern）业务代表模式（Business Delegate Pattern）组合实体模式（Composite Entity Pattern）数据访问对象模式（Data Access Object Pattern）前端控制器模式（Front Controller Pattern）拦截过滤器模式（Intercepting Filter Pattern）服务定位器模式（Service Locator Pattern）传输对象模式（Transfer Object Pattern） 设计模式的六大原则1、开闭原则（Open Close Principle） 开闭原则的意思是：对扩展开放，对修改关闭。在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。想要达到这样的效果，我们需要使用接口和抽象类，后面的具体设计中我们会提到这点。 2、里氏代换原则（Liskov Substitution Principle） 里氏代换原则是面向对象设计的基本原则之一。 里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。 3、依赖倒转原则（Dependence Inversion Principle） 这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。 4、接口隔离原则（Interface Segregation Principle） 这个原则的意思是：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。 5、迪米特法则，又称最少知道原则（Demeter Principle） 最少知道原则是指：一个实体应当尽量少地与其他实体之间发生相互作用，使得系统功能模块相对独立。 6、合成复用原则（Composite Reuse Principle） 合成复用原则是指：尽量使用合成/聚合的方式，而不是使用继承。 学习网站 https://www.runoob.com/design-pattern/design-pattern-tutorial.html","categories":[{"name":"designPattern","slug":"designPattern","permalink":"http://yoursite.com/categories/designPattern/"}],"tags":[{"name":"data","slug":"data","permalink":"http://yoursite.com/tags/data/"}]},{"title":"IDEA快捷键","slug":"Tools/IDEA快捷键","date":"2020-04-11T15:09:08.000Z","updated":"2020-06-07T07:44:48.947Z","comments":true,"path":"2020/04/11/Tools/IDEA快捷键/","link":"","permalink":"http://yoursite.com/2020/04/11/Tools/IDEA快捷键/","excerpt":"","text":"IDEA常用快捷键Codingcrtl + f9 build Project alt + 7 查看类中的方法 crtl + H 接口，类继承结构 ctrl + shfit +f12 窗口最大化 crtl + alt + T 快速surround with，异常处理 Ctrl + X 剪切一行 ##Crtl + shift + y 删除一行 crtl + D 复制一行 crtl + Y redo 重做 crtl + Z undo 撤销 crtl + I 实现接口方法 crtl + O 重写方法 Shift+Enter 向下插入新行 Alt+left/right 切换代码视图Alt+Up/Down 在方法间快速移动定位Ctrl+P 可以显示参数信息 Ctrl+Alt+O 优化导入的类和包(可以在设置中设置自动导入和优化) Crtl + B 查看声明 Crtl + alt + B 查看实现 shift + shift 查找全部文件 （ ​ crtl + N classes ​ ctrl+shift+n files ​ ctrl+shift+alt+n symbols ​ ctrl+shift+A actions ） alt + insert generate生成 crtl + alt + t surround with(try catch，if, while……) crtl + shift + o Load Maven Changes ctrl+shift+enter 收尾(结尾分号，if大括号等) alt+F1 弹出Select in视图，然后选择Project View中的Project，回车，就可以立刻定位到类的位置 crtl + E 最近的文件 crtl + shift + space 手动提示(suggestions) { ​ ctrl + r: 当前文件内容替换，指的是在当前打开的文件中替换匹配的字符，只操作一个文件。 ​ ctrl + shift + r: 在路径中替换，指的是在选定的目录下或者类包下 ​ 使用说明：查找要被替换的字符，再在第二个输入框中输入要替换的字符，点击弹出框的右下角的replace或者 replaceall即可。 } Conf Ctrl+Shift+Alt+/ Maintenance（Idea的一些配置) pluginsTranslation（翻译）​ crtl + shift + Y 翻译","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/tags/tools/"}]},{"title":"servlet3.0","slug":"Java Web/servlet3.0","date":"2020-04-06T05:54:03.000Z","updated":"2020-04-06T07:33:13.181Z","comments":true,"path":"2020/04/06/Java Web/servlet3.0/","link":"","permalink":"http://yoursite.com/2020/04/06/Java Web/servlet3.0/","excerpt":"","text":"Servlet3.0​ 在Servlet3.0协议规范中 ​ 1）包含在JAR文件/META-INFO/resources/路径下的资源可以直接访问(就像在webapp目录下一样)， ​ 2）但是注意：该路径下建立的WEB-INF目录不可以被直接访问，和webapp目录下一样","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"servlet","slug":"servlet","permalink":"http://yoursite.com/tags/servlet/"}]},{"title":"SpringBoot不推荐使用jsp","slug":"SpringBoot/SpringBoot不推荐jsp","date":"2020-04-05T13:08:59.000Z","updated":"2020-04-05T13:16:55.772Z","comments":true,"path":"2020/04/05/SpringBoot/SpringBoot不推荐jsp/","link":"","permalink":"http://yoursite.com/2020/04/05/SpringBoot/SpringBoot不推荐jsp/","excerpt":"","text":"关于Springboot不推荐使用Jsp的讨论springboot不推荐使用jsp，如果使用了jsp会失去一些springboot的特性，这是为什么呢？jsp和其他模板引擎FreeMarker，thymeleaf有什么区别呢？ 回答1原因简单，就因为它叫 JSP (Java Server Page) Java社区的领导者JCP 制定JSP规则就是专门为了给 JavaServer 用的， 所以 JSP 的定义里就指定了它是运行在容器里的. 里面最最重要的就是第一条. (使用jsp的项目 部署时) 把war包放到 tomcat或者其他 java 容器；或者用 java -jar 启一个可执行的 war包 时 是可以正常工作的， 但 直接执行 jar包是不支持的。 也就是说打包方式不一样同样的代码运行结果就是不一样： “java -jar app.jar” 不可以解析jsp“java -jar app.war” 正常解析 剩余几个限制也多少都是因为jsp的规范/法律层面上的原因联锁引起的，或者导致开发者修复/额外考虑的兴致不大。 至于从技术层面的开发使用上 用 JSP当模板 和 用其他模板引擎支持的文件没有任何本质的区别。 差别仅存在于开发书写效率和程序解析运行效率。 比如 jsp 和 freemarker 的解析执行效率都是很高的， 而thymeleaf的书写效率高并且与前端模板语法很相似，学习成本很低。 回答2springboot 是内嵌web容器的，推荐打成jar包不是war包 你如果想使用jsp也可以啊，自建WEB-INF web.xml 然后像往常一样使用jsp 打成war包使用外部容器即可，这就相当于失去了一些springboot的特性了 至于模板引擎其实都差不多，jsp也可以算是模板引擎，springboot推荐的thymeleaf主要嵌入到html的标签属性，这样对前端很友好，有一些优点，但和jsp，FreeMarker比起来也没什么绝对性的优势。 现在web前端技术飞一样的发展，前后端分离才是主流，模板引擎说白了还是给后端人员用的东西，早就不符合现代的前端思想了，而且和React、Vue这类的前端框架比起来又是连提鞋都不配，所以放弃这些模板引擎改用RestController吧。 springboot官方说明jsp限制https://docs.spring.io/spring-boot/docs/2.1.1.RELEASE/reference/htmlsingle/#boot-features-jsp-limitations 官方： 28.4.5 JSP Limitations When running a Spring Boot application that uses an embedded servlet container (and is packaged as an executable archive), there are some limitations in the JSP support. With Jetty and Tomcat, it should work if you use war packaging. An executable war will work when launched with java -jar, and will also be deployable to any standard container. JSPs are not supported when using an executable jar. Undertow does not support JSPs. Creating a custom error.jsp page does not override the default view for error handling. Custom error pages should be used instead. There is a JSP sample so that you can see how to set things up. 翻译：28.4.5 JSP的局限性 在运行使用嵌入式servlet容器(并打包为可执行归档文件)的Spring引导应用程序时，JSP支持存在一些限制。 对于Jetty和Tomcat，如果使用war打包，它应该可以工作。一个可执行的war在使用java -jar启动时可以工作，并且也可以部署到任何标准容器中。使用可执行jar时不支持jsp。 Undertow不支持jsp。 创建自定义error.jsp页面不会覆盖用于错误处理的默认视图。应该使用自定义错误页面。 这里有一个JSP示例，以便您了解如何进行设置。","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"事务的隔离级别和传播机制","slug":"DataBase/Transaction/事务的隔离级别和传播机制","date":"2020-04-04T08:15:01.000Z","updated":"2020-04-04T13:22:32.422Z","comments":true,"path":"2020/04/04/DataBase/Transaction/事务的隔离级别和传播机制/","link":"","permalink":"http://yoursite.com/2020/04/04/DataBase/Transaction/事务的隔离级别和传播机制/","excerpt":"","text":"事务什么是事务？​ 要么全部都要执行，要么就都不执行。 事务所具有的四种特性原子性 （Atimicty）​ 个人理解，就是事务执行不可分割，要么全部完成，要么全部拉倒不干。 一致性（Consistency）​ 关于一致性这个概念我们来举个例子说明吧，假设张三给李四转了100元，那么需要先从张三那边扣除100，然后李四那边增加100，这个转账的过程对于其他事务而言是无法看到的，这种状态始终都在保持一致，这个过程我们称之为一致性。 隔离性（Isolation）​ 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据是独立的； 持久性（Durability）​ 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。 事务并发问题脏读： 事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。幻读： 用户A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是用户B就在这个时候插入了一条具体分数的记录，当修改A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。（一个事务读到另一个事务已提交的insert数据） 概念： 12345678脏读: 指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据， 那么另外一 个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。不可重复读: 指在一个事务内，多次读同一数据。在这个事务还没有结束时，另外一个事务也访问该同一数据。 那么，在第一个事务中的两次读数据之间，由于第二个事务的修改，那么第一个事务两次读到的数据可能是不一样的。这样就发生了在一个事务内两次读到的数据是不一样的，因此称为是不可重复读。幻觉读:理解1：指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及 到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，就会发生操作第一个事务的用户发现表中还有 没有修改的数据行,也就是说幻像读是指同一查询在同一事务中多次进行，由于其他提交事务所做的插入操作，每次返回不同的结果集，此时发生幻像读,就好象发生了幻觉一样。理解2：幻读是事务非独立执行时发生的一种现象。例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项，而这个数据项的数值还是为“1”并且提交给数据库。而操作事务T1的用户如果再查看刚刚修改的数据，会发现还有一行没有修改，其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。幻读和不可重复读都是读取了另一条已经提交的事务(这点就脏读不同)，所不同的是不可重复读可能发生在update,delete操作中，而幻读发生在insert操作中。 小结：不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表 思考：mysql的不可重复读解决了幻读？https://www.cnblogs.com/liyus/p/10556563.html 事务隔离级别事务隔离级别 脏读 不可重复读 幻读读未提交（read-uncommitted） 是 是 是读已提交（read-committed） 否 是 是可重复读（repeatable-read） 否 否 是串行化（serializable） 否 否 否 MYSQL: 默认为REPEATABLE_READ级别SQLSERVER: 默认为READ_COMMITTED Spring对事务的处理编程式事务和声明式事务编程式事务需要你在代码中直接加入处理事务的逻辑,可能需要在代码中显式调用beginTransaction()、commit()、rollback()等事务管理相关的方法,如在执行a方法时候需要事务处理,你需要在a方法开始时候开启事务,处理完后。在方法结束时候,关闭事务. ​ 声明式的事务的做法是在a方法外围添加注解或者直接在配置文件中定义,a方法需要事务处理,在spring中会通过配置文件在a方法前后拦截,并添加事务. ​ 二者区别.编程式事务侵入性比较强，但处理粒度更细. 声明式事务：通过AOP（面向切面）方式在方法前使用编程式事务的方法开启事务，在方法后提交或回滚。用配置文件的方法或注解方法（如：@Transactional）控制事务。 编程式事务：手动开启、提交、回滚事务。 spring在事务方面进行了各种操作的封装，特别是声明式事务的出现，让开发变得更加的舒心. spring事务定义及状态描述从事务管理器PlatformTransactionManager中可以看出，spring完成事务管理还需2个关键元素：事务定义TransactionDefinition及事务状态TransactionStatus描述。 事务定义 1234567public interface TransactionDefinition &#123; int getPropagationBehavior(); //传播行为，默认PROPAGATION_REQUIRED int getIsolationLevel(); //隔离级别，默认数据库默认级别，如mysql为可重复读 int getTimeout(); boolean isReadOnly(); //是否只读，查询操作可以设置为true String getName();&#125; 事务状态 12345678public interface TransactionStatus extends SavepointManager &#123; boolean isNewTransaction(); //是否新事务 boolean hasSavepoint(); //是否有恢复点 void setRollbackOnly(); boolean isRollbackOnly(); void flush(); //Flush the underlying session to the datastore, if applicable: for example, all affected Hibernate/JPA sessions. boolean isCompleted();&#125; 什么是事务的传播行为​ Spring在TransactionDefinition接口中规定了7种类型的事务传播行为。事务传播行为是Spring框架独有的事务增强特性，他不属于的事务实际提供方数据库行为。这是Spring为我们提供的强大的工具箱，使用事务传播行可以为我们的开发工作提供许多便利。但是人们对他的误解也颇多，你一定也听过“service方法事务最好不要嵌套”的传言。要想正确的使用工具首先需要了解工具。 什么是事务传播行为？ 事务传播行为用来描述由某一个事务传播行为修饰的方法被嵌套进另一个方法的时事务如何传播。 事务的传播行为1）PROPAGATION_REQUIRED ​ 说明： 如果当前已经存在事务，那么加入该事务，如果不存在事务，创建一个事务，这是默认的传播属性值。 2）PROPAGATION_SUPPORTS ​ 说明: 如果当前已经存在事务，那么加入该事务，否则创建一个所谓的空事务（可以认为无事务执行）。 3) PROPAGATION_MANDATORY 说明：当前必须存在一个事务，否则抛出异常。 4)PROPAGATN_REQUIRES_NEW 说明：如果当前存在事务，先把当前事务相关内容封装到一个实体，然后重新创建一个新事务，接受这个实体为参数，用于事务的恢复。更直白的说法就是暂停当前事务(当前无事务则不需要)，创建一个新事务。 针对这种情况，两个事务没有依赖关系，可以实现新事务回滚了，但外部事务继续执行。 5)Propagation.NOT_SUPPORTED 说明：如果当前存在事务，挂起当前事务，然后新的方法在没有事务的环境中执行，没有spring事务的环境下，sql的提交完全依赖于 defaultAutoCommit属性值 。 6) PROPAGATION_NEVER 说明： 如果当前存在事务，则抛出异常，否则在无事务环境上执行代码。 7）PROPAGATION_NESTED 说明： 如果当前存在事务，则使用 SavePoint 技术把当前事务状态进行保存，然后底层共用一个连接，当NESTED内部出错的时候，自行回滚到 SavePoint这个状态，只要外部捕获到了异常，就可以继续进行外部的事务提交，而不会受到内嵌业务的干扰，但是，如果外部事务抛出了异常，整个大事务都会回滚。 ​ 注意： spring配置事务管理器要主动指定 nestedTransactionAllowed=true，如下所示： 12345&lt;bean id=&quot;dataTransactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataDataSource&quot; /&gt; &lt;property name=&quot;nestedTransactionAllowed&quot; value=&quot;true&quot; /&gt; &lt;/bean&gt; 例子： ​ 1234567891011121314151617@Transactionalpublic void service()&#123; serviceA(); try&#123; serviceB(); &#125;catch(Exception e)&#123; &#125;&#125;serviceA()&#123; do sql&#125;@Transactional(propagation=Propagation.NESTED)serviceB()&#123; do sql1 1/0; do sql2&#125; serviceB是一个内嵌的业务，内部抛出了运行时异常，所以serviceB整个被回滚了，由于service捕获了异常，所以serviceA是可以正常提交的。 12345678910111213@Transactionalpublic void service()&#123; serviceA(); serviceB(); 1/0;&#125;@Transactional(propagation=Propagation.NESTED)serviceA()&#123; do sql&#125;serviceB()&#123; do sql&#125; 由于service抛出了异常，所以会导致整个service方法被回滚。（这就是跟PROPAGATION_REQUIRES_NEW不一样的地方了，NESTED方式下的内嵌业务会受到外部事务的异常而回滚。） 实现原理浅析​ 前面举例说明了spring事务提供的几种传播属性，用于满足多种不同的业务需求，大家可以依业务而定。接着我们再来看看spring实现这些传播属性最重要的技术依赖是什么。本小节列举 PROPAGATION_REQUIRES_NEW 和 Propagation.NESTED 分别进行简要说明。 ​ 1、 PROPAGATION_REQUIRES_NEW 实现原理 123456789101112131415161718@Transactionalpublic void service()&#123; serviceB(); try&#123; serviceA(); &#125;catch(Exception e)&#123; &#125;&#125;@Transactional(propagation=Propagation.REQUIRES_NEW)serviceA()&#123; do sql 1 1/0; do sql 2&#125;serviceB()&#123; do sql&#125; ​ 执行原理图如下 ​ 12345678910111213before service,执行a和b​ 执行serviceB​ before serviceA, 执行c和d​ 执行serviceA​ 抛出异常​ after serviceA, 执行e​ after service,执行f a. 创建事务状态对象，获取一个新的连接，重置连接的 autoCommit，fetchSize，timeout等属性 b. 把连接绑定到ThreadLocal变量 c. 挂起当前事务，把当前事务状态对象，连接等信息封装成一SuspendedResources对象，可用于恢复 d. 创建新的事务状态对象，重新获取新的连接，重置新连接的 autoCommit，fetchSize，timeout等属性，同时，保存SuspendedResources对象，用于事务的恢复，把新的连接绑定到ThreadLocal变量（覆盖操作） e. 捕获到异常，回滚ThreadLocal中的连接，恢复连接参数，关闭连接，恢复SuspendedResources f. 提交ThreadLocal变量中的连接(导致serviceB被提交)，还原连接参数，关闭连接，连接归还数据源 所以程序执行的结果就是 serviceA被回滚了，serviceB成功提交了。 2、 PROPAGATION_NESTED 实现原理 1234567891011121314151617@Transactionalpublic void service()&#123; serviceA(); try&#123; serviceB(); &#125;catch(Exception e)&#123; &#125;&#125;serviceA()&#123; do sql&#125;@Transactional(propagation=Propagation.NESTED)serviceB()&#123; do sql1 1/0; do sql2&#125; 执行原理图如下： a. 创建事务状态对象，获取一个新的连接，重置连接的 autoCommit，fetchSize，timeout等属性 b. 把连接绑定到ThreadLocal变量 c. 标记使用当前事务状态对象，获取ThreadLocal连接对象，保存当前连接的SavePoint，用于异常恢复，此时的SavePoint就是执行完serviceA后的状态 d. 捕获到异常，使用c中的SavePoint进行事务回滚，也就是把状态回滚到执行serviceA后的状态，serviceB方法所有执行不生效 e. 获取ThreadLocal中的连接对象，提交事务，恢复连接属性，关闭连接 其他: ​ spring在底层数据源的基础上，利用 ThreadLocal，SavePoint等技术点实现了多种事务传播属性，便于实现各种复杂的业务。只有理解了传播属性的原理才能更好的驾驭spring事务。Spring回滚事务依赖于对异常的捕获，默认情况下，只有抛出RuntimeException和Error才会回滚事务，当然可以进行配置，更多信息可以查看 @Transactional 这个注解。 Spring事务的几个传播机制先假设A是大方法，B是小方法 ​ required，A没有事务时调用B方法（B的事务隔离级别是required），B就会开启自己单独的事务，B要回滚的话，也是回滚B。A有事务时，B就加入到A这个事务（B不开启自己的事务了），这里发生回滚的话，AB的事务就都被回滚了。 ​ new ， A没有事务时调用B方法（B的事务隔离级别是new），B就会开启自己单独的事务，B要回滚的话，也是回滚B。A有事务时，B还是会开启自己的事务，B事务发生回滚时，AB事务都会一起回滚，但是当执行了B事务时,A事务时挂起的，当执行完B事务且commit成功后，B事务结束，A事务恢复，若此时A事务发生回滚，那只是A事务回滚，不影响B事务的提交了。 ​ nested，A没有事务调用B方法时（B的事务隔离级别是nested），此时就相当于是required了。A有事务时，B事务也开启，但B事务此时是相当于A事务的嵌套子事务，B事务发生回滚时，会回到B事务开启执行时的savepoint（保存点），此时B事务已经结束了，然后继续从B事务开始时的保存点开始，继续A事务。如果期间B事务没回滚，那B事务的提交也是要和A事务一起提交，而且此时B事务没回滚执行完之后，但A事务出现回滚，AB事务就没法提交，那就都回滚了（这就是嵌套子事务的概念吧？） require回滚整个事务，nested回滚到创建回滚点的地方 参考：https://www.cnblogs.com/tartis/p/9232660.html ​ https://blog.csdn.net/f45056231p/article/details/83510291 ​ https://blog.csdn.net/chuangxin/article/details/80921704 只读事务的概念​ 从这一点设置的时间点开始（时间点a）到这个事务结束的过程中，其他事务所提交的数据，该事务将看不见！（查询中不会出现别人在时间点a之后提交的数据） 应用场合： ​ 如果你一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持SQL执行期间的读一致性；​ 如果你一次执行多条查询语句，例如统计查询，报表查询，在这种场景下，多条查询SQL必须保证整体的读一致性，否则，在前条SQL查询之后，后条SQL查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时，应该启用事务支持。【注意是一次执行多次查询来统计某些信息，这时为了保证数据整体的一致性，要用只读事务】 怎样设置： 对于只读查询，可以指定事务类型为readonly，即只读事务。由于只读事务不存在数据的修改，因此数据库将会为只读事务提供一些优化手段，例如Oracle对于只读事务，不启动回滚段，不记录回滚log。 （1）在JDBC中，指定只读事务的办法为： connection.setReadOnly(true); （2）在Hibernate中，指定只读事务的办法为： session.setFlushMode(FlushMode.NEVER);此时，Hibernate也会为只读事务提供Session方面的一些优化手段 （3）在Spring的Hibernate封装中，指定只读事务的办法为： bean配置文件中，prop属性增加“readOnly”或者用注解方式@Transactional(readOnly=true)【 if the transaction is marked as read-only, Spring will set the Hibernate Session’s flush mode to FLUSH_NEVER,and will set the JDBC transaction to read-only】也就是说在Spring中设置只读事务是利用上面两种方式 在将事务设置成只读后，相当于将数据库设置成只读数据库，此时若要进行写的操作，会出现错误 参考：https://blog.csdn.net/andyzhaojianhui/article/details/51984157","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"Transaction","slug":"Transaction","permalink":"http://yoursite.com/tags/Transaction/"}]},{"title":"Springmvc视图解析与渲染","slug":"Spring/springmvc视图解析与渲染","date":"2020-03-26T07:45:59.000Z","updated":"2020-04-05T07:50:44.433Z","comments":true,"path":"2020/03/26/Spring/springmvc视图解析与渲染/","link":"","permalink":"http://yoursite.com/2020/03/26/Spring/springmvc视图解析与渲染/","excerpt":"","text":"springmvc视图解析与渲染springmvc处理步骤具体步骤： 第一步：发起请求到前端控制器(DispatcherServlet) 第二步：前端控制器请求HandlerMapping查找 Handler （可以根据xml配置、注解进行查找） 第三步：处理器映射器HandlerMapping向前端控制器返回Handler，HandlerMapping会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象，多个HandlerInterceptor拦截器对象），通过这种策略模式，很容易添加新的映射策略 第四步：前端控制器调用处理器适配器去执行Handler 第五步：处理器适配器HandlerAdapter将会根据适配的结果去执行Handler 第六步：Handler执行完成给适配器返回ModelAndView 第七步：处理器适配器向前端控制器返回ModelAndView （ModelAndView是springmvc框架的一个底层对象，包括 Model和view） 第八步：前端控制器请求视图解析器去进行视图解析 （根据逻辑视图名解析成真正的视图(jsp)），通过这种策略很容易更换其他视图技术，只需要更改视图解析器即可 第九步：视图解析器向前端控制器返回View 第十步：前端控制器进行视图渲染 （视图渲染将模型数据(在ModelAndView对象中)填充到request域） 第十一步：前端控制器向用户响应结果 视图解析与渲染(render方法)org.springframework.web.servlet.DispatcherServlet#doDispatch方法中 12mv = ha.handle(processedRequest, response, mappedHandler.getHandler());//945行返回了 ModelAndView 对象processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);// 959行进行的就是返回值处理问题 org.springframework.web.servlet.DispatcherServlet#processDispatchResult方法中 1render(mv, request, response); //1012进行视图的渲染（包含视图解析） org.springframework.web.servlet.DispatcherServlet#render 方法 12345678910111213141516171819202122232425262728293031323334353637383940414243protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; // Determine locale for request and apply it to the response. Locale locale = (this.localeResolver != null ? this.localeResolver.resolveLocale(request) : request.getLocale()); response.setLocale(locale); View view; String viewName = mv.getViewName(); if (viewName != null) &#123; // We need to resolve the view name. view = resolveViewName(viewName, mv.getModelInternal(), locale, request); if (view == null) &#123; throw new ServletException(&quot;Could not resolve view with name &apos;&quot; + mv.getViewName() + &quot;&apos; in servlet with name &apos;&quot; + getServletName() + &quot;&apos;&quot;); &#125; &#125; else &#123; // No need to lookup: the ModelAndView object contains the actual View object. view = mv.getView(); if (view == null) &#123; throw new ServletException(&quot;ModelAndView [&quot; + mv + &quot;] neither contains a view name nor a &quot; + &quot;View object in servlet with name &apos;&quot; + getServletName() + &quot;&apos;&quot;); &#125; &#125; // Delegate to the View object for rendering. if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Rendering view [&quot; + view + &quot;] in DispatcherServlet with name &apos;&quot; + getServletName() + &quot;&apos;&quot;); &#125; try &#123; if (mv.getStatus() != null) &#123; response.setStatus(mv.getStatus().value()); &#125; view.render(mv.getModelInternal(), request, response); &#125; catch (Exception ex) &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Error rendering view [&quot; + view + &quot;] in DispatcherServlet with name &apos;&quot; + getServletName() + &quot;&apos;&quot;, ex); &#125; throw ex; &#125; &#125; view = resolveViewName(viewName, mv.getModelInternal(), locale, request);视图解析，返回视图view view.render(mv.getModelInternal(), request, response); 视图渲染 视图解析：通过视图解析器进行视图的解析1.解析一个视图名到一个视图对象，具体解析的过程是：在容器中查找所有配置好的视图解析器（List类型），然后进行遍历， 只要有一个视图解析器能解析出视图就返回 View 对象，若遍历完成后都不能解析出视图，那么返回 null。 具体来看： org.springframework.web.servlet.DispatcherServlet#resolveViewName 12345678910111213protected View resolveViewName(String viewName, @Nullable Map&lt;String, Object&gt; model, Locale locale, HttpServletRequest request) throws Exception &#123; if (this.viewResolvers != null) &#123; for (ViewResolver viewResolver : this.viewResolvers) &#123; View view = viewResolver.resolveViewName(viewName, locale); if (view != null) &#123; return view; &#125; &#125; &#125; return null; &#125; 解析一个视图名到一个视图对象，具体解析的过程是：在容器中查找所有配置好的视图解析器（List类型），然后进行遍历，只要有一个视图解析器能解析出视图就返回 View 对象，若遍历完成后都不能解析出视图，那么返回 null。 创建视图，以 InternalResourceViewResolver为例，继承UrlBasedViewResolver org.springframework.web.servlet.view.UrlBasedViewResolver#createView 12345678910111213141516171819202122232425@Override protected View createView(String viewName, Locale locale) throws Exception &#123; // If this resolver is not supposed to handle the given view, // return null to pass on to the next resolver in the chain. if (!canHandle(viewName, locale)) &#123; return null; &#125; // Check for special &quot;redirect:&quot; prefix. if (viewName.startsWith(REDIRECT_URL_PREFIX)) &#123; String redirectUrl = viewName.substring(REDIRECT_URL_PREFIX.length()); RedirectView view = new RedirectView(redirectUrl, isRedirectContextRelative(), isRedirectHttp10Compatible()); String[] hosts = getRedirectHosts(); if (hosts != null) &#123; view.setHosts(hosts); &#125; return applyLifecycleMethods(viewName, view); &#125; // Check for special &quot;forward:&quot; prefix. if (viewName.startsWith(FORWARD_URL_PREFIX)) &#123; String forwardUrl = viewName.substring(FORWARD_URL_PREFIX.length()); return new InternalResourceView(forwardUrl); &#125; // Else fall back to superclass implementation: calling loadView. return super.createView(viewName, locale); &#125; 在创建视图前会检查返回值是否是以：”redirect:” 或 “forward:” 开头的。 如果是重定向：则创建一个重定向视图，返回创建的视图。如果是转发：则返回通过 转发 url 创建的 InternalResourceView 视图。 super.createView(viewName, locale),调用父类创建视图 org.springframework.web.servlet.view.UrlBasedViewResolver#loadView 123protected View createView(String viewName, Locale locale) throws Exception &#123; return loadView(viewName, locale);&#125; 调用具体的 InternalResourceViewResolver ，然后又调用 父类的 buildView() 方法 org.springframework.web.servlet.view.UrlBasedViewResolver#buildView 123456789101112131415161718192021222324252627282930protected AbstractUrlBasedView buildView(String viewName) throws Exception &#123; Class&lt;?&gt; viewClass = getViewClass(); Assert.state(viewClass != null, &quot;No view class&quot;); AbstractUrlBasedView view = (AbstractUrlBasedView) BeanUtils.instantiateClass(viewClass); view.setUrl(getPrefix() + viewName + getSuffix()); String contentType = getContentType(); if (contentType != null) &#123; view.setContentType(contentType); &#125; view.setRequestContextAttribute(getRequestContextAttribute()); view.setAttributesMap(getAttributesMap()); Boolean exposePathVariables = getExposePathVariables(); if (exposePathVariables != null) &#123; view.setExposePathVariables(exposePathVariables); &#125; Boolean exposeContextBeansAsAttributes = getExposeContextBeansAsAttributes(); if (exposeContextBeansAsAttributes != null) &#123; view.setExposeContextBeansAsAttributes(exposeContextBeansAsAttributes); &#125; String[] exposedContextBeanNames = getExposedContextBeanNames(); if (exposedContextBeanNames != null) &#123; view.setExposedContextBeanNames(exposedContextBeanNames); &#125; return view; &#125; 可以看出：是通过 BeanUtils.instantiateClass(getViewClass()) 来创建 View 对象的。这个例子与其说是 InternalResourceViewResolver ，倒不如说是 UrlBasedViewResolver 类型的例子。 从这里也可以看出：该类型最终要到的目标URL为：getPrefix() + viewName + getSuffix() 视图渲染View接口官方文档： 1`* MVC View for a web interaction. Implementations are responsible for rendering* content, and exposing the model. A single view exposes multiple model attributes.** &lt;p&gt;This class and the MVC approach associated with it is discussed in Chapter 12 of* &lt;a href=&quot;http://www.amazon.com/exec/obidos/tg/detail/-/0764543857/&quot;&gt;Expert One-On-One J2EE Design and Development&lt;/a&gt;* by Rod Johnson (Wrox, 2002).** &lt;p&gt;View implementations may differ widely. An obvious implementation would be* JSP-based. Other implementations might be XSLT-based, or use an HTML generation library.* This interface is designed to avoid restricting the range of possible implementations.** &lt;p&gt;Views should be beans. They are likely to be instantiated as beans by a ViewResolver.* As this interface is stateless, view implementations should be thread-safe.` 说明： SpringMVC 对一个 web 来说是相互作用的（不太明白）。View 的实现类是负责呈现内容的，并且 exposes（暴露、揭露、揭发的意思，这里就按暴露解释吧，想不出合适的词语） 模型的。 一个单一的视图可以包含多个模型。 View 的实现可能有很大的不同。一个明显的实现是基于 JSP 的。其他的实现可能是基于 XSLT 的，或者是一个 HTML 生成库。 设计这个接口是为了避免约束可能实现的范围（这里是不是说，我们可以通过实现该接口来自定义扩展自定义视图？）。 所有的视图都应该是一个 Bean 类。他们可能被 ViewResolver 当做一个 bean 进行实例化。 由于这个接口是无状态的，View 的所有实现类应该是线程安全的。 View接口的实现类IDEA中crtl+H可查看View接口所有的实现类 具体渲染的一个过程​ 举例：View类型为JstlView 继承关系： public class JstlView extends InternalResourceView ​ public class InternalResourceView extends AbstractUrlBasedView ​ public abstract class AbstractUrlBasedView extends AbstractView implements InitializingBean ​ public abstract class AbstractView extends WebApplicationObjectSupport implements View, BeanNameAware 通过org.springframework.web.servlet.DispatcherServlet#render 方法中的渲染view.render(mv.getModelInternal(), request, response); 进入到org.springframework.web.servlet.view.AbstractView#render 12345678910111213@Override public void render(@Nullable Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;Rendering view with name &apos;&quot; + this.beanName + &quot;&apos; with model &quot; + model + &quot; and static attributes &quot; + this.staticAttributes); &#125; Map&lt;String, Object&gt; mergedModel = createMergedOutputModel(model, request, response); prepareResponse(request, response); renderMergedOutputModel(mergedModel, getRequestToExpose(request), response); &#125; renderMergedOutputModel(mergedModel, getRequestToExpose(request), response); 这里只看 org.springframework.web.servlet.view.InternalResourceView#renderMergedOutputModel 这个方法 renderMergedOutputModel（渲染合并输出模型） 12345678910111213141516171819202122232425262728293031323334353637@Override protected void renderMergedOutputModel( Map&lt;String, Object&gt; model, HttpServletRequest request, HttpServletResponse response) throws Exception &#123; // Expose the model object as request attributes. exposeModelAsRequestAttributes(model, request); // Expose helpers as request attributes, if any. exposeHelpers(request); // Determine the path for the request dispatcher. String dispatcherPath = prepareForRendering(request, response); // Obtain a RequestDispatcher for the target resource (typically a JSP). RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath); if (rd == null) &#123; throw new ServletException(&quot;Could not get RequestDispatcher for [&quot; + getUrl() + &quot;]: Check that the corresponding file exists within your web application archive!&quot;); &#125; // If already included or response already committed, perform include, else forward. if (useInclude(request, response)) &#123; response.setContentType(getContentType()); if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Including resource [&quot; + getUrl() + &quot;] in InternalResourceView &apos;&quot; + getBeanName() + &quot;&apos;&quot;); &#125; rd.include(request, response); &#125; else &#123; // Note: The forwarded resource is supposed to determine the content type itself. if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Forwarding to resource [&quot; + getUrl() + &quot;] in InternalResourceView &apos;&quot; + getBeanName() + &quot;&apos;&quot;); &#125; rd.forward(request, response); &#125; &#125; RequestDispatcher rd = getRequestDispatcher(request, dispatcherPath);//创建RequestDispatcher rd.forward(request, response); //转发请求 可以看到前面的几个步骤都是为 RequestDispatch 做准备，装填数据。最后，到目标页面是通过转发。 DispatcherServlet做最后处理DispatcherServlet继承FrameworkServlet FrameworkServlet重写service()方法,(也重写了doGet,doPost方法等） 123456789101112@Override protected void service(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; HttpMethod httpMethod = HttpMethod.resolve(request.getMethod()); if (HttpMethod.PATCH == httpMethod || httpMethod == null) &#123; processRequest(request, response); &#125; else &#123; super.service(request, response); &#125; &#125; 1）service()方法或者super.service()方法，以及super.service()方法调用的doGet(),doPost()等等都调用processRequest()方法 2）processRequest()方法，processRequest()调用doService()方法 3）doService()调用doDispatch(request, response)， 4）doDispatch(request, response)调用processDispatchResult()， 5）processDispatchResult方法调用render()方法，虽然在render()方法中请求已经转发，但是后面还做了一些异常处理等 123456789101112131415161718192021222324252627282930313233343536373839404142434445/** * Handle the result of handler selection and handler invocation, which is * either a ModelAndView or an Exception to be resolved to a ModelAndView. */ private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception &#123; boolean errorView = false; if (exception != null) &#123; if (exception instanceof ModelAndViewDefiningException) &#123; logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception); mv = ((ModelAndViewDefiningException) exception).getModelAndView(); &#125; else &#123; Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null); mv = processHandlerException(request, response, handler, exception); errorView = (mv != null); &#125; &#125; // Did the handler return a view to render? if (mv != null &amp;&amp; !mv.wasCleared()) &#123; render(mv, request, response); if (errorView) &#123; WebUtils.clearErrorRequestAttributes(request); &#125; &#125; else &#123; if (logger.isDebugEnabled()) &#123; logger.debug(&quot;Null ModelAndView returned to DispatcherServlet with name &apos;&quot; + getServletName() + &quot;&apos;: assuming HandlerAdapter completed request handling&quot;); &#125; &#125; if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; // Concurrent handling started during a forward return; &#125; if (mappedHandler != null) &#123; mappedHandler.triggerAfterCompletion(request, response, null); &#125; &#125; 总结介绍了 SpringMVC 视图解析和视图渲染问题是如何解决的。SpringMVC 为逻辑视图提供了多种视图解析策略，可以在配置文件中配置多个视图的解析策略。并制定其先后顺序。 这里所说的视图解析策略，就是指视图解析器。视图解析器会将逻辑视图名解析为一个具体的视图对象。再说视图渲染的过程，视图对模型进行了渲染，最终将模型的数据以某种形式呈现给用户。 参考：https://www.cnblogs.com/solverpeng/p/5743609.html","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Springmvc中的404","slug":"Spring/Springmvc中的404","date":"2020-03-26T07:45:59.000Z","updated":"2020-03-26T15:05:31.155Z","comments":true,"path":"2020/03/26/Spring/Springmvc中的404/","link":"","permalink":"http://yoursite.com/2020/03/26/Spring/Springmvc中的404/","excerpt":"","text":"关于404Springmvc中的基本流程SpringMVC从浏览器发送请求，到服务器响应数据，一共会经过哪些步骤： 浏览器发送请求到前端控制器 DispatherServlet 前端控制器将请求消息转发给处理器映射器 HandlerMapping 处理器映射器将请求消息中的路径根据其映射关系,找到需要执行的Controller方法信息,并返回给前端控制器返回途中经过拦截器(拦截器根据方法拦截,经处理器映射器处理后已确定需要执行的方法信息) 前端控制器将执行方法的映射信息发送给处理器适配器HandlerAdapter 处理器适配器根据方法信息,发送给处理器Handler,找到对应的Controller方法并执行 Handler执行完返回一个ModelAndView对象给处理器适配器 处理器适配器将ModelAndView对象返回给前端控制器 前端控制器将ModelAndView对象发送给视图解析器ViewResolver 视图解析器将ModelAndView对象解析,返回一个View对象给前端控制器 前端控制器将Model中的数据填充到View中,得到一个具体的页面 前端控制器将页面视图响应给浏览器 springmvc的404 1）如 404 等是通过 Servlet (DispatcherServlet.noHandlerFound) 的处理并返回 response ( response.sendError) ，并未到达 Controller 层，所以并不能捕获到。 2）如果是用户请求了一个不存在的页面，没有对应的@RequestMapping，此时Spring的DispatcherServlet就会处理掉返回404，不会进入任何一个controller 3）还有比如spring security之类的权限管理模块，如果用户的密码正确，但是该账户的权限组没有权限访问当前页面，此时权限模块会有自己的AccessDeniedHandler处理，也不会进入配置的@ControllerAdvice 如果采用spring boot 或者AppInitializer来配置，需要在AppInitializer的实现类中重写createDispatcherServlet方法： 1）设置抛出NoHandlerFoundException异常 1234567@Override protected DispatcherServlet createDispatcherServlet(WebApplicationContext servletAppContext) &#123; final DispatcherServlet dispatcherServlet = (DispatcherServlet) super.createDispatcherServlet(servletAppContext); //设置抛出NoHandlerFoundException异常 dispatcherServlet.setThrowExceptionIfNoHandlerFound(true); return dispatcherServlet; &#125; 2）同时在@ControllerAdvice中添加方法： 12345@ExceptionHandler public ResponseEntity&lt;String&gt; handleResourceNotFoundException(NoHandlerFoundException nhre) &#123; logger.error(nhre.getMessage(), nhre); return new ResponseEntity&lt;String&gt;(&quot;Not Found&quot;, HttpStatus.NOT_FOUND); &#125; 我们可以配置Spring在没有对应的@RequestMapping时，不要自行处理，让他抛出一个NoHandlerFoundException的异常，从而让我们配置的@ControllerAdvice进行统一处理 如果是xml风格的配置，可以在DispatcherServlet对应的配置文件中配置 如果是之前介绍的class风格的配置，可以这样配置： 1dispatcherServlet.setThrowExceptionIfNoHandlerFound(true);//for NoHandlerFoundException 实现方式1： 1234567891011121314&lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;!-- 设置抛出NoHandlerFound异常，即404--&gt; &lt;param-name&gt;throwExceptionIfNoHandlerFound&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt; 参考: https://www.cnblogs.com/yangchongxing/p/9271900.html","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"jsp中使用基路径","slug":"Java Web/jsp使用基路径","date":"2020-03-25T07:20:03.000Z","updated":"2020-03-25T07:07:17.603Z","comments":true,"path":"2020/03/25/Java Web/jsp使用基路径/","link":"","permalink":"http://yoursite.com/2020/03/25/Java Web/jsp使用基路径/","excerpt":"","text":"基路径的使用问题在jsp中使用基路径base href123456789101112131415&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" isELIgnored=\"false\" %&gt;&lt;% String path = request.getContextPath();//项目的发布路径，例如: /rabc String basePath = request.getScheme()+\"://\"+request.getServerName()+\":\"+request.getServerPort()+path+\"/\";%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;base href=\"&lt;%=basePath%&gt;\"&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;欢迎使用路人丁OA&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"test\"&gt;测试&lt;/a&gt;&lt;/body&gt; a标签中的路径 href=”test” 则访问 http://localhost:8080/动态获取项目名/test ​ 推荐使用 a标签中的路径 href=”/test” 则访问 http://localhost:8080/test 不使用base href一a标签中的路径 href=”test” 则访问 当前路径的相对路径 ​ 例如当前路径 http://localhost:8080/项目名/duty/duty.html ​ 则访问 http://localhost:8080/项目名/duty/test 因此该种方式不推荐使用 二a标签中的路径 href=”/test” 则访问 http://localhost:8080/test 在项目直接部署在根路径下可以使用，即不使用项目名","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/tags/jsp/"}]},{"title":"jsp中的标签库","slug":"Java Web/jsp的标签库","date":"2020-03-20T08:20:03.000Z","updated":"2020-03-20T10:11:20.685Z","comments":true,"path":"2020/03/20/Java Web/jsp的标签库/","link":"","permalink":"http://yoursite.com/2020/03/20/Java Web/jsp的标签库/","excerpt":"","text":"JSP中的标签库标签库运行原理​ JSP标签的定义步骤： ​ 1 创建标记处理类( 处理标签的类必须扩展javax.servlet.jsp.TagSupport 或 BodyTagSupport) ​ 2 创建TLD文件 ​ 3 在jsp页面通过指令引入标签库 自定义标签库​ 创建标记处理类: 12345678910111213141516171819package test; import javax.servlet.jsp.JspException; import javax.servlet.jsp.JspWriter; import javax.servlet.jsp.tagext.TagSupport; public class OutputTag extends TagSupport &#123; private String name=null; public void setName(String name) &#123; this.name = name; &#125; public int doEndTag() throws JspException &#123; try &#123; JspWriter out = pageContext.getOut(); out.print(&quot;Hello! &quot; + name); &#125; catch (Exception e) &#123; throw new JspException(e); &#125; return EVAL_PAGE; &#125; &#125; 1 如何输出到jsp页面：调用JspWriter JspWriter out = pageContext.getOut();out.print……记住这个方法就可以了。2 输出后如何作处理，函数会返回几个值之一。EVAL_PAGE 表示tag已处理完毕，返回jsp页面。还有几个值，例如 EVAL_BODY_AGAIN 和EVAL_BODY_INCLUDE等 跟流程控制有关. Tag系列的Interface里定义的静态int,通过他们也能一窥tag组键的执行流程,这几个静态值分别是：SKIP_BODY ： 跳过了开始和结束标签之间的代码,一般是在doStartTag中使用EVAL_BODY_INCLUDE ：处理嵌套的标签,一般是在doStartTag中使用,由负责处理标签正文的tag接口提供EVAL_BODY_BUFFERED :对包含的内容进行解析 一般是在doStartTag中使用,由负责处理标签正文的bodyTag接口提供,目的是通知jsp容器作好读取正文的工作(创建一个body-content包装正文和获取存放操作结果的out对象,便于以后的操作和输出).EVAL_BODY_AGAIN:处理标签正文,嵌套标签的iteratorTag接口的使用SKIP_PAGE ： 忽略剩下的页面,一般是在doEndTag中使用EVAL_PAGE ： 继续执行下面的页, 一般是在doEndTag中使用 编写tld 文件 12345678910111213141516171819&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot; ?&gt; &lt;!DOCTYPE taglib PUBLIC &quot;-//Sun Microsystems, Inc.//DTD JSP Tag Library 1.2//EN&quot; &quot;http://java.sun.com/dtd/web-jsptaglibrary_1_2.dtd&quot;&gt; &lt;taglib&gt; &lt;tlib-version&gt;1.0&lt;/tlib-version&gt; &lt;jsp-version&gt;1.2&lt;/jsp-version&gt; &lt;short-name&gt;test&lt;/short-name&gt; &lt;!--OutputTag--&gt; &lt;tag&gt; &lt;name&gt;out&lt;/name&gt; &lt;!-- 全限定路径 --&gt;&lt;tag-class&gt;test.OutputTag&lt;/tag-class&gt; &lt;body-content&gt;empty&lt;/body-content&gt; &lt;attribute&gt; &lt;name&gt;name&lt;/name&gt; &lt;required&gt;false&lt;/required&gt; &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;/tag&gt; &lt;/taglib&gt; 在WEB-INF下新建tlds文件夹，把这个文件取名为test.tld，放到tlds文件夹下。引用时的路径应该这样：WEB-INF\\tlds\\test.tld 关于tld的简单说明：short-name：taglib的名称，也称为前缀。比如“c:out value=””/” 里的“c”name：tag的名字。例如“c:out value=””/” 里的”out”，我们的类也取名为out，由于有前缀作区分，不会同其他库的 同名tag组件混淆tag-class：完整的tag组件路径,记着带包名body-content：指tag之间的内容。例如c:out value=”” …… /c 起始和关闭标签之间就是body-content。由于没有处理body-content ，所以上面设为empty,如果是嵌套标签,或则是要在服务器端处理标签体的话,就是jsp了“attribute”里的name：属性名字。例如c:out value=””/里的value。名字可任意取，只要类里提供相应的set方法即 可。required：是否必填属性。rtexprvalue：是否支持运行时表达式取值就是是否可以&lt;%=%&gt;或则是${}方式传值。这是tag的强大功能。 编写jsp 1234567&lt;%@ page language=&quot;java&quot;%&gt; &lt;%@ taglib uri=&quot;/WEB-INF/tlds/test.tld&quot; prefix=&quot;test&quot;%&gt; &lt;html&gt; &lt;body&gt; Test Tag: &lt;test:out name=&quot;TEST&quot;/&gt; &lt;/body&gt; &lt;/html&gt; 标签库的uri路径引入​ 在JSP中使用标签是很平常的事情，在制作自定义标签时，通常都需要写tld文件来定义标签的各种属性，对应的java类，前缀等等。标签与tld文件紧紧相连，那么，到底应该怎么放置tld文件？在web.xml中怎么定义tld文件的位置？ ​ Web容器(jsp引擎)遇到类似【&lt;c:import】这样的标签时，会通过prefix定位到uri，再根据uri定位到相应的tld文件，对tld文件进行解析。其中uri ——–tld文件的映射关系如下： ​ Key （Uri） Value（String[] taglib_tld_location） ​ /jstl-examples-taglib、 taglib_tld_location[0] + taglib_tld_location[1] http://java.sun.com/jstl/core Tld文件路径定义方式 ​ 如下方式1和方式2只能在2.3版本使用，Servlet2.4开始便不能在web.xml中定义taglib了。 ​ &lt;!DOCTYPE web-app PUBLIC &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot; ​ “http://java.sun.com/dtd/web-app_2_3.dtd&quot;&gt; l 方式1： ​ 如下所示，在web.xml中定义 1234 &lt;taglib&gt; &lt;taglib-uri&gt;/jstl-examples-taglib&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/lib/jstl-examples.tld&lt;/taglib-location&gt;&lt;/taglib&gt; 如果这样定义的话，映射关系便如下： /jstl-examples-taglib —————-{“/WEB-INF/lib/jstl-examples.tld”,””} // taglib_tld_location[0]就足以表示tld路径，因此taglib_tld_location[1]为空。 ​ 方式二: ​ 如下所示，在web.xml中定义 1234 &lt;taglib&gt; &lt;taglib-uri&gt;/jstl-examples-taglib&lt;/taglib-uri&gt; &lt;taglib-location&gt;/WEB-INF/lib/jstl-examples.jar&lt;/taglib-location&gt;&lt;/taglib&gt; 如果这样定义的话，映射关系便如下： /jstl-examples-taglib ———– {“/WEB-INF/lib/ jstl-examples.jar”,” META-INF/taglib.tld”} // taglib_tld_location[0]表示jar路径，taglib_tld_location[1]固定为META-INF/taglib.tld(也就是说，tld在jar文件中的保存路径必须是META-INF/taglib.tld，名称必须是taglib.tld)。这就是说一个jar里只能有一个tld。如果代码中不固定为taglib.tld的话，也很难处理，因为如果tld的名称可以随便定义的话，出现多个tld在jar文件中时将会导致混乱。 方式三： 不需要在web.xml中定义，只需要把tld保存在web应用能够使用的jar文件中的META-INF路径下便可。这种情况的机制是这样的：web容器会遍历当前web应用能够访问的jar文件，从jar文件中查找META-INF/xxx.tld文件，当找到一个tld文件之后，便会解析tld文件，取出节点的值，把uri作为key值生成映射关系。 如下所示的jstl的core标签库的tld文件，便会有如下的映射关系 http://java.sun.com/jstl/core ——–{“tld文件所在的jar文件的路径”,” META-INF/xxx.tld”} //taglib_tld_location[0]表示jar路径，taglib_tld_location[1]为所搜到的tld在jar文件中的相对路径 例：这是jstl.jar中的META-INF/c.tld文件的部分 12345678910111213141516171819202122232425262728293031323334&lt;description&gt;JSTL 1.1 core library&lt;/description&gt; &lt;display-name&gt;JSTL core&lt;/display-name&gt; &lt;tlib-version&gt;1.1&lt;/tlib-version&gt; &lt;short-name&gt;c&lt;/short-name&gt; &lt;uri&gt;http://java.sun.com/jsp/jstl/core&lt;/uri&gt; &lt;validator&gt; &lt;description&gt; Provides core validation features for JSTL tags. &lt;/description&gt; &lt;validator-class&gt; org.apache.taglibs.standard.tlv.JstlCoreTLV &lt;/validator-class&gt; &lt;/validator&gt; &lt;tag&gt; &lt;description&gt; Catches any Throwable that occurs in its body and optionally exposes it. &lt;/description&gt; &lt;name&gt;catch&lt;/name&gt; &lt;tag-class&gt;org.apache.taglibs.standard.tag.common.core.CatchTag&lt;/tag-class&gt; &lt;body-content&gt;JSP&lt;/body-content&gt; &lt;attribute&gt; &lt;description&gt;Name of the exported scoped variable for theexception thrown from a nested action. The type of thescoped variable is the type of the exception thrown. &lt;/description&gt; &lt;name&gt;var&lt;/name&gt; &lt;required&gt;false&lt;/required&gt; &lt;rtexprvalue&gt;false&lt;/rtexprvalue&gt; &lt;/attribute&gt; &lt;/tag&gt; Tld文件的解析逻辑 以jstl为例： Web容器遇到类似【&lt;c:import】标签时，就会通过在头部中定义的&lt;%@ taglib prefix=”c” uri=”http://java.sun.com/jstl/core&quot; %&gt;找到uri，再根据此uri便可以定位到taglib_tld_location。当taglib_tld_location[0]不是jar文件时，便直接使用java的FileInputStream读取tld文件；当taglib_tld_location[0]是jar文件时，则会 通过如下代码读取tld文件。 URL jarFileUrl = new URL(“jar:” + location[0] + “!/“); ZipEntry jarEntry = jarFile.getEntry(location[1]); 总结: ​ tld的定义可以不在web.xml中定义，这时需要保证tld在web应用能够访问的jar中，并且保存在jar的META-INF目录下。此时JSP直接使用tld中定义的\\&lt;uri>便可； 如果在web.xml中定义tld的路径的话，可以直接指定tld文件路径，此时要保证tld不在jar包中(比如在WEB-INF目录下)；也可以指定为jar文件路径，此时要保证tld在jar中且路径为META-INF/taglib.tld。 在web.xml中定义的uri优先级要高于tld文件中定义的优先级。 补充​ jsp中使用JSTL，需要哪些jar包? ​ jstl.jar和standard.jar ​ standard.jar是JSP标准标签库，和jstl.jar 1.0版本中一起使用， ​ 但在jstl-1.2.jar就不再需要了 参考: JSP标签在tomcat中的运行原理 https://www.iteye.com/blog/jianfulove-1826982 ​ jsp自定义标签(taglib)编写的原理和实现 https://blog.csdn.net/zhangdaiscott/article/details/8622975 ​ 如何引用自定义标签库中的tld文件 http://blog.sina.com.cn/s/blog_7ffe993c01019ebe.html","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/tags/jsp/"}]},{"title":"mybatis中xml映射和方法注解两种配置sql语句的方式是否可以同时存在","slug":"DataBase/MyBatis/mybatis中xml映射和方法注解两种配置sql语句的方式是否可以同时存在","date":"2019-12-12T03:07:30.000Z","updated":"2019-12-12T03:12:41.363Z","comments":true,"path":"2019/12/12/DataBase/MyBatis/mybatis中xml映射和方法注解两种配置sql语句的方式是否可以同时存在/","link":"","permalink":"http://yoursite.com/2019/12/12/DataBase/MyBatis/mybatis中xml映射和方法注解两种配置sql语句的方式是否可以同时存在/","excerpt":"","text":"mybatis中xml映射和方法注解两种配置sql语句的方式是否可以同时存在​ 不能进行同时设置。执行会找不到接口的mapper代理工厂。mybatis会先解析xml文件，将解析后的sql封装在mapperstament中并放进Configuration的mappedStatements中，将命名空间和方法名（也就是id）作为key，mappedStatements是个自定义map。然后生成接口的代理工程，生产代理工厂后会解析注解，解析完注解，也会生成mapperstament，也会往统一的Configuration大对象里面放，但是放的时候自定义map会先判断是否存在，此时已经存在了，存在就会抛出IllegalArgumentException(name + “ already contains value for “ + key）。但是创建代理工厂的时候把异常吃掉了，所以加载的时候不会报错，但是不会给接口生成代理工厂。没有代理工厂，接口就没有实现类去操作。","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"}]},{"title":"Spring中的事件处理","slug":"Spring/Spring中的事件处理","date":"2019-09-04T07:45:59.000Z","updated":"2019-09-04T08:21:06.028Z","comments":true,"path":"2019/09/04/Spring/Spring中的事件处理/","link":"","permalink":"http://yoursite.com/2019/09/04/Spring/Spring中的事件处理/","excerpt":"","text":"Spring中的事件处理Spring 的核心是 ApplicationContext，它负责管理 beans 的完整生命周期。当加载 beans 时，ApplicationContext 发布某些类型的事件。例如，当上下文启动时，ContextStartedEvent 发布，当上下文停止ContextStoppedEvent发布。 通过 ApplicationEvent 类和 ApplicationListener 接口来提供在 ApplicationContext 中处理事件。如果一个 bean 实现 ApplicationListener，那么每次 ApplicationEvent 被发布到 ApplicationContext 上，那个 bean 会被通知。 Spring 提供了以下的标准事件： 序号 Spring 内置事件 &amp; 描述 1 ContextRefreshedEvent*ApplicationContext 被初始化或刷新时，该事件被发布。这也可以在 ConfigurableApplicationContext*接口中使用 refresh() 方法来发生。 2 ContextStartedEvent当使用 ConfigurableApplicationContext 接口中的 start() 方法启动 ApplicationContext 时，该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。 3 ContextStoppedEvent当使用 ConfigurableApplicationContext 接口中的 stop() 方法停止 ApplicationContext 时，发布这个事件。你可以在接受到这个事件后做必要的清理的工作。 4 ContextClosedEvent当使用 ConfigurableApplicationContext 接口中的 close() 方法关闭 ApplicationContext 时，该事件被发布。一个已关闭的上下文到达生命周期末端；它不能被刷新或重启。 5 RequestHandledEvent这是一个 web-specific 事件，告诉所有 bean HTTP 请求已经被服务。 由于 Spring 的事件处理是单线程的，所以如果一个事件被发布，直至并且除非所有的接收者得到的该消息，该进程被阻塞并且流程将不会继续。因此，如果事件处理被使用，在设计应用程序时应注意。 监听上下文事件为了监听上下文事件，一个 bean 应该实现只有一个方法 onApplicationEvent() 的 ApplicationListener 接口。因此，我们写一个例子来看看事件是如何传播的，以及如何可以用代码来执行基于某些事件所需的任务。 让我们在恰当的位置使用 Eclipse IDE，然后按照下面的步骤来创建一个 Spring 应用程序： 步骤 描述 1 创建一个名称为 SpringEventTest 的项目，并且在创建项目的 src 文件夹中创建一个包com.szxy 2 使用 Add External JARs 选项，添加所需的 Spring 库 3 在 com.szxy包中创建 Java 类 HelloSpringEvent、CStartEventHandler、CStopEventHandler* 和 Start 4 在 src 文件夹中创建 Bean 的配置文件 applicationContext.xml.xml 5 最后一步是创建的所有 Java 文件和 Bean 配置文件的内容，并运行应用程序，解释如下所示. 这里是 HelloSpringEvent.java 文件的内容： 12345678910111213141516171819package com.szxy;public class HelloSpringEvent &#123; private String msg; public HelloSpringEvent()&#123; System.out.println(&quot;HelloSpringEvent 初始化&quot;); &#125; public String getMsg() &#123; return msg; &#125; public void setMsg(String msg) &#123; this.msg = msg; &#125; &#125; 下面是 CStartEventHandler.java 文件的内容： 1234567891011121314151617181920package com.szxy;import org.springframework.context.ApplicationListener;import org.springframework.context.event.ContextStartedEvent;/** * ContextStartedEvent: * 当使用 ConfigurableApplicationContext 接口中的 start()方法启动 ApplicationContext时, * 该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。 * @author Administrator * */public class CStartEventHandler implements ApplicationListener&lt;ContextStartedEvent&gt;&#123; @Override public void onApplicationEvent(ContextStartedEvent event) &#123; System.out.println(&quot;ContextStartedEvent start!!&quot;); &#125;&#125; 下面是 CStopEventHandler.java 文件的内容： 1234567891011121314151617181920package com.szxy;import org.springframework.context.ApplicationListener;import org.springframework.context.event.ContextStoppedEvent;/** * ContextStoppedEvent: * 当使用 ConfigurableApplicationContext 接口中的 stop() 方法停止 ApplicationContext 时， * 发布这个事件。你可以在接受到这个事件后做必要的清理的工作。 * @author Administrator * */public class CStopEventHandler implements ApplicationListener&lt;ContextStoppedEvent&gt;&#123; @Override public void onApplicationEvent(ContextStoppedEvent event) &#123; System.out.println(&quot;ContextStoppedEvent stop!!&quot;); &#125;&#125; 下面是 Start.java 文件的内容： 1234567891011121314151617181920package com.szxy;import org.springframework.context.support.ClassPathXmlApplicationContext;public class Start &#123; public static void main(String[] args) &#123; //加载spring配置文件,初始化所有的bean ClassPathXmlApplicationContext ac = new ClassPathXmlApplicationContext(&quot;classpath:applicationContext.xml&quot;); //启动spring容器 ac.start(); HelloSpringEvent hello = ac.getBean(&quot;helloSpringEvent&quot;, HelloSpringEvent.class); System.out.println(hello.getMsg()); //停止spring容器 ac.stop(); &#125;&#125; 下面是配置文件 applicationContext.xml 文件： 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot; http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; &lt;bean id=&quot;helloSpringEvent&quot; class=&quot;com.szxy.HelloSpringEvent&quot;&gt; &lt;property name=&quot;msg&quot;&gt; &lt;value&gt;Test SpringEvent!!&lt;/value&gt; &lt;/property&gt; &lt;/bean&gt; &lt;bean id=&quot;cStartEventHandler&quot; class=&quot;com.szxy.CStartEventHandler&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;cStopEventHandler&quot; class=&quot;com.szxy.CStopEventHandler&quot;&gt;&lt;/bean&gt;&lt;/beans&gt; 一旦你完成了创建源和 bean 的配置文件，我们就可以运行该应用程序。如果你的应用程序一切都正常，将输出以下消息： 1234HelloSpringEvent 初始化ContextStartedEvent start!!Test SpringEvent!!ContextStoppedEvent stop!! 注意： ​ 由于 Spring 的事件处理是单线程的，所以如果一个事件被发布，直至并且除非所有的接收者得到的该消息，该进程被阻塞并且流程将不会继续。因此，如果事件处理被使用，在设计应用程序时应注意。 例如： ​ CStartEventHandler类的监听函数处理中加入一个阻塞调用System.in.read(); 12345678910111213141516171819202122232425262728package com.szxy;import java.io.IOException;import org.springframework.context.ApplicationListener;import org.springframework.context.event.ContextStartedEvent;/** * ContextStartedEvent: * 当使用 ConfigurableApplicationContext 接口中的 start()方法启动 ApplicationContext时, * 该事件被发布。你可以调查你的数据库，或者你可以在接受到这个事件后重启任何停止的应用程序。 * @author Administrator * */public class CStartEventHandler implements ApplicationListener&lt;ContextStartedEvent&gt;&#123; @Override public void onApplicationEvent(ContextStartedEvent event) &#123; System.out.println(&quot;ContextStartedEvent start!!&quot;); try &#123; System.in.read(); &#125; catch (IOException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 运行结果： ​ 12HelloSpringEvent 初始化ContextStartedEvent start!! 可以看出进程被阻塞了，程序不会往下继续执行 参考： ​ https://wiki.jikexueyuan.com/project/spring/event-handling-in-spring.html","categories":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/categories/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"SpringBoot学习","slug":"SpringBoot/SpringBoot学习","date":"2019-09-04T07:45:59.000Z","updated":"2019-09-11T09:27:00.499Z","comments":true,"path":"2019/09/04/SpringBoot/SpringBoot学习/","link":"","permalink":"http://yoursite.com/2019/09/04/SpringBoot/SpringBoot学习/","excerpt":"","text":"SpringBootSpringBoot官方定义​ Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”. ​ We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration. Spring Boot使创建独立的、基于生产级Spring的应用程序变得很容易，您可以“直接运行”这些应用程序。 我们对Spring平台和第三方库有自己的见解，这样您就可以轻松入门了。大多数Spring引导应用程序只需要很少的Spring配置。 SpringBoot学习SpringBoot的启动123456789101112131415/** * SpringBoot 启动类 * 注意： * 启动器存放的位置。启动器可以和 controller位于同一个包下，或者位于 controller的上一级 包中， * 但是不能放到 controller的平级以及子包下。 * @author Administrator * */@SpringBootApplicationpublic class App &#123; public static void main(String[] args) &#123; //启动SpringBoot SpringApplication.run(App.class, args); &#125;&#125; ​ SpringBoot的静态资源访问​ 源码分析 ​ org.springframework.boot.autoconfigure.web.ResourceProperties 123private static final String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; &quot;classpath:/META-INF/resources/&quot;, &quot;classpath:/resources/&quot;, &quot;classpath:/static/&quot;, &quot;classpath:/public/&quot; &#125;; 因此，在类路径下的这几个目录都可以访问到静态资源 注意1： ​ 在maven中的src/main下建立webapp目录，可以访问静态资源 分析： ​ eclipse编译会产生一个target/classes目录,有eclipse中.classpath文件指定编译输出目录 ​ output=”target/classes” ​ maven中则将所有的资源打成一个jar或者war包，如果是jar包，则jar目录结构和eclipse中 ​ 中的target/classes下的目录结构相同，由项目中的包文件以及一个META-INF文件夹组成 ​ 用法： ​ 可以使用Maven中的资源打包插件,将src/main/webapp下的静态资源打包至META-INF/resources ​ 1234567891011121314151617181920&lt;build&gt; &lt;resources&gt; &lt;resource&gt; &lt;directory&gt;src/main/resources&lt;/directory&gt; &lt;includes&gt; &lt;include&gt;**/**&lt;/include&gt; &lt;/includes&gt; &lt;!-- 开启过滤，用指定的参数替换directory下的文件中的参数 --&gt; &lt;filtering&gt;true&lt;/filtering&gt; &lt;/resource&gt; &lt;resource&gt; &lt;directory&gt;src/main/webapp&lt;/directory&gt; &lt;targetPath&gt;META-INF/resources&lt;/targetPath&gt; &lt;includes&gt; &lt;include&gt;**/**&lt;/include&gt; &lt;/includes&gt; &lt;/resource&gt; &lt;/resources&gt;&lt;/build&gt; ​ 注意2： ​ 在有多个目录下有相同的静态资源，则优先级顺序优先级序 ​ /META-INF/resources &gt; resources &gt; static &gt; public 注意3： ​ 静态资源路径也可以通过配置文件指定 1spring.resources.static-locations=指定路径 #修改默认的静态资源存放目录，多个路径可以用逗号隔开 spring.resources.static-locations=classpath:/ 修改后，默认路径无效 注意4： 访问时使用相对路径， ​ 如果使用绝对路径static，public等默认是不计入路径的 参考：https://blog.csdn.net/qq_34797335/article/details/80194137 SprinBoot的配置文件SpringBoot配置文件支持yml格式和properties格式,默认命名为 ​ application.properties ​ application.yml 两种配置文件选择哪一种都可以 配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好； yml全称YAML， YAML（Yet Another Markup Language）（发音 /ˈjæməl/ ）, 一种基于Unicode 容易阅读，容易和脚本语言交互的，用来表达资料序列的编程语言。yaml语言广泛用于书写配置文件。 yml主要特点参考：https://www.cnblogs.com/geeklove01/p/8284236.html 注： ​ 配置文件也可以不使用默认的配置名称,只需要在启动类中手动读取配置文件即可 12345678910@SpringBootApplicationpublic class SpringbootConfigApplication &#123; public static void main(String[] args) &#123; //变更配置文件读取位置启动 new SpringApplicationBuilder(SpringbootConfigApplication.class). properties(&quot;spring.config.location=classpath:/springbootconfig.properties&quot;).run(args); //读取默认配置文件启动 SpringApplication.run(SpringbootConfigApplication.class, args); &#125;&#125;","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"SpringBoot的原理分析","slug":"SpringBoot/SpringBoot的原理分析","date":"2019-09-04T07:45:59.000Z","updated":"2020-05-14T10:02:21.154Z","comments":true,"path":"2019/09/04/SpringBoot/SpringBoot的原理分析/","link":"","permalink":"http://yoursite.com/2019/09/04/SpringBoot/SpringBoot的原理分析/","excerpt":"","text":"SpringBootSpringBoot官方定义​ Spring Boot makes it easy to create stand-alone, production-grade Spring based Applications that you can “just run”. ​ We take an opinionated view of the Spring platform and third-party libraries so you can get started with minimum fuss. Most Spring Boot applications need very little Spring configuration. Spring Boot使创建独立的、基于生产级Spring的应用程序变得很容易，您可以“直接运行”这些应用程序。 我们对Spring平台和第三方库有自己的见解，这样您就可以轻松入门了。大多数Spring引导应用程序只需要很少的Spring配置。 SpringBoot原理分析​ SpringBoot是Spring框架对“约定大于配置(Convention over Configuration)”理念的最佳实践。SpringBoot应用本质上就是一个基于Spring框架的应用。 spring-boot-starter-xxx是官方提供的starter， xxx-spring-boot-starter是第三方提供的starter。 springboot扩展机制——spring factoriesSpring Boot中有一种非常解耦的扩展机制：Spring Factories。这种扩展机制实际上是仿照Java中的SPI扩展机制来实现的。 什么是SPI机制SPI的全名为Service Provider Interface.大多数开发人员可能不熟悉，因为这个是针对厂商或者插件的。在java.util.ServiceLoader的文档里有比较详细的介绍。简单的总结下java SPI机制的思想。我们系统里抽象的各个模块，往往有很多不同的实现方案，比如日志模块的方案，xml解析模块、jdbc模块的方案等。面向的对象的设计里，我们一般推荐模块之间基于接口编程，模块之间不对实现类进行硬编码。一旦代码里涉及具体的实现类，就违反了可拔插的原则，如果需要替换一种实现，就需要修改代码。为了实现在模块装配的时候能不在程序里动态指明，这就需要一种服务发现机制。java SPI就是提供这样的一个机制：为某个接口寻找服务实现的机制。有点类似IOC的思想，就是将装配的控制权移到程序之外，在模块化设计中这个机制尤其重要。 Spring Boot中的SPI机制在Spring中也有一种类似与Java SPI的加载机制。它在META-INF/spring.factories文件中配置接口的实现类名称，然后在程序中读取这些配置文件并实例化。这种自定义的SPI机制是Spring Boot Starter实现的基础。 Spring Factories实现原理​ spring-core包里定义了SpringFactoriesLoader类，这个类实现了检索META-INF/spring.factories文件，并获取指定接口的配置的功能。在这个类中定义了两个对外的方法： loadFactories 根据接口类获取其实现类的实例，这个方法返回的是对象列表。loadFactoryNames 根据接口获取其接口类的名称，这个方法返回的是类名的列表。上面的两个方法的关键都是从指定的ClassLoader中获取spring.factories文件，并解析得到类名列表 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859/** * Load and instantiate the factory implementations of the given type from * &#123;@value #FACTORIES_RESOURCE_LOCATION&#125;, using the given class loader. * &lt;p&gt;The returned factories are sorted in accordance with the &#123;@link AnnotationAwareOrderComparator&#125;. * &lt;p&gt;If a custom instantiation strategy is required, use &#123;@link #loadFactoryNames&#125; * to obtain all registered factory names. * @param factoryClass the interface or abstract class representing the factory * @param classLoader the ClassLoader to use for loading (can be &#123;@code null&#125; to use the default) * @see #loadFactoryNames * @throws IllegalArgumentException if any factory implementation class cannot * be loaded or if an error occurs while instantiating any factory */public static &lt;T&gt; List&lt;T&gt; loadFactories(Class&lt;T&gt; factoryClass, ClassLoader classLoader) &#123; Assert.notNull(factoryClass, \"'factoryClass' must not be null\"); ClassLoader classLoaderToUse = classLoader; if (classLoaderToUse == null) &#123; classLoaderToUse = SpringFactoriesLoader.class.getClassLoader(); &#125; List&lt;String&gt; factoryNames = loadFactoryNames(factoryClass, classLoaderToUse); if (logger.isTraceEnabled()) &#123; logger.trace(\"Loaded [\" + factoryClass.getName() + \"] names: \" + factoryNames); &#125; List&lt;T&gt; result = new ArrayList&lt;T&gt;(factoryNames.size()); for (String factoryName : factoryNames) &#123; result.add(instantiateFactory(factoryName, factoryClass, classLoaderToUse)); &#125; AnnotationAwareOrderComparator.sort(result); return result; &#125; /** * Load the fully qualified class names of factory implementations of the * given type from &#123;@value #FACTORIES_RESOURCE_LOCATION&#125;, using the given * class loader. * @param factoryClass the interface or abstract class representing the factory * @param classLoader the ClassLoader to use for loading resources; can be * &#123;@code null&#125; to use the default * @see #loadFactories * @throws IllegalArgumentException if an error occurs while loading factory names */ public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, ClassLoader classLoader) &#123; String factoryClassName = factoryClass.getName(); try &#123; Enumeration&lt;URL&gt; urls = (classLoader != null ? classLoader.getResources(FACTORIES_RESOURCE_LOCATION) : ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION)); List&lt;String&gt; result = new ArrayList&lt;String&gt;(); while (urls.hasMoreElements()) &#123; URL url = urls.nextElement(); Properties properties = PropertiesLoaderUtils.loadProperties(new UrlResource(url)); String factoryClassNames = properties.getProperty(factoryClassName); result.addAll(Arrays.asList(StringUtils.commaDelimitedListToStringArray(factoryClassNames))); &#125; return result; &#125; catch (IOException ex) &#123; throw new IllegalArgumentException(\"Unable to load [\" + factoryClass.getName() + \"] factories from location [\" + FACTORIES_RESOURCE_LOCATION + \"]\", ex); &#125; &#125; loadFactoryNames()在这个方法中会遍历整个ClassLoader中所有jar包下的spring.factories文件。也就是说我们可以在自己的jar中配置spring.factories文件，不会影响到其它地方的配置，也不会被别人的配置覆盖。 spring.factories的是通过Properties解析得到的，所以我们在写文件中的内容都是安装下面这种方式配置的： com.xxx.interface=com.xxx.classname 如果一个接口希望配置多个实现类，可以使用’,’进行分割。 Spring Factories在Spring Boot中的应用 ​ 在spring-boot-1.5.10.RELEASE.jar包下，/META-INF/spring.factories ​ 打开spring.factories ​ 12345678910# PropertySource Loadersorg.springframework.boot.env.PropertySourceLoader=\\org.springframework.boot.env.PropertiesPropertySourceLoader,\\org.springframework.boot.env.YamlPropertySourceLoader# Run Listenersorg.springframework.boot.SpringApplicationRunListener=\\org.springframework.boot.context.event.EventPublishingRunListener................................... 在spring-boot-autoconfigure-1.5.10.RELEASE.jar包下，/META-INF/spring.factories ​ 打开spring.factories 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129# Initializersorg.springframework.context.ApplicationContextInitializer=\\org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\\org.springframework.boot.autoconfigure.logging.AutoConfigurationReportLoggingInitializer# Application Listenersorg.springframework.context.ApplicationListener=\\org.springframework.boot.autoconfigure.BackgroundPreinitializer# Auto Configuration Import Listenersorg.springframework.boot.autoconfigure.AutoConfigurationImportListener=\\org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener# Auto Configuration Import Filtersorg.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\\org.springframework.boot.autoconfigure.condition.OnClassCondition# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,\\org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,\\org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,\\org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,\\org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,\\org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,\\org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,\\org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,\\org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,\\org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,\\org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,\\org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,\\org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,\\org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,\\org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,\\org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,\\org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,\\org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,\\org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,\\org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,\\org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,\\org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,\\org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,\\org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,\\org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,\\org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,\\org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,\\org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,\\org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,\\org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,\\org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,\\org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,\\org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,\\org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,\\org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,\\org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,\\org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,\\org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,\\org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,\\org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,\\org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,\\org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,\\org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,\\org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,\\org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,\\org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,\\org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,\\org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,\\org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration# Failure analyzersorg.springframework.boot.diagnostics.FailureAnalyzer=\\org.springframework.boot.autoconfigure.diagnostics.analyzer.NoSuchBeanDefinitionFailureAnalyzer,\\org.springframework.boot.autoconfigure.jdbc.DataSourceBeanCreationFailureAnalyzer,\\org.springframework.boot.autoconfigure.jdbc.HikariDriverConfigurationFailureAnalyzer# Template availability providersorg.springframework.boot.autoconfigure.template.TemplateAvailabilityProvider=\\org.springframework.boot.autoconfigure.freemarker.FreeMarkerTemplateAvailabilityProvider,\\org.springframework.boot.autoconfigure.mustache.MustacheTemplateAvailabilityProvider,\\org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAvailabilityProvider,\\org.springframework.boot.autoconfigure.thymeleaf.ThymeleafTemplateAvailabilityProvider,\\org.springframework.boot.autoconfigure.web.JspTemplateAvailabilityProvider 这是关于spirngboot自动配置的类的定义,这样通过解析factories文件就能实例化这些定义的类 分析： ​ 自动配置这些类都使用了spring的注解，spring容器在实例化这些类时,通过这些类上的注解可以完成 注册某些Bean等 例如： ​ @Configuration ​ @Bean ​ 能够被springIOC使用的工厂注解和bean的Annotation，springIOC通过注解就可以注入bean 自定义的factories ​ mybatis-spring-boot-autoconfigure-1.1.1.jar中的META-INF/spring.factories ​ 打开spring.factories ​ 123# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.mybatis.spring.boot.autoconfigure.MybatisAutoConfiguration 通过扩展机制配置了一个MybatisAutoConfiguration类,可以查看源码进行具体分析 参考：https://blog.csdn.net/gwd1154978352/article/details/89248273 SpringBoot的starter机制（原理分析）​ starter机制明显是在通过扩展机制来进行实现的，通过扩展机制，可以自定义实现 ​ springboot启动器 起步依赖​ 以一个web项目为例: ​ spring-boot-starter-web包自动帮我们引入了web模块开发需要的相关jar包， ​ mybatis-spring-boot-starter帮我们引入了dao开发相关的jar包。 自动配置​ 对springboot中的mybatis进行分析 ​ mybatis-spring-boot-starter这个包是第三方提供的 ​ mybatis-spring-boot-starter这个包帮我们引入了mybatis-spring-boot-autoconfigure这个包 里面有MybatisAutoConfiguration这个类,源码如下 1234567891011121314151617181920212223242526272829303132333435363738...................@Configuration@ConditionalOnClass(&#123; SqlSessionFactory.class, SqlSessionFactoryBean.class &#125;)@ConditionalOnBean(DataSource.class)@EnableConfigurationProperties(MybatisProperties.class)@AutoConfigureAfter(DataSourceAutoConfiguration.class)public class MybatisAutoConfiguration &#123; ........................................ @Bean @ConditionalOnMissingBean public SqlSessionFactory sqlSessionFactory(DataSource dataSource) throws Exception &#123; SqlSessionFactoryBean factory = new SqlSessionFactoryBean(); factory.setDataSource(dataSource); factory.setVfs(SpringBootVFS.class); if (StringUtils.hasText(this.properties.getConfigLocation())) &#123; factory.setConfigLocation(this.resourceLoader.getResource(this.properties.getConfigLocation())); &#125; factory.setConfiguration(properties.getConfiguration()); if (!ObjectUtils.isEmpty(this.interceptors)) &#123; factory.setPlugins(this.interceptors); &#125; if (this.databaseIdProvider != null) &#123; factory.setDatabaseIdProvider(this.databaseIdProvider); &#125; if (StringUtils.hasLength(this.properties.getTypeAliasesPackage())) &#123; factory.setTypeAliasesPackage(this.properties.getTypeAliasesPackage()); &#125; if (StringUtils.hasLength(this.properties.getTypeHandlersPackage())) &#123; factory.setTypeHandlersPackage(this.properties.getTypeHandlersPackage()); &#125; if (!ObjectUtils.isEmpty(this.properties.resolveMapperLocations())) &#123; factory.setMapperLocations(this.properties.resolveMapperLocations()); &#125; return factory.getObject(); &#125; .............................. ​ @Configuration,@Bean这两个注解一起使用就可以创建一个基于java代码的配置类，可以用来替代相应的xml配置文件。 @Configuration注解的类可以看作是能生产让Spring IoC容器管理的Bean实例的工厂。 @Bean注解告诉Spring，一个带有@Bean的注解方法将返回一个对象，该对象应该被注册到spring容器中。 所以上面的MybatisAutoConfiguration这个类，自动帮我们生成了SqlSessionFactory这些Mybatis的重要实例并交给spring容器管理，从而完成bean的自动注册。 自动配置条件依赖 从MybatisAutoConfiguration这个类中使用的注解可以看出，要完成自动配置是有依赖条件的。 123456789101112131415@ConditionalOnBean，仅在当前上下文中存在某个bean时，才会实例化这个Bean。@ConditionalOnClass，某个class位于类路径上，才会实例化这个Bean。@ConditionalOnExpression，当表达式为true的时候，才会实例化这个Bean。@ConditionalOnMissingBean，仅在当前上下文中不存在某个bean时，才会实例化这个Bean。@ConditionalOnMissingClass，某个class在类路径上不存在的时候，才会实例化这个Bean。@ConditionalOnNotWebApplication，不是web应用时才会实例化这个Bean。@AutoConfigureAfter，在某个bean完成自动配置后实例化这个bean。@AutoConfigureBefore，在某个bean完成自动配置前实例化这个bean。 ​ 所以要完成Mybatis的自动配置，需要在类路径中存在SqlSessionFactory.class、SqlSessionFactoryBean.class这两个类，需要存在DataSource这个bean且这个bean完成自动注册。 ​ 进入DataSourceAutoConfiguration这个类，这个类是在spring-boot-autoconfigure-2.0.4.RELEASE.jar这个包下的，通过扩展机制也自动进行了配置。 ​ 自动配置这个包帮们引入了jdbc、kafka、logging、mail、mongo等包。很多包需要我们引入相应jar后自动配置才生效。 bean参数获取 ​ springboot是如何读取yml或者properites配置文件的的属性来创建数据源的？ ​ 在DataSourceAutoConfiguration类里面，我们注意到使用了EnableConfigurationProperties这个注解。 DataSourceProperties中封装了数据源的各个属性，且使用了注解ConfigurationProperties指定了配置文件的前缀。 123@ConfigurationProperties( prefix = &quot;spring.datasource&quot;) @ConfigurationProperties注解的作用是把yml或者properties配置文件转化为bean。 @EnableConfigurationProperties注解的作用是使@ConfigurationProperties注解生效。如果只配置 @ConfigurationProperties注解，在spring容器中是获取不到yml或者properties配置文件转化的bean的。 通过这种方式，把yml或者properties配置参数转化为bean，这些bean又是如何被发现与加载的？ bean发现 ​ 我们通常在启动类中加@SpringBootApplication这个注解 ​ 实际上重要的只有三个Annotation： @Configuration（@SpringBootConfiguration里面还是应用了@Configuration） @EnableAutoConfiguration @ComponentScan @Configuration的作用上面我们已经知道了，被注解的类将成为一个bean配置类。 @ComponentScan的作用就是自动扫描并加载符合条件的组件，比如@Component和@Repository等，最终将这些bean定义加载到spring容器中。 @EnableAutoConfiguration 这个注解的功能很重要，借助@Import的支持，收集和注册依赖包中相关的bean定义。对于详解可以查看springboot中对于这个注解的实现。最终还是借助spring.factories注册bean。 @EnableAutoConfiguration注解引入了@AutoConfigurationPackage和@Import这两个注解。 12345678910@SuppressWarnings(&quot;deprecation&quot;)@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; ...&#125; @AutoConfigurationPackage的作用就是自动配置的包，@Import导入需要自动配置的组件。 进入@AutoConfigurationPackage，发现也是引入了@Import注解 1234567@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@Import(&#123;Registrar.class&#125;)public @interface AutoConfigurationPackage &#123;&#125; ​ 查看Registrar 1234567891011121314static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123; @Override public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123; register(registry, new PackageImport(metadata).getPackageName()); &#125; @Override public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123; return Collections.&lt;Object&gt;singleton(new PackageImport(metadata)); &#125; &#125; new PackageImport(metadata)).getPackageName() new PackageImport(metadata) 这两句代码的作用就是加载启动类所在的包下的主类与子类的所有组件注册到spring容器，这就是前文所说的springboot默认扫描启动类所在的包下的主类与子类的所有组件。 那问题又来了，要搜集并注册到spring容器的那些beans来自哪里？ @EnableAutoConfiguration类上的@Import(EnableAutoConfigurationImportSelector.class) 选择EnableAutoConfigurationImportSelector的父类AutoConfigurationImportSelector 在AutoConfigurationImportSelector中 123456789101112131415161718192021222324252627282930public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered &#123;private static final String[] NO_IMPORTS = new String[0];... public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if(!this.isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; else &#123; AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader); AnnotationAttributes attributes = this.getAttributes(annotationMetadata); List configurations = this.getCandidateConfigurations(annotationMetadata, attributes); configurations = this.removeDuplicates(configurations); Set exclusions = this.getExclusions(annotationMetadata, attributes); this.checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = this.filter(configurations, autoConfigurationMetadata); this.fireAutoConfigurationImportEvents(configurations, exclusions); return StringUtils.toStringArray(configurations); &#125; &#125;... protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; List configurations = SpringFactoriesLoader.loadFactoryNames(this.getSpringFactoriesLoaderFactoryClass(), this.getBeanClassLoader()); Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you are using a custom packaging, make sure that file is correct.&quot;); return configurations; &#125;...&#125; SpringFactoriesLoader.loadFactoryNames方法调用loadSpringFactories方法从所有的jar包中读取META-INF/spring.factories文件信息。 loadSpringFactories方法 1234567891011121314151617181920212223242526272829private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123; MultiValueMap result = (MultiValueMap)cache.get(classLoader); if(result != null) &#123; return result; &#125; else &#123; try &#123; Enumeration ex = classLoader != null?classLoader.getResources(&quot;META-INF/spring.factories&quot;):ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;); LinkedMultiValueMap result1 = new LinkedMultiValueMap(); while(ex.hasMoreElements()) &#123; URL url = (URL)ex.nextElement(); UrlResource resource = new UrlResource(url); Properties properties = PropertiesLoaderUtils.loadProperties(resource); Iterator var6 = properties.entrySet().iterator(); while(var6.hasNext()) &#123; Entry entry = (Entry)var6.next(); List factoryClassNames = Arrays.asList(StringUtils.commaDelimitedListToStringArray((String)entry.getValue())); result1.addAll((String)entry.getKey(), factoryClassNames); &#125; &#125; cache.put(classLoader, result1); return result1; &#125; catch (IOException var9) &#123; throw new IllegalArgumentException(&quot;Unable to load factories from location [META-INF/spring.factories]&quot;, var9); &#125; &#125; &#125; 下面是spring-boot-autoconfigure这个jar中spring.factories文件部分内容，其中有一个key为org.springframework.boot.autoconfigure.EnableAutoConfiguration的值定义了需要自动配置的bean，通过读取这个配置获取一组@Configuration类。 123456789101112131415org.springframework.boot.autoconfigure.AutoConfigurationImportListener=\\org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener# Auto Configuration Import Filtersorg.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\\org.springframework.boot.autoconfigure.condition.OnClassCondition# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\............. 每一个个xxxAutoConfiguration都是一个基于java的bean配置类。实际上，这些xxxAutoConfiguratio不是所有都会被加载，会根据xxxAutoConfiguration上的@ConditionalOnClass等条件判断是否加载。 如上代码段，通过反射机制将spring.factories中@Configuration类实例化为对应的java实例。到此我们已经知道怎么发现要自动配置的bean了，最后一步就是怎么样将这些bean加载到spring容器。 bean加载 ​ 如果要让一个普通类交给Spring容器管理，通常有以下方法： 1、使用 @Configuration与@Bean 注解 2、使用@Controller @Service @Repository @Component 注解标注该类，然后启用@ComponentScan自动扫描 3、使用@Import 方法 springboot中使用了@Import 方法 @EnableAutoConfiguration注解中使用了@Import({AutoConfigurationImportSelector.class})注解，AutoConfigurationImportSelector实现了DeferredImportSelector接口， DeferredImportSelector接口继承了ImportSelector接口，ImportSelector接口只有一个selectImports方法。 1234567891011121314151617181920public class AutoConfigurationImportSelector implements DeferredImportSelector&#123;... public String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if(!this.isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; else &#123; AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader); AnnotationAttributes attributes = this.getAttributes(annotationMetadata); List configurations = this.getCandidateConfigurations(annotationMetadata, attributes); configurations = this.removeDuplicates(configurations); Set exclusions = this.getExclusions(annotationMetadata, attributes); this.checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = this.filter(configurations, autoConfigurationMetadata); this.fireAutoConfigurationImportEvents(configurations, exclusions); return StringUtils.toStringArray(configurations); &#125;&#125;...&#125; 1234567public interface DeferredImportSelector extends ImportSelector &#123; @Nullable default Class&lt;? extends DeferredImportSelector.Group&gt; getImportGroup() &#123; return null;&#125;public interface Group &#123;...&#125;&#125; ​ 实现该接口可以自定义返回一组bean 123public interface ImportSelector &#123; String[] selectImports(AnnotationMetadata var1);&#125; ​ selectImports方法返回一组bean，@EnableAutoConfiguration注解借助@Import注解将这组bean注入到spring容器中，springboot正式通过这种机制来完成bean的注入的。 总结: ​ 我们可以将自动配置的关键几步以及相应的注解总结如下： 1、@Configuration&amp;与@Bean-&gt;基于java代码的bean配置， 2、@Conditional-&gt;设置自动配置条件依赖 3、@EnableConfigurationProperties与@ConfigurationProperties-&gt;读取配置文件转换为bean。 4、@EnableAutoConfiguration、@AutoConfigurationPackage 与@Import-&gt;实现bean发现与加载。 参考：https://www.cnblogs.com/hjwublog/p/10332042.html#autoid-1-0-0 SpringBoot中的启动类分析​ SpringBoot启动类 123456789101112package com.hafiz.springbootdemo;import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;@SpringBootApplicationpublic class SpringbootDemoApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(SpringbootDemoApplication.class, args); &#125;&#125; ​ @SpringBootApplication注解​ 123456789101112@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)public @interface SpringBootApplication &#123; ...&#125; 我们看到@SpringBootApplication其实是一个复合的注解，起主要作用的就是@SpringBootConfiguration、@EnableAutoConfiguration以及@ComponentScan 三个注解组成. @SpringBootConfiguration1234567@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Configurationpublic @interface SpringBootConfiguration &#123;&#125; 我们可以看到，这里面依旧没有什么新东西，它SpringBoot为了区别@Configuration而新提供的专属于SpringBoot的注解，功能和@Configuration一模一样。 @EnableAutoConfiguration简单的来说，就是该注解借助@Import注解的支持，Spring的IoC容器收集和注册特定场景相关的Bean定义： 关于‘Enable’开头的spring注解 @EnableScheduling是通过@Import将Spring调度框架相关的bean都加载到IoC容器。 @EnableMBeanExport是通过@Import将JMX相关的bean定义加载到IoC容器。 @EnableAutoConfiguration注解也是借助@Import将所有复合配置条件的bean定义加载到IoC容器 12345678910@SuppressWarnings(\"deprecation\")@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@AutoConfigurationPackage@Import(EnableAutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration &#123; ...&#125; ​ 这其中最关键的就是@Import(EnableAutoConfigurationImportSelector.class)了，EnableAutoConfigurationImportSelector.class可以帮助SpringBoot应用将所有符合条件的@Configuration配置类都加载到当前SpringBoot创建并使用的IoC容器。 下面我们给出EnableAutoConfigurationImportSelector.java的父类AutoConfigurationImportSelector.java的部分源码，来解释和验证 12345678910111213public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware,BeanFactoryAware, EnvironmentAware, Ordered &#123; protected List&lt;AutoConfigurationImportFilter&gt; getAutoConfigurationImportFilters() &#123; return SpringFactoriesLoader.loadFactories(AutoConfigurationImportFilter.class, this.beanClassLoader); &#125; protected List&lt;AutoConfigurationImportListener&gt; getAutoConfigurationImportListeners() &#123; return SpringFactoriesLoader.loadFactories(AutoConfigurationImportListener.class, this.beanClassLoader); &#125;&#125; 以上源码可以看出，@EnableAutoConfiguration正是借助SpringFactoriesLoader的支持，完成所有配置类都加载 到当前SpringBoot创建并使用的IOC容器. SpringFactoriesLoader详解​ SpringFactoriesLoader属于Spring框架专属的一种扩展方案(其功能和使用方式类似于Java的SPI方案:java.util.ServiceLoader)，它的主要功能就是从指定的配置文件META-INF/spring.factories中加载配置，spring.factories是一个非常经典的java properties文件，内容格式是Key=Value形式，只不过这Key以及Value都非常特殊，为Java类的完整类名(Fully qualified name)。 ​ 对于@EnableAutoConfiguraion来说，SpringFactoriesLoader的用途和其本意稍微不同，它本意是为了提供SPI扩展，而在@EnableAutoConfiguration这个场景下，它更多的是提供了一种配置查找的功能的支持。 1234567891011121314151617181920212223# Initializersorg.springframework.context.ApplicationContextInitializer=\\org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\\org.springframework.boot.autoconfigure.logging.AutoConfigurationReportLoggingInitializer# Application Listenersorg.springframework.context.ApplicationListener=\\org.springframework.boot.autoconfigure.BackgroundPreinitializer# Auto Configuration Import Listenersorg.springframework.boot.autoconfigure.AutoConfigurationImportListener=\\org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener# Auto Configuration Import Filtersorg.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\\org.springframework.boot.autoconfigure.condition.OnClassCondition# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\ 这是spring-boot-autoconfigure-1.5.10.RELEASE.jar下的spring.factories。 非必须的@ComponentScan解析​ 为什么说这个注解是非必需的呢？因为我们知道作为Spring框架里的老成员，@ComponentScan的功能就是自动扫描并加载复合条件的组件或Bean定义，最终将这些bean定义加载到当前使用的容器中。这个过程，我们可以手工单个进行注册，不是一定要通过这个注解批量扫描和注册，所以说@ComponentScan是非必需的。 ​ 所以，如果我们当前应用没有任何bean定义需要通过@ComponentScan加载到当前SpringBoot应用对应的IoC容器，那么，去掉@ComponentScan注解，当前的SpringBoot应用依旧可以完美运行！ ​ 扩展机制和starter进行自定义实现​ 自定义封装一个starter ​ ​ ​ 参考:https://www.cnblogs.com/hjwublog/p/10335464.html springboot中的元数据​ spring-boot-autoconfigure-1.5.10.RELEASE.jar包含元数据文件，提供所有支持的配置属性的详细信息。这些文件旨在允许IDE开发人员在用户使用application.properties 或application.yml文件时提供上下文帮助和自动补全 。 主要的元数据文件是在编译器通过处理所有被@ConfigurationProperties注解的节点来自动生成的。（自定义的 一些自动配置包也可以提供，例如mybatis-spring-boot-autoconfigure.jar） 配置元数据位于jar文件中的META-INF/spring-configuration-metadata.json，它们使用一个具有”groups”或”properties”分类节点的简单JSON格式。 如果不知道springboot是否支持某个配置的话，可以查看元数据文件看是否有对应的节点。 注意： ​ 在application.properties中，驼峰的写法有两种，都是可以的 123spring.datasource.driver-class-name=com.mysql.jdbc.Driverspring.datasource.driverClassName=com.mysql.jdbc.Driver ​","categories":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/categories/SpringBoot/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://yoursite.com/tags/SpringBoot/"}]},{"title":"java的classpath","slug":"JavaSE/java的classpath","date":"2019-08-25T09:46:31.000Z","updated":"2019-09-11T09:23:44.847Z","comments":true,"path":"2019/08/25/JavaSE/java的classpath/","link":"","permalink":"http://yoursite.com/2019/08/25/JavaSE/java的classpath/","excerpt":"","text":"java中classpath理解类路径(classpath)​ 默认java虚拟机要从classpath环境变量的路径中搜索class文件去执行，对于java虚拟机来说，这不是类文件，而是类。它只有类路径，而没有文件系统路径。而classpath环境变量正是为java虚拟机提供搜索类路径的环境。注意，虚拟机不会递归搜索classpath定义的路径。（因此，在spring中有classpath*,表示递归classpath定义的路径下的所有路径） java编译器编译.java文件和java虚拟机执行.class文件时的路径和写法不一样。在没有设置任何classpath环境变量的情况下，javac可以编译全路径的.java文件 ​ 要明确的是javac编译器搜索的是文件路径，和环境变量classpath无关。而java虚拟机搜索的是类文件，严格地说是类，搜索路径由环境变量classpath决定，且有先后顺序 (1).何时需要使用-classpath：当你要编译或执行的类引用了其它的类，但被引用类的.class文件不在当前目录下时，就需要通过-classpath来引入类路径 (2).何时需要指定路径：当你要编译的类所在的目录和你执行javac命令的目录不是同一个目录时，就需要指定源文件的路径(CLASSPATH是用来指定.class路径的，不是用来指定.java文件的路径的) 包(package)1）​ 包是类的集合。在java源文件的第一行(不包括注释行或空行)写上package关键字并给定包名，即可将该类文件放到包中。 ​ javac在编译时从路径上搜索文件。例如，将这个Cat.java放到com/longshuai/home下。执行时java虚拟机从classpath搜索要加载的类文件，而加载类的方式是使用”.”连接各类名。所以编译这个文件和java虚拟机执行这个文件时的方法分别是： 12javac com/longshuai/home/Cat.javajava com.longshuai.home.Cat 注意，嵌套的包之间没有任何关系，例如java.util包和java.util.jar包没有任何依赖关系。 2）​ 在某个java源文件中，无法直接使用其他文件中的类，除非要使用的这个类正好能被classpath的路径搜索到。要引用非classpath下的其他类，只能将其添加到classpath或者装入package中，然后引用包中的类。 ​ 导入包时可以在尾部使用星号”“通配导入的所有类，只能在尾部使用”“，因为”“匹配的是类名，而不是包名。也因此，不能在非结尾处使用”“号来表示导入其他包中的类，例如： 12import com.longshuai.home.*; //导入com.longshuai.home包中的所有类import com.longshuai.*; //导入com.longshuai包中所有类，但不会导入com.longshuai.home中类 类搜索机制​ 在java虚拟机搜索类文件时，除了classpath环境变量指定的路径，还会先搜索两个默认的路径:jre/lib和jre/lib/ext下的jar文件中似乎否有待搜索的类。 ​ 例如，当classpath设置为”.;d:\\myjava;d:\\myjar.jar”时，要搜索com.longshuai.com.Cat类文件：(a).先搜索jre/lib和jre/lib/ext下的jar文件;(b).再搜索当前目录下是否有com\\longshuai\\com\\Cat.class;(c).再搜索d:\\myjava\\Cat.class;(d).搜索d:\\myjar.jar文件中是否有com.longshuai.com.Cat类。 如果在某个java源文件中引用了某个类，则在编译时，将通过以下几种方式判断该类是否合理有效： (1).搜索导入的包类中是否包含该类。(2).搜索隐式导入的java.lang包，该包是默认导入的。(3).当前文件中是否定义了该类。(4).按照类路径的搜索规则((a)-(d))搜索其中是否有该类。 JAVA获取classpath路径：ClassLoader 提供了两个方法用于从装载的类路径中取得资源： ​ public URL getResource (String name);​ public InputStream getResourceAsStream (String name); 这里name是资源的类路径，它是相对与“/”根路径下的位置。getResource得到的是一个URL对象来定位资源，而getResourceAsStream取得该资源输入流的引用保证程序可以从正确的位置抽取数据。 但是真正使用的不是ClassLoader的这两个方法，而是Class的 getResource和getResourceAsStream方法，因为Class对象可以从你的类得到（如YourClass.class或 YourClass.getClass()），而ClassLoader则需要再调用一次YourClass.getClassLoader()方法，不过根据JDK文档的说法，Class对象的这两个方法其实是“委托”（delegate）给装载它的ClassLoader来做的，所以只需要使用 Class对象的这两个方法就可以了。 ​ 因此，直接调用 this.getClass().getResourceAsStream(String name) ;获取流，静态化方法中则使用ClassLoader.getSystemResourceAsStream (String name) ; 。 12345678910111213141516171819202122231.this.getClass().getResource（&quot;&quot;） 得到的是当前类class文件的URI目录。不包括自己！如：file：/D：/workspace/jbpmtest3/bin/com/test/2.this.getClass().getResource（&quot;/&quot;） 得到的是当前的classpath的绝对URI路径 。如：file：/D：/workspace/jbpmtest3/bin/3.this.getClass() .getClassLoader().getResource（&quot;&quot;） 得到的也是当前ClassPath的绝对URI路径 。如：file：/D：/workspace/jbpmtest3/bin/4.ClassLoader.getSystemResource（&quot;&quot;） 得到的也是当前ClassPath的绝对URI路径 。如：file：/D：/workspace/jbpmtest3/bin/5.Thread.currentThread().getContextClassLoader ().getResource（&quot;&quot;） 得到的也是当前ClassPath的绝对URI路径 。如：file：/D：/workspace/jbpmtest3/bin/6.ServletActionContext.getServletContext().getRealPath(“/”) Web应用程序 中，得到Web应用程序的根目录的绝对路径。这样，我们只需要提供相对于Web应用程序根目录的路径，就可以构建出定位资源的绝对路径。如：file：/D:/workspace/.metadata/.plugins/org.eclipse.wst.server.core/tmp0/wtpwebapps/WebProject 注意点： 1.尽量不要使用相对于System.getProperty（”user.dir”）当前用户目录的相对路径。这是一颗定时炸 弹，随时可能要你的命。 2.尽量使用URI形式的绝对路径资源。它可以很容易的转变为URI，URL，File对象。 3.尽量使用相对classpath的相对路径。不要使用绝对路径。使用上面ClassLoaderUtil类的public static URL getExtendResource（String relativePath）方法已经能够使用相对于classpath的相对路径定位所有位置的资源。 4.绝对不要使用硬编码的绝对路径。因为，我们完全可以使用ClassLoader类的getResource（””）方法得到当前classpath的绝对路径。如果你一定要指定一个绝对路径，那么使用配置文件，也比硬编码要好得多！ 获得CLASSPATH之外路径的方法：URL base = this.getClass（）.getResource（””）； //先获得本类的所在位置，如/home/popeye/testjava/build/classes/net/ String path = new File（base.getFile（）， “……/……/……/“+name）.getCanonicalPath（）； //就可以得到/home/popeye/testjava/name 另外，如果从ANT启动程序，this.getClass().getResource(“”)取出来的比较怪，直接用JAVA命令行调试就可成功。 PS：以上内容来自转载 在dos下编译Java程序，就要用到classpath这个概念，尤其是在没有设置环境变量的时候。classpath就是存放.class等编译后文件的路径。 在spring中，classpath 和 classpath* 区别： 12classpath：只会到你的class路径中查找找文件;classpath*：不仅包含class路径，还将递归classpath定义的路径下的所有子路径 如何执行指定class文件目录（classpath）如果我们 Java 编译后的class文件不在当前目录，我们可以使用 -classpath 来指定class文件目录： 1C:&gt; java -classpath C:\\java\\DemoClasses HelloWorld 以上命令中我们使用了 -classpath 参数指定了 HelloWorld 的 class 文件所在目录。 如果class文件在jar文件中，则命令如下： 1c:&gt; java -classpath C:\\java\\myclasses.jar com.test.HelloWorld javac： 如果当前你要编译的 java 文件中引用了其它的类(比如说：继承)，但该引用类的 .class 文件不在当前目录下，这种情况下就需要在 javac 命令后面加上 -classpath 参数，通过使用以下三种类型的方法 来指导编译器在编译的时候去指定的路径下查找引用类。 (1).绝对路径：javac -classpath c:/junit3.8.1/junit.jar Xxx.java (2).相对路径：javac -classpath ../junit3.8.1/Junit.javr Xxx.java (3).系统变量：javac -classpath %CLASSPATH% Xxx.java (注意：%CLASSPATH%表示使用系统变量CLASSPATH的值进行查找，这里假设Junit.jar的路径就包含在CLASSPATH系统变量中) 总结： (1).何时需要使用 -classpath：当你要编译或执行的类引用了其它的类，但被引用类的 .class 文件不在当前目录下时，就需要通过 -classpath 来引入类 (2).何时需要指定路径：当你要编译的类所在的目录和你执行 javac 命令的目录不是同一个目录时，就需要指定源文件的路径(CLASSPATH 是用来指定 .class 路径的，不是用来指定 .java 文件的路径的) assembly打包duboo-provider的理解assembly打包的目录结构 ​ bin ​ start.bat ​ ….. ​ conf ​ dubbo.properties ​ lib ​ 所有的jar包 assembly的bin下的start.bat 12345678910111213141516171819202122@echo off &amp; setlocal enabledelayedexpansionset LIB_JARS=&quot;&quot;cd ..\\libfor %%i in (*) do set LIB_JARS=!LIB_JARS!;..\\lib\\%%icd ..\\binif &quot;&quot;%1&quot;&quot; == &quot;&quot;debug&quot;&quot; goto debugif &quot;&quot;%1&quot;&quot; == &quot;&quot;jmx&quot;&quot; goto jmxjava -Xms64m -Xmx1024m -XX:MaxPermSize=64M -classpath ..\\conf;%LIB_JARS% com.alibaba.dubbo.container.Maingoto end:debugjava -Xms64m -Xmx1024m -XX:MaxPermSize=64M -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=n -classpath ..\\conf;%LIB_JARS% com.alibaba.dubbo.container.Maingoto end:jmxjava -Xms64m -Xmx1024m -XX:MaxPermSize=64M -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -classpath ..\\conf;%LIB_JARS% com.alibaba.dubbo.container.Main:endpause java -Xms64m -Xmx1024m -XX:MaxPermSize=64M -classpath ..\\conf;%LIB_JARS% com.alibaba.dubbo.container.Main ​ 根据以上的理解，该命令是执行com.alibaba.dubbo.container.Main 但是该类需要依赖许多其他类，因此需要指定-classpath (..\\conf是一个配置文件，将其加入到 classpath中，%LIB_JARS%是执行com.alibaba.dubbo.container.Main所依赖的所有jar包路径, 也将其加载到classpath中，这样，com.alibaba.dubbo.container.Main才可以正确执行) 注意： ​ 加入echo %LIB_JARS% 测试打印结果 1&quot;&quot;;..\\lib\\aopalliance-1.0.jar;..\\lib\\aspectjweaver-1.8.4.jar;..\\lib\\commons-logging-1.2.jar;..\\lib\\druid-1.0.9.jar;..\\lib\\dubbo-2.5.4.jar;..\\lib\\dubbo-mapper-0.0.1-SNAPSHOT.jar;..\\lib\\dubbo-pojo-0.0.1-SNAPSHOT.jar;..\\lib\\dubbo-user-interface-0.0.1-SNAPSHOT.jar;..\\lib\\dubbo-user-service-0.0.1-SNAPSHOT.jar;..\\lib\\hamcrest-core-1.3.jar;..\\lib\\javassist-3.20.0-GA.jar;..\\lib\\jline-0.9.94.jar;..\\lib\\junit-4.12.jar;..\\lib\\log4j-1.2.16.jar;..\\lib\\mybatis-3.2.8.jar;..\\lib\\mybatis-spring-1.2.2.jar;..\\lib\\mysql-connector-java-5.1.32.jar;..\\lib\\netty-3.2.5.Final.jar;..\\lib\\netty-3.7.0.Final.jar;..\\lib\\slf4j-api-1.6.1.jar;..\\lib\\slf4j-log4j12-1.6.4.jar;..\\lib\\spring-aop-4.1.3.RELEASE.jar;..\\lib\\spring-aspects-4.1.3.RELEASE.jar;..\\lib\\spring-beans-4.1.3.RELEASE.jar;..\\lib\\spring-context-4.1.3.RELEASE.jar;..\\lib\\spring-core-4.1.3.RELEASE.jar;..\\lib\\spring-expression-4.1.3.RELEASE.jar;..\\lib\\spring-jdbc-4.1.3.RELEASE.jar;..\\lib\\spring-tx-4.1.3.RELEASE.jar;..\\lib\\spring-web-4.1.3.RELEASE.jar;..\\lib\\zkclient-0.10.jar;..\\lib\\zookeeper-3.4.8.jar 是所有jar的路径，通过-classpath将其加入到类路径中，这样就可以引用这些jar中的.class或者资源文件 eclipse中执行的classpath分析​ eclipse的项目文件夹有一个.classpath文件，用于描述classpath 123456789&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;classpath&gt; &lt;classpathentry kind=&quot;src&quot; path=&quot;src&quot;/&gt; &lt;classpathentry kind=&quot;con&quot; path=&quot;org.eclipse.jdt.launching.JRE_CONTAINER/org.eclipse.jdt.internal.debug.ui.launcher.StandardVMType/JavaSE-1.8&quot;/&gt; &lt;classpathentry kind=&quot;lib&quot; path=&quot;lib/mysql-connector-java-8.0.11.jar&quot;/&gt; &lt;classpathentry kind=&quot;lib&quot; path=&quot;lib/commons-beanutils-1.9.3.jar&quot;/&gt; &lt;classpathentry kind=&quot;lib&quot; path=&quot;lib/commons-logging-1.2.jar&quot;/&gt; &lt;classpathentry kind=&quot;output&quot; path=&quot;bin&quot;/&gt;&lt;/classpath&gt; 将src目录，以及所引用的jar路径都添加到classpath中，这样才能保证程序正常执行。 总结​ 将一个路径添加到classpath中，则该路径下的目录或者资源可以被直接通过类路径被访问到，例如: ​ hello目录下有test,resource两个文件夹，test中有com/szxy/Test.class，resource中有一个res/index.html, ​ hello ​ test ​ com ​ test ​ Test.class ​ resource ​ res ​ index.html 执行 java -classpath ./test;./resource com.bjsxt.Test，将test和resouce都加载到类路径中， com.szxy.Test类中需要加载这个资源，通过getResourceAsStream(“res/index.html”), 因为类路径是test目录下和resource目录下，因此可以拿到资源res/index.html, 需要注意一点，不能直接getResourceAsStream(“index.html”)，因为类路径加载了不会递归查询，除非将 hello/resource/res也添加到类路径中才可以直接拿到，否则必须从类路径下沿着路径找到资源. 参考： ​ https://www.cnblogs.com/jixp/articles/9349845.html ​ https://www.runoob.com/java/env-classpath.html","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"solor全文检索服务","slug":"JavaAdvancedTechnology/Solr/Solr全文检索服务","date":"2019-08-25T09:46:31.000Z","updated":"2019-09-03T03:05:19.949Z","comments":true,"path":"2019/08/25/JavaAdvancedTechnology/Solr/Solr全文检索服务/","link":"","permalink":"http://yoursite.com/2019/08/25/JavaAdvancedTechnology/Solr/Solr全文检索服务/","excerpt":"","text":"全文检索为什么使用全文检索说明​ 没有使用全文检索的时候，大部分会利用WHERE子句匹配LIKE关键词，在庞大的数据字段中搜索某些想要的字，如： select * from test WHERE Notes LIKE ‘%你好%’ ​ 然而这种查询方式非常没有效率，即使在Notes字段建立了一般的索引，帮助也不大，因为SQL SERVER为数据表建立的索引是排序过的数据结构。因此，可以用二分搜索算法来快速寻找数据，但搜索’%你好%’可没有什么顺序可言，因为搜索条件以’%’开头.全文检索则提供完全不同的索引架构，以关键词为基础建立全文检索索引。搭配特有的SQL查询语法，对于大型文本的字词查询更具弹性和效率 例1： 123456我们有一个表大概有50万条数据，其中有一个字段是字符串类型需要实现like 模糊查询，我们使用的是mysql，虽然已经建立了索引，但是由于使用的是%a%模式匹配，很不给力，在大量并发下，数据库会挂掉，或者用户等到抓狂查询结果还不出来，后来想出了一个办法解决了这个问题，每次查询可以控制在15ms左右，效果很是不错。我们采用是全文索引技术：1、使用lucene或者其他可以提供全文索引的nosql数据库，比如tt server或mongodb2、把需要模糊查询的字段的字符串数据进行”全分词“，即把所有可能分词都枚举出来，比如abc,可以分成a,ab,abc,b,bc,c3、把这些分好的term建立索引，如果使用lucene则需要建立一个分词器，能把传入的字符串分解成第2步描述的分词后建立索引，如果使用的是mongodb，则把分好的词存入一个字段并且建立索引，如果使用的tt server，那就简单了，直接建立qgram类型的索引即可，不需要自己去分词，我们最终就是使用tt server解决的问题4、使用各自提供的查询语法进行查询，绝对高效最终采用tt server的qgram方式实现，50多万条数据的模糊查询时间不超过15毫秒，有缓存的情况可能是0ms。 例2：mysql的全文索引与like实现 12345678在数据库使用中，DBA都会告诉大家SQL的LIKE条件为%XXX%号时，由于不能使用索引，当数据量变大时(比如超过百万条)，全表扫描会导致性能很差。 但是在实际业务中，很难避免MySQL全文检索并Like索引的这种需求。比如模糊搜索用户帐号，昵称之类。既然这个需求必须做，但又不可以直接用LIKE。这里我和大家分享一下我们关于这种需求的一种解决方案。当然别人也可能采用过类似的办法，我不是很清楚。所以也用一下“原创”吧。 MySQL数据库很早就支持全文索引，但是全文索引和LIKE语句是不同的。具体点说，全文索引的单位是词，耳LIKE匹配的是字符。当然实际的区别更大，比如“老鼠爱大米”这段文本用全文搜索的话，条件“老鼠爱大米”，“老鼠和大米”，“大米老鼠”，“大米与老鼠”会搜索到内容，但是“爱”，“鼠爱”，“爱大”不会搜索到内容。反之，使用LIKE搜索时，“老鼠和大米”，“大米老鼠”，“大米与老鼠”不会找到内容，而“爱”，“鼠爱”，“爱大”会找到内容。我们这里不讨论两种方式的优劣，根据实际情况每种功能都会有各自的实际需求。比如对于大段文本，全文检索是最好的方法，但是对于姓名，帐号，昵称等很短的通常无意义文本，LIKE会更合适一些。 虽然全文检索和LIKE搜索不同，但是在特殊情况下，可以用全文搜索功能来实现LIKE搜索。具体就是每个字符作为一个词，而且使用双引号来限制词精确匹配(简单点说就是老鼠大米和大米老鼠不同)，这样可以实现LIKE搜索的功能。 来自：https://www.cnblogs.com/bobsoft/archive/2012/10/07/2714545.html 例3： 123456当我们访问购物网站的时候，我们可以根据我们随意所想的内容输入关键字就可以查询出相关的内容，这是怎么做到呢？这些随意的数据不可能是根据数据库的字段查询的，那是怎么查询出来的呢，为什么千奇百怪的关键字都可以查询出来呢？答案就是全文检索工具的实现，luncence采用了词元匹配和切分词。举个例子：北京天安门----luncence切分词：北京 京天 天安 安门 等等这些分词。所以我们搜索的时候都可以检索到。有一种分词器就是IKanalyzer中文分词器，它有细粒度切分和智能切分，即根据某种智能算法。这就使用solr的最大的好处：检索功能的实现。来自：https://blog.csdn.net/jokeylin/article/details/80562148 有数据库为什么要solr​ lucene负责数据存储，而solr只是一个引擎提供搜索和插入而已，跟数据库的解释器一样，有什么好处呢，比如一个数据库有一个字段存了1000个字，你想从这些字里面搜一个词的时候，普通的数据库只会让你使用like去查询，他会遍历每个字去模糊匹配，效率很低，而且有些是无法查询的，当然除了像一些特殊的数据库带有分词，比如postgresql，那lucene做的事情就是分词，然后去匹配分词的词中是否有你想搜的词就好了，当然了，为了提高这种检索效率和内存节省底层做了很复杂的事情，可以这么简单的认为，全文搜索这件事情上数据库是无法满足的 二​ 大型的SQL数据库上很难执行高速的查询。Solr是Apache 下的一个开源项目，使用Java基于Lucene开发的全文检索服务；它是一个独立的企业级搜索应用服务器，它对外提供类似于Web-service的API接口。用户可以通过http请求，向搜索引擎服务器提交一定格式的XML文件，生成索引；也可以通过Http Get操作提出查找请求，并得到XML格式的返回结果。 ​ 为什么使用solr??????? 第一点原因来自SQL数据库在性能上缺乏亮点。基本上，你需要在你的查询中使用JOIN操作。 第二点原因是文档的天然数据特性：松散的文本文件，这种查询都是需要使用LIKE。然而joins和likes都是性能杀手，在目前的数据库引擎中是不方便的。 所以，很多时候希望找到一种跟SQL完全不同的数据检索方式：倒排索引。 这种数据结构类似与美化过的词典： key是单个的term values是跟term对应的文档列表 这种数据方式可以帮助在大型的数据库上面进行高速查询。 全文检索定义数据分类我们生活中的数据总体分为两种：结构化数据和非结构化数据。 结构化数据：指具有固定格式或有限长度的数据，如数据库中的数据，元数据等。 非结构化数据：指不定长或无固定格式的数据，如邮件，word文档等磁盘上的文件。 非结构化数据查询方法顺序扫描法(Serial Scanning)​ 所谓顺序扫描，比如要找内容包含某一个字符串的文件，就是一个文档一个文档的看，对于每一个文档，从头看到尾，如果此文档包含此字符串，则此文档为我们要找的文件，接着看下一个文件，直到扫描完所有的文件。如利用windows的搜索也可以搜索文件内容，只是相当的慢。 全文检索(Full-text Search)​ 将非结构化数据中的一部分信息提取出来，重新组织，使其变得有一定结构，然后对此有一定结构的数据进行搜索，从而达到搜索相对较快的目的。这部分从非结构化数据中提取出的然后重新组织的信息，我们称之索引。例如：字典。字典的拼音表和部首检字表就相当于字典的索引，对每一个字的解释是非结构化的，如果字典没有音节表和部首检字表，在茫茫辞海中找一个字只能顺序扫描。然而字的某些信息可以提取出来进行结构化处理，比如读音，就比较结构化，分声母和韵母，分别只有几种可以一一列举，于是将读音拿出来按一定的顺序排列，每一项读音都指向此字的详细解释的页数。我们搜索时按结构化的拼音搜到读音，然后按其指向的页数，便可找到我们的非结构化数据——也即对字的解释。这种先建立索引，再对索引进行搜索的过程就叫全文检索(Full-text Search)。虽然创建索引的过程也是非常耗时的，但是索引一旦创建就可以多次使用，全文检索主要处理的是查询，所以耗时间创建索引是值得的。 如何实现全文检索可以使用Lucene实现全文检索。Lucene是apache下的一个开放源代码的全文检索引擎工具包（提供了Jar包，实现全文检索的类库）。它提供了完整的查询引擎和索引引擎，部分文本分析引擎。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便地在目标系统中实现全文检索的功能。注意：Lucene只是一个引擎，只是一个工具包，如果使用Lucene开发全文检索功能，要记住Lucene是不能单独运行的。 全文检索技术的应用场景对于数据量大、数据结构不固定的数据可采用全文检索方式搜索。例如： 使用全文检索技术可以实现搜索引擎（百度、google…），搜索引擎可以搜索互联网上所有的内容（网页、pdf电子书、视频、音乐）。Lucene和搜索引擎的区别：搜索引擎是对外提供全文检索服务，是可以单独运行的。Lucene只是一个工具包不能单独运行，需要在project中加入lucene的jar包，最终project在JVM中运行。使用全文检索技术可以实现站内搜索，站内搜索只能搜索本网站的信息（网页、pdf电子书、视频、音乐、关系数据库中的信息等等），比如：电商网站搜索商品信息，论坛网站搜索网内帖子。 总结全文检索过程分为索引、搜索两个过程： 索引从关系数据库中、互联网上、文件系统采集源数据(要搜索的目标信息)，源数据的来源是很广泛的。将源数据采集到一个统一的地方，要创建索引，将索引创建到一个索引库（文件系统）中，从源数据库中提取关键信息，从关键信息中抽取一个一个词，词和源数据是有关联的。也即创建索引时，词和源数据有关联，索引库中记录了这个关联，如果找到了词就说明找到了源数据（http的网页、pdf电子书等……）。 搜索用户执行搜索（全文检索）编写查询关键字。从索引库中搜索索引，根据查询关键字搜索索引库中的一个一个词。展示搜索的结果。 全文检索实现创建索引​ 对文档索引的过程，将用户要搜索的文档内容进行索引，索引存储在索引库（index）中。这里我们要搜索的文档是磁盘上的文本文件，根据案例描述：凡是文件名或文件内容包括关键字的文件都要找出来，这里要对文件名和文件内容创建索引。 获得原始文档​ 原始文档是指要索引和搜索的内容。原始内容包括互联网上的网页、数据库中的数据、磁盘上的文件等 ​ 从互联网上、数据库、文件系统中等数据源处获取需要搜索的原始信息，这个过程就是信息采集，信息采集的目的是为了对原始内容进行索引。针对不同的源数据，使用不同的技术进行采集获得原始文档： 针对互联网上的数据，使用http协议抓取html网页到本地，生成一个html文件。针对关系数据库中的数据，连接数据库读取表中的数据。针对文件系统中的数据，通过流读取文件系统的文件。 以上技术中使用第一种较多，因为目前全文检索主要搜索数据的来源是互联网，在Internet上采集信息的软件通常称为爬虫或蜘蛛，也称为网络机器人，爬虫访问互联网上的每一个网页，将获取到的网页内容存储起来，所以搜索引擎使用一种爬虫程序抓取网页（ 通过http抓取html网页信息）。Lucene不提供信息采集的类库，需要自己编写一个爬虫程序实现信息采集，也可以通过一些开源软件实现信息采集，以下是一些爬虫项目（了解）： 1234Solr（http://lucene.apache.org/solr），solr是apache的一个子项目，支持从关系数据库、xml文档中提取原始数据。Nutch（http://lucene.apache.org/nutch）, Nutch是apache的一个子项目，包括大规模爬虫工具，能够抓取和分辨web网站数据。jsoup（http://jsoup.org/ ），jsoup是一款Java的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。Heritrix（http://sourceforge.net/projects/archive-crawler/files/），Heritrix是一个由java开发的、开源的网络爬虫，用户可以使用它来从网上抓取想要的资源。其最出色之处在于它良好的可扩展性，方便用户实现自己的抓取逻辑。 创建文档对象分析文档创建索引查询索引用户查询接口创建查询执行查询渲染结果Solr集群配置的一些说明​ 1)安装zookeeper集群，做配置管理 ​ 2)安装四个tomcat,和四个索引库，依旧是一对一(solr的web服务中web.xml配置索引库的绝对路径) ​ 3)上传索引库的配置文件至zookeeper(索引库目录下的collection/conf) ​ 4)修改每一个索引库下的 solr.xml,指定当前实例运行的ip地址及端口号 ​ 5)修改每一台solr的tomcat的bin目录下 catalina.sh文件中加入DzkHost指定zookeeper服务器地址 ​ JAVA_OPTS=”-DzkHost=192.168.70.147:2181,192.168.70.147:2182,192.168.70.14 7:2183” ​ 注意：加入JAVA_OPTS的参数的含义，也就是程序可以读取该键值对配置 12345678910111213141516171819202122JVM自定义参数通过java命令的可选项:-D&lt;name&gt;=&lt;value&gt;来传入JVM，传入的参数作为system的property。因此在程序中可以通过下面的语句获取参数值：System.getProperty(&lt;name&gt;)public class JVMParameter &#123; /** * 运行前设置JVM参数 -Djvm.index=1 * @param args */ public static void main(String[] args) &#123; // TODO Auto-generated method stub String jvmIndex = System.getProperty(&quot;jvm.index&quot;); System.out.println(&quot;jvmIndex=&quot; + jvmIndex); &#125;&#125;运行class命令：java -Djvm.index=1 JVMParameter说明：JVM自定义参数可用来在集群环境区分当前class运行在哪个JVM上，可以达到让某个class只在某个指定的JVM上运行，避免多个JVM同时运行，出现混乱。也可以作为程序读取的配置信息 参考： ​ https://blog.csdn.net/qq_16162981/article/details/70142166 ​ https://blog.csdn.net/yerenyuan_pku/article/details/72582979","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"dubbo使用","slug":"JavaAdvancedTechnology/Dubbo/dubbo使用","date":"2019-08-25T09:46:31.000Z","updated":"2019-08-27T06:02:09.810Z","comments":true,"path":"2019/08/25/JavaAdvancedTechnology/Dubbo/dubbo使用/","link":"","permalink":"http://yoursite.com/2019/08/25/JavaAdvancedTechnology/Dubbo/dubbo使用/","excerpt":"","text":"assembly打包后启动provider分析assembly打包的目录结构 ​ bin ​ start.bat ​ ….. ​ conf ​ dubbo.properties ​ lib ​ 所有的jar包 assembly包的bin下的start.bat（windows下的启动脚本） 12345678910111213141516171819202122@echo off &amp; setlocal enabledelayedexpansionset LIB_JARS=&quot;&quot;cd ..\\libfor %%i in (*) do set LIB_JARS=!LIB_JARS!;..\\lib\\%%icd ..\\binif &quot;&quot;%1&quot;&quot; == &quot;&quot;debug&quot;&quot; goto debugif &quot;&quot;%1&quot;&quot; == &quot;&quot;jmx&quot;&quot; goto jmxjava -Xms64m -Xmx1024m -XX:MaxPermSize=64M -classpath ..\\conf;%LIB_JARS% com.alibaba.dubbo.container.Maingoto end:debugjava -Xms64m -Xmx1024m -XX:MaxPermSize=64M -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=n -classpath ..\\conf;%LIB_JARS% com.alibaba.dubbo.container.Maingoto end:jmxjava -Xms64m -Xmx1024m -XX:MaxPermSize=64M -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false -classpath ..\\conf;%LIB_JARS% com.alibaba.dubbo.container.Main:endpause java -Xms64m -Xmx1024m -XX:MaxPermSize=64M -classpath ..\\conf;%LIB_JARS% com.alibaba.dubbo.container.Main ​ 根据以上的理解，该命令是执行com.alibaba.dubbo.container.Main 但是该类需要依赖许多其他类，因此需要指定-classpath (..\\conf是一个配置文件，将其加入到 classpath中，%LIB_JARS%是执行com.alibaba.dubbo.container.Main所依赖的所有jar包路径, 也将其加载到classpath中，这样，com.alibaba.dubbo.container.Main才可以正确执行) 注意： ​ 加入echo %LIB_JARS% 测试打印结果 1&quot;&quot;;..\\lib\\aopalliance-1.0.jar;..\\lib\\aspectjweaver-1.8.4.jar;..\\lib\\commons-logging-1.2.jar;..\\lib\\druid-1.0.9.jar;..\\lib\\dubbo-2.5.4.jar;..\\lib\\dubbo-mapper-0.0.1-SNAPSHOT.jar;..\\lib\\dubbo-pojo-0.0.1-SNAPSHOT.jar;..\\lib\\dubbo-user-interface-0.0.1-SNAPSHOT.jar;..\\lib\\dubbo-user-service-0.0.1-SNAPSHOT.jar;..\\lib\\hamcrest-core-1.3.jar;..\\lib\\javassist-3.20.0-GA.jar;..\\lib\\jline-0.9.94.jar;..\\lib\\junit-4.12.jar;..\\lib\\log4j-1.2.16.jar;..\\lib\\mybatis-3.2.8.jar;..\\lib\\mybatis-spring-1.2.2.jar;..\\lib\\mysql-connector-java-5.1.32.jar;..\\lib\\netty-3.2.5.Final.jar;..\\lib\\netty-3.7.0.Final.jar;..\\lib\\slf4j-api-1.6.1.jar;..\\lib\\slf4j-log4j12-1.6.4.jar;..\\lib\\spring-aop-4.1.3.RELEASE.jar;..\\lib\\spring-aspects-4.1.3.RELEASE.jar;..\\lib\\spring-beans-4.1.3.RELEASE.jar;..\\lib\\spring-context-4.1.3.RELEASE.jar;..\\lib\\spring-core-4.1.3.RELEASE.jar;..\\lib\\spring-expression-4.1.3.RELEASE.jar;..\\lib\\spring-jdbc-4.1.3.RELEASE.jar;..\\lib\\spring-tx-4.1.3.RELEASE.jar;..\\lib\\spring-web-4.1.3.RELEASE.jar;..\\lib\\zkclient-0.10.jar;..\\lib\\zookeeper-3.4.8.jar 是所有jar的路径，通过-classpath将其加入到类路径中，这样就可以jvm就可以加载到这些jar中的.class或者资源文件 linux环境下运行问题问题1:启动provider以下是start.sh部分代码，linux下的执行脚本 12345678910111213141516171819JAVA_OPTS=&quot; -Djava.awt.headless=true -Djava.net.preferIPv4Stack=true &quot;JAVA_DEBUG_OPTS=&quot;&quot;if [ &quot;$1&quot; = &quot;debug&quot; ]; then JAVA_DEBUG_OPTS=&quot; -Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,address=8000,server=y,suspend=n &quot;fiJAVA_JMX_OPTS=&quot;&quot;if [ &quot;$1&quot; = &quot;jmx&quot; ]; then JAVA_JMX_OPTS=&quot; -Dcom.sun.management.jmxremote.port=1099 -Dcom.sun.management.jmxremote.ssl=false -Dcom.sun.management.jmxremote.authenticate=false &quot;fiJAVA_MEM_OPTS=&quot;&quot;BITS=`java -version 2&gt;&amp;1 | grep -i 64-bit`if [ -n &quot;$BITS&quot; ]; then JAVA_MEM_OPTS=&quot; -server -Xmx2g -Xms2g -Xmn256m -XX:PermSize=128m -Xss256k -XX:+DisableExplicitGC -XX:+UseConcMarkSweepGC -XX:+CMSParallelRemarkEnabled -XX:+UseCMSCompactAtFullCollection -XX:LargePageSizeInBytes=128m -XX:+UseFastAccessorMethods -XX:+UseCMSInitiatingOccupancyOnly -XX:CMSInitiatingOccupancyFraction=70 &quot;else JAVA_MEM_OPTS=&quot; -server -Xms1g -Xmx1g -XX:PermSize=128m -XX:SurvivorRatio=2 -XX:+UseParallelGC &quot;fiecho -e &quot;Starting the $SERVER_NAME ...\\c&quot;nohup java $JAVA_OPTS $JAVA_MEM_OPTS $JAVA_DEBUG_OPTS $JAVA_JMX_OPTS -classpath $CONF_DIR:$LIB_JARS com.alibaba.dubbo.container.Main &gt; $STDOUT_FILE 2&gt;&amp;1 &amp; 注意： java $JAVA_OPTS $JAVA_MEM_OPTS $JAVA_DEBUG_OPTS $JAVA_JMX_OPTS -classpath $CONF_DIR:$LIB_JARS com.alibaba.dubbo.container.Main &gt; $STDOUT_FILE 2&gt;&amp;1 &amp; 使用了JVM参数，如果配置不当，则会导致服务无法启动，直接jvm错误（产生hs_err_pid8647.log日志文件） 目前不会配置，因此直接删除JVM参数即可,java -classpath $CONF_DIR:$LIB_JARS com.alibaba.dubbo.container.Main &gt; $STDOUT_FILE 2&gt;&amp;1 &amp; 问题2：consumer调用provider​ consumer调用provider总是产生Timeout,原本是以为服务运行时间过长导致的，于是在provider中 的META-INF/spring/application-dubbo.xml配置 12&lt;!-- 设置超时时间 --&gt;&lt;dubbo:provider timeout=&quot;5000&quot;&gt;&lt;/dubbo:provider&gt; 在dubbo-admin中可以看到超时时间被设置为5s，但是还是出现Timeout,不是该问题 以下是报异常的部分代码 root cause: 12345678910111213141516171819202122232425262728293031323334353637383940com.alibaba.dubbo.remoting.TimeoutException: Waiting server-side response timeout. start time: 2019-08-26 19:52:03.221, end time: 2019-08-26 19:52:08.222, client elapsed: 0 ms, server elapsed: 5001 ms, timeout: 5000 ms, request: Request [id=6, version=2.0.0, twoway=true, event=false, broken=false, data=RpcInvocation [methodName=selectUsersAll, parameterTypes=[], arguments=[], attachments=&#123;path=com.bjsxt.dubbo.service.FindUserDubboService, interface=com.bjsxt.dubbo.service.FindUserDubboService, version=0.0.0, timeout=5000&#125;]], channel: /192.168.1.112:48407 -&gt; /192.168.1.113:20880 com.alibaba.dubbo.remoting.exchange.support.DefaultFuture.get(DefaultFuture.java:136) com.alibaba.dubbo.remoting.exchange.support.DefaultFuture.get(DefaultFuture.java:113) com.alibaba.dubbo.rpc.protocol.dubbo.DubboInvoker.doInvoke(DubboInvoker.java:97) com.alibaba.dubbo.rpc.protocol.AbstractInvoker.invoke(AbstractInvoker.java:144) com.alibaba.dubbo.monitor.support.MonitorFilter.invoke(MonitorFilter.java:75) com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:69) com.alibaba.dubbo.rpc.protocol.dubbo.filter.FutureFilter.invoke(FutureFilter.java:54) com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:69) com.alibaba.dubbo.rpc.filter.ConsumerContextFilter.invoke(ConsumerContextFilter.java:48) com.alibaba.dubbo.rpc.protocol.ProtocolFilterWrapper$1.invoke(ProtocolFilterWrapper.java:69) com.alibaba.dubbo.rpc.listener.ListenerInvokerWrapper.invoke(ListenerInvokerWrapper.java:74) com.alibaba.dubbo.rpc.protocol.InvokerWrapper.invoke(InvokerWrapper.java:53) com.alibaba.dubbo.rpc.cluster.support.FailoverClusterInvoker.doInvoke(FailoverClusterInvoker.java:77) com.alibaba.dubbo.rpc.cluster.support.AbstractClusterInvoker.invoke(AbstractClusterInvoker.java:229) com.alibaba.dubbo.rpc.cluster.support.wrapper.MockClusterInvoker.invoke(MockClusterInvoker.java:72) com.alibaba.dubbo.rpc.proxy.InvokerInvocationHandler.invoke(InvokerInvocationHandler.java:52) com.alibaba.dubbo.common.bytecode.proxy1.selectUsersAll(proxy1.java) com.bjsxt.service.impl.UserServiceImpl.selectUserAll(UserServiceImpl.java:42) com.bjsxt.controller.UsersController.findAll(UsersController.java:31) sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method) sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62) sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43) java.lang.reflect.Method.invoke(Method.java:483) org.springframework.web.method.support.InvocableHandlerMethod.doInvoke(InvocableHandlerMethod.java:221) org.springframework.web.method.support.InvocableHandlerMethod.invokeForRequest(InvocableHandlerMethod.java:137) org.springframework.web.servlet.mvc.method.annotation.ServletInvocableHandlerMethod.invokeAndHandle(ServletInvocableHandlerMethod.java:110) org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.invokeHandleMethod(RequestMappingHandlerAdapter.java:777) org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter.handleInternal(RequestMappingHandlerAdapter.java:706) org.springframework.web.servlet.mvc.method.AbstractHandlerMethodAdapter.handle(AbstractHandlerMethodAdapter.java:85) org.springframework.web.servlet.DispatcherServlet.doDispatch(DispatcherServlet.java:943) org.springframework.web.servlet.DispatcherServlet.doService(DispatcherServlet.java:877) org.springframework.web.servlet.FrameworkServlet.processRequest(FrameworkServlet.java:966) org.springframework.web.servlet.FrameworkServlet.doGet(FrameworkServlet.java:857) javax.servlet.http.HttpServlet.service(HttpServlet.java:621) org.springframework.web.servlet.FrameworkServlet.service(FrameworkServlet.java:842) javax.servlet.http.HttpServlet.service(HttpServlet.java:728) org.apache.tomcat.websocket.server.WsFilter.doFilter(WsFilter.java:51) org.springframework.web.filter.CharacterEncodingFilter.doFilterInternal(CharacterEncodingFilter.java:88) org.springframework.web.filter.OncePerRequestFilter.doFilter(OncePerRequestFilter.java:107) 问题解决： ​ provider(192.168.1.113)中使用的是192.168.1.103的主机的mysql,而192.168.1.103的防火墙需要打开 ​ 然后重启provider即可. 注意： ​ consumer和provider两台主机需要开放dubbo协议连接的所需端口(连接形成一个channel: /192.168.1.112:52877 -&gt; /192.168.1.113:20880) ​ 1）provider：配置服务端口 ​ linux中开放服务端口，例如20880（或者关闭防火墙，否则consumer启动失败） ​ iptables相关配置： 1234561)iptables -nL --line-number 查看规则，行号2)iptables -D INPUT 6 删除行号为6的规则# 因为最后一行是reject-with icmp-host-prohibited，拒绝所有,因此需要插入到最后一行前面3)iptables -I INPUT 3 -p tcp --dport 8080 -j ACCEPT 添加规则插入到第3行，#注意不要使用service iptables restart,否则规则会到最后一行4)iptables-save 保存即可 ​ 2）consumer: ​ 请求连接并获得回应：channel: /192.168.1.112:37711 -&gt; /192.168.1.113:20880 注意：37711端口没有开放为什么可以得到回应? 12345IPtable第一条规则1 ACCEPT all -- 0.0.0.0/0 0.0.0.0/0 state RELATED,ESTABLISHED 这个想要进入的封包是否为刚刚我发出去的回应?如果是刚刚我发出去的回应,那麼就可以予以接受放行.ESTABLISHED：已建立的链接状态.RELATED：该封包为本机发出的封包有关. 192.168.1.112:37711向192.168.1.113:20880请求服务，provider处理完毕，再通过192.168.1.113:20880将结果回应给192.168.1.112:37711。 由于是37711建立的连接，按照iptables的第一条规则所以允许接收，因此consumer的37711这个端口可以不建立iptables放行规则。 Dubbo注册IP混乱的问题windows​ 关闭其他网卡服务，例如虚拟机的vmnet1,vmnet8 linuxa) 通过hostname命令得到机器名b) 通过vim /etc/hosts设置机器名对应的外网IP127.0.0.1 localhost localhost.localdomain外网IP VM_31_182_centos 示例配置: 123127.0.0.1 localhost localhost.localdomain localhost4 localhost4.localdomain4::1 localhost localhost.localdomain localhost6 localhost6.localdomain6192.168.1.112 slave1 consumer启动问题以及远程部署远程部署consumer​ 通过maven插件远程部署consumer(一个web项目)至tomcat，由于 zookeeper 注册中心没有开启， 因此consumer无法从zookeeper获取服务接口信息，初始化会失败，即项目启动失败。 注意： ​ 远程部署需要配置tomcat用户,conf/tomcat-users.xml 123&lt;role rolename=&quot;manager-gui&quot;/&gt;&lt;role rolename=&quot;manager-script&quot;/&gt;&lt;user username=&quot;tomcat&quot; password=&quot;tomcat&quot; roles=&quot;manager-gui,manager-script&quot;/&gt; 将consumer项目拷贝至tomcat的webapps下注意： ​ 在consumer的项目中，如果使用的某些路径是/,则要将其拷贝至ROOT中 将consumer拷贝至webapps目录下，启动tomcat,如果zookeeper注册中心没有启动， 或者zookeeper启动但是consumer无法获取需要的服务接口信息，都会导致consumer启动 失败.","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Maven项目构建工具","slug":"Tools/Maven项目构建工具","date":"2019-08-14T15:24:08.000Z","updated":"2019-08-16T10:00:13.477Z","comments":true,"path":"2019/08/14/Tools/Maven项目构建工具/","link":"","permalink":"http://yoursite.com/2019/08/14/Tools/Maven项目构建工具/","excerpt":"","text":"MavenMaven 简介​ Maven 是一个项目管理工具，它包含了一个项目对象模 型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管 理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标 (goal)的逻辑! IDEA使用Maven遇到的坑tomcat插件​ tomcat:run ​ 如果没有在src/main下找到webapp，则就直接启动，因此就算删除webapp目录还是可以启动tomcat 如果找到了webapp目录,就将当前项目发布(并不会在target中生成war包) 使用maven打war包后放入tomcat运行​ 打包时的项目根路径有两种方式： 1）默认从src/main/webapp作为项目根目录 ​ 2）在pom文件中指定 1234567891011&lt;plugin&gt; &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt; &lt;artifactId&gt;maven-war-plugin&lt;/artifactId&gt; &lt;version&gt;2.2&lt;/version&gt; &lt;configuration&gt; &lt;!-- 指定web.xml的路径--&gt; &lt;webXml&gt;web\\WEB-INF\\web.xml&lt;/webXml&gt; &lt;!-- 指定jsp、js、css的路径 --&gt; &lt;warSourceDirectory&gt;web&lt;/warSourceDirectory&gt; &lt;/configuration&gt; &lt;/plugin&gt; ​ 注意:打war包可以，但是指定的项目目录不被maven的tomcat插件识别，无法发布比较坑 3）将war包放到到tomcat的webapps目录进行发布 ​ 注意: ​ 路径问题: ​ 引入： ​ 例如：IDEA发布时使用Application context为/, ​ 即使用http://localhost:8080就可以访问项目 ​ 但是，在重定向时路径/表示服务器根路径， ​ 则路径写法：/项目名/需要跳转的路径 ​ 如果写死,项目在需要使用项目名或者不需要使用项目名访问时，访问就会出现问题 ​ 或者是jsp文件中路径 ​ 解决： ​ 项目中最好使用req.getContextPath() + “/login”来得到工程名+路径 ​ 这样在发布时有没有项目名都可以正常运行 ​ jsp文件可以使用基路径来控制:先得到路径，再使用basePath标签 ​","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/tags/tools/"}]},{"title":"tomcat9.0的filter拦截静态资源问题","slug":"Java Web/tomcat9.0的filter拦截静态资源问题","date":"2019-08-13T15:33:08.000Z","updated":"2019-08-14T04:28:33.026Z","comments":true,"path":"2019/08/13/Java Web/tomcat9.0的filter拦截静态资源问题/","link":"","permalink":"http://yoursite.com/2019/08/13/Java Web/tomcat9.0的filter拦截静态资源问题/","excerpt":"","text":"引入tomcat9.0中，servlet-api.jar中的Filter接口有三个方法： ​ init(): public default void init(FilterConfig filterConfig); ​ doFilter(): public void doFilter(ServletRequest request, ServletResponse response,FilterChain chain); ​ destory(): public default void destroy(); init()和destory()有default修饰，也就是说， 可以不实现init()和destory()方法，实现该接口的类会继承这两个方法 无法解决的问题？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？？ 定义MyFilter实现Filter接口，重写doFilter()方法，拦截路径/*，这样会拦截所有的资源。 接着，对请求和响应进行设置编码格式,再放行 123456789101112@Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException &#123; //设置请求编码格式 request.setCharacterEncoding(&quot;utf-8&quot;); //设置响应编码格式 response.setCharacterEncoding(&quot;utf-8&quot;); //浏览器的解码格式 response.setContentType(&quot;text/html;charset=utf-8&quot;); //放行 chain.doFilter(request, response); &#125; 问题出现: ​ 访问静态资源全部变成document类型 ​ 例如访问一个图片，该图片会以文档的形式被浏览器解析 问题定位: ​ 设置响应编码格式的问题，具体原因 ​ 浏览器解析成text/html格式 ​ response.setContentType(“text/html;charset=utf-8”); ​ 解决: ​ 解决1 ​ tomcat7不会出现该问题 ​ 解决2： ​ 对静态资源，非静态资源进行判断 ​ 如果是静态资源，不设置响应编码格式 ​ 默认会自动设置响应格式 ​ 例如：图片格式Content-Type:image/jpeg;charset=utf-8 ​ 如果是非静态资源，再设置响应编码格式","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"servlet中的请求路径","slug":"Java Web/servlet中的请求路径","date":"2019-08-09T07:23:02.000Z","updated":"2019-08-10T16:04:20.452Z","comments":true,"path":"2019/08/09/Java Web/servlet中的请求路径/","link":"","permalink":"http://yoursite.com/2019/08/09/Java Web/servlet中的请求路径/","excerpt":"","text":"关于servlet配置中 / 和 /*配置为 / ，结果 test、test.do、test.html 都可以请求到，但是test.jsp请求不到 “/‘表示匹配所有请求（其中包含除.jsp和.jspx外的所有后缀）。 如果不配置静态资源，它会把匹配所有请求都当做是对控制器的访问，去掉后缀进行匹配。例如你访问/main.css会变成/main，这也是造成你引入的.css,.js等静态资源无法访问的原因，因为他们都被当做控制器的路径了。 12345&lt;url-pattern&gt;/&lt;/url-pattern&gt;这个/不会覆盖任何其他servlet。它只对所有请求替换servlet容器的内置默认servlet，这与任何其他注册的servlet都不匹配。这通常只在静态资源(CSS/JS/Image/etc)和目录清单上调用。servlet容器的内置默认servlet还能够处理HTTP缓存请求、媒体(音频/视频)流和文件下载恢复。通常，您不希望覆盖默认的servlet，因为否则您就必须处理它的所有任务，这并不简单(JSF实用程序库)OmniFaces有一个开源 例)。因此，这也是servlet的一个糟糕的URL模式。至于为什么JSP页面不访问这个servlet，这是因为servlet容器的内置JSPservlet将被调用，默认情况下，它已经映射到了更具体的URL模式上*.jsp. 配置为 /* ，结果 test、test.do、test.html、test.jsp 都可以请求到，这意味着如果你配置成这个，跳转回jsp页面都会被拦截，所以需要注意 “/*“表示匹配所有请求（包含所有后缀） 这里*.jsp比”/\\“的匹配度低，所以配置后会使.jsp也进入DispatcherServlet,而.jsp既不是控制器路径也不是静态资源，所以就算配了静态资源还是访问不到，所以这个/*的配置不适用于DispatcherServlet,一般用于过滤器来拦截所有资源 123&lt;url-pattern&gt;/*&lt;/url-pattern&gt;这个/*在servlet上覆盖所有其他servlet，包括servlet容器提供的所有servlet，比如默认的servlet和JSP servlet。不管您发出什么请求，它都将在那个servlet中结束。因此，对于servlet来说，这是一个糟糕的URL模式。 通常，/\\在上Filter使用。它可以通过调用FilterChain#doFilter().放行* 参考1：https://www.cnblogs.com/coder-lichao/p/10698996.html /*.do错误Servlet和filter是J2EE开发中常用的技术，使用方便，配置简单，老少皆宜。 估计大多数朋友都是直接配置用，也没有关心过具体的细节，今天遇到一个问题，上网查了servlet的规范才发现，servlet和filter中的url-pattern还是有一些文章在里面的，总结了一些东西，放出来供大家参考，以免遇到问题又要浪费时间。 一、servlet容器对url的匹配过程 当一个请求发送到servlet容器的时候，容器先会将请求的url减去当前应用上下文的路径作为servlet的映射url，比如我访问的是 http://localhost/test/aaa.html，我的应用上下文是test，容器会将http://localhost/test去掉， 剩下的/aaa.html部分拿来做servlet的映射匹配。这个映射匹配过程是有顺序的，而且当有一个servlet匹配成功以后，就不会去理会剩下 的servlet了（filter不同，后文会提到）。其匹配规则和顺序如下： 1. 精确路径匹配。例子：比如servletA 的url-pattern为 /test，servletB的url-pattern为 /* ，这个时候，如果我访问的url为http://localhost/test ，这个时候容器就会先进行精确路径匹配，发现/test正好被servletA精确匹配，那么就去调用servletA，也不会去理会其他的 servlet了。 2. 最长路径匹配。例子：servletA的url-pattern为/test/，而servletB的url-pattern为/test/a/，此 时访问http://localhost/test/a时，容器会选择路径最长的servlet来匹配，也就是这里的servletB. 3. 扩展匹配，如果url最后一段包含扩展，容器将会根据扩展选择合适的servlet.例子：servletA的url-pattern：*.action 4. 如果前面三条规则都没有找到一个servlet，容器会根据url选择对应的请求资源。如果应用定义了一个default servlet，则容器会将请求丢给default servlet（什么是default servlet？后面会讲）。 根据这个规则表，就能很清楚的知道servlet的匹配过程，所以定义servlet的时候也要考虑url-pattern的写法，以免出错。 对于filter，不会像servlet那样只匹配一个servlet，因为filter的集合是一个链，所以只会有处理的顺序不同，而不会出现只选择一个filter.Filter的处理顺序和filter-mapping在web.xml中定义的顺序相同。 二、url-pattern详解 在web.xml文件中，以下语法用于定义映射： 以“/‘开头和以”/*“结尾的是用来做路径映射的 以前缀“*.”开头的是用来做扩展映射的 “是用来定义default servlet映射的。 剩下的都是用来定义详细映射的。比如： /aa/bb/cc.action 所以，为什么定义“/*.action”这样一个看起来很正常的匹配会错？因为这个匹配即属于路径映射，也属于扩展映射，导致容器无法判断。 原文：https://passw0rd-j.iteye.com/blog/2156919","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"java中调用父类方法之super关键字","slug":"JavaSE/java中调用父类方法之super关键字","date":"2019-08-04T15:12:33.000Z","updated":"2019-08-04T15:24:51.360Z","comments":true,"path":"2019/08/04/JavaSE/java中调用父类方法之super关键字/","link":"","permalink":"http://yoursite.com/2019/08/04/JavaSE/java中调用父类方法之super关键字/","excerpt":"","text":"123456789101112131415161718192021222324252627 class Father &#123; String name; int age; public void test() &#123; System.out.println(\"我是父类的test()方法\"); System.out.println(\"父类姓名=\" + this.name + \" 父类年龄=\" + this.age); &#125; &#125; public class Son extends Father &#123; public void test() &#123; super.test(); System.out.println(\"我是子类的test()方法\"); System.out.println(\"子类姓名=\" + this.name + \" 子类年龄=\" + this.age); &#125; public static void main(String[] args) &#123; Son son = new Son(); son.name = \"test\"; son.age = 18; son.test(); &#125; &#125; 理解1： 1）我觉得super.test()只是在说调用父类中的test方法，并不是说用父类对象来调用父类的test方法。而你使用son子对象来调用子类的test方法，此时虽然子类test中有父类的test方法，但是你此时是使用son子对象来调用父类的test方法的，所以父类的test方法里面的this指的是调用该方法的son子对象 2）这里面的super关键词，我觉得就是作为一个对于父类的方法的指示。参考Java核心卷；有些人认为 super 与 this 引用是类似的概念， 实际上，这样比较并不太恰当。这是因为 super 不是一个对象的引用， 不能将 super 赋给另一个对象变量， 它只是一个指示编译器调用超类方法的特殊关键字. 理解2： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public class Servlets &#123; public void service(String req,String resp)&#123; System.out.println(&quot;Servlets:service:(1)&quot;); if(req.equals(&quot;doGet&quot;))&#123; doGet(); &#125;else if(resp.equals(&quot;doPost&quot;))&#123; doPost(); &#125; &#125; public void doGet()&#123; System.out.println(&quot;Servlets.doGet:(2)&quot;); int i=1/0; &#125; public void doPost() &#123; System.out.println(&quot;Servlets.doPost:(3)&quot;); int i=1/0; &#125;&#125;public class Son extends Servlets&#123; @Override public void service(String req, String resp) &#123; // TODO Auto-generated method stub System.out.println(&quot;Son.service:(4)&quot;); super.service(req, resp); &#125; @Override public void doGet() &#123; // TODO Auto-generated method stub System.out.println(&quot;Son.doGet:(5)&quot;); super.doGet(); &#125; @Override public void doPost() &#123; // TODO Auto-generated method stub System.out.println(&quot;Son.doPost(6)&quot;); super.doPost(); &#125; &#125;//测试类public class Test &#123; public static void main(String[] args) &#123; Son son=new Son(); son.service(&quot;doGet&quot;,&quot;&quot;); &#125;&#125; 打印结果： 12345678910Son.service:(4)Exception in thread &quot;main&quot; java.lang.ArithmeticException: / by zeroServlets:service:(1)Son.doGet:(5)Servlets.doGet:(2) at com.servlet_source_test.Servlets.doGet(Servlets.java:14) at com.servlet_source_test.Son.doGet(Son.java:16) at com.servlet_source_test.Servlets.service(Servlets.java:7) at com.servlet_source_test.Son.service(Son.java:9) at com.servlet_source_test.Test.main(Test.java:6) 分析：son对象调用service，service中调用super.service(),父类的service中调用this.doGet()方法，很明显调用的是子类的doGet()方法,该this是son对象， super只是一个指示编译器调用超类方法的特殊关键字.","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"jsp中的注释","slug":"Java Web/jsp中的注释","date":"2019-07-25T15:08:03.000Z","updated":"2019-07-25T15:20:12.327Z","comments":true,"path":"2019/07/25/Java Web/jsp中的注释/","link":"","permalink":"http://yoursite.com/2019/07/25/Java Web/jsp中的注释/","excerpt":"","text":"jsp注释&lt;%– – %&gt; 和 的区别本文为博主原创，未经允许，不得转载： ​ 最近在写jsp页面注释的时候，遇到一个问题，在jsp页面引用的静态属性资源文件时，在浏览器控制台报错，当我把 引用的标签注释掉后，用的是 1&lt;!----&gt; 。然后浏览器仍然报了之前那个的错，当经过查询以后，jsp页面注释代码推荐用 &lt;%—-%&gt;进行注释，两者的区别在于： ​ 用 1&lt;!----&gt; 注释jsp代码只能在客户端进行注释，其在加载的时候，仍然会经过服务器端进行加载解析，当加载解析不到的 时候，就会在浏览器控制台进行报错，且注释掉的代码，在浏览器控制台可以看见。而用&lt;%—-%&gt;进行注释的时候， 会在服务端也进行注释，在解析的时候会解析不到，而注释掉的代码，在浏览器控制台也是不可见的。 1例：&lt;%-- $&#123;1+1&#125;--%&gt;，这个经过解析加载之后，不会发生变化。 而用&lt;!-- $&#123;1+1&#125;--&gt;,这个进过加载和解析之后，会被解析为&lt;!--2--&gt; 来源：https://www.cnblogs.com/zjdxr-up/p/7954470.html","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"jsp","slug":"jsp","permalink":"http://yoursite.com/tags/jsp/"}]},{"title":"servlet学习","slug":"Java Web/servlet学习","date":"2019-07-22T12:54:03.000Z","updated":"2019-08-07T07:49:46.724Z","comments":true,"path":"2019/07/22/Java Web/servlet学习/","link":"","permalink":"http://yoursite.com/2019/07/22/Java Web/servlet学习/","excerpt":"","text":"Servlet学习Servlet介绍问题： ​ 服务器在接收到浏览器的请求后，会自动调用对应的逻辑代码进行请求 ​ 处理。但是逻辑代码是由程序员编写并放到服务器中，那么服务器怎么知道该怎 ​ 么调用并调用哪个类和哪个方法来进行请求处理。 解决： ​ 程序员在编写代码的时候如果能够按照服务器能够识别的规则进行编写， ​ 浏览器按照指定的规则进行发送请求，那么服务器就可以调用并执行响应的逻辑 ​ 代码进行请求处理了。 实现： ​ Servlet 技术 概念： ​ 狭义的 Servlet 是指 Java 语言实现的一个接口，广义的 Servlet 是 ​ 指任何实现了这个 Servlet 接口的类，一般情况下，人们将 Servlet 理解为后者。 ​ Servlet 运行于支持 Java 的应用服务器中。从原理上讲，Servlet 可以响应任何 ​ 类型的请求，但绝大多数情况下 Servlet 只用来扩展基于 HTTP 协议的 Web 服 务器 特点： ​ 运行在支持 java 的应用服务器上 ​ Servlet 的实现遵循了服务器能够识别的规则，也就是服务器会自动的根据请求调用对应的 servlet 进行请求处理。简单方便，可移植性强 使用： ​ 1、 创建普通的 java 类并继承 HttpServlet ​ 2、 覆写 service 方法 ​ 3、 在 service 方法中书写逻辑代码即可 ​ 4、 在 webRoot 下的 WEB-INF 文件夹下的 web.xml 文件中配配置 servlet ​ Servlet 的 web.xml 配置​ Web.xml 配置的作用： 保护 Servlet。 12345678910111213141516171819202122232425262728293031&lt;!-- 精确配置: &lt;url-pattern&gt;/路径名&lt;/url-pattern&gt; 注意:\"/\"是必须的，该配置项可以配置多个 模糊配置: &lt;url-pattern&gt;*.后缀名&lt;/url-pattern&gt; 注意: 所有以指定的后缀名结尾的请求会调用该servlet进行处理 作用: 进行模块化开发的划分 拦截所有请求: &lt;url-pattern&gt;/*&lt;/url-pattern&gt; 注意: 会拦截所有类型的请求，包括静态资源请求（css,js,图片）和jsp请求 拦截以某个名称开头的路径下的所有请求: &lt;url-pattern&gt;/one/*&lt;/url-pattern&gt; --&gt; &lt;servlet&gt; &lt;servlet-name&gt;my&lt;/servlet-name&gt; &lt;servlet-class&gt;com.szxy.servlet.MyServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;my&lt;/servlet-name&gt; &lt;url-pattern&gt;/my&lt;/url-pattern&gt; &lt;url-pattern&gt;/m&lt;/url-pattern&gt; &lt;!-- 配置2 --&gt; &lt;url-pattern&gt;*.do&lt;/url-pattern&gt; &lt;!-- 配置3 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 加载时机： ​ 服务器启动的时候会将 webapps 中部署好的项目统一进行加载，并完成对每个项目的 web.xml 文件的加载。 注意： ​ 一个 Servlet 可有拥有多个 url-pattern 配置，但是 一个 url-pattern 配置只能对应一个 Servlet。 Servlet是单例的​ 服务器在接收到浏览器的请求后，会开辟一个线程来处理此次请求， 在线程中调用对应的Servlet进行处理。 服务器调用Servlet处理请求，但是一个Servlet服务器只会创建一个实例化对象，该对象是线程共享的。 ​ Servlet是单例的，只创建一个对象。 ​ Servlet的生命周期 Servlet的生命周期：从第一次被调用到服务器关闭 ​ init():servlet被初始化创建的时候调用 ​ service():处理请求的时候 ​ destory():Servlet对象被销毁的时候（服务器关闭时销毁Servlet对象） 注意： ​ 可以在web.xml中配置 123456&lt;servlet&gt; &lt;servlet-name&gt;LifeServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;com.szxy.servlet.LifeServlet&lt;/servlet-class&gt; &lt;!-- 配置servlet服务器启动时完成加载和初始化创建 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; 来设置Servlet加载时机为服务器启动（生命周期从服务器开启到服务器关闭） 本质：单例的懒汉式和饿汉式 ​ 注： 12345678910111213在servlet的配置当中，1的含义是：标记容器是否在启动的时候就加载这个servlet。当值为0或者大于0时，表示容器在应用启动时就加载这个servlet；当是一个负数时或者没有指定时，则指示容器在该servlet被选择时才加载。正数的值越小，启动该servlet的优先级越高。如果我们在web.xml中设置了多个servlet的时候，可以使用load-on-startup来指定servlet的加载顺序，服务器会根据load-on-startup的大小依次对servlet进行初始化。不过即使我们将load-on-startup设置重复也不会出现异常，服务器会自己决定初始化顺序。配置load-on-startup后，servlet在startup后立即加载，但只是调用servlet的init()方法，用以初始化该servlet相关的资源。初始化成功后，该servlet可响应web请求；如未配置load-on-startup，容器一般在第一次响应web请求时，会先检测该servlet是否初始化，如未初始化，则调用servlet的init()先初始化，初始化成功后，再响应请求。 PS：一般我们在开发web应用时，都会配置这个参数，有两个好处：1、如果初始化过程失败，则容器会提示启动失败，此时我们能够提前知道相关错误；2、配置该参数相当于将初始化servlet的工作转移到容器启动过程，使得容器只要启动成功后，就可立即响应web请求。--------------------- 作者：saiofo 来源：CSDN 原文：https://blog.csdn.net/u012393192/article/details/79323979 版权声明：本文为博主原创文章，转载请附上博文链接！ Servlet中的方法doGet(HttpServletRequest req, HttpServletResponse resp) 特点： ​ 处理get方式的请求 注意：如果在servlet中没有生命对应的请求处理方法，则会报405 doPost(HttpServletRequest req, HttpServletResponse resp) 特点： ​ 处理post方式的请求 service(HttpServletRequest req, HttpServletResponse resp) 特点： ​ 如果没有重写该方法，父类中调用service()方法进行请求转发（doGet(),doPost()） ​ 如果重写该方法，服务器会执行该方法 注意：tomcat服务器只会调用Servlet中service()方法(Servlet接口中只有service()方法)，如果没有覆写service(),则会调用父类HttpServlet中的service() Servlet 的常见错误总结​ 123456789101112131415161718192021222324Servlet的常见错误： 404错误:资源未找到 原因一：在请求地址中的servlet的别名书写错误。 原因二：虚拟项目名称拼写错误 500错误：内部服务器错误 错误一： java.lang.ClassNotFoundException: com.bjsxt.servlet.ServletMothod 解决： 在web.xml中校验servlet类的全限定路径是否拼写错误。 错误二： 因为service方法体的代码执行错误导致 解决： 根据错误提示对service方法体中的代码进行错误更改。 405错误:请求方式不支持 原因： 请求方式和servlet中的方法不匹配所造成的（调用父类的doGet() 或者doPost()方法） 解决： 尽量使用 service 方法进行请求处理，并且不要再 service 方法中调用父类的service Request 对象​ 问题： ​ 浏览器发起请求到服务器，会遵循HTTP协议将请求数据发送给服务器。 ​ 那么服务器接受到请求的数据改怎么存储呢?不但要存，而且要保证完整性。 ​ 解决： ​ 使用对象进行存储，服务器每接受一个请求，就创建一个对象专门的存 储此次请求的请求数据。 ​ 实现： ​ request 对象 ​ 解释： ​ 服务器接收到浏览器的请求后，会创建一个 Request 对象，对象中 存储了此次请求相关的请求数据。服务器在调用 Servlet 时会将创建的 Request 对象作为实参传递给 Servlet 的方法，比如：service 方法。 ​ 使用： ​ 获取请求头数据 ​ 获取请求行数据 ​ 获取用户数据 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126package com.szxy.servlet;import java.io.IOException;import java.util.Enumeration;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Request对象学习 * 获取请求数据： * 请求行：请求方式,请求URL,协议 * getMethod(); 返回请求方式 * getRequestURL() 返回请求url * getRequestURI() 返回请求uri * getQueryString() 返回get请求URL中的请求数据 * getScheme() 返回协议 * 请求头：getHeader(String name) * 注意：如果获取的请求头信息不存在则放回null * getHeaderNames() 返回存储请求头键名的枚举集合 * 请求实体： * getParameter(String name) 根据键名获取数据 * 注意: * 键名就是前端页面的表单标签的name属性的值或者其他方式提交的数据的键的名 * 如果没有对应的请求数据，则返回null * getParameterValues(String name) 根据键名获取同名不同的值，返回数组 * 注意：没有对应的键名，返回null * getParameterNames() 返回实体数据中键名的枚举 * 请求中的网络数据 * getRemoteAddr() 获取客户端ip * getRemotePort() 获取客户端的端口号 * getLocalAddr() 获取服务器端的ip * getLocalPort() 获取服务器端的端口 * @author Momentonly * */@WebServlet(&quot;/request&quot;)public class RequestServlet extends HttpServlet&#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //获取请求信息 //获取请求行信息 //获取请求方式 String method = req.getMethod(); System.out.println(&quot;请求方式:&quot; + method); //获取请求URL StringBuffer requestURL = req.getRequestURL(); System.out.println(&quot;请求URL:&quot; + requestURL.toString()); //获取请求URI String requestURI = req.getRequestURI(); System.out.println(&quot;请求URI:&quot; + requestURI); //获取get请求URL中的请求数据 String queryString = req.getQueryString(); System.out.println(&quot;获取get请求URL中的数据:&quot; + queryString); //获取协议 String scheme = req.getScheme(); System.out.println(&quot;获取请求协议:&quot; + scheme); //获取请求头信息 //根据键名获取请求头信息(如果不存在则返回null) String header = req.getHeader(&quot;User-Agent&quot;); System.out.println(&quot;获取浏览器版本信息&quot; + header); //获取请求头中键名的枚举 Enumeration&lt;String&gt; headerNames = req.getHeaderNames(); while(headerNames.hasMoreElements())&#123; //获取请求头键名 String name = headerNames.nextElement(); //获取请求头的键名对应的值 System.out.println(name + &quot;:&quot; + req.getHeader(name)); &#125; //获取请求实体数据（用户数据） //根据键名获取数据(如果请求中不存在键则返回null) String uname = req.getParameter(&quot;uname&quot;); String pwd = req.getParameter(&quot;pwd&quot;); System.out.println(&quot;请求实体数据:&quot; + uname + &quot;:&quot; + pwd); //获取同键不同值的实体数据 String[] favs = req.getParameterValues(&quot;fav&quot;); if(favs != null)&#123; //NullPointerException for(String s : favs)&#123; System.out.println(&quot;fav的值为&quot; + s); &#125; &#125; //获取请求实体中键名的枚举 Enumeration&lt;String&gt; names = req.getParameterNames(); while(names.hasMoreElements())&#123; //System.out.println(names.nextElement()); //判断 String name = names.nextElement(); if(&quot;fav&quot;.equals(name))&#123; String[] favs2 = req.getParameterValues(name); if(favs2 != null)&#123; for(String s : favs2)&#123; System.out.println(name + &quot;:&quot; + s); &#125; &#125; &#125;else&#123; String value = req.getParameter(name); System.out.println(name + &quot;:&quot; + value); &#125; &#125; //请求相关的网络数据 //获取客户端信息 String remoteAddr = req.getRemoteAddr(); System.out.println(&quot;客户端ip:&quot; + remoteAddr); //获取客户端的端口号(浏览器) int remotePort = req.getRemotePort(); System.out.println(&quot;客户端的端口号:&quot; + remotePort); //获取服务器主机ip String localAddr = req.getLocalAddr(); System.out.println(&quot;获取服务器ip:&quot; + localAddr); //获取服务器的端口号 int localPort = req.getLocalPort(); System.out.println(&quot;服务器端口号:&quot; + localPort); //处理请求信息 //响应处理结果 &#125;&#125; Response对象问题： ​ 在使用 Request 对象获取了请求数据并进行处理后，处理的结果如何显示到浏览器中呢？ 解决： ​ 使用 Response 对象 解释： ​ 服务器在调用指定的 Servlet 进行请求处理的时候，会给 Servlet 的方法 传递两个实参 request 和 response。 其中 request 中封存了请求相关的请求 数据，而 response 则是用来进行响应的一个对象。 使用： ​ 设置响应行 ​ 设置响应头 ​ 设置响应实体 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.szxy.servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Response对象 * 设置响应行： 协议 状态码 状态消息 * resp.sendError(int status) 自定义响应的状态码 * 设置响应头 * addHeader(String name, String value) 添加响应头信息，同名数据不会覆盖 * setHeader(String name, String value) 设置响应头信息，会覆盖原有信息，如果没有该响应头则添加 * 设置响应实体(处理结果) * resp.getWriter().write(&quot;实体内容&quot;); * 注意： * 实体内容可以分开响应 * * 注意：使用resp对象做出了请求响应，意味着此次请求处理完毕，服务器在响应后会将此次请求相关的req和resp对象销毁 * * @author Momentonly * */@WebServlet(&quot;/response&quot;)public class ResponseServlet extends HttpServlet&#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; System.out.println(&quot;ResponseServlet.service()&quot;); //获取请求数据 //处理请求数据 //响应处理结果 //设置响应行 //自定义响应404异常 //resp.sendError(404); //设置响应头 //添加响应头信息 resp.addHeader(&quot;mouse&quot;, &quot;thinkpad&quot;); resp.addHeader(&quot;mouse&quot;, &quot;thinkpad2&quot;); //设置响应头 //resp.setHeader(&quot;Content-Length&quot;, &quot;20&quot;); //resp.setHeader(&quot;mouse&quot;, &quot;two fly&quot;); //resp.setHeader(&quot;mouse&quot;, &quot;two fly2&quot;); //设置响应实体 resp.getWriter().write(&quot;resp object&quot;); resp.getWriter().write(&quot;resp object&quot;); &#125;&#125; 乱码问题​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354package com.szxy.servlet;import java.io.IOException;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * 乱码问题 * 请求乱码（服务器获取的请求数据乱码） * post: * req.setCharacterEncoding(&quot;utf-8&quot;); * get: * 方式一： * String uname = req.getParameter(&quot;uname&quot;); String uname2 = new String(uname.getBytes(&quot;iso-8859-1&quot;),&quot;utf-8&quot;); * 方式二：配置tomcat的server.xml * req.setCharacterEncoding(&quot;utf-8&quot;); * 在tomcat中的server.xml中的Connecgtor标签中增加属性：useBodyEncodingForURI=&quot;true&quot; * 响应乱码（浏览器中显示的服务器响应数据乱码） * service流程 * 设置请求编码格式 * 设置响应编码格式 * 获取请求信息 * 处理请求信息 * 响应处理结果 * @author Momentonly * */@WebServlet(&quot;/code&quot;)public class CodeServlet extends HttpServlet&#123; @Override protected void service(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; //设置请求编码格式 req.setCharacterEncoding(&quot;utf-8&quot;); //设置响应编码格式 //resp.setHeader(&quot;ontent-type&quot;,&quot;text/html;charset=utf-8&quot;); resp.setContentType(&quot;text/html;charset=utf-8&quot;); //获取请求数据 System.out.println(req.getMethod()); System.out.println(req.getRequestURI()); String uname = req.getParameter(&quot;uname&quot;); //String uname2 = new String(uname.getBytes(&quot;iso-8859-1&quot;),&quot;utf-8&quot;); //处理请求数据 System.out.println(uname); //响应处理结果 resp.getWriter().write(&quot;请求处理完毕&quot;); &#125;&#125; request中的setCharacterEncoding方法作用是用指定的编码集去覆盖request对象中的默认的”ISO-8859-1”编码集，这样request.getParameter(“”)方法就会用新的编码集去解码 请求转发转发问题： ​ 服务器在接收到浏览器的请求后，仅仅使用一个 Servlet 进行请求处理，会造成不同的 Servlet 逻辑代码冗 ​ 余，Servlet 的职责不明确。 解决： 使用请求转发。 特点： 降低servlet之间的代码冗余 ​ 一次请求转发内的servlet共享此次请求 ​ 浏览器地址栏信息不改变，一次请求 ​ 1req.getRequestDispatcher(&quot;转发的路径&quot;).forward(req, resp); Request对象作用域​ 一次请求 ​ 问题：使用请求转发后，不同的 Servlet 之间怎么进行数据的共享 呢？或者说数据怎么从一个 servlet 流转给另外 一个 Servlet 呢？ 解决：使用 request 对象的作用域 使用： ​ request.setAttribute(object name,Object value); ​ request.getAttribute(Object obj) 作用：解决了一次请求内的不同 Servlet 的数据(请求数据+其他数据)共享问题。 作用域：基于请求转发，一次请求中的所有 Servlet 共享。 注意： ​ 使用 Request 对象进行数据流转，数据只在一次请求内有效。 特点： ​ 服务器创建 ​ 每次请求都会创建 ​ 生命周期一次请求 重定向两次请求 问题： ​ 如果当前的请求，Servlet 无法进行处理怎么办? ​ 如果使用请求转发，造成表单数据重复提交怎么办？ 解决： ​ 使用重定向 使用： ​ response.sendRedirect(“路径”). ​ 本地路径为：uri ​ 网络路径为：定向资源的 URL 信息 特点： ​ 两次请求浏览器地址栏信息改变 ​ 避免因为用户的刷新而造成表单重复提交 Cookie​ 作用：解决了不同请求之间请求数据共享的问题 ​ ​ 特点： ​ 1）如果不设置有效期，则默认存储在浏览器内存中，浏览器关闭即失效 ​ 2）如果不设置有效路径则(Cookie的默认path为当前项目的根路径 ​ 3）如果设置了有效期，则存储到客户端的硬盘里，到期后自动销毁 ​ 4）如果设置了有效路径则只有在该路径下的请求才会附带设置的cookie信息 ​ 注意： ​ c.setPath(“/bjservlet/mm”); ​ 表示/bjservlet/mm以及/bjservlet/mm/* ​ ​ c.setPath(“/bjservlet/mm/“); ​ 表示/bjservlet/mm/* Session问题： ​ Request 对象解决了一次请求内的不同 Servlet 的数据共享问 题，那么一个用户的不同请求的处理需要使 用相同的数据怎么办呢? 解决： ​ 使用 session 技术。 原理： ​ 用户使用浏览器第一次向服务器发送请求，服务器在接受到请 求后，调用对应的 Servlet 进行处理。在处理过程中会给用户创建 一个 session 对象(调用req.getsession()才会创建)，用来存储用户请求处理相关的公共数据，并将 此 session 对象JSESSIONID 以 Cookie 的形式存储在浏览器中(临 时存储，浏览器关闭即失效)。用户在发起第二次请求及后续请求 时，请求信息中会附带 JSESSIONID，服务器在接收到请求后，调用对应的 Servlet 进行请求处理，同时根据 JSESSIONID 返回其对应的 session 对象。 特点：Session 技术是依赖 Cookie 技术的服务器端的数据存储技术。由服务器进行创建 每个用户独立拥有一个 session ​ 默认存储时间为 30 分钟 作用： ​ 解决了一个用户的不同请求的数据共享问题。 使用： ​ 创建 Session 对象 ​ 存储数据到 session 对象 ​ 获取 session 对象 ​ 获取数据从 session 对象 ​ 如果获取 session 中不存在的数据返回 null。 注意： ​ 只要不关闭浏览器，并且 session 不失效的情况下，同一个用 户的任意请求在项目的任意Servlet中获取到 的都是同一个session对象。 作用域： ​ 一次会话 注意： 一个常见的误解是以为session在有客户端访问时就被创建，然而事实是直到某server端程序调用HttpServletRequest.getSession(true)这样的语句时才被创建，注意如果JSP没有显示的使用 &lt;%@page session=”false”%&gt; 关闭session，则JSP文件在编译成Servlet时将会自动加上这样一条语句HttpSession session = HttpServletRequest.getSession(true);这也是JSP中隐含的session对象的来历。 由于session会消耗内存资源，因此，如果不打算使用session，应该在所有的JSP中关闭它。 ServletContext问题： ​ Request 解决了一次请求内的数据共享问题，session 解决了 用户不同请求的数据共享问题，那么不同的用户的数据共享该怎 么办呢？ 解决： ​ 使用 ServletContext 对象 作用： ​ 解决了不同用户的数据共享问题 原理： ​ ServletContext 对象由服务器进行创建，一个项目只有一个对 象。不管在项目的任意位置进行获取得到的都是同一个对象，那 么不同用户发起的请求获取到的也就是同一个对象了，该对象由 用户共同拥有。 特点： ​ 服务器进行创建用户共享 ​ 一个项目只有一个 生命周期： ​ 服务器启动到服务器关闭 作用域： ​ 项目内 使用： ​ 获取 ServletContext 对象 ​ 使用作用域进行共享数据流转 ​ 获取 web.xml 中的全局配置 ​ 获取 webroot 下项目资源流对象 ​ 获取 webroot 下资源绝对路径 ServletConfig问题： ​ 使用 ServletContext 对象可以获取 web.xml 中的全局配置文件， 在 web.xml 中 每个 Servlet 也可以进行单独的配置，那么该怎么获取配置信息呢？ 解决： ​ 使用 ServletConfig 对象作用： ​ ServletConfig 对象是 Servlet 的专属配置对象，每个 Servlet 都单独拥有一个 ServletConfig 对象，用来获取 web.xml 中的配置信息。 使用： ​ 获取 ServletConfig 对象 ​ 获取 web.xml 中 servlet 的配置信息","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"servlet","slug":"servlet","permalink":"http://yoursite.com/tags/servlet/"}]},{"title":"JS中的闭包","slug":"Web/Js中的闭包理解","date":"2019-07-21T09:01:11.000Z","updated":"2019-07-21T09:37:18.713Z","comments":true,"path":"2019/07/21/Web/Js中的闭包理解/","link":"","permalink":"http://yoursite.com/2019/07/21/Web/Js中的闭包理解/","excerpt":"","text":"JS中的闭包闭包就是跨作用域访问变量​ 闭包是指有权访问另外一个函数作用域中的变量的函数.可以理解为(能够读取其他函数内部变量的函数) 测试1123456789var name = 'wangxi'function user () &#123; // var name = 'wangxi' function getName () &#123; console.log(name) &#125; getName()&#125;user() // wangxi ​ 在 getName 函数中获取 name，首先在 getName 函数的作用域中查找 name，未找到，进而在 user 函数的作用域中查找，同样未找到，继续向上回溯，发现在全局作用域中存在 name，因此获取 name 值并打印。这里很好理解，即变量都存在在指定的作用域中，如果在当前作用中找不到想要的变量，则通过作用域链向在父作用域中继续查找，直到找到第一个同名的变量为止（或找不到，抛出 ReferenceError 错误）。这是 js 中作用域链的概念，即子作用域可以根据作用域链访问父作用域中的变量，那如果相反呢，在父作用域想访问子作用域中的变量呢？——这就需要通过闭包来实现。 12345678function user () &#123; var name = 'wangxi' return function getName () &#123; return name &#125;&#125;var userName = user()()console.log(userName) // wangxi ​ 分析代码我们知道，name 是存在于 user 函数作用域内的局部变量，正常情况下，在外部作用域（这里是全局）中是无法访问到 name 变量的，但是通过闭包（返回一个包含变量的函数，这里是 getName 函数），可以实现跨作用域访问变量了（外部访问内部）。因此上面的这种说法完整的应该理解为： ​ 闭包就是跨作用域访问变量 —— 内部作用域可以保持对外部作用域中变量的引用从而使得外部作用域可以访问内部作用域中的变量。 测试212345678910111213141516171819202122232425262728&lt;script&gt; function user()&#123; var a = 1; return function()&#123; console.log(a++); &#125;; &#125; /**** 1)aaa 是将 user() 的运行结果赋值给它，即 return 返回的匿名函数， 此时有一个闭包，则每次调用 aaa 时都访问的同一个 a，aaa() 第一次运行结果为 1，第二次为2 2)bbb 将是将 user 这个函数名赋值给它，则调用 bbb() 后返回一个匿名函数表达式， 即function()&#123;console.log(a++)&#125;; ****/ var aaa = user(); console.log(aaa); //ƒ()&#123;console.log(a++);&#125; console.log(aaa()); //1 undefined aaa(); //2 aaa(); //3 aaa(); //4 var bbb = user; console.log(bbb); //ƒ user()&#123;var a = 1;return function()&#123;console.log(a++);&#125;;&#125; console.log(bbb()); //ƒ()&#123;console.log(a++);&#125; console.log(bbb()()); //1 undefined console.log(bbb()()); //1 undefined &lt;/script&gt; 闭包就是一个引用了父环境的对象，并且从父环境中返回到更高层的环境中的一个对象123456function user () &#123; var name = 'wangxi' return name&#125;var userName = user()console.log(userName) // wangxi 问：这是闭包吗？ 答：当然不是。首先要明白闭包是什么。虽然这里形式上看好像也是在全局作用域下访问了 user 函数内的局部变量 name，但是问题是，user 执行完，name 也随之被销毁了，即函数内的局部变量的生命周期仅存在于函数的声明周期内，函数被销毁，函数内的变量也自动被销毁。 ​ 但是使用闭包就相反，函数执行完，生命周期结束，但是通过闭包引用的外层作用域内的变量依然存在，并且将一直存在，直到执行闭包的的作用域被销毁，这里的局部变量才会被销毁（如果在全局环境下引用了闭包，则只有在全局环境被销毁，比如程序结束、浏览器关闭等行为时才会销毁闭包引用的作用域）。因此为了避免闭包造成的内存损耗，建议在使用闭包后手动销毁。 123456789function user () &#123; var name = 'wangxi' return function getName () &#123; return name &#125;&#125;var userName = user()() // userName 变量中始终保持着对 name 的引用console.log(userName) // wangxiuserName = null // 销毁闭包，释放内存 ​ 为什么 user()() 是两个括号：执行 user() 返回的是 getName 函数，要想获得 name 变量，需要对返回的 getName 函数执行一次，所以是 user()() ​ 分析一下代码：在全局作用域下创建了 userName 变量（爷爷），保存了对 user 函数最终返回结果的引用（即局部变量 name 的值），执行 user()()（爸爸），返回了 name（孙子）,正常情况下，在执行了 user()() 之后，user 的环境（爸爸）应该被清除掉，但是因为返回的结果 name（孙子）引用了爸爸的环境（因为 name 本来就是存在于 user 的作用域内的），导致 user 的环境无法被释放（会造成内存损耗）。 那么【”闭包就是一个引用了父环境的对象，并且从父环境中返回到更高层的环境中的一个对象。”】如何理解？ 我们换个说法：如果一个函数引用了父环境中的对象，并且在这个函数中把这个对象返回到了更高层的环境中，那么，这个函数就是闭包。 解析：getName 函数中引用了 user（父）环境中的对象（变量 name），并且在函数中把 name 变量返回到了全局环境（更高层的环境）中，因此，getName 就是闭包。 JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里123456789var name = 'Schopenhauer'function getName () &#123; console.log(name)&#125;function myName () &#123; var name = 'wangxi' getName()&#125;myName() // Schopenhauer ​ 如果执行 myName() 输出的结果和你想象的不一样，你就要再回去看看上面说的这句话了。 JavaScript 中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里执行 myName，函数内部执行了 getName，而 getName 是在全局环境下定义的，因此尽管在 myName 中定义了变量 name，对getName 的执行并无影响，getName 中打印的依然是全局作用域下的 name。 测试：JavaScript中的函数运行在它们被定义的作用域里，而不是它们被执行的作用域里 1234567891011121314var name = 'Schopenhauer'function getName () &#123; var name = 'Aristotle' var intro = function() &#123; // 这是一个闭包 console.log('I am ' + name) &#125; return intro&#125;function showMyName () &#123; var name = 'wangxi' var myName = getName() //得到intro函数 myName() //执行intro()&#125;showMyName() // I am Aristotle 总结什么是闭包?简单来说，闭包是指可以访问另一个函数作用域变量的函数，一般是定义在外层函数中的内层函数。 为什么需要闭包？局部变量无法共享和长久的保存，而全局变量可能造成变量污染，所以我们希望有一种机制既可以长久的保存变量又不会造成全局污染。 特点 占用更多内存 不容易被释放 何时使用？变量既想反复使用，又想避免全局污染 如何使用? 定义外层函数，封装被保护的局部变量。 定义内层函数，执行对外部函数变量的操作。 外层函数返回内层函数的对象，并且外层函数被调用，结果保存在一个全局的变量中。 原文:https://www.jb51.net/article/126565.htm","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"a标签的href=\"javascript:;\" href=\"javacript:void(0);\" href=\"#\"区别","slug":"Web/JS使用a标签的href","date":"2019-07-19T12:17:11.000Z","updated":"2019-07-19T14:27:24.845Z","comments":true,"path":"2019/07/19/Web/JS使用a标签的href/","link":"","permalink":"http://yoursite.com/2019/07/19/Web/JS使用a标签的href/","excerpt":"","text":"a标签的href=”javascript:;” href=”javacript:void(0);” href=”#”区别在使用标签时，经常会绑定其他事件比如onclick，这时候我们会给标签的href属性赋值为“#”，“javacript:;”，“javacript:void(0);”等。 一、href=”javacript:;” 用这个的话会出现浏览器访问“javascript:;”这个地址的现象，所以任何情况下都不建议使用； 二、href=”javacript:void(0);” 表示点击这个链接后执行一条javascript语句：void(0); 这条语句表示什么也不做，是个空语句。当绑定了onclick()事件并且点击后，页面会停留在原地； 三、href=”#” 这个是HTML的链接用法，意思是跳转到页面顶部，如果想快速地返回到顶部，那么就用这个链接，这种用法叫做锚。 四、如果想使用a标签来对一个函数进行调用，有两种方式： 121)&lt;a href=&quot;javascript:void(0);&quot; onClick=&quot;hello();&quot; &gt;点我&lt;/a&gt;2)&lt;a href=&quot;javascript:hello();&quot; &gt;点我&lt;/a&gt; 所以应该在不同的场景应该选择合适的用法。","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"JS自定义对象","slug":"Web/Js自定义对象","date":"2019-07-19T12:17:11.000Z","updated":"2019-07-19T14:27:09.737Z","comments":true,"path":"2019/07/19/Web/Js自定义对象/","link":"","permalink":"http://yoursite.com/2019/07/19/Web/Js自定义对象/","excerpt":"","text":"关于这个this关键字，也是很多项目中常常被用到的，那么，有人也许会问，干嘛要用this呢，在函数被调用时，直接指明是什么对象在调用不就行了？还整那么个模模糊糊的概念出来干嘛？不过嘛，存在即真理，既然有这么个东西，那也就有他存在的意义，下面来看看吧。 ​ 首先，我们要先回忆一下js函数都有哪几种调用的场合，有如下几种场合： ​ 1、很常规的调用（即直接调用，其实你发现也是全局调用）； ​ 2、作为某个对象的豆哥方法被调用； ​ 3、作为构造函数，用来新建某个新对象（object）； ​ 4、很让人头大的apply调用（在实现部分继承的时候经常这么干）。 好了，一起来看看上述几种情况下this关键字是怎样被玩的出神入化的。 一、纯粹的函数调用 这是函数的最通常用法，属于全局性调用，因此this就代表全局对象Global，那么这里Global很多人又很迷惑了，实则在浏览器环境下，Global也即是window对象，global对象是单体内置对象，即不依赖宿主环境的对象，而window对象依赖浏览器。 看下面这段代码： function test(){ this.name = “dearxiangxiao”; console.log(this.name ); } test(); //dearxiangxiao 感觉还是很神奇的，不知不觉test函数里面定义的属性，在外面也可以读取了？对代码做一些修改，如下： var name = “xiangxiao”; function test(){ this.name = “dearxiangxiao”; } test(); alert(name); // dearxiangxiao 可以看出，在执行完test函数之后，name的值被改变了，原因何在？这里就是这个调用test的对象是Global在作怪，既然test是被全局对象Global调用的，那么this也就指向Global对象了，全局对象的属性，当然可以读取并修改了，没啥错。 二、作为对象方法的调用 函数还可以作为某个对象的方法调用，这时this就指这个上级对象，也来看一段代码： function test(){ console.log(“my name is “+this.name + “ and my profession is “+this.profession); }; var person = {}; person .name= “dearxiangxiao”; person.profession = “projector”; person.interduce= test; person .interduce(); // my name is dearxiangxiao,and my profession is projector 这里很好理解，既然是person在调用test函数，那么理所应当的this指向的是person实体，也就是前面说的调用函数的上一级对象，它的name和profession 属性当然应该被读取出来了。 三、作为构造函数调用 所谓构造函数，就是通过这个函数生成一个新对象（object）。这时，this就指这个新对象，也来看一段代码，将一中的例子做轻微的修改： var name = “xiangxiao”; function Person(){ this.name = “dearxiangxiao”; } var person1 = new Person(); console.log(name); // xiangxiao console.log(person1.name); // dearxiangxiao 可以看出，this指向的对象是刚刚新建的person1，读取出了它的名称dearxiangxiao，而直接打印name变量，值仍然未变，为之前的xiangxiao。这更加表明this指向person1，而不是Global对象。 四、apply调用 apply()是函数对象的一个方法，它的作用是改变函数的调用对象（实则是将某某对象的某个方法放到另一个好基友对象那里去执行），它的第一个参数就表示改变后的调用这个函数的对象。因此，this指的就是这第一个参数。 关于这个apply，可能大多数人不太喜欢用它，要想调用某个对象直接调用不就好了么？但是应该想到，假如你想调用别人写好的某个方法，某些参数变量却要用到你自己的，怎么办？apply和call就派上用场了，这也是js面向对象思维转换的重要一环，必须理解的（关于apply和call具体详情，请看我的另一篇博文：js面向对象思维转换的一个阶梯：apply和call）。 下面还是来看个例子吧，这里把三中的例子做一些轻微的修改： var name = “xiangxiao”; function test(){ console.log(this.name); } var person1 = new Person(); person1.name = “dearxiangxiao”; person1.interduce = test; person1.interduce.apply(); // 这里输出的四xiangxiao 怎么回事，不是说好了的要改变函数的调用对象么？怎么还是被Global调用了？不急不急，来看看apply后面的括号里，没任何东西，默认没有残数时是全局对象Global，因此，此处也就真的是调用出了Global的name变量。那person1.interduce.apply()怎么理解呢？可以这么理解：将person1实体的interduce方法放到Global对象上去执行。 好了，我们刚刚在前面说了，apply后面括号里的第一个参数，即为this的指向，那么改一改上面的最后一句代码吧，如下： person1.interduce.apply(person1); // 这里输出的就是dearxiangxiao 得到person1的name属性值了，突然冒出个想法，这里person1.interduce.apply(person1) 理解出来貌似很拗口额：将person1实体对象的interduce方法放到person1实体对象上去执行，什么鬼？自己的方法自己直接调用不好么？写成 person1.interduce()就行了噻！！！当然可以，那样更简洁，不过，这就是apply方法的特点所致吧，自己的方法，转一圈回到自己手里被调用了，还给出个冠冕堂皇的解释，哈哈，就不吐槽了，我们还是要看到apply带给我们的诸多好处的。 来源：https://www.cnblogs.com/xiangxiao/p/6822997.html","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"javascript","slug":"javascript","permalink":"http://yoursite.com/tags/javascript/"}]},{"title":"jdk7的try-catch-resource","slug":"JavaSE/jdk7的try-with-resource","date":"2019-07-18T02:08:01.000Z","updated":"2019-07-18T02:32:12.202Z","comments":true,"path":"2019/07/18/JavaSE/jdk7的try-with-resource/","link":"","permalink":"http://yoursite.com/2019/07/18/JavaSE/jdk7的try-with-resource/","excerpt":"","text":"jdk7的try-with-resources​ JDK1.7开始，java引入了 try-with-resources 声明，将 try-catch-finally 简化为 try-catch，这其实是一种语法糖，在编译时会进行转化为 try-catch-finally 语句。新的声明包含三部分：try-with-resources 声明、try 块、catch 块。它要求在 try-with-resources 声明中定义的变量实现了 AutoCloseable 接口，这样在系统可以自动调用它们的close方法，从而替代了finally中关闭资源的功能。 测试12345678910111213141516@Test public void TestForTryWithResources() &#123; try (InputStream inputStream = new FileInputStream(&quot;/test.md&quot;); //InputStream inputStream = TryCatchDemo.class.getResourceAsStream(&quot;/test.md&quot;) BufferedReader bf = new BufferedReader(new InputStreamReader(inputStream)) ) &#123; StringBuilder sb = new StringBuilder(); String tmpString = null; while ((tmpString = bf.readLine()) != null) &#123;//抛出IOException的地方 sb.append(tmpString); &#125; System.out.println(sb.toString()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; 它的结构是try(){} 因为括号里头的InputStream ，BufferedReader 都实现了一个AutoCloseable接口，所以无论这段代码是正常执行完，还是有异常往外抛，还是内部代码块发生异常被截获，最终都会按照创建资源的逆顺序，自动关闭资源. 1234567891011121314151617181920212223 @Test public void AutoCloseTest() &#123; try (AutoCloseAbleBean autoCloseable = new AutoCloseAbleBean()) &#123; throw new RuntimeException(&quot;test&quot;);// autoCloseable.dosomething();// return; &#125; catch (Exception e) &#123; e.printStackTrace();// throw new RuntimeException(&quot;test&quot;); &#125;finally &#123; throw new RuntimeException(&quot;test&quot;); &#125; &#125; class AutoCloseAbleBean implements AutoCloseable &#123; @Override public void close() throws Exception &#123; System.out.println(&quot;i am close&quot;); &#125; void dosomething() &#123; System.out.println(&quot;before close&quot;); &#125; &#125; 异常机制的变化​ 它们的异常抛出机制发生了变化。在过去的 try-catch-finally 结构中，我们在finally块中关闭资源通常是这样的： 123456789101112catch (Exception e) &#123; e.printStackTrace(); // 第一处异常处理 &#125; finally &#123; try &#123; if (c != null) &#123; c.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); // 第二处异常处理 &#125; &#125; 异常处理有两种情况： try 块没有发生异常时，直接调用finally块，如果 close 发生异常，就处理。try 块发生异常，catch 块捕捉，进行第一处异常处理，然后调用 finally 块，如果 close 发生异常，就进行第二处异常处理。但是在 try-with-resources 结构中，异常处理也有两种情况（注意，不论 try 中是否有异常，都会首先自动执行 close 方法，然后才判断是否进入 catch 块，建议阅读后面的反编译代码）： try 块没有发生异常时，自动调用 close 方法，如果发生异常，catch 块捕捉并处理异常。try 块发生异常，然后自动调用 close 方法，如果 close 也发生异常，catch 块只会捕捉 try 块抛出的异常，close 方法的异常会在catch 中被压制，但是你可以在catch块中，用 Throwable.getSuppressed 方法来获取到压制异常的数组。 我们可以通过自定义的 AutoCloseable 类来理解这个过程。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class Main &#123; public static void startTest() &#123; try (MyAutoCloseA a = new MyAutoCloseA(); MyAutoCloseB b = new MyAutoCloseB()) &#123; a.test(); b.test(); &#125; catch (Exception e) &#123; System.out.println(&quot;Main: exception&quot;); System.out.println(e.getMessage()); Throwable[] suppressed = e.getSuppressed(); for (int i = 0; i &lt; suppressed.length; i++) System.out.println(suppressed[i].getMessage()); &#125; &#125; public static void main(String[] args) throws Exception &#123; startTest(); &#125;&#125;/* 输出为： MyAutoCloaseA: test() MyAutoCloseB: on close MyAutoCloseA: on close() Main: exception MyAutoCloaseA: test() IOException MyAutoCloaseB: close() ClassNotFoundException MyAutoCloaseA: close() ClassNotFoundException*/class MyAutoCloseA implements AutoCloseable &#123; public void test() throws IOException &#123; System.out.println(&quot;MyAutoCloaseA: test()&quot;); throw new IOException(&quot;MyAutoCloaseA: test() IOException&quot;); &#125; @Override public void close() throws Exception &#123; System.out.println(&quot;MyAutoCloseA: on close()&quot;); throw new ClassNotFoundException(&quot;MyAutoCloaseA: close() ClassNotFoundException&quot;); &#125;&#125;class MyAutoCloseB implements AutoCloseable &#123; public void test() throws IOException &#123; System.out.println(&quot;MyAutoCloaseB: test()&quot;); throw new IOException(&quot;MyAutoCloaseB: test() IOException&quot;); &#125; @Override public void close() throws Exception &#123; System.out.println(&quot;MyAutoCloseB: on close&quot;); throw new ClassNotFoundException(&quot;MyAutoCloaseB: close() ClassNotFoundException&quot;); &#125;&#125; 通过反编译class文件，可以看到实际的执行过程： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public static void startTest() &#123; try &#123; MyAutoCloseA a = new MyAutoCloseA(); Throwable var33 = null; try &#123; MyAutoCloseB b = new MyAutoCloseB(); Throwable var3 = null; try &#123; // 我们定义的 try 块 a.test(); b.test(); &#125; catch (Throwable var28) &#123; // try 块中抛出的异常 var3 = var28; throw var28; &#125; finally &#123; if (b != null) &#123; // 如果 try 块中抛出异常，就将 close 中的异常（如果有）附加为压制异常 if (var3 != null) &#123; try &#123; b.close(); &#125; catch (Throwable var27) &#123; var3.addSuppressed(var27); &#125; &#125; else &#123; // 如果 try 块没有抛出异常，就直接关闭，可能会抛出关闭异常 b.close(); &#125; &#125; &#125; &#125; catch (Throwable var30) &#123; var33 = var30; throw var30; &#125; finally &#123; if (a != null) &#123; if (var33 != null) &#123; try &#123; a.close(); &#125; catch (Throwable var26) &#123; var33.addSuppressed(var26); &#125; &#125; else &#123; a.close(); &#125; &#125; &#125; // 所有的异常在这里交给 catch 块处理 &#125; catch (Exception var32) &#123; // 我们定义的 catch 块 System.out.println(&quot;Main: exception&quot;); System.out.println(var32.getMessage()); Throwable[] suppressed = var32.getSuppressed(); for(int i = 0; i &lt; suppressed.length; ++i) &#123; System.out.println(suppressed[i].getMessage()); &#125; &#125; &#125; 12345我还想补充的是：catch 块中，看不到 try-with-recourse 声明中的变量。try-with-recourse 中，try 块中抛出的异常，在 e.getMessage() 可以获得，而调用 close() 方法抛出的异常在e.getSuppressed() 获得。try-with-recourse 中定义多个变量时，由反编译可知，关闭的顺序是从后往前。 参考来源1.https://www.jianshu.com/p/8e4421aff0a6 2.https://blog.csdn.net/weixin_40255793/article/details/80812961","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"CSS中的transform属性","slug":"Web/CSS中的transform属性","date":"2019-07-10T14:59:11.000Z","updated":"2019-07-15T07:37:44.747Z","comments":true,"path":"2019/07/10/Web/CSS中的transform属性/","link":"","permalink":"http://yoursite.com/2019/07/10/Web/CSS中的transform属性/","excerpt":"","text":"transform属性一、移动 translate用法：transform: translate(45px) 或者 transform: translate(45px, 150px); 参数表示移动距离，单位px， 一个参数时：表示水平方向的移动距离；两个参数时：第一个参数表示水平方向的移动距离，第二个参数表示垂直方向的移动距离。 二、缩放 scale用法：transform: scale(0.5) 或者 transform: scale(0.5, 2); 参数表示缩放倍数； 一个参数时：表示水平和垂直同时缩放该倍率两个参数时：第一个参数指定水平方向的缩放倍率，第二个参数指定垂直方向的缩放倍率。 三、旋转 rotate用法：transform: rotate(45deg); 围绕旋转中心旋转而不变形的转换，rotate()默认旋转中心为图片的中点。共一个参数“角度”，单位deg为度的意思，正数为顺时针旋转，负数为逆时针旋转，上述代码作用是顺时针旋转45度。 四、倾斜 skew用法：transform: skew(30deg) 或者 transform: skew(30deg, 30deg); 参数表示倾斜角度，单位deg 一个参数时：表示水平方向的倾斜角度； 两个参数时：第一个参数表示水平方向的倾斜角度，第二个参数表示垂直方向的倾斜角度。 旋转举例进行旋转时其对应的坐标系会跟随旋转的角度进行变化。 12341.transform:rotateY(90deg) translateZ(200px) ;该操作会将一个div正向旋转90度，（旋转的角度是根据Y轴的垂直面（x向右，y向上，二维）原来的xyz轴也进行正向旋转90度，因此，Z轴的正向会变成向右的方向， 黑色的x,y轴是旋转角度面 122. transform:rotateY(90deg) translateZ(200px) rotateZ(45deg);该操作会在原来的基础上绕Z轴进行旋转 黑色的x,y轴是旋转角度面","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"JavaScript的学习","slug":"Web/JavaScript的学习","date":"2019-07-10T14:59:11.000Z","updated":"2019-07-21T09:44:43.634Z","comments":true,"path":"2019/07/10/Web/JavaScript的学习/","link":"","permalink":"http://yoursite.com/2019/07/10/Web/JavaScript的学习/","excerpt":"","text":"JavaScript的学习JavaScript的简介为什么学习JavaScript​ 1、html+css 只是可以实现静态的页面无法实现动态的效 果 ​ 2、表单的校验 ​ 3、背景图片的更换 ​ 4、操作节点的信息 ​ 5、 小游戏的开发 ​ ………………… JavaScript的概念​ JavaScript 一种直译式脚本语言，是一种动态类型、弱类型、 基于原型的语言，内置支持类型 JavaScript的组成​ 1.ECMAScript：JavaScript的核心 ​ 2.文档对象模型（DOM）：DOM（文档对象模型）是 HTML 和XML 的应用程序接口（API）。DOM 将把整个页面规划成由节点层级构成的文档 3.浏览器对象模型（BOM）对浏览器窗口进行访问和操作 JavaScript的特点1.脚本语言 ​ 脚本语言是一种简单的程序，是由一些ASCII字符构 成，可以使用任何一种文本编辑器编写。一些程序语言（如C、C++、Java等）都必须经过编译，将源 代码编译成二进制的可执行文件之后才能运行，而 脚本语言不需要事先编译，只要有一个与其相适应 的解释器就可以执行。  脚本语言是指在web浏览器内有解释器解释执行的 编程语言，每次运行程序的时候，解释器会把程序 代码翻译成可执行的格式。 2、基于对象的语言 ​  面向对象有三大特点（封装，继承，多态）却一不 可。 ​  通常“基于对象”是使用对象，但是无法利用现有的对象模板产生新的对象类型，也就是说“基于对象” 没有继承的特点。没有了继承的概念也就无从谈论“多态” 3、事件驱动： ​  在网页中执行了某种操作的动作，被称为“事 件”(Event)，比如按下鼠标、移动窗口、选择菜单 等都可以视为事件。当事件发生后，可能会引起相 应的事件响应。 4、简单性 ​  变量类型是采用弱类型，并未使用严格的数据类型。 var a,b,c; a=123; b=“abc”; a=b; 5、安全性 ​  JavaScript不能访问本地的硬盘，不能将数据存入 到服务器上，不能对网络文档进行修改和删除，只 能通过浏览器实现信息浏览或动态交互 6、跨平台性 ​  JavaScript依赖于浏览器本身，与操作平台无关， 只要计算机安装了支持JavaScript 的浏览器（装有 JavaScript解释器），JavaScript 程序就可以正确执行。 ​  缺点 ​  各种浏览器支持JavaScript的程度是不一样的，支 持和不完全支持JavaScript的 浏览器在浏览同一 个带有JavaScript脚本的网页时，效果会有一定的 差距，有时甚至会显示不出来。 JS的声明和引入123456789101112&lt;!-- JS引入的方式1 --&gt; &lt;script type=&quot;text/javascript&quot;&gt; /* 网页中的弹框 */ alert(&quot;js的引入方式1&quot;) &lt;/script&gt; &lt;!-- JS引入的方式2 type:引入文件的类型 src:引入文件的路径 charset:指定文件编码方式 --&gt; &lt;!-- 注意：引入JS的时候千万不要二合一 --&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;js/test.js&quot; charset=&quot;UTF-8&quot;&gt;&lt;/script &gt; ​","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"CSS的学习","slug":"Web/CSS的学习","date":"2019-07-10T14:59:11.000Z","updated":"2019-11-22T10:48:34.264Z","comments":true,"path":"2019/07/10/Web/CSS的学习/","link":"","permalink":"http://yoursite.com/2019/07/10/Web/CSS的学习/","excerpt":"","text":"CSSCSS入门为什么学习CSS(CSS的作用)​ 【1】HTML 虽然可以在一定程度上修饰页面，但是页面的整体还是不够美观 ​ 【2】HTML 进行网页的书写重复的代码比较多，后期的维 护性不好。 什么是CSS(CSS的概念)​ 英文全称：Cascading Style Sheets ​ 层叠样式表（级联样式表） CSS引入​ CSS的引入的三种方式 &lt;!-- CSS引入方式的顺序，就近原则 --&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/css1.css&quot;/&gt; &lt;style&gt; /*p代表标签的名称*/ p{ /*字体颜色*/ color: yellow; /*字体大小*/ font-size: 25px; /*字体加粗*/ font-weight: bold; } &lt;/style&gt; &lt;!-- 外部式（链接式） rel:引入的文件和当前文件的关系 type:引入类型 href:引入文件的 --&gt; &lt;!-- &lt;style&gt; /**导入式(了解即可)*/ @import url(&quot;css/css1.css&quot;); &lt;/style&gt; --&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 1.行内形式 键：值--&gt; &lt;!-- &lt;p style=&quot;color: red;&quot;&gt;我们不一样&lt;/p&gt; --&gt; &lt;!-- 内嵌形式 --&gt; &lt;!-- &lt;p&gt;我们不一样&lt;/p&gt; &lt;p&gt;我们不一样&lt;/p&gt; --&gt; &lt;p&gt;我们不一样&lt;/p&gt; &lt;/body&gt; 外部css 123456789p&#123; /**字体的风格*/ font-family: 宋体; /**字体的样式*/ font-style: italic; color: green;&#125; CSS引入方式的顺序，就近原则，跟随最近的加载的引入 选择器通用选择器/**通用选择器,代表该页面中所有元素*/ *{ color: red; background-color: black; } 元素选择器12345678/**元素选择器*/div&#123; width: 200px; height: 200px; background: blue; /**边框的粗细:1px 边框的风格:solid 边框的颜色*/ border: 1px solid red;&#125; id选择器123456/* id选择器，#后加id名,id的名称保证唯一， id的命名: 由数字、字母、下划线、中划线组成，不能以数字开头*/#div1&#123; background: green;&#125; 类选择器1234/* 类选择器 */.div_1&#123; background: pink;&#125; 选择器的优先级​ id选择器&gt;类选择器&gt;元素选择器&gt;通用选择器权重： 100 10 1 0​ 其他选择器可以使用任意组合（元素选择器，id选择器,类选择器） 后代选择器12345678/**后代选择器:只要包含该标签对象即可*/div span&#123; font-size: 27px; font-family: 宋体; color: green;&#125; ​ 子选择器 ​ 1234/**子选择器：直系子标签*/div&gt;span&#123; color: red;&#125; 兄弟选择器​ 123456789/**兄弟选择器:只会改变下面相邻的元素对象*/ #p_1+p&#123; color: #0000FF;&#125;/**兄弟选择器后面所有的兄弟对象都改变*/#p_1~p&#123; color: red; font-size: 30px;&#125; 伪类选择器1234/**伪类选择器**/a:hover&#123; /*hover:鼠标放上*/ color: red;&#125; 常用的属性常用的属性112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;style&gt; .top&#123; width: 100%; height: 100px; border: 1px solid red; &#125; .top_a&#123; /**字体颜色*/ color: gray; /**字体大小*/ font-size: 12px; /*字体的加粗*/ /* font-weight: bold; */ /**字体的风格*/ /* font-family: 宋体; */ /**字体的样式*/ font-style: italic; /**去除下划线*/ text-decoration: none; &#125; a:hover&#123; color: red; /**下划线展示*/ text-decoration: underline; &#125; .tips&#123; width: 100%; height: 40px; border: 1px dotted indigo; background-color: pink; /**文本居中*/ text-align: center; /**行高： 行高的高度和div外面的高度一致，这时里面的内容就会垂直居中*/ line-height: 40px; &#125; .center&#123; width: 100%; height: 500px; border: 1px solid red; /**设置背景图片*/ background-image: url(&quot;http://img13.360buyimg.com/da/jfs/t1/43308/30/8709/99646/5d22e91dE4a7f5729/6b8ea2cf39afcbd1.jpg&quot;); /**设置背景图片不重复*/ background-repeat: no-repeat; /**调整背景图片的位置 x值 y值*/ background-position: center; /*调整背景图片的大小 宽 高*/ /* background-size: 1200px 500px; */ /**背景颜色 或者使用rgb(255,0,0)*/ background-color: #37cef5; /**rgba()最后的.1是透明度*/ /* background-color: rgba(255,0,0,.1); */ &#125; &lt;/style&gt; &lt;body&gt; &lt;!-- 顶部的位置 --&gt; &lt;div class=&quot;top&quot;&gt; &lt;a href=&quot;&quot; class=&quot;top_a&quot;&gt;登录页面，调查问卷&lt;/a&gt; &lt;/div&gt; &lt;!-- 中间的提示 --&gt; &lt;div class=&quot;tips&quot;&gt; &lt;span&gt;根据网络安全法，为保障您的账号安全，请完成手机号验证&lt;/span&gt; &lt;/div&gt; &lt;!-- 中间位置 --&gt; &lt;div class=&quot;center&quot;&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 常用的属性21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .div_1&#123; width: 200px; height: 200px; background: rgba(255, 0, 0); color: rgba(0,0,255); /**调整透明度（0-1）*/ opacity: 0.4; /**超出：hidden隐藏 auto：自动*/ overflow: hidden; &#125; #span_1&#123; width: 100px; height: 100px; color: red; border: 1px solid red; /**显示： 行内元素转换成块元素 行内元素：inline 块元素:block none：隐藏 */ display: block; &#125; ul&#123; /*向右浮动*/ float: right; &#125; li&#123; /*列表的风格去除*/ list-style: none; /**向左浮动*/ float: left; /*内边距*/ padding-left: 15px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;hao123&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;地图&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;视频&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;贴吧&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;学术&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &lt;!-- 行内元素：多个标签位于同一行 span,font,小标签 块元素：标签可以自动换行 div, h1-h6, ul, p --&gt; &lt;div class=&quot;div_1&quot;&gt; 我们都是div我们都是div我们都是div 我们都是div我们都是div 我们都是div我们都是div 我们都是div我们都是div我们都是div 我们都是div我们都是div 我们都是div我们都是div 我们都是div我们都是div我们都是div 我们都是div我们都是div 我们都是div我们都是div我们都是div我们都是div我们都是div 我们都是div我们都是div 我们都是div我们都是div &lt;/div&gt; &lt;hr /&gt; 01&lt;span id=&quot;span_1&quot;&gt;234&lt;/span&gt;56 &lt;/body&gt;&lt;/html&gt; 定位123456789101112131415161718192021222324252627282930313233343536373839/** 绝对定位 absolute:定位离开之后释放的之前的位置 基于外层父级标签 相对定位 relative:定位离开之后不释放之前的位置 基于之前的位置来说 固定定位 fixed:始终是居于浏览器的左上角的定位， 适合做广告 默认定位 static:初始的定位位置 */ .div_1&#123; width: 200px; height: 200px; background-color: red; /* 绝对定位 */ /* position: absolute; top: 300px; left: 300px; */ /* 相对定位 */ /* position: relative; top: 300px; left: 300px; */ /**固定定位*/ position: fixed; top: 150px; left: 150px; /**置于底层*/ z-index: -1; &#125; .div_2&#123; width: 200px; height: 200px; background-color: green; /**相对定位：基于之前的位置*/ /* position: relative; top: 300px; left: 300px; */ &#125; &lt;/style&gt; 盒子模型12345678910111213141516171819202122232425262728293031323334353637383940&lt;style type=&quot;text/css&quot;&gt; /**清除body和html标签的边距**/ body,html&#123; margin: 0px; padding: 0px; &#125; .div_1&#123; width: 300px; height: 300px; background-color: red; /* 内边距 真实div与border之间的距离 30px是上下的距离，50px是指左右的距离 指定四个值：上右下左 padding-left: 30px;在一个方向加 */ /* padding: 30px 50px; */ /* padding-left: 30px; */ /* 外边距 给盒子进行定位*/ /* margin: 50px; */ /* margin-left: 100px; margin-top: 70px; */ margin-bottom: 40px; margin-right: 40px; &#125; .div_2&#123; width: 300px; height: 300px; background-color: green; /* 外边距 垂直的方向会取较大的值 */ margin-top: 70px; /* 外边距 水平方向会合并 */ margin-left: 50px; &#125; div&#123; float: left; &#125; &lt;/style&gt; CSS3新增选择器伪类选择器，伪对象选择器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;style type=&quot;text/css&quot;&gt; /* 获取class名称是div_1下面的第一个子元素 */ .div_1&gt;p:first-child&#123; color: red; &#125; .div_1&gt;p:last-child&#123; color: blueviolet; &#125; /**获得具体的某一个子元素*/ /* .div_1&gt;p:nth-child(4)&#123; color: brown; &#125; */ /* 单双行 even:双 odd:单*/ /* .div_1&gt;p:nth-child(even)&#123; background-color: red; &#125; .div_1&gt;p:nth-child(odd)&#123; background-color: green; &#125; */ /* 获得空的元素对象 */ .div_1&gt;p:empty&#123; height: 50px; background-color: #8A2BE2; &#125; /* 获得焦点执行的样式 */ /* input:focus&#123; width: 300px; height: 300px; &#125; */ input:checked&#123; width: 20px; height: 20px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;div_1&quot;&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;4&lt;/p&gt; &lt;p&gt;5&lt;/p&gt; &lt;/div&gt; &lt;hr /&gt; &lt;input type=&quot;text&quot; /&gt; &lt;hr /&gt; 男:&lt;input type=&quot;radio&quot; name=&quot;sex&quot;/&gt; 女:&lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt; &lt;/body&gt; 属性选择器12345678910111213141516171819202122232425262728293031323334353637383940&lt;style type=&quot;text/css&quot;&gt; /* 属性选择器 可以操作任意有属性的标签*/ /* input[type=text]&#123; width: 300px; height: 30px; &#125; */ /* 属性 ^用fom开头的 $用结尾 */ input[name^=fom]&#123; width: 300px; height: 30px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 选择器的种类 1)基础选择器 * id class 标签 ..... 2)关系选择器 &gt; + ~ ....... 3)伪类选择器 hover ......... 4)伪对象选择器 before after ....... 4)属性选择器 input[type=text] ...... --&gt; &lt;p&gt; 账号：&lt;input type=&quot;text&quot; name=&quot;fom_zh&quot;/&gt; &lt;/p&gt; &lt;p&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;fom_pwd&quot;/&gt; &lt;/p&gt; &lt;p&gt; 邮箱：&lt;input type=&quot;email&quot; name=&quot;fom_email&quot;/&gt; &lt;/p&gt; &lt;p&gt; 年龄：&lt;input type=&quot;number&quot; name=&quot;age&quot; /&gt; &lt;/p&gt; &lt;/body&gt; 新增属性​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475body&#123; background-color: pink; &#125; .cen&#123; width: 200px; height: 200px; background-color: red; /* 阴影 参数值：水平偏移 垂直偏移 模糊度(值越大越模糊) 颜色 */ box-shadow: 0px 0px 70px red; /* 调用动画 */ /* animation: 1s aj infinite; */ &#125; .lef&#123; /**倒圆角指令*/ border-radius: 100px; /* 左上右下 右上左下 */ /* border-radius: 10px 60px; */ /**左上 右上 右下 左下*/ /* border-radius: 10px 20px 30px 40px; */ position: absolute; top: 200px; left: 200px; animation: 1s aj1 infinite; &#125; .rig&#123; border-radius: 100px; position: absolute; top: 200px; left: 341px; animation: 1s aj1 infinite; &#125; .c&#123; /* 旋转角度 */ transform: rotate(45deg); position: absolute; top: 269px; left: 271px; /* background-color: black; */ animation: 1s aj2 infinite; &#125; div:hover&#123; /* 放大的倍数 */ /* transform: scale(1.3); */ /* translate（水平位移 垂直位移） */ /* transform: translate(0px,-50px); box-shadow: 0px 0px 70px red; */ /* skew：2d旋转 */ /* transform: skew(45deg); */ &#125; /**C3中的动画*/ @keyframes aj1&#123; /* 过程 */ /* form&#123;&#125; to&#123;&#125; */ /* 百分比指定 */ 0%&#123;transform: scale(1);&#125; 50%&#123;transform: scale(1.1);&#125; 100%&#123;transform: scale(1);&#125; &#125; @keyframes aj2&#123; /* 需要旋转 */ 0%&#123;transform: scale(1) rotate(45deg);&#125; 50%&#123;transform: scale(1.1) rotate(45deg);&#125; 100%&#123;transform: scale(1) rotate(45deg);&#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 给class起两个名字 --&gt; &lt;div class=&quot;cen lef&quot;&gt;&lt;/div&gt; &lt;div class=&quot;cen c&quot;&gt;&lt;/div&gt; &lt;div class=&quot;cen rig&quot;&gt;&lt;/div&gt; &lt;/body&gt;","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"HTML的学习","slug":"Web/HTML的学习","date":"2019-07-08T12:27:11.000Z","updated":"2019-07-15T02:21:20.192Z","comments":true,"path":"2019/07/08/Web/HTML的学习/","link":"","permalink":"http://yoursite.com/2019/07/08/Web/HTML的学习/","excerpt":"","text":"HTML入门为什么学习 HTML？需求：（生活中遇到问题） 随着技术的发展，信息量的增大网页的数据信息没有办 法完美的、漂亮的展现到用户的面前。 意义:(作用)： HTML是一种专门对网页信息进行规范化展示的语言。 把网页的信息格式化展现的语言 什么是HTML？ HTML(Hyper Text Markup Language)：超文本标记语言 超文本：文本信息 、图片、声音、视频、超链接等 标记：标签的体现 HTML中的标签Head标签的子标签12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 搜索引擎优化 --&gt; &lt;meta name=\"author\" content=\"朱自清,张三\" /&gt; &lt;meta name=\"description\" content=\"盼望着盼望着东风来了\" /&gt; &lt;meta name=\"keywords\" content=\"东风,盼望\"/&gt; &lt;!-- 自动刷新网页(5s后刷新) --&gt; &lt;meta http-equiv=\"refresh\" content=\"5;https://www.baidu.com\" /&gt; &lt;!-- 禁止网页缓存 --&gt; &lt;meta http-equiv=\"Pragma\" content=\"no-cache\"/&gt; &lt;meta http-equiv=\"Cache-Control\" content=\"no-cache\" /&gt; &lt;meta http-equiv=\"expires\" content=\"0\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; meta标签的组成meta标签共有两个属性，它们分别是http-equiv属性和name属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。 1、name属性 name属性主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。 meta标签的name属性语法格式是： 1&lt;meta name=&quot;参数&quot; content=&quot;具体的参数值&quot;&gt; 其中name属性主要有以下几种参数： A、Keywords(关键字) 说明：keywords用来告诉搜索引擎你网页的关键字是什么。 举例： 1&lt;meta name=&quot;keywords&quot; content=&quot;science,education,culture,politics,ecnomics，relationships,entertaiment,human&quot;&gt; B、description(网站内容描述) 说明：description用来告诉搜索引擎你的网站主要内容。 举例： 1&lt;meta name=&quot;description&quot; content=&quot;Thispageisaboutthemeaningofscience,education,culture.&quot;&gt; C、robots(机器人向导) 说明：robots用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引。 content的参数有all,none,index,noindex,follow,nofollow。默认是all。 举例： 1&lt;meta name=&quot;robots&quot; content=&quot;none&quot;&gt; D、author(作者) 说明：标注网页的作者 举例： 1&lt;meta name=&quot;author&quot; content=&quot;root,root@xxxx.com&quot;&gt; 2、http-equiv属性 http-equiv顾名思义，相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。 meta标签的http-equiv属性语法格式是： 1&lt;meta http-equiv=&quot;参数&quot; content=&quot;参数变量值&quot;&gt;； 其中http-equiv属性主要有以下几种参数： A、Expires(期限) 说明：可以用于设定网页的到期时间。一旦网页过期，必须到服务器上重新传输。 用法： 1&lt;meta http-equiv=&quot;expires&quot; content=&quot;Fri,12Jan200118:18:18GMT&quot;&gt; 注意：必须使用GMT的时间格式。 B、Pragma(cache模式) 说明：禁止浏览器从本地计算机的缓存中访问页面内容。 用法： 1&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt; 注意：这样设定，访问者将无法脱机浏览。 C、Refresh(刷新) 说明：自动刷新并指向新页面。 用法：&lt; 1metahttp-equiv=&quot;Refresh&quot;content=&quot;2;URL=http://www.jb51.net&quot;&gt; 注意后面的引号，分别在秒数的前面和网址的后面) 注意：其中的2是指停留2秒钟后自动刷新到URL网址。 D、Set-Cookie(cookie设定) 说明：如果网页过期，那么存盘的cookie将被删除。 用法：&lt; 1meta http-equiv=&quot;Set-Cookie&quot; content=&quot;cookievalue=xxx;expires=Friday,12-Jan-200118:18:18GMT；path=/&quot;&gt; 注意：必须使用GMT的时间格式。 E、Window-target(显示窗口的设定) 说明：强制页面在当前窗口以独立页面显示。 用法：&lt;metahttp-equiv=”Window-target”content=”_top”&gt; 注意：用来防止别人在框架里调用自己的页面。 F、content-Type(显示字符集的设定) 说明：设定页面使用的字符集。 用法：&lt;metahttp-equiv=”content-Type”content=”text/html;charset=gb2312”&gt; G、content-Language（显示语言的设定） 用法：&lt;metahttp-equiv=”Content-Language”content=”zh-cn”/&gt; H、Cache-Control指定请求和响应遵循的缓存机制。Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、on ly-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。各个消息中的指令含义如下Public指示响应可被任何缓存区缓存Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效no-cache指示请求或响应消息不能缓存no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。 Meta标签使用技巧Meta标签是用来描述网页属性的一种语言，标准的Meta标签可以便于搜索引擎排序，提高搜索引擎网站权重排名。要想网站做的更符合搜索引擎标准就必须了解meta标签，下面由Seoer惜缘于大家讲讲meta标签含义与使用方法： 1、META标签的keywords 写法为：&lt;metaname=”Keywords”content=”信息参数”/&gt; meat标签的Keywords的的信息参数，代表说明网站的关键词是什么。 2、META标签的Description &lt;metaname=”Description”content=”信息参数”/&gt; meta标签的Description的信息参数，代表说明网站的主要内容，概况是什么。 3、META标签的http-equiv=Content-Typecontent=”text/html http-equiv=Content-Type代表的是HTTP的头部协议，提示浏览器网页的信息， &lt;metahttp-equiv=”Content-Type”content=”text/html;charset=信息参数”/&gt; meta标签的charset的信息参数如GB2312时，代表说明网站是采用的编码是简体中文； meta标签的charset的信息参数如BIG5时，代表说明网站是采用的编码是繁体中文； meta标签的charset的信息参数如iso-2022-jp时，代表说明网站是采用的编码是日文； meta标签的charset的信息参数如ks_c_5601时，代表说明网站是采用的编码是韩文； meta标签的charset的信息参数如ISO-8859-1时，代表说明网站是采用的编码是英文； meta标签的charset的信息参数如UTF-8时，代表世界通用的语言编码； 4、META标签的generator &lt;metaname=”generator”content=”信息参数”/&gt; meta标签的generator的信息参数，代表说明网站的采用的什么软件制作。 5、META标签的author &lt;metaname=”author”content=”信息参数”&gt; meta标签的author的信息参数，代表说明网页版权作者信息。 6、META标签的http-equiv=”Refresh” &lt;Metahttp-equiv=”Refresh”Content=”时间;Url=网址参数”&gt; meta标签的Refresh代表多少时间网页自动刷新，加上Url中的网址参数就代表，多长时间自动链接其他网址。 7、META标签的HTTP-EQUIV=”Pragma”CONTENT=”no-cache” &lt;METAHTTP-EQUIV=”Pragma”CONTENT=”no-cache”&gt;代表禁止浏览器从本地计算机的缓存中访问页面内容,这样设定，访问者将无法脱机浏览。 8、META标签的COPYRIGHT &lt;METANAME=”COPYRIGHT”CONTENT=”信息参数”&gt; meta标签的COPYRIGHT的信息参数，代表说明网站版权信息。 9、META标签的http-equiv=”imagetoolbar” &lt;metahttp-equiv=”imagetoolbar”content=”false”/&gt; 指定是否显示图片工具栏，当为false代表不显示，当为true代表显示。 10、META标签的Content-Script-Type &lt;Metahttp-equiv=”Content-Script-Type”Content=”text/javascript”&gt; W3C网页规范，指明页面中脚本的类型。 11、META标签的revisit-after &lt;METAname=”revisit-after”CONTENT=”7days”&gt; revisit-after代表网站重访,7days代表7天，依此类推。 12、META标签的Robots&lt;metaname=”Robots”contect=”信息参数”&gt; Robots代表告诉搜索引擎机器人抓取哪些页面 其中的属性说明如下: 信息参数为all：文件将被检索，且页面上的链接可以被查询； 信息参数为none：文件将不被检索，且页面上的链接不可以被查询； 信息参数为index：文件将被检索； 信息参数为follow：页面上的链接可以被查询； 信息参数为noindex：文件将不被检索，但页面上的链接可以被查询； 信息参数为nofollow：文件将被检索，但页面上的链接不可以被查询； 基本标签标题标签1234&lt;!--标题标签 h1-h6 自动的加粗加黑 会自动的换行align:调整标签的位置 （默认是left） --&gt;【新时代·幸福美丽新边疆】西藏：代代接力守护绿色家园&lt;h1 align=&quot;right&quot;&gt;【新时代·幸福美丽新边疆】&lt;/h1&gt; &lt;h2&gt;【新时代·幸福美丽新边疆】&lt;/h2&gt; &lt;h3&gt;【新时代·幸福美丽新边疆】&lt;/h3&gt; &lt;h4&gt;【新时代·幸福美丽新边疆】&lt;/h4&gt; &lt;h5&gt;【新时代·幸福美丽新边疆】&lt;/h5&gt; &lt;h6&gt;【新时代·幸福美丽新边疆】&lt;/h6&gt; 分割线标签12345&lt;!--分割线标签 width：宽度 500px:像素 color:颜 色 align:位置（默认center） size:垂直方向的大小 --&gt; p段落标签1&lt;!--p段落标签 br:换行 &amp;nbsp;空格--&gt; 预文本标签123&lt;!--预文本标签 按照我们指定的格式输出 （灵活 性比较的大）--&gt; 小标签123456789101112131415161718&lt;!-- 下划线标签 --&gt;&lt;u&gt;北京尚学堂&lt;/u&gt;&lt;!-- 斜体标签 --&gt;&lt;i&gt;北京尚学堂&lt;/i&gt;&lt;!-- 加粗加黑 --&gt;&lt;b&gt;北京尚学堂&lt;/b&gt;&lt;!-- 删除线标签 --&gt;&lt;del&gt;北京尚学堂&lt;/del&gt;&lt;!-- 上标标签 --&gt;2&lt;sup&gt;3&lt;/sup&gt;&lt;!-- 下标标签 --&gt;log&lt;sub&gt;10&lt;/sub&gt;&lt;!-- 放大字体 --&gt;&lt;big&gt;北京尚学堂&lt;/big&gt;&lt;!-- 字体标签 font:指定字体的风格--&gt;&lt;font color=&quot;red&quot; size=&quot;25px&quot; face=&quot;宋体&quot;&gt;北京尚学堂&lt;/font&gt;&lt;!-- --&gt;&lt;span &gt;北京尚学堂&lt;/span&gt; 列表标签12345678910111213141516171819202122232425&lt;!-- 列表标签 1.有序列表 2.无序列表 3.自定义列表 作用: 1.树形菜单 2.导航栏的布局 3. ... --&gt; &lt;!--有序列表--&gt; &lt;ol type = &quot;I&quot;&gt; &lt;li&gt;javase&lt;/li&gt; &lt;li&gt;javaee&lt;/li&gt; &lt;li&gt;javame&lt;/li&gt; &lt;/ol&gt; &lt;!-- 无序列表 --&gt; &lt;ul&gt; &lt;li&gt;javase&lt;/li&gt; &lt;li&gt;javaee&lt;/li&gt; &lt;li&gt;javame&lt;/li&gt; &lt;/ul&gt; &lt;!-- 自定义列表 --&gt; &lt;dl&gt; &lt;dt&gt;java&lt;/dt&gt; &lt;dd&gt;javase&lt;/dd&gt; &lt;dd&gt;javaee&lt;/dd&gt; &lt;dd&gt;javame&lt;/dd&gt; &lt;/dl&gt; 跑马灯标签12&lt;!-- 跑马灯标签 direction:方向 scrollamount：移动像素--&gt; &lt;marquee direction=&quot;right&quot; scrollamount=&quot;40px&quot;&gt;北京尚学堂&lt;/marquee&gt; 超链接标签超链接标签的作用（不会自动换行） 【1】实现不同页面之间的跳转 href:指定跳转到目标资源的位置 target：打开网页的方式 【2】实现锚点功能 1234567&lt;!--跳转到本地的资源位置--&gt;&lt;a href=&quot;02body中常用小标签.html&quot;target=&quot;_blank&quot;&gt;02小标签测试&lt;/a&gt;&lt;!--跳转到网络的位置--&gt;&lt;a href=&quot;http://www.bjsxt.com&quot;&gt;北京尚学堂&lt;/a&gt;锚点功能&lt;a href=&quot;#bottom&quot; name=&quot;top&quot;&gt;返回底部&lt;/a&gt; &lt;a href=&quot;#top&quot; name=&quot;bottom&quot;&gt;返回顶部&lt;/a&gt; 图片标签img (不会自动的换行) src:引入图片的位置{相对路径、绝对路径、网络路径 } title：图片的标题 原始 宽和高 400px 260px 200px 130px border:图片的边框 alt：图片无法正常显示的时候显示的属性 align:图片的位置 ，必须有参照物 123456789101112131415161718&lt;!--相对路径--&gt;&lt;img src=&quot;img/2.jpg&quot; /&gt;&lt;!--绝对路径--&gt;&lt;imgsrc=&quot;C:\\\\Users\\\\my\\\\Documents\\\\HBuilderProjects\\\\01HTML\\\\img\\\\1.jpg&quot; /&gt;&lt;!--网络路径--&gt;&lt;img src=&quot;https://www.baidu.com/img/bd_logo1.png&quot;/&gt;&lt;p&gt;6666&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;img/1.jpg&quot; title=&quot;图片&quot; width=&quot;200px&quot;height=&quot;200px&quot; border=&quot;2px&quot; alt=&quot;图片显示错误&quot;align=&quot;right&quot;/&gt;&lt;/a&gt;8888&lt;/p&gt; 表格标签hbuilder的快捷键：table&gt;tr3&gt;th3 :声明3行3列的表格 ，再按下table table表格的自适应能力 (align=”center”) width=”300px” height=”300px” cellpadding：内容和单 元格的距离 cellspacing：单元格和单元格的距离 tr:指定height行高属性，行td:指定width的列宽属性，普通列 th:标题列，自动的居中，加黑效果 colspan:列合并 rowspan：行合并 bgcolor：背景颜色 表单标签https://www.baidu.com/s？键1=值1&amp;键2=值2 action：表单提交的位置 method（get/post）：表单提交的方式 GET: (1)参数会依附于url地址之后 (2)利用get方式提交数据，数据的长度有限制 (3)利用get方式提交数据，是不安全的 Post (1)请求不会依附于地址， (2)利用post处理参数不受限制 (3)post提交数据比较安全 12345678910111213141516171819202122232425262728293031323334&lt;form&gt; &lt;!-- 普通文本框 value：默认值， --&gt; 账号:&lt;input type=\"text\" name=\"zh\" value=\"123\"/&gt;&lt;br/&gt; 密码:&lt;input type=\"password\" name=\"pwd\" value=\"123\" /&gt;&lt;br/&gt; &lt;!-- 单选框(指定同一个name属性) value值 checked,默认值--&gt; 男: &lt;input type=\"radio\" name=\"sex\" value=\"0\"/&gt; 女: &lt;input type=\"radio\" name=\"sex\" value=\"1\" checked=\"checked\"/&gt; &lt;!-- 多选框 --&gt; 抽烟: &lt;input type=\"checkbox\" checked=\"checked\"/&gt; 喝酒: &lt;input type=\"checkbox\" checked=\"checked\"/&gt; 烫头: &lt;input type=\"checkbox\" /&gt;&lt;br /&gt; &lt;!-- 多行文本框 --&gt; 个人介绍:&lt;textarea rows=\"15\" cols=\"20\" &gt;你好&lt;/textarea&gt;&lt;br/&gt; &lt;!-- 文件选择 --&gt; &lt;input type=\"file\" name=\"file\" /&gt; &lt;!-- 隐藏框 --&gt; &lt;input type=\"hidden\" name=\"sno\" value=\"20180607\" /&gt; &lt;!-- 下拉框 --&gt; &lt;select name=\"ch\"&gt; &lt;!-- 1,2,3，value是保存在数据库中的 --&gt; &lt;option value=\"1\"&gt;中国&lt;/option&gt; &lt;option value=\"2\"&gt;美国&lt;/option&gt; &lt;!-- selected,默认勾选的属性 --&gt; &lt;option value=\"3\" selected=\"selected\"&gt;日本&lt;/option&gt; &lt;/select&gt; &lt;!-- 提交按钮 --&gt; &lt;input type=\"submit\" value=\"提交\" /&gt;&lt;br/&gt; &lt;!-- 清除按钮,清空写好的内容，回归默认的值 --&gt; &lt;input type=\"reset\" value=\"清除\" /&gt; &lt;!-- 普通按钮 --&gt; &lt;input type=\"button\" value=\"普通按钮\"/&gt;&lt;/form&gt; div标签div本身是没有任何的含义 div：作用就是把网页进行模块化的划分 123456789101112131415&lt;!-- div本身没有任何的含义 div作用就是把网页进行模块化的划分 --&gt; &lt;!-- 头部模块 --&gt; &lt;div class=&quot;top&quot;&gt;&lt;/div&gt; &lt;!-- 中间提示 --&gt; &lt;div class=&quot;tips&quot;&gt;&lt;/div&gt; &lt;!-- 中间的展现 --&gt; &lt;div class=&quot;center&quot;&gt; &lt;div class=&quot;login&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 底部模块 --&gt;&lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt; HTML5增强的form表单标签123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;p&gt; &lt;!-- 邮箱 --&gt; 邮箱：&lt;input type=\"email\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;!-- 数字 只支持字母e，科学计数法--&gt; 年龄:&lt;input type=\"number\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;!-- 滑动器 --&gt; 滑动器:&lt;input type=\"range\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;!-- 搜索 --&gt; 搜索:&lt;input type=\"search\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;!-- 日期 --&gt; 日期:&lt;input type=\"date\" /&gt; 日期:&lt;input type=\"week\" /&gt; 日期:&lt;input type=\"month\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;!-- 颜色 --&gt; 颜色:&lt;input type=\"color\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;!-- 网址 --&gt; 网址:&lt;input type=\"url\" /&gt; &lt;/p&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;input type=\"reset\" value=\"重置\" /&gt; &lt;/form&gt; &lt;hr /&gt; &lt;!-- h5中的增强属性 placeholder: autofocus:自动获得焦点 max:最大值 min:最小值 maxlength:最大长度 minlength:最小长度 --&gt; &lt;form&gt; &lt;p&gt; 账号:&lt;input type=\"text\" placeholder=\"手机号/邮箱/账号\" autofocus/&gt; &lt;/p&gt; &lt;p&gt; 密码:&lt;input type=\"password\" maxlength=\"4\" minlength=\"2\" /&gt; &lt;/p&gt; &lt;p&gt; 最大值:&lt;input type=\"number\" max=\"130\" min=\"0\"/&gt; &lt;/p&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;input type=\"reset\" value=\"重置\" /&gt; &lt;/form&gt; 结构标签12345678910style中引用header&#123; height: 100px; width: 100%; background-color: red;&#125;body中引用&lt;!-- 头部模块 --&gt; &lt;header&gt;&lt;/header&gt; 音频视频标签12345678910111213141516&lt;!-- 音频标签，control:控制条 --&gt; &lt;audio src=&quot;img/1.mp3&quot; controls=&quot;controls&quot;&gt; 该网页不支持媒体标签 &lt;/audio&gt; &lt;audio&gt; &lt;source src=&quot;img/1.mp3&quot;&gt;&lt;/source&gt; &lt;source src=&quot;img/1.ogg&quot;&gt;&lt;/source&gt; 该网页不支持媒体标签 &lt;/audio&gt; &lt;!-- 视频标签 --&gt; &lt;video src=&quot;&quot; controls=&quot;controls&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;&lt;/video&gt; &lt;video&gt; &lt;source src=&quot;&quot;&gt;&lt;/source&gt; &lt;/video&gt; &lt;!-- 多媒体,支持视频音频，自动播放 --&gt; &lt;embed src=&quot;img/1.mp3&quot;&gt;&lt;/embed&gt; 其他标签12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;figure&gt; &lt;img src=&quot;img/2.jpg&quot; /&gt; &lt;figcaption&gt;动漫图片&lt;/figcaption&gt; &lt;/figure&gt; &lt;!-- &lt;dl&gt; &lt;dd&gt; &lt;img src=&quot;img/2.jpg&quot; /&gt; &lt;/dd&gt; &lt;dd&gt; IT程序员 &lt;/dd&gt; &lt;/dl&gt; --&gt; &lt;!-- 展示详细信息 --&gt; &lt;details&gt; &lt;summary&gt;显示详细信息&lt;/summary&gt; &lt;p&gt;中国&lt;/p&gt; &lt;!-- mark标记 --&gt; &lt;mark&gt;中国2&lt;/mark&gt; &lt;p&gt;日本&lt;/p&gt; 美国 &lt;/details&gt; &lt;!-- 刻度 , max,min最大最小值， value默认值， low,high自己定义的最小值，最大值--&gt; &lt;meter max=&quot;100&quot; min=&quot;0&quot; value=&quot;100&quot; low=&quot;20&quot; high=&quot;80&quot;&gt;&lt;/meter&gt; &lt;!-- 进度条 --&gt; &lt;progress max=&quot;100&quot; value=&quot;40&quot;&gt;&lt;/progress&gt; &lt;!-- datalist 中描述了其可能的值 --&gt; &lt;datalist id=&quot;city&quot;&gt; &lt;option value=&quot;IBM&quot;&gt;IBM&lt;/option&gt; &lt;option value=&quot;ORACLE&quot;&gt;ORACLE&lt;/option&gt; &lt;/datalist&gt; &lt;input type=&quot;text&quot; list=&quot;city&quot; /&gt; &lt;!-- 画布标签 --&gt; &lt;canvas id=&quot;mycat&quot;&gt;&lt;/canvas&gt; &lt;script&gt; var ca = document.getElementById(&quot;mycat&quot;); var te = ca.getContext(&quot;2d&quot;); //背景颜色 te.fillStyle = &quot;#FF0000&quot;; //绘制图形的大小 te.fillRect(0,0,80,100); &lt;/script&gt;","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"SQL使用","slug":"DataBase/Oracle/SQL使用","date":"2019-07-01T04:55:01.000Z","updated":"2019-12-06T07:53:57.626Z","comments":true,"path":"2019/07/01/DataBase/Oracle/SQL使用/","link":"","permalink":"http://yoursite.com/2019/07/01/DataBase/Oracle/SQL使用/","excerpt":"","text":"SQLSQL语言基础SQL 语言定义 SQL，Structured Query Language 结构化查询语言 SQL 是所有关系型数据库的操作的标准语言 SQL 是非过程化语言-只需要告诉做什么，不需要关注怎么做 SQL 的用途 数据库数据的增删改查操作(GRUD) 数据库对象（用户，表格，序列，索引)的创建，修改和删除操作 用户权限/角色的授予和取消 事务 (Transaction) SQL 语言的分类a) DQL ，Data Query Language ，执行查询 select b) DML,Data Manipulation Language，执行增删改的任务 insert delete update c) DLL,Data Definition Language ,用于操作数库对象 add，modify，drop d) DCL,Data Control Language，用于操作用户权限，grant， revoke(撤与) e) TCL, Transaction Control Language, 事务控制语言 commit，rollback 关系数据库基本概念 关系：整个二维表 关系名：表格名称 元组：行数据(记录) 属性：列数据(字段) 属性名：列名称(字段名) 主键：唯一确定元组的属性组(关键字) 域：属性的取值范围 函数函数的分类​ 单行函数：这些函数仅对单个行进行运算，并且每行返回一个结果 ​ 多行函数（聚合函数）：这些函数能够操纵成组的行，每个行组给出一个结果，这些函数 ​ 也被称为组函数 单行函数的使用字符函数​ 数值函数​ 日期函数​ 转换函数​ 隐式转换 ​ 显示转换 ​ to_char（num or date,format） ​ to_number（char, format） ​ to_date（char, format） 通用(其他)函数​ NVL(EXP1, EXP2) ​ 如果exp1的值为null，则返回exp2的值，否则返回exp1的值 ​ NVL2(EXP1, EXP2, EXP3) ​ 如果exp1的值为null，则返回exp2的值，否则返回exp3的值 ​ NULLIF(expr1, expr2) ​ 比较两个表达式，如果相等，返回空，如果不相等，返回第一个表达式，第一个表达式不能为空 ​ expr1是对于expr2的被比较原值 ​ expr2是对于expr1的被比较原值(如果它不等于expr1,expr1被返回) ​ COALESCE(expr1, expr2, …expm) ​ expr1 如果非空，返回该表达式 ​ expr2 如果第一个表达式为空并且该表达式非空，返回该表达式 ​ expm 如果前面的表达式都为空，返回该表达式 ​ DECODE(VALUE,IF1,THEN1,IF2,THEN2,……,ELSE) ​ 如果value的值为if1，则返回then1的值，如果value的值为if2,则返回then2的值，……，否则返回else值 ​ 示例: ​ select REGION_ID, decode(REGION_ID, 1, ‘1号’, 2, ‘2号’, 3, ‘3号’, ‘错误’) from REGIONS ​ …… 多行函数的使用​ 多表查询内连接​ 内连接基本与自然连接相同，不同之处在于自然连接的是同名属性列的连接，而内连接则不要求两属性列同名，可以用using或on来指定某两列字段相同的连接条件。 自然连接​ 自然连接是一种特殊的等值连接，他要求两个关系表中进行连接的必须是相同的属性列（名字相同），无须添加连接条件，并且在结果中消除重复的属性列。 外连接左外连接​ 左外连接是在两表进行连接，只把左表要舍弃的保留在结果集中，右表对应的列上填null。 右外连接​ 右外连接是在两表进行连接，只把右表要舍弃的保留在结果集中，左表对应的列上填null。 全外连接​ 全外连接是在两表进行连接，只把左表和右表要舍弃的都保留在结果集中，相对应的列上填null。 ​","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://yoursite.com/tags/Oracle/"}]},{"title":"Oracle","slug":"DataBase/Oracle/oracle的用户","date":"2019-07-01T04:55:01.000Z","updated":"2019-07-01T05:01:12.267Z","comments":true,"path":"2019/07/01/DataBase/Oracle/oracle的用户/","link":"","permalink":"http://yoursite.com/2019/07/01/DataBase/Oracle/oracle的用户/","excerpt":"","text":"Oracle用户和登录sys和system1)【sys】所有 oracle 的数据字典的基表和视图都存放在 sys 用户中，这些基表和视图对于 oracle 的运行是至关重要的，由数据库自己维护，任何用户都不能手动更改。 sys 用户拥有 dba ， sysdba ， sysoper 等角色或权限，是 oracle 权限最高的用户。 2)【 system 】 用户用于存放次一级的内部数据，如 oracle 的一些特性或工具的管理信息。 system 用户拥有普通 dba 角色权限。 以normal,sysdba,sysopra身份登录normal 是普通用户 sysdba 拥有最高的系统权限，登陆后是 syssysoper 主要用来启动、关闭数据库， sysoper 登陆后用户是 public 注意:sys只能以sysdba身份登录","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://yoursite.com/tags/Oracle/"}]},{"title":"git提交github仓库","slug":"Config/git提交github仓库","date":"2019-06-28T15:12:26.000Z","updated":"2019-07-08T06:53:16.875Z","comments":true,"path":"2019/06/28/Config/git提交github仓库/","link":"","permalink":"http://yoursite.com/2019/06/28/Config/git提交github仓库/","excerpt":"","text":"git提交github仓库提交1) 本地新建一个文件夹res,作为项目根目录 2) 打开git,进入res, 3) git init 在项目根目录执行git init命令 4)建立远程仓库连接: (use ssh) ​ git remote add origin git@github.com:Momentonly/Java.git ​ git remote add origin git@github.com:账号名/仓库名.git ` 5)查看git状态: git status 6)git add -A 自动添加全部要上传到仓库的文件 7)git commit -m ‘注释’ 8) git push -u origin master 从远程分支拉取master分支并与本地master分支合并。 拉取1)git pull origin master:master 从远程分支拉取master分支并与本地master分支合并。 注意：当发现远程仓库已经有内容并提示先执行git pull，将内容进行合并后再上传，在执行git pull的时候，或者会出现 123456789There is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details git pull &lt;remote&gt; &lt;branch&gt;If you wish to set tracking information for this branch you can do so with: git branch --set-upstream-to=origin/&lt;branch&gt; master 也就是指定当前工作目录工作分支，跟远程的仓库，分支之间的链接关系。然后按照提示输入git branch --set-upstream-to=origin/master master与master分支关联，完成后再执行 git pull 和 git push,","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"log4j的配置","slug":"Logging/Log4j的配置","date":"2019-06-25T00:50:30.000Z","updated":"2020-04-20T00:47:20.145Z","comments":true,"path":"2019/06/25/Logging/Log4j的配置/","link":"","permalink":"http://yoursite.com/2019/06/25/Logging/Log4j的配置/","excerpt":"","text":"log4jEclipse的log4j.properties配置 rootCategory以前的配置，不推荐使用 123456789101112131415161718192021# Set root category priority to INFO and its only appender to CONSOLE. #只打印到控制台，并设置日志级别# log4j.rootCategory=DEBUG, CONSOLE #打印到控制台，日志文件，并设置日志级别为DEBUGlog4j.rootCategory=DEBUG, CONSOLE, LOGFILE # CONSOLE is set to be a ConsoleAppender using a PatternLayout. #控制台的输出格式log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout #指定输出的信息格式 %m:message,%n:换行,%c:class,追踪产生日志的类#%l,包名类名方法名，第几行出现问题,log4j.appender.CONSOLE.layout.ConversionPattern=- %m %c %l%d&#123;yyyy-MM-dd HH:mm:ss&#125;%n # LOGFILE is set to be a File appender using a PatternLayout. #日志文件的输出格式log4j.appender.LOGFILE=org.apache.log4j.FileAppender log4j.appender.LOGFILE.File=d:/test.log log4j.appender.LOGFILE.Append=true log4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayout log4j.appender.LOGFILE.layout.ConversionPattern=- %m %l%n 详细配置详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#配置根日志优先级，及输出位置#语法：log4j.rootLogger = [debug],apppenderName1,appenderName2...log4j.rootLogger = debug,stdout,D #上面定义了两个输出位置名：stdout与D，现分别配置：#配置stdout为调试窗口输出:log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.out#指定了一个模式表达式的布局log4j.appender.stdout.layout=org.apache.log4j.PatternLayout#设置该模式表达式log4j.appender.stdout.layout.ConversionPattern=[%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n#说明：#[%-5p]:%p设置输出日志优先级，&apos;-&apos;表示左对齐，5表示日志优先级所占字符个数的宽度，取5是为了保持一致。如：[DEBUG]#%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125;,指定了打印日志时间与时间格式，SSS表示？#%l: 输出日志事件的发生位置，见第四部分。%n，输出换行符。%m，输出日志事件发生的方法名。#配置D为输出日志到文件：log4j.appender.D=org.apache.log4j.FileAppenderlog4j.appender.D.File=D:\\\\Program_software\\\\Apache7_0_75\\\\webapps\\\\testLog.loglog4j.appender.D.layout=org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern=[%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n####################################################################———————————配置详细说明，共四部分——————————##一、配置log4j.rootLogger#语法：log4j.rootLogger = [debug],apppenderName1,appenderName2...#如：log4j.rootLogger = debug,stdout#二、配置Appeder——输出位置#语法：log4j.appender.appenderName = fully.qualified.name.of.appender.class#完全合法的appenderName 有几类选择#1、控制台：org.apache.log4j.ConsoleAppender#对应选项：#Threshold=WARN:指定日志消息的输出最低层次#ImmediateFlush=true:默认日志立即打印#Target=System.err:默认情况下使用System.out 输出控制台#2、文件：org.apache.log4j.FileAppender#对应选项：#Threshold=WARN:指定日志消息输出最低层次#ImmediateFlush=true:默认日志立即打印#File=mylog.txt:指定输出路径，可以是任何路径#Append=false：默认值是true，为false则覆盖#3、周期产生日志文件：org.apache.log4j.DailyRollingFileAppender#对应选项：#Threshold=WARN:指定日志消息输出最低层次#ImmediateFlush=true:默认日志立即打印#File=a.log:指定消息输出到a.log文件，默认是从web服务器的根路径开始#Append=false：默认为true#DatePattern=&apos;.&apos;yyyy-ww:每周滚动一次文件，即每周产生一个新的文件。#也可指定周期：#&apos;.&apos;yyyy-MM:每月#&apos;.&apos;yyyy-ww:每周#&apos;.&apos;yyyy-MM-dd:每天#&apos;.&apos;yyyy-MM-dd-a：每天两次#&apos;.&apos;yyyy-MM-dd-HH：每小时#&apos;.&apos;yyyy-MM-dd-HH-mm：每分钟#4、指定文件尺寸大小产生日志文件：org.apache.log4j.RollingFileAppender#对应选项：#Threshold=WARN:指定日志消息输出最低层次#ImmediateFlush=true:默认日志立即打印#File=a.log：指定日志文件#Append=false：默认为true#MaxFileSize=100KB：单位可以是KB|MB|GB，日志文件达到最大时，将会自动滚动，即将原来的内容移到mylog.log.1文件#MaxBackupIndex=2：指定可以产生滚动文件的最大数#5、将日志以流格式发送到任意指定的地方：org.apache.log4j.WriterAppender#例如：#log4j.appender.R=org.apache.log4j.DailyRollingFileAppender #log4j.appender.R.File=D:\\\\eclipsespace\\\\testSSH\\\\WebContent\\\\WEB-INF\\\\testlog.log #三、配置日志信息的格式布局(layout)#layout负责格式化Appender 的输出#语法：#log4j.appender.appenderName.layout=fully.qualified.name.of.layout.class#有效的layout类名字有以下几种：#1、org.apache.log4j.HTMLLayout（以HTML表格形式布局） #该选项有以下几种： #LocationInfo=true:默认值是false,输出java文件名称和行号 #Title=my app file: 默认值是 Log4J Log Messages. #2、org.apache.log4j.PatternLayout（可以灵活地指定布局模式） #该选项有以下几种： #ConversionPattern=%m%n :指定怎样格式化指定的消息 #其中%m%n等符号所代表的含义如下： (有问题，暂不管)#－X号: X信息输出时左对齐； #%p: 输出日志信息优先级，即DEBUG，INFO，WARN，ERROR，FATAL, #%d: 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d&#123;yyy MMM dd HH:mm:ss,SSS&#125;，输出类似：2002年10月18日 22：10：28，921 #%r: 输出自应用启动到输出该log信息耗费的毫秒数 #%c: 输出日志信息所属的类目，通常就是所在类的全名 #%t: 输出产生该日志事件的线程名 #%l: 输出日志事件的发生位置，相当于%C.%M(%F:%L)的组合,包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10) #%x: 输出和当前线程相关联的NDC(嵌套诊断环境),尤其用到像java servlets这样的多客户多线程的应用中。 #%%: 输出一个&quot;%&quot;字符 #%F: 输出日志消息产生时所在的文件名称 #%L: 输出代码中的行号 #%m: 输出代码中指定的消息,产生的日志具体信息 #%n: 输出一个回车换行符，Windows平台为&quot;\\r\\n&quot;，Unix平台为&quot;\\n&quot;输出日志信息换行 #可以在%与模式字符之间加上修饰符来控制其最小宽度、最大宽度、和文本的对齐方式。如： #%20c：指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，默认的情况下右对齐。 #%-20c:指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，&quot;-&quot;号指定左对齐。 #%.30c:指定输出category的名称，最大的宽度是30，如果category的名称大于30的话，就会将左边多出的字符截掉，但小于30的话也不会有空格。 #%20.30c:如果category的名称小于20就补空格，并且右对齐，如果其名称长于30字符，就从左边交远销出的字符截掉。 # 如：%-4r %-5p %d&#123;yyyy-MM-dd HH:mm:ssS&#125; %c %m%n [TEST] %p [%t] %C.%M(%L) | %m%n #3、org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串） #4、org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息） #四、其他#指定包名下的日志级别#语法：log4j.logger.包名=日志级别#如：#log4j.logger.com.neusoft =DEBUG #指定com.neusoft包下的所有类的等级为DEBUG。 #log4j.logger.com.opensymphony.oscache=ERROR #log4j.logger.net.sf.navigator=ERROR #这两句是把这两个包下出现的错误的等级设为ERROR，如果项目中没有配置EHCache，则不需要这两句。 #log4j.logger.org.apache.commons=ERROR #log4j.logger.org.apache.struts=WARN ## #这两句是struts的包。作者：Liekkas_BX 来源：CSDN 原文：https://blog.csdn.net/qq_19865749/article/details/70306971 版权声明：本文为博主原创文章，转载请附上博文链接！","categories":[{"name":"Logging","slug":"Logging","permalink":"http://yoursite.com/categories/Logging/"}],"tags":[{"name":"log4j","slug":"log4j","permalink":"http://yoursite.com/tags/log4j/"}]},{"title":"数据源和连接池","slug":"DataBase/MyBatis/数据源和连接池","date":"2019-06-22T05:24:30.000Z","updated":"2019-06-22T06:51:34.022Z","comments":true,"path":"2019/06/22/DataBase/MyBatis/数据源和连接池/","link":"","permalink":"http://yoursite.com/2019/06/22/DataBase/MyBatis/数据源和连接池/","excerpt":"","text":"数据源（1）数据源是一种数据库对编程提供的一个接口，每个数据源对应一个数据库。（2）连接池只是存放数据库连接对象的一个缓冲池，需要数据连接的时候从缓冲池中取就行了。（3）连接池可以管理数据源。 ​ 用TCP来连接你的应用程序与数据库是一件昂贵的事情（很费时的事情），开发者可以通过用连接池来反复的使用数据库的连接。比起每次请求都用TCP来连一次数据库，连接池只有在不存在有效的连接时才新建一个TCP连接。当关闭一个连接的时候，它会被放到池中，它仍然会保持与数据库的连接，这样就可以减少与数据库的TCP连接次数。​ 数据源是指数据的来源，比如数据库。连接池是指这样一个“池子”，池子中的每个东西都是连接数据源的一个“连接”，这样别人想连接数据源的时候可以从这个“池子”里取，用完以后再放回来供以后其他想使用的人使用。我们一般说的数据源指的就是数据库～ 数据源是指数据的来源的概括，包含了数据库位置 和 数据库类型等信息，实际上是一种数据连接的抽象。 也可以说，你要得到的信息存放的地方的概括（包括 存放信息的数据库类型、数据库的地址等等信息的概括） c3p0,dbcp,druid配置数据源也可以说是对整个数据库连接参数的配置（包括各种配置，以及连接池的管理）","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"}]},{"title":"mytabis的学习","slug":"DataBase/MyBatis/mytabis的学习","date":"2019-06-22T03:07:30.000Z","updated":"2019-06-30T09:19:55.388Z","comments":true,"path":"2019/06/22/DataBase/MyBatis/mytabis的学习/","link":"","permalink":"http://yoursite.com/2019/06/22/DataBase/MyBatis/mytabis的学习/","excerpt":"","text":"接口绑定方案MyBatis中，提供了一套接口绑定方案，程序员可以提供一个接口，然后提供对应接口的一个mapper.xml文件。 MyBatis会自动将接口和xml文件进行绑定，实际上就是MyBatis会根据接口和对应的xml文件创建接口的实现类。 可以得到实现类的对象。 实现: 映射文件的命名和接口的命名一致 映射文件的namespace写接口的全限定路径 Mapper接口与Mapper.xml放在同一个包下 mybatis如何通过接口查找对应的mapper.xml及方法执行详解链接:https://www.jb51.net/article/116402.htm mybatis中接口文件Mapper和接口配置文件Mapper.xml不在同一个目录下1：只有单独的Mybatis没有Spring的情况下 a:首先修改*Mapper.xml中的namespace 1&lt;mapper namespace=&quot;cn.gsm.mkm.dao.UserMapper&quot;&gt; 指定到你的*Mapper接口 b:在mybatis总配置文件中指定扫描目标 &lt;mappers&gt; &lt;mapper resource=&quot;cn/gsm/mkm/mapper/UserMapper.xml&quot;&gt;&lt;/mapper&gt; &lt;package name=&quot;cn.gsm.mkm.dao.UserMapper&quot;&gt;&lt;/package&gt;&lt;!-- 指定具体文件--&gt; &lt;/mappers&gt; 需要注意，这样配置必须指定具体的文件。否则dom4j解析会报错SAXParseException。 通过接口绑定解决多参数的传递1)接口中定义方法 1User selByUP(String username, String password); 映射文件中提供对应的标签. 此时, SQL语句中获取方式 有两种, 通过#{index}或#{param+数字}的方式. 12345&lt;select id=*&quot;selByUP&quot;* resultType=*&quot;user&quot;*&gt; select * from t_user where username=#&#123;0&#125; and password=#&#123;1&#125; &lt;/select&gt; 2) 接口中定义方法, 参数中使用@Param 注解设定参数名用 于在 SQL 语句中使用. 1User selByUP(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password); 映射文件中提供对应的标签. 此时, SQL语句中获取方式 有两种, 通过#{参数名称}或#{param+数字}的方式. 1234567&lt;select id=*&quot;selByUP&quot;* resultType=*&quot;user&quot;*&gt; select * from t_user where username=#&#123;username&#125; and password=#&#123;password&#125; &lt;/select&gt; 动态SQL根据条件的不同, SQL 语句也会随之动态的改变. MyBatis 中, 提供了一组标签用于实现动态 SQL. if标签用于进行条件判断, test 属性用于指定判断条件. 为了拼接 条件, 在 SQL 语句后强行添加 1=1 的恒成立条件. 1234567891011121314151617&lt;select id=*&quot;sel&quot;* resultType=*&quot;user&quot;*&gt; select * from t_user where 1=1 &lt;if test=*&quot;username != null and username != &apos;&apos;&quot;*&gt; and username=#&#123;username&#125; &lt;/if&gt; &lt;if test=*&quot;password != null and password != &apos;&apos;&quot;*&gt; and password=#&#123;password&#125; &lt;/if&gt; &lt;/select&gt; if标签中的test属性中取值直接写别名，不能用索引或者param+数字取值，也不用#{别名} 12345&lt;!-- 5.判断字符串是否等于特定字符(比如此处的user) --&gt;&lt;if test=&apos;stringParam != null and stringParam == &quot;user&quot;&apos;&gt;&lt;/if&gt;&lt;if test=&quot;stringParam != null and stringParam != &apos;user&apos;&quot;&gt;&lt;/if&gt; &lt;!-- 如果要用这个写法要 --&gt;&lt;if test=&quot;stringParam != null and stringParam != &apos;user&apos;.toString()&quot;&gt;&lt;/if&gt; where 标签用于管理 where 子句. 有如下功能: a)如果没有条件, 不会生成 where 关键字 b)如果有条件, 会自动添加 where 关键字 c)如果第一个条件中有 and, 去除之 1234567891011&lt;select id=&quot;sel&quot; resultType=&quot;user&quot;&gt;select * from t_user&lt;where&gt; &lt;if test=&quot;username != null and username != &apos;&apos;&quot;&gt; and username=#&#123;username&#125; &lt;/if&gt; &lt;if test=&quot;password != null and password != &apos;&apos;&quot;&gt; and password=#&#123;password&#125; &lt;/if&gt;&lt;/where&gt;&lt;/select&gt; choose,when,otherwise标签这是一套标签, 功能类似于 switch…case…default when只成立一个 12345678910111213141516171819&lt;select id=*&quot;sel&quot;* resultType=*&quot;user&quot;*&gt; select * from t_user &lt;where&gt; &lt;choose&gt; &lt;!-- when 只成立一个--&gt; &lt;when test=*&quot;username != null and username != &apos;&apos;&quot;*&gt; and username = #&#123;username&#125; &lt;/when&gt; &lt;when test=*&quot;password != null and password != &apos;&apos;&quot;*&gt; and password = #&#123;password&#125; &lt;/when&gt; &lt;otherwise&gt; and 1=1 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; Set标签用于维护 update 语句中的 set 子句. 功能如下: a)满足条件时, 会自动添加 set 关键字 b)会去除 set 子句中多余的逗号 c)不满足条件时, 不会生成 set 关键字 Trim标签用于在前后添加或删除一些内容 a)prefix, 在前面添加内容 b)prefixOverrides, 从前面去除内容 c)suffix, 向后面添加内容 d)suffixOverrides, 从后面去除内容 1234567891011121314&lt;update id=*&quot;updUser&quot;* parameterType=*&quot;user&quot;*&gt; update t_user &lt;!-- prefix: 前缀, 表示向前面添加内容 prefixOverrides: 从前面删除内容 suffix: 后缀, 表示向后面添加内容 suffixOverrides: 从后面删除内容 --&gt; &lt;trim prefix=*&quot;set&quot;* prefixOverrides=*&quot;user&quot;* suffix=*&quot;hahaha&quot;* suffixOverrides=*&quot;,&quot;*&gt; username=#&#123;username&#125;, &lt;/trim&gt; where id=#&#123;id&#125; &lt;/update&gt; bind标签用于对数据进行再加工, 用于模糊查询 12345678910&lt;select id=&quot;sel&quot; resultType=&quot;user&quot;&gt; select * from t_user &lt;where&gt; &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt; &lt;!-- 处理username，将值处理后依旧赋值给username --&gt; &lt;bind name=&quot;username&quot; value=&quot;&apos;%&apos; + username + &apos;%&apos;&quot;/&gt; and username like #&#123;username&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; foreach标签用于在 SQL 语句中遍历集合参数, 在 in 查询中使用 a)collection: 待遍历的集合 b)open: 设置开始符号 c)item: 迭代变量 d)separator: 项目分隔符 e)close: 设置结束符号 12345678910&lt;select id=&quot;selIn&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt;select * from t_user where id in&lt;!--collection=&quot;list&quot; 指定集合是list--&gt;&lt;foreach collection=&quot;list&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;item=&quot;item&quot;&gt;#&#123;item&#125;&lt;/foreach&gt;&lt;/select&gt;//接口中起别名listList&lt;User&gt; selIn(@Param(&quot;list&quot;) List&lt;Integer&gt; list); sql,include标签1234567891011121314151617&lt;sql&gt;用于提取 SQL 语句, &lt;include&gt;用于引用 SQL 语句&lt;sql id=&quot;mySql&quot;&gt;id, username, password&lt;/sql&gt; &lt;select id=&quot;selIn&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt; select &lt;!--引用提取的sql语句--&gt; &lt;include refid=&quot;mySql&quot;/&gt; from t_user where id in &lt;foreach collection=&quot;list&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot; item=&quot;item&quot;&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; MyBatis的缓存机制a)缓存用于提高查询的效率. b)MyBatis的缓存是使用SQL标签的. 执行相同的标签可以使用缓缓存. c) MyBatis 中有两种缓存机制. 注意:缓存的查询通过id标识，即同一个sql语句(namespace+id) 一级缓存a)默认开启. 线程级别的缓存, SqlSession 的缓存 b)在一个 SqlSession 生命周期中有效. SqlSession 关闭, 缓存清空.sqlSession对象级别的 二级缓存a)进程级别的缓存, SqlSessionFactory 的缓存 b)在一个 SqlSessionFactory 生命周期中有效.可以在多个 SqlSession 生命中期中共享. c)默认关闭, 需要使用的时候, 要为某个命名空间开启二级 缓存(在 mapper.xml 中配置\\&lt;cache>. 12&lt;!-- 开启二级缓存, 要求实体类进行序列化 --&gt;&lt;cache /&gt; 12&lt;!--readOnly只读，实体类可以不实现序列化接口--&gt;&lt;cache readOnly=&quot;true&quot;&gt;&lt;/cache&gt; 解决列名和属性名不一致问题如果查询时使用 resultType 属性, 表示采用 MyBatis 的 Auto-Mapping(自动映射)机制, 即相同的列名和属性名会自 动匹配. 因此, 当数据库表的列名和类的属性名不一致时, 会导致查不到数据. 解决该问题可以有两种方式: 列别名查询时, 可以通过列别名的方式将列名和属性名保持一致, 继续使用自动映射, 从而解决该问题. 但是较为麻烦. 123&lt;select id=&quot;selAll&quot; resultType=&quot;user&quot;&gt;select id id1, username username1, password password2 from t_user&lt;/select&gt; 使用\\&lt;resultMap>\\&lt;resultMap>用于自定义映射关系, 可以由程序员自主制定 列名和属性名的映射关系. 一旦使用 resultMap, 表示不再 采用自动映射机制. 1234567891011&lt;!--type实体类，id标识该resultMap--&gt;&lt;resultMap type=*&quot;user&quot;* id=*&quot;umap&quot;*&gt; &lt;!-- id用于映射主键 --&gt; &lt;id column=*&quot;id&quot;* property=*&quot;id1&quot;* /&gt; &lt;!-- 非主键使用result映射 --&gt; &lt;result column=*&quot;username&quot;* property=*&quot;username1&quot;* /&gt; &lt;result column=*&quot;password&quot;* property=*&quot;password1&quot;* /&gt; &lt;/resultMap&gt; &lt;select id=*&quot;selAll&quot;* resultMap=*&quot;umap&quot;*&gt; select * from t_user &lt;/select&gt; 多表查询resultMap的N+1方式实现多表查询（多对一）resultMap中的association属性用于关联一个对象 1） property: 指定要关联的属性名 2） select: 设定要继续引用的查询, namespace+id 3） column: 查询时需要传递的列 12345678910111213141516&lt;resultMap type=&quot;Student&quot; id=&quot;stumap&quot;&gt; &lt;!-- id用于映射主键 --&gt; &lt;id column=&quot;s_id&quot; property=&quot;id&quot;/&gt; &lt;!-- 非主键使用result映射 --&gt; &lt;result column=&quot;s_name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;s_age&quot; property=&quot;age&quot;/&gt; &lt;result column=&quot;s_gender&quot; property=&quot;gender&quot;/&gt; &lt;result column=&quot;s_c_id&quot; property=&quot;cid&quot;/&gt; &lt;!-- 用于关联一个对象 property:Student实体类中的属性 select:调用一个查询方法 column:使用哪一列的值作为参数传递到select调用的查询方法 注意:column使用数据库列名s_c_id --&gt; &lt;association property=&quot;clazz&quot; select=&quot;com.szxy.mapper.ClazzMapper.selById&quot; column=&quot;s_c_id&quot;&gt;&lt;/association&gt; &lt;/resultMap&gt; 关联查询a)在 StudentMapper.xml 中定义多表连接查询 SQL 语句, 一 次性查到需要的所有数据, 包括对应班级的信息. b)通过resultMap定义映射关系, 并通过association指 定对象属性的映射关系. 可以把association看成一个resultMap使用. javaType 属性表示当前对象, 可以写 全限定路径或别名. 12345678910111213141516171819202122&lt;!-- 关联查询 --&gt; &lt;resultMap type=&quot;Student&quot; id=&quot;smap&quot;&gt; &lt;id column=&quot;sid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;sname&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;s_age&quot; property=&quot;age&quot;/&gt; &lt;result column=&quot;s_gender&quot; property=&quot;gender&quot;/&gt; &lt;result column=&quot;s_c_id&quot; property=&quot;cid&quot;/&gt; &lt;!-- property:Student类的属性名 javaType:是一个类型，Clazz的类型,可以当做association的返回值类型 --&gt; &lt;association property=&quot;clazz&quot; javaType=&quot;Clazz&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;c_name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;c_room&quot; property=&quot;room&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=&quot;selAll&quot; resultMap=&quot;smap&quot;&gt; select s_id sid,s_name sname,s_age, s_gender,s_c_id cid,c_name cname,c_room from t_student s left join t_class c on s.s_c_id = c_id &lt;/select&gt; resultMap的N+1方式实现多表查询（一对多）​ 提供 ClazzMapper 和 StudentMapper, ClazzMapper 查询所有 班级信息, StudentMapper 根据班级编号查询学生信息. 在 ClazzMapper 中使用\\&lt;collection>设置装配. a)\\&lt;collection>用于关联一个集合  property: 指定要关联的属性名  select: 设定要继续引用的查询, namespace+id  column: 查询时需要传递的列 1234567891011&lt;!-- N+1多对一查询 --&gt; &lt;resultMap type=&quot;Clazz&quot; id=&quot;cmap&quot;&gt; &lt;id column=&quot;c_id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;c_name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;c_room&quot; property=&quot;room&quot;/&gt; &lt;!-- 关联一个集合 --&gt; &lt;collection property=&quot;stus&quot; select=&quot;com.szxy.mapper.StudentMapper.selByCid&quot; column=&quot;c_id&quot;&gt;&lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;selAll&quot; resultMap=&quot;cmap&quot;&gt; select * from t_class &lt;/select&gt; resultMap的关联方式实现多表查询（一对多）a)在 ClazzMapper.xml 中定义多表连接查询 SQL 语句, 一次 性查到需要的所有数据, 包括对应学生的信息. b)通过\\&lt;resultMap>定义映射关系, 并通过\\&lt;collection>指 定集合属性泛型的映射关系. 可以把\\&lt;collection>看成一 个\\&lt;resultMap>使用. ofType 属性表示集合的泛型, 可以 写全限定路径或别名. 注:colletion关联一个集合 1）property: Clazz类中的stus属性名 2)javaType: Clazz类中的stus属性的类型 3)ofType:stus属性是List集合，指定泛型 12345678910111213141516171819202122&lt;!-- 关联查询（多对一） --&gt; &lt;resultMap type=&quot;Clazz&quot; id=&quot;clzmap&quot;&gt; &lt;id column=&quot;cid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;cname&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;croom&quot; property=&quot;room&quot;/&gt; &lt;!-- 关联一个集合 ofType:集合的泛型 --&gt; &lt;collection property=&quot;stus&quot; javaType=&quot;list&quot; ofType=&quot;Student&quot;&gt; &lt;id column=&quot;sid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;sname&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;sage&quot; property=&quot;age&quot;/&gt; &lt;result column=&quot;sgender&quot; property=&quot;gender&quot;/&gt; &lt;result column=&quot;cid&quot; property=&quot;cid&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;selAll2&quot; resultMap=&quot;clzmap&quot;&gt; select c.c_id cid,c.c_name cname, c_room croom,s.s_id sid, s.s_name sname,s.s_age sage,s.s_gender sgender from t_class c left join t_student s on c.c_id = s.s_c_id &lt;/select&gt; 通过Auto-Mapping实现多表查询（多对一）a)通过 MyBatis 的 Auto-Mapping 机制及数据库查询时的别 名结合, 可以方便的实现多表查询. b)SQL 语句中, 别名出现特殊符号时, 必须进行处理. MySQL 可以使用()符号, Oracle 可以使用(“”)符号. 123456789&lt;!-- AutoMapping 将别名使用属性名.属性来进行自动映射 --&gt; &lt;select id=&quot;selAutoMapping&quot; resultType=&quot;Student&quot;&gt; select s_id id,s_name name,s_age age,s_gender gender,s_c_id cid,s_c_id `clazz.id`,c_name `clazz.name`,c_room `clazz.room` from t_student s left JOIN t_class c on s.s_c_id = c.c_id &lt;/select&gt; 注解开发a)注解是用于描述代码的代码. 例如: @Test(用于描述方法 进行 junit 测试), @Override(用于描述方法的重写), @Param(用于描述属性的名称) b)注解的使用风格: @xxx(属性), 使用前必须先导包 c)使用注解一般用于简化配置文件. 但是, 注解有时候也不 是很友好(有时候反而更麻烦), 例如动态 SQL. d)关于注解的属性  属性的设定方式是: 属性名=属性值 e)关于属性值的类型  基本类型和 String, 可以直接使用双引号的形式  数组类型, name={值 1, 值 2, …}; 如果数组元素只有 一个, 可以省略大括号  对象类型, name=@对象名(属性)  如果属性是该注解的默认属性, 而且该注解只配置这 一个属性, 可以将属性名省略 f)注解和配置文件可以配合使用 1234567891011@Select(&quot;select * from t_student&quot;) List&lt;Student&gt; selAll(); @Insert(value = &#123;&quot;insert into t_student values(default,#&#123;name&#125;,#&#123;age&#125;,#&#123;gender&#125;,#&#123;cid&#125;)&quot;&#125;) int insStu(Student student); @Update(value = &#123;&quot;update t_student set s_age = #&#123;age&#125; where s_id = #&#123;0&#125;&quot;&#125;) int updStu(int id, @Param(&quot;age&quot;)int age); @Delete(&quot;delete from t_student where s_id = #&#123;0&#125;&quot;) int delStu(int id); 其他注解 1234567@Results: 类似于&lt;resultMap&gt; @Result: 类似于&lt;resultMap&gt;的子标签 @One: 类似于&lt;association&gt; @Many: 类似于&lt;collection&gt; @One 1234567891011121314 //N+1查询@Select(&quot;select * from t_student&quot;)@Results(value = &#123; @Result(column = &quot;s_id&quot;, property = &quot;id&quot;,id = true), @Result(column = &quot;s_name&quot;, property = &quot;name&quot;), @Result(column = &quot;s_age&quot;, property = &quot;age&quot;), @Result(column = &quot;s_gender&quot;, property = &quot;gender&quot;), @Result(column = &quot;s_c_id&quot;, property = &quot;cid&quot;), @Result(property = &quot;clazz&quot;, one = @One(select = &quot;com.szxy.mapper.ClazzMapper.selById&quot;), column = &quot;s_c_id&quot; )&#125;)List&lt;Student&gt; sel(); @Many 1234567891011@Select(&quot;select * from t_class&quot;) @Results(value = &#123; @Result(column = &quot;c_id&quot;, property = &quot;id&quot;, id = true), @Result(column = &quot;c_name&quot;, property = &quot;name&quot;), @Result(column = &quot;c_room&quot;, property = &quot;room&quot;), @Result(property = &quot;stus&quot;, many = @Many(select = &quot;com.szxy.mapper.StudentMapper.selByCid&quot;), column = &quot;c_id&quot; ) &#125;) List&lt;Clazz&gt; selClz(); MyBatis运行原理运行过程中涉及到的类或接口1)Resources(C) 用于加载 MyBatis 核心配置文件 2)XMLConfigBuilder(C) 用于解析 xml 文件(核心配置文件) 3) Configuration(C) 用于存放 xml 文件解析后的结果 4)DefaultSqlSessionFactory(C) 是 SqlSessionFactory(I)的 实 现 类 , 创 建 时 需 要 使 用 Configuration 对象 5) SqlSession(I) 是 MyBatis 操作的核心 6)DefaultSqlSession(C) 是 SqlSession 接口的实现类 7) TransactionFactory(I) 用于生产 Transaction 对象 8) Transaction(I) 用于表示操作数据库的事务对象 9)Executor(I) 是 MyBatis 的核心执行器, 类似于 jdbc 中的 Statement, 常 用的实现类是 SimpleExecutor 描述​ 当Mybatis运行开始时，先要通过Resources加载核心配置文件，之后使用XmlConfigBuilder对配置文件进行 解析，将解析结果封装为Configuration对象。接着，使用Configuration对象构建一个DefaultSqlSessionFactory 对象，至此，SqlSession工厂构建完成。 ​ 接下来，通过工厂对象调用openSession方法创建SqlSession对象。在这个过程中，需要通过TransactionFactory 生产一个Transaction对象，并且，还需要创建核心执行器Executor对象。之后，通过这些对象来创建DefaultSqlSession对象，至此，SqlSession对象创建成功。 ​ 之后，通过SqlSession对象执行相应的操作。如果执行成功，调用commit()方法提交事务；如果失败，调用rollback()方法进行事务回滚。最后，调用close()方法关闭SqlSession资源，以上，就是MyBatis的运行原理。","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"}]},{"title":"mysql配置","slug":"Linux/mysql配置","date":"2019-06-20T14:35:59.000Z","updated":"2020-02-20T12:02:47.571Z","comments":true,"path":"2019/06/20/Linux/mysql配置/","link":"","permalink":"http://yoursite.com/2019/06/20/Linux/mysql配置/","excerpt":"","text":"mysql配置配置远程访问1.查看表 12345678use mysql;select host,user from user; host | user |+-----------+-----------+| % | root || localhost | mysql.sys || localhost | root | host是主机，root表示主机可以登录的用户，%表示所有主机，但不包括localhost 2.如果没有%,root 12grant all privileges on 库名.表名 to &apos;用户名&apos;@&apos;IP地址&apos; identified by &apos;密码&apos; with grant option;flush privileges; 库名:要远程访问的数据库名称,所有的数据库使用“*”表名:要远程访问的数据库下的表的名称，所有的表使用“*”用户名:要赋给远程访问权限的用户名称IP地址:可以远程访问的电脑的IP地址，所有的地址使用“%” 3.如果配置所有ip可以远程登录root 1234567GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos; WITH GRANT OPTION; 所有的地址都可以使用root用户，密码为123456远程访问所有的数据库和表GRANT ALL PRIVILEGES ON testdb.* TO &apos;lxh&apos;@&apos;172.16.52.225&apos; IDENTIFIED BY &apos;lxh&apos; WITH GRANT OPTION;IP为172.16.52.225的电脑可以使用lxh用户，密码为lxh远程访问数据库testdb的所有表 注意需要注意mysql的配置文件中的bindaddress 的参数和skip-networking 配置 bindaddress : 设定哪些ip地址被配置，使得mysql服务器只回应哪些ip地址的请求),最好注释掉该参数或设置成为127.0.0.1以外的值 skip-networking : 如果设置了该参数项，将导致所有TCP/IP端口没有被监听,也就是说出了本机，其他客户端都无法用网络连接到本mysql服务器，所以应该注释掉该参数 mysql修改密码如果MySQL数据库用户的密码设置过于简单，数据库在用户登录后会提示重置密码，并且不接受简单的密码。 提示需要重置密码： ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement. 1ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;123456&apos;; 以上操作后又遇到新问题：ERROR 1819 (HY000): Your password does NOT satisfy the CURRENT policy requirements。 这是因为密码不符合mysql的密码策略检查 先设置复杂密码 1ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;Aa123456*&apos;; flush privileges; mysql初始密码策略 1SHOW VARIABLES LIKE &apos;validate_password%&apos;; 使用以下两个设置简单密码策略 set global validate_password_policy=0; set global validate_password_length=1; 再设置简单密码 ALTER USER ‘root‘@’localhost’ IDENTIFIED BY ‘123456’; flush privileges; mysql出现访问拒绝ERROR 1045 (28000): Access denied for user ‘root‘@’localhost’ (using password: YES) 解决： 1)修改mysql配置文件，跳过权限检查 ​ vim /etc/my.cnf ​ 加入 ​ skip-grant-tables ​ 重启mysql服务 2)修改密码 ​ use mysql; ​ update user set authentication_string=password(123456) where user=’root’; ​ flush privileges; 3)注释掉 ​ #skip-grant-tables ​ 重启mysql服务","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"hostname和hosts的区别","slug":"Linux/hostname和etchosts的区别","date":"2019-06-20T06:43:59.000Z","updated":"2019-07-16T07:44:29.011Z","comments":true,"path":"2019/06/20/Linux/hostname和etchosts的区别/","link":"","permalink":"http://yoursite.com/2019/06/20/Linux/hostname和etchosts的区别/","excerpt":"","text":"很多人一提到更改hostname首先就想到修改/etc/hosts文件，认为hostname的配置文件就是/etc/hosts。其实不是的。hosts文件的作用相当于DNS，提供IP地址hostname的对应。早期的互联网计算机少，单机hosts文件里足够存放所有联网计算机。不过随着互联网的发展，这就远远不够了。于是就出现了分布式的DNS系统。由DNS服务器来提供类似的IP地址到域名的对应。Linux系统在向DNS服务器发出域名解析请求之前会查询/etc/hosts文件，如果里面有相应的记录，就会使用hosts里面的记录。由此，/etc/hosts于设置hostname是没直接关系的，仅仅当你要在本机上用新的hostname来映射自己的IP时候才会用到/etc/hosts文件。两者没有必然的联系。redhat的hostname的配置文件是/etc/sysconfig/network. /etc/hosts内容摘录如下： #Do not remove the following line, or various programs #that require network functionality will fail. 192.168.1.102 localhost.localdomain localhost127.0.0.1 localhost.localdomain localhost::1 localhost6.localdomain6 localhost6对以上内容的解释作用：hosts 文件是用来把主机名字映射到IP地址的方法，这种方法比较简单。但这种映射只是本地映射，也就是说每台机器都是独立的，所有的计算机都不能相互通过hostname来访问。格式： 一般情况下hosts的内容关于主机名(hostname)的定义，每行为一个主机，每行由三部份组成，每个部份由空格隔开。其中#号开头的行做说明，不被系统解释。 第一部份：网络IP地址； 第二部份：主机名.域名，注意主机名和域名之间有个半角的点，比如 localhost.localdomain 第二部份：主机名(主机名别名） ，其实就是主机名；注释：1）127.0.0.1 是回环地址，比如我们不想让局域网的其它机器看到我们测试的网络程序，就可以用回环地址来测试。2）为什么需要定义域名呢？其实理解也简单，比如我们有三台主机，每台做不同的事，一台做MAIL服务器，一台做FTP服务器，一台做SMB服务器，所以我们就可以这样来设计hostname； 127.0.0.1 localhost.localdomain localhost 192.168.1.2 ftp 192.168.1.3 mail.localdomain mail 192.168.1.4 smb.localdomin smb把这上面这个配置文件的内容分别写入每台机器的/etc/hosts内容中，这样这三台局域网的机器就可以通过hostname来访问了。也就是，在局域网中，主机名也是可以解析到IP上的，相当于DNS域名解析。对于主机名的修改有两种方式:hostname和/etc/sysconfig/network [sql] view plaincopyprint?[root@think ~]# hostnamethin[root@think ~]# hostname think[root@think ~]# hostnamethink 通过hostname 这个kernel变量来设置主机名只是临时的，下次重启系统时，此主机名将不会存在.hostname也可用于显示:hostname -i。如果要永久修改RedHat hostname，就修改/etc/sysconfig/network文件，将里面的HOSTNAME这一行修改成HOSTNAME=NEWNAME，其中NEWNAME就是你要设置的hostname。 2./hosts文件可以帮助解决哪些问题2.1 远程登录linux主机过慢问题 有时客户端想远程登录一台linux主机，但每次登录输入密码后都会等很长一段时间才会进入，这是因为linux主机在返回信息时需要解析ip，如果在linux主机的hosts文件事先加入客户端的ip地址，这时再从客户端远程登录linux就会变很快。 注：这里所说的远程登录不仅仅是ssh，还可能是mysql远程登录，或是文件共享的查询等。 2.2 双机互连 当两台主机只是双机互连时，这时两台主机都需要设置自己的ip，同时在对方的hosts文件里加入自己的ip和主机名。 注：不同发行版的主机名称对应文件可以通过man host那么进行查阅 3.关于FQDN FQDN：(Fully Qualified Domain Name)完全合格域名/全称域名，是指主机名加上全路径，全路径中列出了序列中所有域成员。全域名可以从逻辑上准确地表示出主机在什么地方，也可以说全域名是主机名的一种完全表示形式。从全域名中包含的信息可以看出主机在域名树中的位置。DNS解析流程：首先查找本机HOSTS表，有的直接使用表中定义，没有查找网络连接中设置的DNS 服务器由他来解析。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"jdbc中的execute()返回值","slug":"DataBase/JDBC/jdbc中的execute()返回值","date":"2019-06-20T05:54:47.000Z","updated":"2019-06-22T06:51:51.725Z","comments":true,"path":"2019/06/20/DataBase/JDBC/jdbc中的execute()返回值/","link":"","permalink":"http://yoursite.com/2019/06/20/DataBase/JDBC/jdbc中的execute()返回值/","excerpt":"","text":"jdbc中的execute()返回值表示不同的操作 true表示查询 false表示更新或者删除","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"}]},{"title":"centos7配置dhcp和静态Ip","slug":"Linux/centos7配置DHCP和静态IP","date":"2019-06-20T05:19:59.000Z","updated":"2020-06-08T16:04:38.215Z","comments":true,"path":"2019/06/20/Linux/centos7配置DHCP和静态IP/","link":"","permalink":"http://yoursite.com/2019/06/20/Linux/centos7配置DHCP和静态IP/","excerpt":"","text":"cd /etc/sysconfig/network-scripts/ vi ifcfg-eth0 TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=static DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=eth0 UUID=85a5000d-dbaa-4a2a-8075-0df5562bf331 DEVICE=eth0 ONBOOT=yes IPADDR=192.168.1.166 NETMASK=255.255.255.0 GATEWAY=192.168.1.1 DNS1=8.8.8.8 DNS2=114.114.114.114 DNS3=223.6.6.6 1.静态IPBOOTPROTO=static #设置static IPADDR=192.168.1.166 #静态ip NETMASK=255.255.255.0 #子网掩码 GATEWAY=192.168.1.1 #网关 2.DHCP​ 12345BOOTPROTO=dhcp #设置dhcp#注释掉配置的静态ip部分#IPADDR=192.168.1.166 #NETMASK=255.255.255.0#GATEWAY=192.168.1.1 配置完成后重启网络 centos7 systemctl restart network centos7以下 service network restart","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"centos7安装缺少命令","slug":"Linux/安装centos7缺少命令问题","date":"2019-06-20T05:19:59.000Z","updated":"2019-07-16T07:45:09.684Z","comments":true,"path":"2019/06/20/Linux/安装centos7缺少命令问题/","link":"","permalink":"http://yoursite.com/2019/06/20/Linux/安装centos7缺少命令问题/","excerpt":"","text":"没有 ifconfig 、netstat命令： 1yum install -y net-tools 没有命令补全，tab补全命令： 1yum install -y bash-completion 没有killall命令： 1yum install -y psmisc","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"centos7修改网卡名","slug":"Linux/centos7修改网卡名","date":"2019-06-20T03:26:31.000Z","updated":"2019-06-20T05:14:57.104Z","comments":true,"path":"2019/06/20/Linux/centos7修改网卡名/","link":"","permalink":"http://yoursite.com/2019/06/20/Linux/centos7修改网卡名/","excerpt":"","text":"用ifconfig查看网卡名称为ens33，现在要将它修改成eth0 1)编辑配置文件/etc/sysconfig/network-scripts/ifcfg-ens33 将DEVICE=ens33修改成DEVICE=eth0 将NAME=ens33修改成NAME=eth0 保存并退出 2)重命名该配置文件。 [root@remote network-scripts]# cd /etc/sysconfig/network-scripts/ [root@remote network-scripts]# mv ifcfg-ens33 ifcfg-eth0 3)编辑/etc/default/grub并加入“net.ifnames=0 biosdevname=0 ” 示例:GRUB_CMDLINE_LINUX=”crashkernel=auto net.ifnames=0 biosdevname=0 rhgb quiet” 保存并退出 4)运行命令grub2-mkconfig -o /boot/grub2/grub.cfg 来重新生成GRUB配置并更新内核参数 5)使用reboot命令重启操作系统 注意:重启后查看ifcfg-eth0,dhcp可能被修改为static,如果没有配置静态ip网络会出错","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"数据库元数据MetaData","slug":"DataBase/JDBC/数据库元数据MetaDate","date":"2019-06-19T01:19:47.000Z","updated":"2019-06-22T06:52:17.759Z","comments":true,"path":"2019/06/19/DataBase/JDBC/数据库元数据MetaDate/","link":"","permalink":"http://yoursite.com/2019/06/19/DataBase/JDBC/数据库元数据MetaDate/","excerpt":"","text":"本篇介绍数据库方面的元数据（MetaData）的有关知识。元数据在建立框架和架构方面是特别重要的知识，再下一篇我们仿造开源数据库工具类DbUtils就要使用数据库的元数据来创建自定义JDBC框架。 在我们前面使用JDBC来处理数据库的接口主要有三个，即Connection，PreparedStatement和ResultSet这三个，而对于这三个接口，还可以获取不同类型的元数据，通过这些元数据类获得一些数据库的信息。 元数据(MetaData)，即定义数据的数据。打个比方，就好像我们要想搜索一首歌(歌本身是数据)，而我们可以通过歌名，作者，专辑等信息来搜索，那么这些歌名，作者，专辑等等就是这首歌的元数据。因此数据库的元数据就是一些注明数据库信息的数据。 ① 由Connection对象的getMetaData()方法获取的是DatabaseMetaData对象。 ② 由PreparedStatement对象的getParameterMetaData ()方法获取的是ParameterMetaData对象。 ③由ResultSet对象的getMetaData()方法获取的是ResultSetMetaData对象。 一、DatabaseMetaDataDatabaseMetaData是由Connection对象通过getMetaData方法获取而来，主要封装了是对数据库本身的一些整体综合信息，例如数据库的产品名称，数据库的版本号，数据库的URL，是否支持事务等等，能获取的信息比较多，具体可以参考DatabaseMetaData的API文档。 以下有一些关于DatabaseMetaData的常用方法： ·getDatabaseProductName：获取数据库的产品名称 ·getDatabaseProductName：获取数据库的版本号 ·getUserName：获取数据库的用户名 ·getURL：获取数据库连接的URL ·getDriverName：获取数据库的驱动名称 ·driverVersion：获取数据库的驱动版本号 ·isReadOnly：查看数据库是否只允许读操作 ·supportsTransactions：查看数据库是否支持事务 例1： 简单地获取一些常用的数据库综合信息。 二、ParameterMetaData ParameterMetaData是由PreparedStatement对象通过getParameterMetaData方法获取而来，主要是针对PreparedStatement对象和其预编译的SQL命令语句提供一些信息，比如像”insert into account(id,name,money) values(?,?,?)”这样的预编译SQL语句，ParameterMetaData能提供占位符参数的个数，获取指定位置占位符的SQL类型等等，功能也比较多，这里不列举完，详细请看有关ParameterMetaData的API文档。 以下有一些关于ParameterMetaData的常用方法： ·getParameterCount：获取预编译SQL语句中占位符参数的个数 在我看来，ParameterMetaData对象能用的只有获取参数个数的getParameterCount()方法。 注意：ParameterMetaData许多方法MySQL并不友好支持，比如像获取指定参数的SQL类型的getParameterType方法，如果数据库驱动连接URL只是简单的“jdbc:mysql://localhost:3306/jdbcdemo”那么MyEclipse会抛出SQLException异常，必须要将URL修改为“jdbc:mysql://localhost:3306/jdbcdemo?generateSimpleParameterMetadata=true”才行。但是像getParameterType等等与其他的方法也没多好用，因为如下面的例子，这些方法好像只会将所有的参数认为是字符串(VARCHAR)类型。 因为我们的SQL语句为”insert into user(id,name,age) values(?,?,?)”，而我们所有利用ParameterMetaData查询的信息除了参数个数以外，都是查询第一个参数的信息，也就是“id”列，而这个“id”列我们创建时是int整型的，但是利用ParameterMetaData的查询结果都是显示为字符串类型，因此我对ParameterMetaData的功能产生了怀疑。 因此在以后使用参数元数据ParameterMetaData尽量只要使用其getParamterCount()方法获取参数个数，对于该对象其他方法请慎用。 三、ResultSetMetaData ResultSetMetaData是由ResultSet对象通过getMetaData方法获取而来，主要是针对由数据库执行的SQL脚本命令获取的结果集对象ResultSet中提供的一些信息，比如结果集中的列数、指定列的名称、指定列的SQL类型等等，可以说这个是对于框架来说非常重要的一个对象。关于该结果集元数据对象的其他具体功能和方法请查阅有关ResultSetMetaData的API文档。 以下有一些关于ResultSetMetaData的常用方法： ·getColumnCount：获取结果集中列项目的个数 ·getColumnType：获取指定列的SQL类型对应于Java中Types类的字段 ·getColumnTypeName：获取指定列的SQL类型 ·getClassName：获取指定列SQL类型对应于Java中的类型(包名加类名)","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"JDBC操作数据库","slug":"DataBase/JDBC/JDBC操作数据库","date":"2019-06-17T14:35:47.000Z","updated":"2019-06-22T06:51:44.412Z","comments":true,"path":"2019/06/17/DataBase/JDBC/JDBC操作数据库/","link":"","permalink":"http://yoursite.com/2019/06/17/DataBase/JDBC/JDBC操作数据库/","excerpt":"","text":"","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"}]},{"title":"关于时间插入MYSQL数据库少8个小时的问题","slug":"DataBase/JDBC/关于时间插入MYSQL数据库少8个小时的问题","date":"2019-06-17T14:35:47.000Z","updated":"2019-07-22T01:49:47.929Z","comments":true,"path":"2019/06/17/DataBase/JDBC/关于时间插入MYSQL数据库少8个小时的问题/","link":"","permalink":"http://yoursite.com/2019/06/17/DataBase/JDBC/关于时间插入MYSQL数据库少8个小时的问题/","excerpt":"","text":"指定连接参数（时区）1serverTimezone=Asia/Shanghai 修改mysql时区12set global time_zone = &apos;+8:00&apos;; ##修改mysql全局时区为北京时间，即我们所在的东8区flush privileges; #立即生效","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"}]},{"title":"java中的时间类型和mysql中的时间类型","slug":"DataBase/JDBC/java中的时间类型和mysql中的时间类型","date":"2019-06-17T14:35:47.000Z","updated":"2019-07-22T02:04:31.401Z","comments":true,"path":"2019/06/17/DataBase/JDBC/java中的时间类型和mysql中的时间类型/","link":"","permalink":"http://yoursite.com/2019/06/17/DataBase/JDBC/java中的时间类型和mysql中的时间类型/","excerpt":"","text":"java中的时间类型和mysql中的时间类型mysql创建表并插入数据12345678910CREATE TABLE `time_test` ( `id` int(11) NOT NULL AUTO_INCREMENT, `dt` datetime DEFAULT NULL, `d` date DEFAULT NULL, `t` time DEFAULT NULL, `ts` timestamp(3) NULL DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8;INSERT INTO `time_test` VALUES (&apos;1&apos;, &apos;2019-06-06 10:05:06&apos;, &apos;2019-06-06&apos;, &apos;03:03:55&apos;, &apos;2019-07-19 15:29:37.999&apos;); time_test表的查询结果 12id dt d t ts1 2019-06-06 10:05:06 2019-06-06 03:03:55 2019-07-19 15:29:37.999 JDBC解析结果集12345678910while(res.next())&#123; //date System.out.println(new Date(res.getDate(\"d\").getTime())); //time System.out.println(res.getTime(\"t\")); //datetime System.out.println(new Date(res.getTimestamp(\"dt\").getTime())); //timestamp（mysql中的timestamp需要3个长度，否则无法保存毫秒值） System.out.println(res.getTimestamp(\"ts\"));&#125; 分析：java.util.Date: 年月日，时分秒 ​ java.sql.Date: 年月日 ​ java.sql.Time: 时分秒 ​ java.sql.Timestamp: 年月日，时分秒 ，毫秒 ​ mysql中的数据类型是datetime,jdbc中使用res.getTimestamp(“列名”)来获取，再转换成java.util.Date()，可以得 到（年月日，时分秒），否则，如果使用res.getDate(“列名”)，再转换成java.util.Date则丢失 时分秒（res.getDate()返回java.sql.Date(),只能精确到年月日） 注意：mysql中的timestamp需要3个长度，否则无法保存毫秒值","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"}]},{"title":"mysql注释的三种写法","slug":"DataBase/JDBC/mysql注释的三种写法","date":"2019-06-17T08:07:47.000Z","updated":"2019-06-22T06:52:09.230Z","comments":true,"path":"2019/06/17/DataBase/JDBC/mysql注释的三种写法/","link":"","permalink":"http://yoursite.com/2019/06/17/DataBase/JDBC/mysql注释的三种写法/","excerpt":"","text":"MySql--三种注释写法 需要特别注意 -- 这种注释后面要加一个空格 #DELETE FROM SeatInformation /DELETE FROM SeatInformation /– DELETE FROM SeatInformation","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"properties文件的读取","slug":"Java Web/properties文件的读取","date":"2019-06-17T02:00:38.000Z","updated":"2019-06-17T02:06:02.317Z","comments":true,"path":"2019/06/17/Java Web/properties文件的读取/","link":"","permalink":"http://yoursite.com/2019/06/17/Java Web/properties文件的读取/","excerpt":"","text":"Java 开发中，需要将一些易变的配置参数放置再 XML 配置文件或者 properties 配置文件中。然而 XML 配置文件需要通过 DOM 或 SAX 方式解析，而读取 properties 配置文件就比较容易。 读取方式1、基于ClassLoder读取配置文件 ​ 注意：该方式只能读取类路径下的配置文件，有局限但是如果配置文件在类路径下比较方便。 2、基于 InputStream 读取配置文件 ​ 注意：该方式的优点在于可以读取任意路径下的配置文件 代码实现db.properties 12user=rootpwd=123 123456789101112131415161718192021222324252627282930313233343536package jdbc.com.szxy.properties;import java.io.File;import java.io.FileInputStream;import java.io.InputStream;import java.util.Properties;/** * 读取properties文件测试 * @author Momentonly */public class ProPertiesTest &#123; public static void main(String[] args) throws Exception &#123; /** * 基于ClassLoder读取配置文件 */ Properties pro1 = new Properties(); //获取资源的输入流,类路径下 InputStream is1 = ProPertiesTest.class.getClassLoader().getResourceAsStream(\"db.properties\"); //读取输入流 pro1.load(is1); // System.out.println(pro1.getProperty(\"user\")); System.out.println(pro1.getProperty(\"pwd\")); /** * 基于 InputStream 读取配置文件 */ Properties pro2 = new Properties(); //获取资源的输入流，相对路径或者绝对路径 InputStream is2 = new FileInputStream(new File(\"src/db.properties\")); pro2.load(is2); System.out.println(pro2.getProperty(\"user\")); System.out.println(pro2.getProperty(\"pwd\")); &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"Linux常用命令2","slug":"Linux/Linux常用命令2","date":"2019-06-16T08:56:55.000Z","updated":"2019-08-18T03:05:24.350Z","comments":true,"path":"2019/06/16/Linux/Linux常用命令2/","link":"","permalink":"http://yoursite.com/2019/06/16/Linux/Linux常用命令2/","excerpt":"","text":"1.scp -r root@39.104.111.122:/usr/local/ /usr/local ​ 将远程39.104.111.122的/usr/local下的文件拷贝到本机/usr/local目录下 ​ -r 复制目录 2.scp -r /usr/local root@39.104.111.122:/usr/local/ ​ 上传本地/usr/local目录到远程39.104.111.122的/usr/local目录 3.du -sh : 查看当前目录总共占的容量。而不单独列出各子项占用的容量 4.du -sh file:查看指定文件的大小 5.userdel -r 用户名 删除一个用户 6.passwd 用户名 修改密码 7.finger 查看登录的终端 8.last 用户名 查看登录记录 9.w -s 查看登录的终端用户 10.ls -lharts 查看文件详细信息 11.pwd 查看当前的路径 12.pgrep 进程名 查看进程的pid 13.ps -ef|grep 进程名 查看进程的pid 14.killall -9 bash 杀掉所有登录的bash 注:killall [参数][进程名] 用来杀掉同名的所有进程 15.&amp;和&amp;&amp;&amp;表示该命令后台执行。 例如执行：ping 192.168.1.* &amp; 表示后台不停的执行ping命令，即便你强制中断掉该线程，它仍然会不停的输出结果。除非你将该线程kill掉。 &amp;&amp;表示并行执行前后命令。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"手写服务器总结","slug":"Java Web/手写服务器总结","date":"2019-06-16T07:23:02.000Z","updated":"2019-06-16T14:16:50.731Z","comments":true,"path":"2019/06/16/Java Web/手写服务器总结/","link":"","permalink":"http://yoursite.com/2019/06/16/Java Web/手写服务器总结/","excerpt":"","text":"手写服务器总结搭建框架​ ………………… 实现编写web.xml123456789101112&lt;!--servlet处理请求--&gt;&lt;servlet&gt; &lt;!--LoginServlet别名:login --&gt; &lt;servlet-name&gt;login&lt;/servlet-name&gt; &lt;servlet-class&gt;com.szxy.httpserver.servlet.LoginServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!--浏览器的请求路径--&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;login&lt;/servlet-name&gt; &lt;url-pattern&gt;/login&lt;/url-pattern&gt; &lt;url-pattern&gt;/log&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; ​ 实体类保存解析xml中的信息 ​ Entity类:servlet-name,servlet-class ​ Mapping类:servlet-name,url-pattern 解析xmldom4j解析xml​ Entity:servlet-name,servlet-class ​ Entity通过String name，String clazz两个成员变量保存web.xml中的\\servlet-name,servlet-class ​ Mapping:servlet-name,url-pattern， ​ Mapping通过String name，和List urlPattern集合两个成员变量保存web.xml中的\\servlet-name,url-pattern， ServletContext类​ 上下文，是一个容器，描述Entity与Mapping之间的关系 该类的成员变量 12private Map&lt;String, String&gt; servlet; //key是servlet-name,value是servlet-classprivate Map&lt;String, String&gt; mapping; //key是url-pattern,value是servlet-name WebApp类​ 1）将Entity和Mapping中的servlet-name,servlet-class,url-pattern,servlet-name ​ 保存到ServletContext类的成员变量中。 ​ 请求路径作为key,获取servlet-name值，获取servlet-name ​ servlet-name作为key,获取servlet的 全路径名(包名+类名) ​ 1） 反射创建Servlet ​ 可以通过全路径名反射创建Servlet对象 1234567//根据url的key获取servlet-name的值 String servletName = context.getMapping().get(url);//根据servlet-name得到对应的servlet-class String servletClass = context.getServlet().get(servletName); //完整的包名和类名//使用反射创建Servlet对象 Class&lt;?&gt; clazz = Class.forName(servletClass); servlet = (Servlet) clazz.newInstance(); servlet建立抽象类Servlet12345678public abstract class Servlet &#123; public void service(Request req, Response rep)throws Exception&#123; this.doGet(req, rep); this.doPost(req, rep); &#125; public abstract void doGet(Request req, Response rep) throws Exception; public abstract void doPost(Request req, Response rep) throws Exception;&#125; 处理请求的Servlet继承Servlet例：登录LoginServlet 12345678910111213141516171819202122public class LoginServlet extends Servlet&#123;@Overridepublic void doGet(Request req, Response rep) throws Exception &#123; // TODO Auto-generated method stub //获取请求参数 String name = req.getParater(\"username\"); String pwd = req.getParater(\"pwd\"); if(\"bjsxt\".equals(name) &amp;&amp; \"123\".equals(pwd))&#123; //调用响应中的print方法 rep.println(name + \"登录成功\"); &#125;else&#123; rep.println(\"账号或者密码不正确\"); &#125; &#125;@Overridepublic void doPost(Request req, Response rep) throws Exception &#123; // TODO Auto-generated method stub &#125;&#125; 封装Request对象(浏览器的请求)​ 通过输入流获取浏览器的请求信息，然后根据HTTP协议，进行请求信息的处理 从请求信息中获取请求方式，路径，参数， 例：GET请求和POST请求的信息 1234567891011121314151617181920212223GET /log?username=bj&amp;pwd=123&amp;hobby=ball HTTP/1.1Host: localhost:8888Connection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.90 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9POST /log HTTP/1.1Host: localhost:8888Connection: keep-aliveContent-Length: 30Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Origin: nullContent-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.90 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9username=bj&amp;pwd=123&amp;hobby=ball 请求参数的乱码问题 处理中文，因为浏览器对中文进行了编码，因此需要解码服务器端获取到发过来的请求参数默认使用ISO8859-1进行解码操作，中文一定有乱码问题 12//value是请求参数，code是编码return URLDecoder.decode(value, code);//decode(keyValues[1].trim(), &quot;utf-8&quot;) 封装Response对象(服务器的响应)1.严格根据HTTP协议封装响应信息 123456789//响应头//协议，状态码，描述headInfo.append(&quot;HTTP1.1&quot;).append(BLANK).append(code).append(BLANK).append(&quot;&quot;);headInfo.append(CRLF);headInfo.append(&quot;Content-Type:text/html;charset=utf-8&quot;).append(CRLF);headInfo.append(&quot;Content-Length:&quot;+length).append(CRLF);headInfo.append(CRLF);//响应正文content.append(“&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;登录响应&lt;/title&gt;&lt;/head&gt;&lt;body&gt;登录成功&lt;/body&gt;&lt;/html&gt;”).append(CRLF); 2.响应正文可以调用Response类中的println(String info)进行设置 ​ content.append(info).append(CRLF); 封装分发器Dispatcher​ Dispatcher是一个请求与响应,并实现了Runnable接口 ​ 通过客户端连接的对象client,初始化Request和Response对象 12req = new Request(client.getInputStream());rep = new Response(client.getOutputStream()); run()方法实现 1.根据请求信息获取路径， 2.根据路径通过反射创建servlet 3.调用servlet的service()方法处理请求 4.rep.pushToClient(code);//响应，将封装后的Response信息发送给客户端 12345678910111213141516171819public void run() &#123; // TODO Auto-generated method stub //根据不同的url创建指定的servlet对象 Servlet servlet = WebApp.getServlet(req.getUrl()); if(servlet == null)&#123; this.code = 404; //路径找不到 &#125;else&#123; //调用service方法 try &#123; servlet.service(req, rep); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); this.code = 500; &#125; &#125; rep.pushToClient(code); IOCloseUtil.closeAll(client); &#125; ServerSocket服务器​ 创建一个ServelSocket对象，监听8888端口 1server = new ServerSocket(port); ​ 循环接收客户端请求，接收到请求，创建一个线程代理Dispatcher对象处理请求 12345678while(!isShutDown)&#123; //1)监听 Socket client = server.accept(); //创建线程类的对象 Dispatcher dis = new Dispatcher(client); //创建代理，启动线程 new Thread(dis).start();&#125; 解决浏览器请求的icon该请求是浏览器默认发送的:http://localhost:8888/favicon.ico 解决： ​ 1.在web.xml中配置路径 12345678&lt;servlet&gt; &lt;servlet-name&gt;favicon&lt;/servlet-name&gt; &lt;servlet-class&gt;com.szxy.httpserver.servlet.FaviconServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;favicon&lt;/servlet-name&gt; &lt;url-pattern&gt;/favicon.ico&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 2.创建FaviconServlet类继承Servlet ​","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"sublime的package control","slug":"Config/sublime的package control","date":"2019-06-15T07:13:46.000Z","updated":"2019-07-08T06:53:06.768Z","comments":true,"path":"2019/06/15/Config/sublime的package control/","link":"","permalink":"http://yoursite.com/2019/06/15/Config/sublime的package control/","excerpt":"","text":"sublime的package control​ preferences-&gt;package control出现There are no packages available for installation错误 据说是IPv6的原因，如果我们的Intent服务提供者（ISP）不支持IPv6就会引发上述错误，原文如下：This error is happened with IPv6 problem. If your Internet Service Provider (ISP) does not support for IPv6 you got this error. 从上面的描述可以知道首先需要获取sublime.wbond.net网站的IPv4地址，然后修改hosts文件就行了。 C:\\Windows\\System32\\drivers\\etc 修改hosts 50.116.34.243 sublime.wbond.net 50.116.34.243 packagecontrol.io Package control的install packageSublime包管理package control 打开install package报错 There are no packages available for installation 本地下载一个channel_v3.json文件:https://github.com/SuCicada/channel_v3.json 放入本地任意目录，然后打开sublime中的Preferences-&gt;package settings-&gt;package control-&gt;settings user 配置 “channels”: [ “H:\\SoftwarePro\\Sublime Text 3\\channel_v3.json” ], 保存重启","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"sublime","slug":"sublime","permalink":"http://yoursite.com/tags/sublime/"}]},{"title":"ThreadLocal的使用","slug":"JavaSE/ThreadLocal的使用","date":"2019-06-13T09:37:18.000Z","updated":"2019-06-22T07:02:46.818Z","comments":true,"path":"2019/06/13/JavaSE/ThreadLocal的使用/","link":"","permalink":"http://yoursite.com/2019/06/13/JavaSE/ThreadLocal的使用/","excerpt":"","text":"ThreadLocal的使用1.说明​ ThreadLocal 直译为“本地线程”，其实它就是一容器，用于 存放线程的局部变量 ​ 能够保持每一个线程里面的值是相应的，说明这些值已经达到了线程私有的目的。 ​ 当你在一个类中使用 static 成员变量时，一定要问自己这个 static 成员变量需要考虑“线程安全吗？” ​ （也就是说 多个线程需要自己独立的 static 成员变量吗？）如果需要那就需要使用 ThreadLocal。 ​ 作用:为解决多线程程序的并发问题 2.实现机制​ 首先获取当前线程，在获取当前线程的ThreadLocalMap ​ 每个Thread对象内部都维护了一个ThreadLocalMap这样一个ThreadLocal的Map，可以存放若干个 ThreadLocal。 123/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null; ​ 当我们在调用get()方法的时候，先获取当前线程，然后获取到当前线程的ThreadLocalMap对象，如果非空，那么取出ThreadLocal的value，否则进行初始化，初始化就是将initialValue的值set到ThreadLocal中。","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"}]},{"title":"Linux常用命令1","slug":"Linux/Linux常用命令1","date":"2019-06-12T05:51:55.000Z","updated":"2019-06-12T05:54:21.711Z","comments":true,"path":"2019/06/12/Linux/Linux常用命令1/","link":"","permalink":"http://yoursite.com/2019/06/12/Linux/Linux常用命令1/","excerpt":"","text":"文件 &amp; 目录操作（16 个） ls ● ls -a 查看所有文件，包含隐藏文件 ● ls -l 简写 ll，查看详细信息 ● ls -h 文件大小以易读的方式显示 cd ● cd ../ 返回上级目录 ● cd ~ 前往家目录 ● cd - 返回上一次所在目录 cp ● cp -r 复制目录及目录下文件 find ● find / -name ‘target’ 查询根目录下面文件名为 target 的文件 mkdir ● mkdir -p /tmp/test 递归创建目录 mv ● mv -f source destination 强制 pwd ● pwd 显示当前路径 rm ● rm -rf / 强制删除根目录及目录下的文件，就是我们通常所说的删库跑路 touch ● touch target 创建 target 文件，若文件存在则改变文件时间戳 tree ● tree 功能是以树形结构显示目录下的内容 basename ● basename /tmp/1 显示文件名 dirname ● dirname /tmp/1 显示路径 chattr ● chattr +i /tmp/1 加 i 属性，防止文件被修改 lsattr ● lsattr /tmp/1 查看文件的扩展属性 file ● file /tmp/1 显示文件类型 md5 ● md5 /tmp/1 显示文件 MD5 值 查看文件 &amp; 内容处理（18 个） cat ● cat -n 显示行号 ● cat file1 file2 打开文件 1 和 2 more ● more file1 逐页显示 less ● less file1 也是逐页显示，与 more 方向相反 head ● head -n file 显示文件头 n 行 tail ● tail -n file 显示文件尾 n 行 ● tailf file 实时显示文件尾 10 行，常用于跟踪日志信息 cut ● who|cut -b 1-3,5 输出每行的 1 至 3 个字节和第 5 个字节 ● who|cut -c -3 输出每行的 1 至 3 个字符 ● who|cut -c 3- 输出每行的第 3 个字符到行尾 ● who|cut -d ‘ ‘ -f 1 以空格为分隔符，输出第一个域 split ● split -b 10k date.file 将文件分割为 10k 的多个子文件 ● split -b 10k date.file split_file 指定子文件前缀为 split_file paste ● psate file1 file2 file3 将 3 个文件按列合并 sort ● sort -n 按照数值大小排序 ● sort -r 倒序排序 ● sort -t 指定分隔符 ● sort -u 忽略相同行 uniq ● uniq -c 显示出现次数，只有相邻的才算重复 ● uniq -d 只显示重复的行 ● unqi -u 只显示不重复的行 wc ● wc -l 显示列数 diff ● diff file1 file2 比较两个文件差异 rev ● rev file 反向输出文件内容 grep ● grep ‘target’ file 过滤输出文件中包含 target 的行 ● grep -v ‘target’ file 过滤输出文件中不包含 target 的行 ● grep -c ‘target’ file 过滤输出文件中包含 target 的行数 ● grep -i ‘target’ file 忽略大小写 ● egrep ‘[1-9]|a’ file 过滤输出正则匹配到的行 ● seq 10 | grep “5” -A 3 显示匹配某个结果之后的 3 行 ● seq 10 | grep “5” -B 3 显示匹配某个结果之前的 3 行 ● seq 10 | grep “5” -C 3 显示匹配某个结果的前三行和后三行 join ● join file1 file2 将两个文件中，指定栏位内容相同的行连接起来 tr ● cat text | tr ‘\\t’ ‘ ‘ 将制表符替换成空格 vim 三种模式： ● 编辑模式（命令模式） ● 输入模式 ● 末行模式 模式的转换 编辑 -&gt; 输入 i: 在当前光标所在字符的前面，转为输入模式； a: 在当前光标所在字符的后面，转为输入模式； o: 在当前光标所在行的下方，新建一行，并转为输入模式； I：在当前光标所在行的行首，转换为输入模式 A：在当前光标所在行的行尾，转换为输入模式 O：在当前光标所在行的上方，新建一行，并转为输入模式； 输入 -&gt; 编辑 ESC 编辑 -&gt; 末行： : 末行 -&gt; 编辑： ESC,ESC 打开文件 vim +# :打开文件，并定位于第#行 vim +：打开文件，定位至最后一行 vim +/PATTERN : 打开文件，定位至第一次被PATTERN匹配到的行的行首 关闭文件 :q 退出 :wq 保存并退出 :q! 不保存并退出 :w 保存 :w! 强行保存 移动光标（编辑模式） 逐字符移动 h: 左 l: 右 j: 下 k: 上 #h: 移动#个字符 以单词为单位移动 w: 移至下一个单词的词首 e: 跳至当前或下一个单词的词尾 b: 跳至当前或前一个单词的词首 #w: 移动#个单词 行内跳转 0: 绝对行首 ^: 行首的第一个非空白字符 $: 绝对行尾 行间跳转 #G：跳转至第#行 gg: 第一行 G：最后一行 翻屏 Ctrl+f: 向下翻一屏 Ctrl+b: 向上翻一屏 Ctrl+d: 向下翻半屏 Ctrl+u: 向上翻半屏 删除单个字符 x: 删除光标所在处的单个字符 #x: 删除光标所在处及向后的共#个字符 删除命令: d dd: 删除当前光标所在行 #dd: 删除包括当前光标所在行在内的#行； 撤消编辑操作 u：撤消前一次的编辑操作 #u: 直接撤消最近#次编辑操作 连续u命令可撤消此前的n次编辑操作 撤消最近一次撤消操作：Ctrl+r 查找 /PATTERN ?PATTERN n 下一个 N 上一个 文件压缩 &amp; 解压缩（3 个） tar ● tar zxvf FileName.tar.gz 解压 ● tar zcvf FileName.tar.gz DirName 压缩 zip ● zip -r html.zip/home/html 递归压缩 unzip ● unzip test.zip -d /tmp 解压到指定目录下 信息显示（11 个） uname ● uname -a 显示系统全部信息 hostname ● hostname 显示主机名 dmesg ● dmesg 显示开机信息 uptime ● uptime 显示系统运行时间及负载 stat ● stat 显示文件的状态信息 du ● du -sh 显示路径下所有文件大小 ● du -sh local 显示路径下 local 目录文件大小 ● du -sh * 显示路径下所有目录文件大小 df ● df -h 显示系统磁盘空间的使用情况 top ● top 实时显示系统资源使用情况 free ● free -m 以 M 为单位查看系统内存 date ● date +”%Y-%m-%d” 2019-05-28 ● date -d “1 day ago” +”% Y-% m-% d” 输出昨天日期 ● date -d “+1 day” +% Y% m% d 显示前一天的日期 ● date -d “-1 day” +% Y% m% d 显示后一天的日期 ● date -d “-1 month” +% Y% m% d 显示上一月的日期 ● date -d “+1 month” +% Y% m% d 显示下一月的日期 ● date -d “-1 year” +% Y% m% d 显示前一年的日期 ● date -d “+1 year” +% Y% m% d 显示下一年的日期 cal ● cal 日历信息 搜索文件（4 个） which ● which pwd 显示命令路径 find ● find /-name ‘target’ 查询根目录下面文件名为 target 的文件 whereis ● whereis php 查找二进制命令 locate ● locate target 从数据库 (/var/lib/mlocate/mlocate.db) 查找目标文件，使用 updatedb 更新库 进程管理（11 个） jobs ● jobs 查看当前有多少在后台运行的命令 bg ● bg 1 将一个在后台暂停的命令，继续执行，1 为作业号 ● （ctrl+z）可以挂起程序，返回作业号 fg ● fg 1 将后台中的命令调至前台继续运行 ，1 为作业号 kill ● kill 进程号 杀进程 ● kill -9 进程号 强杀进程 ● killall ● killall php 通过进程名字杀进程 ● killall -9 php 通过进程名字强杀进程 pkill ● 用法同上 crontab ● crontab -l 查看定时任务 ● crontab -e 编辑定时任务 ● crontab -l -u user1 查看 user1 定时任务，只有 root 才有权限 ● crontab -e -u user1 编辑 user1 定时任务，只有 root 才有权限 ps ● ps -ef 查看进程，显示 UID,PPIP,C 与 STIME，每个程序所使用的环境变量栏位 ● ps -axu 查看所有进程，并显示属于用户 pstree ● pstree -p 显示当前所有进程的进程号和进程 id 树 ● pstree -a 显示所有进程的所有详细信息树 nohup ● nohup command &amp; 退出账户时不挂断程序，仍在后台运行 pgrep ● pgrep -l httpd 查找 http 相关的进程号 用户管理（7 个） useradd ● useradd boy -u 888 建立一个新用户账户，并设置 ID ● useradd –g sales jack –G company,employees ● -g：加入主要组 -G：加入次要组 usermod ● usermod -G staff newuser2 将 newuser2 添加到组 staff 中 ● usermod -l newuser1 newuser 修改 newuser 的用户名为 newuser1 ● usermod -L newuser1 锁定账号 newuser1 ● usermod -U newuser1 解除对 newuser1 的锁定 userdel ● userdel -f user1 强制删除用户 ● userdel -r user1 删除用户的同时，删除与用户相关的所有文件 groupadd ● groupadd -g 1000 group1 建立一个新组，并设置组 ID 加入系统 passwd ● passwd user1 修改 user1 密码 ● passwd -l user1 锁住密码 ● passwd -d user1 删除密码 su ● su root 切换身份 sudo ● sudo command 已管理员身份运行命令 网络操作（11 个） telnet ● telnet 127.0.0.1 登录远程主机 ssh ● ssh root@127.0.0.1 -p22 登录远程主机 scp ● scp local_file remote_username@remote_ip:remote_folder 本地拷贝到远程 ● scp remote_username@remote_ip:remote_folder local_file 远程拷贝到本地 wget ● wget url 下载一个文件 ● wget –limit-rate=300k url 限速下载 ● wget -c url 断点续传 ● wget -b url 后台下载 ping ● ping www.baidu.com -c 2 收到两个包就结束 route ● route 显示当前路由 ifconfig ● ifconfig 查看、配置、启用或禁用网络接口 ifup ● ifup eth0 开启 eth0 网卡 ● ifdown ● ifdown eth0 关闭 eth0 网卡 netstat ● netstat -at 列出所有 tcp 端口 ● netstat -au 列出所有 udp 端口 ● netstat -l 只显示监听端口 ss ● ss -t -a 显示所有 tcp 链接 ● ss -l 显示处于监听状态的套接字 磁盘 &amp; 文件系统（7 个） mount ● mount /dev/hda1 /mnt 将 /dev/hda1 挂载到 /mnt 目录下 ● umount ● umount -v /mnt/mymount/ 卸载 /mnt/mymount/ fsck ● fsck -y /dev/hda2 检查并修复 Linux 文件系统 dumpe2fs ● dumpe2fs /dev/hda1 查看文件系统信息 dump ● ‍dump -0u -f /tmp/homeback.bak /home 将 /home 目录所有内容备份到 /tmp/homeback.bak 文件中，备份层级为 0 并在 /etc/dumpdates 中记录相关信息 fdisk ● fdisk /dev/sdb 输入 m 列出可以执行的命令 输入 p 列出磁盘目前的分区情况 输入 d 然后选择分区，删除现有分区 输入 print 查看分区情况，确认分区已经删除 输入 n 建立新的磁盘分区 输入 w 最后对分区操作进行保存 mkfs ● mkfs -t ext3 /dev/sda6 将 sda6 分区格式化为 ext3 格式 系统权限（3 个） chmod ● chmod 777 file1 修改 file1 文件权限为 777 ● chmod u+x,g+w file1 为 file1 设置自己可以执行，组员可以写入的权限 chown ● chown -R root /usr/meng 修改将目录 /usr/meng 及其下面的所有文件、子目录的文件主改成 root chgrp ● chgrp -R mengxin /usr/meng 将 /usr/meng 及其子目录下的所有文件的用户组改为 mengxin 关机重启（5 个） shutdown ● shutdown -h now 立即关机 ● shutdown +5 “System will shutdown after 5 minutes” 指定 5 分钟后关机，同时送出警告信息给登入用户 halt ● halt -p 关闭系统后关闭电源 ● halt -d 关闭系统，但不留下纪录 poweroff ● poweroff -f 强制关闭操作系统 logout ● logout 退出当前登录的 Shell exit ● exit 退出当前登录的 Shell 其他（6 个） echo ● echo ‘hello’ 打印字符串、变量 print ● printf ‘hell0’ 格式化输出字符串 rpm ● rpm -ivh your-package.rpm 安装 rpm 包 ● rpm -Uvh your-package.rpm 升级 rpm 包 ● rpm -e package 卸载 ● rpm -qa 列出所有安装过的包 ● rpm -ql 包名 rpm 包中的文件安装到那里去 yum ● yum install php 安装 php ● yum remove php 卸载 php clear ● clear 清屏 history ● history 10 最近使用的 10 条历史命令","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"c语言二维数组传递一维数组参数","slug":"C/c语言二维数组传递一维数组参数","date":"2019-06-09T07:46:09.000Z","updated":"2019-06-09T07:49:01.642Z","comments":true,"path":"2019/06/09/C/c语言二维数组传递一维数组参数/","link":"","permalink":"http://yoursite.com/2019/06/09/C/c语言二维数组传递一维数组参数/","excerpt":"","text":"123456789101112131415161718#include&lt;stdio.h&gt;void test(int a[]);int main()&#123; int a[2][2]; a[0][0] = 0; a[0][1] = 1; a[1][0] = 2; a[1][1] = 3; //printf(\"%d,%d,%d,%d\",a[0][0],a[0][1],a[1][0],a[1][1]); test(a[0]); //传递一维数组 test(a[1]); return 0;&#125;void test(int a[])&#123; printf(\"%d,%d\\n\",a[0],a[1]);&#125; 打印 : 0,1 ​ 2,3","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"IDEA的工作区间","slug":"Tools/IDEA的工作区间","date":"2019-06-05T15:09:08.000Z","updated":"2019-10-07T08:08:10.957Z","comments":true,"path":"2019/06/05/Tools/IDEA的工作区间/","link":"","permalink":"http://yoursite.com/2019/06/05/Tools/IDEA的工作区间/","excerpt":"","text":"IDEA中的项目概念与eclipse是不同的，IDEA的项目等同于eclipse中的workspace。Idea的module等同于eclipse中的project。所以我们要实现在一个项目导入多个module。 具体操作如下： File–&gt;Project Structure Import Module，然后选中自己要导入的项目即可 作者：wzz87来源：CSDN原文：https://blog.csdn.net/wzz87/article/details/80234880版权声明：本文为博主原创文章，转载请附上博文链接！","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/tags/tools/"}]},{"title":"重启eclipse color theme失效的解决办法","slug":"Config/Eclipse主题重启失效","date":"2019-06-02T09:22:09.000Z","updated":"2019-07-08T06:53:36.362Z","comments":true,"path":"2019/06/02/Config/Eclipse主题重启失效/","link":"","permalink":"http://yoursite.com/2019/06/02/Config/Eclipse主题重启失效/","excerpt":"","text":"重启eclipse color theme失效的解决办法** 1、在eclipse菜单栏 选择 windows &gt; Perferences； 2、找到Oomph &gt; Setup Task &gt; Perference Recorder选项； 3、将上方的Record Into勾选上，点恢复默认值(Restore Defaults)再应用(apply)-确定(Ok) 4.重启Eclipse主题生效 注：Perference Recorder可以同步Eclipse的配置参数","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"eclipse","slug":"eclipse","permalink":"http://yoursite.com/tags/eclipse/"}]},{"title":"C中的void与void*类型","slug":"C/C中的oid类型与void指针类型","date":"2019-04-24T00:38:14.000Z","updated":"2019-04-24T00:48:20.093Z","comments":true,"path":"2019/04/24/C/C中的oid类型与void指针类型/","link":"","permalink":"http://yoursite.com/2019/04/24/C/C中的oid类型与void指针类型/","excerpt":"","text":"c中的void表示不确定类型1.void类型​ int main(void)表示不可传递参数 ​ void类型不能定义变量 2. void*类型​ void*类型可与任意类型进行强制转换 1234int* p = NULL;*p = 10;void* v = (void *)p; //将int*类型的p强制转换为void*类型int k = *(int *)v; //将void*类型的v强制转换为int*类型 注：void类型强转后的类型需要与原来的类型保持一致*","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Java中serialVersionUID的解释及两种生成方式的区别","slug":"JavaSE/Java中serialVersionUID的解释及两种生成方式的区别","date":"2019-04-07T15:26:33.000Z","updated":"2019-06-22T07:02:25.250Z","comments":true,"path":"2019/04/07/JavaSE/Java中serialVersionUID的解释及两种生成方式的区别/","link":"","permalink":"http://yoursite.com/2019/04/07/JavaSE/Java中serialVersionUID的解释及两种生成方式的区别/","excerpt":"","text":"serialVersionUID作用： 序列化时为了保持版本的兼容性，即在版本升级时反序列化仍保持对象的唯一性。有两种生成方式： 一个是默认的1L，比如：private static final long serialVersionUID = 1L; 一个是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段，比如： private static final long serialVersionUID = xxxxL;关于其定义，可参考JDK文档：http://download.oracle.com/javase/1.5.0/docs/api/java/io/Serializable.html 在Eclipse中，提供两种方式让我们快速添加SerialVersionUid。 add default serial version ID：Adds a default serial version ID to the selected typeUse this option to add a user-defined ID in combination with custom serialization code if the type did undergo structural change since its first release. add generated serial version ID：Adds a generated serial version ID to the selected typeUse this option to add a compiler-generated ID if the type didnot undergo structural change since its first release. 一种就是1L，一种是生成一个很大的数，这两种有什么区别呢？ 看上去，好像每个类的这个类不同，似乎这个SerialVersionUid在类之间有某种关联。其实不然，两种都可以，从JDK文档也看不出这一点。我们只要保证在同一个类中，不同版本根据兼容需要，是否更改SerialVersionUid即可。 对于第一种，需要了解哪些情况是可兼容的，哪些根本就不兼容。 参考文档：http://java.sun.com/j2se/1.4/pdf/serial-spec.pdf 在可兼容的前提下，可以保留旧版本号，如果不兼容，或者想让它不兼容，就手工递增版本号。 1-&gt;2-&gt;3….. 第二种方式，是根据类的结构产生的hash值。增减一个属性、方法等，都可能导致这个值产生变化。我想这种方式适用于这样的场景： 开发者认为每次修改类后就需要生成新的版本号，不想向下兼容，操作就是删除原有serialVesionUid声明语句，再自动生成一下。 个人认为，一般采用第一种就行了，简单。第二种能够保证每次更改类结构后改变版本号，但还是要手工去生成，并不是修改了类，会提示你要去更新这个SerialVersionUid，所以虽然看上去很cool，实际上让人很迷惑。 参考： 1.一篇较好的关于serialVesionUid的说明： http://www.mkyong.com/java-best-practices/understand-the-serialversionuid/","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"java类初始化顺序","slug":"JavaSE/Java类初始化顺序","date":"2019-03-13T09:20:20.000Z","updated":"2020-04-06T09:10:52.006Z","comments":true,"path":"2019/03/13/JavaSE/Java类初始化顺序/","link":"","permalink":"http://yoursite.com/2019/03/13/JavaSE/Java类初始化顺序/","excerpt":"","text":"Java的类初始化顺序123456789101112131415161718192021222324252627282930313233343536373839404142package com.szxy;/** * * @author Administrator * */public class InitClassTest &#123; public static void main(String[] args) &#123; new B(); &#125;&#125;class A&#123; static A a = new A(); //1) static&#123; System.out.println(\"A:static\"); //2) &#125; C c = new C(); //5) &#123; //6) System.out.println(\"A:not static\"); &#125; public A() &#123; //7) System.out.println(\"A:constructor\"); &#125;&#125;class B extends A &#123; static&#123; System.out.println(\"B:static\"); //3) &#125; static B b = new B(); //4) &#123; //8) System.out.println(\"B:not static\"); &#125; public B() &#123; //9) System.out.println(\"B:constructor\"); &#125;&#125;class C&#123; public C() &#123; System.out.println(\"C\"); &#125;&#125; console打印 123456789101112131415C //1)A:not static //1)A:constructor //1)A:static //2)B:static //3)C //4)A:not static //4)A:constructor //4)B:not static //4)B:constructor //4)C //5)A:not static //6)A:constructor //7)B:not static //8)B:constructor //9) 根据打印结果：父类静态变量（静态代码块）-&gt; 子类静态变量（静态代码块） ​ -&gt; 父类成员变量（非静态代码块）-&gt; 父类构造方法 -&gt;子类成员变量（非静态代码块） ​ -&gt; 子类构造方法 ps：静态变量和静态代码块属于平级，谁在前谁先初始化； ​ 非静态代码块和成员变量属于平级，谁在前谁先初始化","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"性能测试工具locust","slug":"Python/性能测试工具locust","date":"2019-03-13T08:20:20.000Z","updated":"2020-05-12T11:28:33.128Z","comments":true,"path":"2019/03/13/Python/性能测试工具locust/","link":"","permalink":"http://yoursite.com/2019/03/13/Python/性能测试工具locust/","excerpt":"","text":"An open source load testing tool. 一个开源性能测试工具。 define user behaviour with python code, and swarm your system with millions of simultaneous users. 使用Python代码来定义用户行为。用它可以模拟百万计的并发用户访问你的系统。 1.安装Python2.安装Locustpip install locust 3.安装成功，CMD敲入命令验证。​ locust –help 4.创建load_test.py文件，通过Python编写性能测试脚本。123456789101112from locust import HttpLocust, TaskSet, taskclass UserBehavior(TaskSet): @task(1) def indesx(self): self.client.get(\"/\")class WebsiteUser(HttpLocust): task_set = UserBehavior min_wait = 3000 max_wait = 6000 创建UserBehavior()类继承TaskSet类，为用户行为类。 ​ 创建index() 方法表示一个行为。用@task() 装饰该方法为一个任务。1表示一个Locust实例被挑选执行的权重，数值越大，执行频率越高。在当前UserBehavior()行为下只有一个index()任务，所以，这里的权重设置为几，并无影响。 WebsiteUser()类用于设置性能测试。 task_set ：指向一个定义了的用户行为类。 min_wait ：用户执行任务之间等待时间的下界，单位：毫秒。 max_wait ：用户执行任务之间等待时间的上界，单位：毫秒。 5.命令行切换到性能测试脚本所在的目录，启动性能测试：1locust -f load_test.py --host=https://www.baidu.com ​ load_test.py 为测试脚本，https://www.baidu.com 为测试的网站。 ​ 打开浏览器访问：http://127.0.0.1:8089或者http://localhost:8089 ps:在pycharm中运行脚本 123if __name__ == '__main__':import osos.system(\"locust -f load_test.py --host=https://www.baidu.com\")","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"java的Package","slug":"JavaSE/java的Package","date":"2019-03-03T04:35:23.000Z","updated":"2019-06-22T07:01:48.575Z","comments":true,"path":"2019/03/03/JavaSE/java的Package/","link":"","permalink":"http://yoursite.com/2019/03/03/JavaSE/java的Package/","excerpt":"","text":"Java的Package没有包含关系 例如： com.szxy和com.szxy.test import com.szxy.*，则只能用com.szxy目录下的类 import com.szxy.test.*,则只能用com.szxy.test目录下的类","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"带标签的break和continue","slug":"JavaSE/带标签的break和continue","date":"2019-03-02T05:00:20.000Z","updated":"2019-06-22T07:09:16.364Z","comments":true,"path":"2019/03/02/JavaSE/带标签的break和continue/","link":"","permalink":"http://yoursite.com/2019/03/02/JavaSE/带标签的break和continue/","excerpt":"","text":"1.不带标签的break和continue break：跳出当前的循环 continue:跳出本次循环 2.带标签的break和continuebreak label:跳出到label，并且不再执行该循环。即跳出label标签下的所有循环 12345678label: for(int i = 0; i &lt; 10; i++) &#123; for(int j = 0; j &lt; 10; j++) &#123; if(i == 5) &#123; break label; &#125; System.out.println(i + \"\\t\" + j); &#125; &#125; continue label:跳出到label,继续执行该label标签后的循环。 12345678label: for(int i = 0; i &lt; 10; i++) &#123; for(int j = 0; j &lt; 10; j++) &#123; if(i == 5) &#123; continue label; &#125; System.out.println(i + \"\\t\" + j); &#125; &#125;","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java 内部类中使用局部变量必须是final","slug":"JavaSE/Java 内部类中使用局部变量必须是final(jdk1.8之前)","date":"2019-02-24T10:22:33.000Z","updated":"2019-06-22T07:01:28.426Z","comments":true,"path":"2019/02/24/JavaSE/Java 内部类中使用局部变量必须是final(jdk1.8之前)/","link":"","permalink":"http://yoursite.com/2019/02/24/JavaSE/Java 内部类中使用局部变量必须是final(jdk1.8之前)/","excerpt":"","text":"注：jdk1.8新特性，Java 内部类中使用局部变量可以不用final修饰 在java中， 方法的内部类可以访问方法中的局部变量，但必须用final修饰才能访问。原因：1.当方法被调用运行完毕之后，局部变量就已消亡了。但内部类对象可能还存在， 直到没有被引用时才会消亡。此时就会出现一种情况，就是内部类要访问一个不存在的局部变量。 2.解决这一问题的办法就是使用final修饰局部变量，通过将final局部变量”复制”一份,复制品直接作为方法内部类中的数据成员，这事方法内部类访问的其实是这个局部变量的复制品！ 而且，由于被final修饰的变量赋值后不能再修改，所以就保证了复制品与原始变量的一致。 3.原因二的功能能实现的原因是：Java采用了一种copy local variable(复制局部变量)的方式来实现，也就是说把定义为final的局部变量拷贝过来用，而引用的也可以拿过来用，只是不能重新赋值。从而造成了可以access local variable(访问局部变量)的假象，而这个时候由于不能重新赋值，所以一般不会造成不可预料的事情发生。 使用final修饰符不仅会保持对象的引用不会改变, 而且编译器还会持续维护这个对象在回调方法中的生命周期. 所以这才是final变量和final参数的根本意义. 作者：姚瑶大坏蛋2007来源：CSDN原文：https://blog.csdn.net/tongnuxie/article/details/50111485版权声明：本文为博主原创文章，转载请附上博文链接！","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"JavaIO流中InputStream中的read()方法返回int","slug":"JavaSE/javaIO流中的InputStream中的read()方法返回int","date":"2019-02-17T07:20:20.000Z","updated":"2019-06-22T07:01:37.529Z","comments":true,"path":"2019/02/17/JavaSE/javaIO流中的InputStream中的read()方法返回int/","link":"","permalink":"http://yoursite.com/2019/02/17/JavaSE/javaIO流中的InputStream中的read()方法返回int/","excerpt":"","text":"public abstract int read()throws IOExceptior从输入流中读取数据的下一个字节。返回0到255范围内的int字节值。如果因为已经到达流末尾而没有可用的字节,则返回值-1,数据可用、检测到流末尾或者抛出异常前,此方法一直阻塞。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.io.*;class MyBufferedInputStream//自定义BuffereedInputStream类&#123; //装饰设计模式 private InputStream in; private byte[] buffer=new byte[1024]; private int count=0; private int pos=0; MyBufferedInputStream(InputStream in)//构造器 &#123; this.in=in; &#125; //模拟read方法 public int Myread()throws IOException &#123; if(count==0) &#123; count=in.read(buffer); //计数器记录通过public int read(byte[] b)方法存 //到数组缓冲区的数据的总字节数 pos=0;//如果计数器为0，则位置指针归零 if(count&lt;0) return -1; &#125; byte b=buffer[pos]; pos++; count--; //return b&amp;255; return b&amp;0xff;//关键在此，为什么要返回b和0xff的与呢？ &#125; //重写close方法 public void Myclose()throws IOException &#123; in.close(); &#125;&#125;class Demo&#123; //为了代码简洁，这里直接抛IO异常了，正确的做法是try，catch。 public static void main(String[] args)throws IOException &#123; long start=System.currentTimeMillis(); Copy(); long end=System.currentTimeMillis(); System.out.println(&quot;runtime:&quot;+(end-start)+&quot;ms&quot;);//获取运行时间 &#125; public static void Copy()throws IOException//拷贝功能封装在Copy方法体里面 &#123; MyBufferedInputStream mb=new MyBufferedInputStream(new FileInputStream(&quot;3.mp3&quot;)); BufferedOutputStream bo=new BufferedOutputStream(new FileOutputStream(&quot;copy_1.mp3&quot;)); int ch=0; while((ch=mb.Myread())!=-1) bo.write(ch); bo.close(); mb.Myclose(); &#125;&#125; 为什么myread方法返回的是b和0xff的与呢？ read方法返回int的原因: 首先我们知道，mp3文件全部为二进制数据组成的。这就有一个问题，如果恰好read方法读取的字节是1111-1111（即byte型的-1）怎么办？这时候返回的是-1.那这样的话Copy方法中的while循环就会停止，也就没有复制。 解决方法： 我们伟大的程序员采取了一个办法.那就是返回int型 1111-1111如果变成int型的话，应该是int型的-1，即11111111-11111111-11111111-11111111， 我们将int型的-1和0xff &amp;一下， 11111111 11111111 -11111111 -11111111 &amp;00000000-00000000-00000000-11111111（int型的255） 00000000-00000000-00000000-11111111 这样返回的就是有效字节了，而且不会出现-1的情况。 read方法做了一个类型提升，其实write方法每次也是强转，将int型的数据再转换为byte，这样获取的还是有效字节。 作者：rowandjj来源：CSDN原文：https://blog.csdn.net/chdjj/article/details/8577861版权声明：本文为博主原创文章，转载请附上博文链接！","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"JAVA中类、实例与Class对象","slug":"JavaSE/JAVA中类、实例与Class对象","date":"2019-01-26T12:20:33.000Z","updated":"2019-06-22T07:02:33.476Z","comments":true,"path":"2019/01/26/JavaSE/JAVA中类、实例与Class对象/","link":"","permalink":"http://yoursite.com/2019/01/26/JavaSE/JAVA中类、实例与Class对象/","excerpt":"","text":"类​ 类是面向对象编程语言的一个重要概念，它是对一项事物的抽象概括，可以包含该事物的一些属性定义，以及操作属性的方法。面向对象编程中，我们都是以类来编码。 实例简单理解，就是new，就是对类的实例化，创建这个类对应的实际对象，类只是对事物的描述，而实例化就相当于为这个描述新开辟了一块内存，可以改变这块区域里的各种属性（成员变量），当然，也可以实例化多块区域，只是不同的对象而已。 Class注意这里C大写了，与类概念区分开，在java里，Class是一个实实在在的类，在包 java.lang 下，有这样一个Class.java文件，它跟我们自己定义的类一样，是一个实实在在的类，Class对象就是这个Class类的实例了。在Java里，所有的类的根源都是Object类，而Class也不例外，它是继承自Object的一个特殊的类，它内部可以记录类的成员、接口等信息，也就是在Java里，Class是一个用来表示类的类。Class是一个实实在在的类，可以为它创建实例，也就是本文后面提到的Class对象，也看叫做Class实例）。 java提供了下面几种获取到类的Class对象的方法： 1) 利用对象实例调用getClass()方法获取该对象的Class实例； ​ Class c=对象.getClass(); ​ 2) 使用Class类的静态方法forName(“包名+类名”)，用类的名字获取一个Class实例 ​ Class c=Class.forName(“包名+类名”); ​ 3)运用 类名.class 的方式来获取Class实例； ​ Class c = 类名.class 我们知道java世界是运行在JVM之上的，我们编写的类代码，在经过编译器编译之后，会为每个类生成对应的.class文件，这个就是JVM可以加载执行的字节码。运行时期间，当我们需要实例化任何一个类时，JVM会首先尝试看看在内存中是否有这个类，如果有，那么会直接创建类实例；如果没有，那么就会根据类名去加载这个类，当加载一个类，或者当加载器(class loader)的defineClass()被JVM调用，便会为这个类产生一个Class对象（一个Class类的实例），用来表达这个类，该类的所有实例都共同拥有着这个Class对象，而且是唯一的。 总结 在java里，类只是信息描述的，写明了有哪些内部属性及接口，你可以理解为是定义了一套规则；而Class对象在java里被用来对类的情况进行表述的一个实例，也就是是类的实际表征，可以理解为是对规则的图表化，这样JVM才能直观的看懂，可以看做是一个模版；而类的实例化对象，就是通过模版，开辟出的一块内存进行实际的使用。","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"关于XML文档的xmlns、xmlns:xsi和xsi:schemaLocation","slug":"Java Web/关于XML文档的xmlns、xmlnsxsi和xsischemaLocation","date":"2019-01-22T08:30:23.000Z","updated":"2020-04-12T07:55:37.240Z","comments":true,"path":"2019/01/22/Java Web/关于XML文档的xmlns、xmlnsxsi和xsischemaLocation/","link":"","permalink":"http://yoursite.com/2019/01/22/Java Web/关于XML文档的xmlns、xmlnsxsi和xsischemaLocation/","excerpt":"","text":"xmlns摘要：相信很多人和我一样，在编写Spring或者Maven或者其他需要用到XML文档的程序时，通常都是将这些XML文档头拷贝过来，并没有理解其中元素 （比如xmlns，xmlns:xsi，xsi:schemaLocation）的真正含义，不知道哪些元素是多余的，也不知道为什么要加那些元素。这样当有 时候网上Copy的XML头有错的时候自己却不知道怎么下手。我也是这样的，于是今天花了点时间好好的理解了一下这些元素及其用法，现整理与此，在此谢谢 各位前辈的经验，如有总结的不对或者不好的地方，欢迎留言提出各位的宝贵意见。 话不多说，先来一段Spring的XML样本，相信大家都很眼熟： 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;context:component-scan base-package=\"xxx.xxx.controller\" /&gt; &lt;context:annotation-config/&gt; &lt;mvc:default-servlet-handler/&gt; &lt;mvc:annotation-driven/&gt; &lt;mvc:resources mapping=\"/images/**\" location=\"/images/\" /&gt; &lt;bean id=\"xxx\" class=\"xxx.xxx.xxx.Xxx\"&gt; &lt;property name=\"xxx\" value=\"xxxx\"/&gt; &lt;/bean&gt;&lt;/beans&gt; ​ 这 个文档中，根元素\\&lt;beans/>就不用说了，接下来是xmlns。那么什么是xmlns呢？xmlns其实是XML Namespace的缩写，可译为“XML命名空间”，但个人觉得，翻译后的名字反而不好理解，所以我们就叫它为XML Namespace吧。 ​ 为什么需要xmlns？​ 考虑这样两个XML文档：表示HTML表格元素的\\&lt;table/>： 123456&lt;table&gt; &lt;tr&gt; &lt;td&gt;Apples&lt;/td&gt; &lt;td&gt;Bananas&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; ​ 和描述一张桌子的： 12345&lt;table&gt; &lt;name&gt;African Coffee Table&lt;/name&gt; &lt;width&gt;80&lt;/width&gt; &lt;length&gt;120&lt;/length&gt;&lt;/table&gt; ​ 假如这两个 XML 文档被一起使用，由于两个文档都包含带有不同内容和定义的 \\&lt;table> 元素，就会发生命名冲突。XML 解析器是无法确定如何处理这类冲突。为了解决上述问题，xmlns就产生了。 ​ 如何是用xmlns？​ 很简单，使用语法： xmlns:namespace-prefix=”namespaceURI”。其中namespace-prefix为自定义前缀，只要在这个XML文档中保证前缀不重复即可；namespaceURI是这个前缀对应的XML Namespace的定义。例如， 1xmlns:context=&quot;http://www.springframework.org/schema/context&quot; ​ 这一句定义了一个http://www.springframwork.org/schema/context的Namespace（这和Java类中的包的声明很相似），并将其和前缀context绑定。所以上面的Spring XML文档中会有这么一句： 1&lt;context:component-scan base-package=&quot;xxx.xxx.controller&quot;/&gt; ​ 这里的\\&lt;component-scan/>元素就来自别名为context的XML Namespace，也就是在http://www.springframework.org/schema/context中定义的。 ​ 我们还可以将前缀定义为abc： 1xmlns:abc=&quot;namespaceURI&quot; ​ 这样再使用这个namespaceURI中的元素时，需要以abc为前缀，例如：abc:xxx/。再拿上面的例子解释怎么使用xmlns： 123456&lt;!-- 这里xmlns:h=&quot;url1&quot;表示这个table是用h作为标记，table的写法在url1中定义 --&gt;&lt;h:table xmlns:h=&quot;url1&quot;&gt; &lt;h:tr&gt; &lt;h:td&gt;Apples&lt;/h:td&gt; &lt;h:td&gt;Bananas&lt;/h:td&gt; &lt;/h:tr&gt;&lt;/h:table&gt; ​ 和： 12345&lt;!-- 这里xmlns:f=&quot;url2&quot;表示这个table是用f作为标记，table的写法在url2中定义 --&gt;&lt;f:table xmlns:f=&quot;url2&quot;&gt; &lt;f:name&gt;African Coffee Table&lt;/f:name&gt; &lt;f:width&gt;80&lt;/f:width&gt; &lt;f:length&gt;120&lt;/f:length&gt;&lt;/f:table&gt; ​ 后者与前者仅仅使用不同前缀，我们为 \\&lt;table> 标签添加了一个 xmlns 属性，这样就为前缀赋予了一个与某个命名空间相关联的限定名称。此时再把它们放在一起，XML解析器就不会报错了。 ​ 注意：当xmlns被定义在元素的开始标签中（如这里的&lt;f:table/&gt;）时，所有带有相同前缀的子元素都会与同一个Namespace相关联（即&lt;f:table/&gt;里面的&lt;f:name/&gt;和&lt;f:width/&gt;也会使用url2定义的写法）。 ​ xmlns和xmlns:xsi有什么不同？​ xmlns表示默认的Namespace。例如Spring XML文档中的 1xmlns=&quot;http://www.springframework.org/schema/beans&quot; ​ 这一句表示该文档默认的XML Namespace为http://www.springframwork.org/schema/beans。**对于默认的Namespace中的元素，可以不使用前缀**。例如Spring XML文档中的 123&lt;bean id=&quot;xxx&quot; class=&quot;xxx.xxx.xxx.Xxx&quot;&gt; &lt;property name=&quot;xxx&quot; value=&quot;xxxx&quot;/&gt;&lt;/bean&gt; ​ xmlns:xsi表示使用xsi作为前缀的Namespace，当然前缀xsi需要在文档中声明。 xsi:schemaLocation有何作用？​ xsi:schemaLocation属性其实是Namespace为http://www.w3.org/2001/XMLSchema-instance里的schemaLocation属性，正是因为我们一开始声明了 1xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; ​ 这里才写作xsi:schemaLocation（当然一般都使用这个前缀）。它定义了XML Namespace和对应的 XSD（Xml Schema Definition）文档的位置的关系。它的值由一个或多个URI引用对组成，两个URI之间以空白符分隔（空格和换行均可）。第一个URI是定义的 XML Namespace的值，第二个URI给出Schema文档的位置，Schema处理器将从这个位置读取Schema文档，该文档的targetNamespace必须与第一个URI相匹配。例如： 12xsi:schemaLocation=&quot;http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot; ​ 这里表示Namespace为http://www.springframework.org/schema/context的Schema的位置为[http://www.springframework.org/schema/context/spring-context.xsd](http://www.springframework.org/schema/context/spring-context.xsd?spm=5176.100239.blogcont40353.18.KFHYwA&amp;file=spring-context.xsd)。这里我们可以打开这个Schema的位置，下面是这个文档的开始部分： 12345678&lt;xsd:schema xmlns=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:beans=&quot;http://www.springframework.org/schema/beans&quot; xmlns:tool=&quot;http://www.springframework.org/schema/tool&quot; &lt;!-- 这里的targetNamespace和上方xsi:schemaLocation中的第一个URI匹配 --&gt; targetNamespace=&quot;http://www.springframework.org/schema/context&quot; elementFormDefault=&quot;qualified&quot; attributeFormDefault=&quot;unqualified&quot;&gt; ​ xmlns=”http://www.w3.org/2001/XMLSchema&quot; ​ 表示当前xml文件是一个schema约束文件（这个属性的值是确定的，不能改变，这个就是一个标志） targetNamespace=”http://www.springframework.org/schema/context&quot; ​ 定义schema地址，被约束文件可以通过这个地址引入使用 xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance&quot; - 表示这是一个被约束的xml文件（标志） - :xsi 这个是别名，为了区分下面的xmlsn属性 xmlns=”http://www.springframework.org/schema/context&quot; - 这个就是引入schema文件，这个值就是schema的地址（包名） xsi:schemaLocation=”http://www.example.org/1 1.xsd” - schema地址 空格 schema路径 ​ 有了上面的说明后，再去理解开始的Spring XML文档，一定会有不一样的感觉！ ​ 最后再次感谢各位前辈的宝贵经验。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"XML","slug":"XML","permalink":"http://yoursite.com/tags/XML/"}]},{"title":"Java多线程之this与Thread.currentThread()的区别","slug":"JavaSE/Java多线程this与Thread.currentThread()的区别","date":"2019-01-18T12:11:44.000Z","updated":"2019-12-26T13:45:08.550Z","comments":true,"path":"2019/01/18/JavaSE/Java多线程this与Thread.currentThread()的区别/","link":"","permalink":"http://yoursite.com/2019/01/18/JavaSE/Java多线程this与Thread.currentThread()的区别/","excerpt":"","text":"this是当前代码所处的对象的线程，Thread.currentThread()是运行当前代码的线程。 12345678910111213141516171819202122232425262728293031public class CountOperate extends Thread&#123; public CountOperate() &#123; System.out.println(\"CountOperate.CountOperate()\"); System.out.println(\"Thread-currentThread.getName()\"+Thread.currentThread().getName()); System.out.println(\"Thread-currentThread.isAlive()\"+Thread.currentThread().isAlive()); System.out.println(\"this.getName()\"+this.getName()); System.out.println(\"this.isAlive()\"+this.isAlive()); System.out.println(\"Thread-currentThread==this\"+(Thread.currentThread()==this)); System.out.println(\"CountOperate.CountOperate()\"); &#125; @Override public void run() &#123; System.out.println(\"CountOperate.run()\"+Thread.currentThread().getName()); System.out.println(\"Thread-currentThread.getName()\"+Thread.currentThread().getName()); System.out.println(\"Thread-currentThread.isAlive()\"+Thread.currentThread().isAlive()); System.out.println(\"this.getName()\"+this.getName()); System.out.println(\"this.isAlive()\"+this.isAlive()); System.out.println(\"Thread-currentThread==this\"+(Thread.currentThread()==this)); System.out.println(\"CountOperate.run()\"); &#125; public static void main(String[] args) &#123; CountOperate c=new CountOperate(); c.start(); Thread t1=new Thread(c); System.out.println(\"main t1.isAlive()\"+t1.isAlive()); t1.setName(\"t1\"); t1.start(); System.out.println(\"main t1.isAlive()\"+t1.isAlive()); &#125;&#125; 打印的log 123456789101112131415161718192021222324252627//-----------------------------------------------CountOperate.CountOperate() //new CountOperate()的构造函数Thread-currentThread.getName()main //jvm创建一个进程，默认有一个线程调用mainThread-currentThread.isAlive()true this.getName()Thread-0 //当前new的CountOperate()对象的线程this.isAlive()falseThread-currentThread==thisfalseCountOperate.CountOperate()//------------------------------------------------main t1.isAlive()false //t1没有调用start()方法main t1.isAlive()true //t1调用过start()方法//------------------------------------------------CountOperate.run()Thread-0 //c.start()调用run()Thread-currentThread.getName()Thread-0Thread-currentThread.isAlive()truethis.getName()Thread-0 //this当前线程this.isAlive()trueThread-currentThread==thistrueCountOperate.run()//------------------------------------------------CountOperate.run()t1 Thread-currentThread.getName()t1 //Thread t1=new Thread(参数),Thread-currentThread.isAlive()true //t1是new的Thread，与传递的参数无关this.getName()Thread-0 //传过来的c对象参数，当执行t1.start(),this.isAlive()false //会调用c的run()方法Thread-currentThread==thisfalseCountOperate.run() 根据打印的Log可以知道调用CountOperate构造函数的是main线程，因此打印出 Thread.currentThread().getName()=mainThread.currentThread().isAlive()=true而此时还没有启动CountOperate子线程所以打印出this.getName=Thread-0this.isAlive()=false 此时this代表的是CountOperate对象实例，所以Thread.currentThread()==this :false 这里比较让人疑惑的是“this.getName() = Thread-0”，这个Thread-0是什么东西？？？通过查看Thread源码发现，在Thread类的构造方法中，会自动给name赋值，赋值代码： 123public Thread() &#123; init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0); &#125; 然后执行到:Thread t1 = new Thread(c);System.out.println(“main begin t1 isAlive=” + t1.isAlive());t1.setName(“t1”);t1.start(); 打印：Thread-currentThread.getName()t1Thread-currentThread.isAlive()trueThread.currentThread()==this :falsethis.getName()=Thread-0this.isAlive()=false说明此时的this和Thread.currentThread()指向不是同一个线程实例 也就是说，this指向的还是new CountOperate()创建的那个线程实例，而不是new Thread(thread)创建的那个实例即t1。查看源代码可以知道 123public Thread(Runnable target) &#123; init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0); &#125; 实际上new Thread(thread)会将thread应用的对象绑定到一个pravite变量target上，在t1被执行的时候即t1.run()被调用的时候，它会调用target.run()方法，也就是说它是直接调用thread对象的run方法，再确切的说，在run方法被执行的时候，this.getName()实际上返回的是target.getName()，而Thread.currentThread().getName()实际上是t1.getName()。","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java理解  子类成员变量与父类成员变量同名   方法的重写","slug":"JavaSE/成员变量的同名和方法的重写","date":"2019-01-17T14:53:34.000Z","updated":"2019-06-22T07:09:01.165Z","comments":true,"path":"2019/01/17/JavaSE/成员变量的同名和方法的重写/","link":"","permalink":"http://yoursite.com/2019/01/17/JavaSE/成员变量的同名和方法的重写/","excerpt":"","text":"1.子类父类成员变量同名1.子类的成员变量与父类成员变量同名时,在子类中父类成员变量被”隐藏”2.要想访问与父类的同名的成员变量, 两种方法 ①: 在子类中是用 super ②:将该变量强转成父类的类 3.对象是什么类型的(不是new的那个类型), 成员变量是什么类型. 2.子类对父类方法的重写子类的方法与父类的方法重名时(我们讲得是重写的情况, 方法名一致, 形参一致, 与返回值无关)叫做重写(覆盖), 顾名思义, 把父类的方法重写了. 所以怎么转换, 都是子类的方法.","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java和mysql的时间类型","slug":"JavaSE/java和mysql的时间类型","date":"2018-12-30T02:49:33.000Z","updated":"2019-07-19T11:41:05.966Z","comments":true,"path":"2018/12/30/JavaSE/java和mysql的时间类型/","link":"","permalink":"http://yoursite.com/2018/12/30/JavaSE/java和mysql的时间类型/","excerpt":"","text":"java.util.Date是不能直接插入数据库中的，虽然它包含了日期和时分秒。 java.sql.Date可以直接插入数据库，但是它只有日期而没有时间； java.sql.Time可以直接插入数据库，但是它只有时间，没有日期 Java.util.Date需要转换为Java.sql.Date,常规的方式转换过来只可以得到年月日，如若要取得时分秒，可以用Java.sql.Date类的子类Timestamp 参照这个就行了，这个对应注入类型。===========java注入数据库==========java类型 mysql类型 成功与否date date yesdate time nodate timestamp nodate datetime no time date notime time yestime timestamp notime datetime no timestamp date yestimestamp time yestimestamp timestamp yestimestamp datetime yes==========end java注入数据库========总规律，如果A完全包含B，则A可以向B注入数据，否则报错 ==========从数据库提取到java ==========mysql类型 java类型 成与否date date yesdate time yes ————–缺少的部分使用历元date timestamp yes ————–缺少的部分使用历元 time date yes ————–缺少的部分使用历元time time yestime timestamp yes ————–缺少的部分使用历元 timestamp date yestimestamp time yestimestamp timestamp yes datetime date yesdatetime time yesdatetime timestamp yes==========end 从数据库提取到java=======不会出错，缺少的部分使用历元，而不是当前日期时间 注意：看看数据库，发现毫秒数没了。再看看数据库的表字段属性，发现timestamp的长度设置为0。问题就出在这了，只需要把timestamp字段的长度设置为3，就可以保存毫秒数了。","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"String.split()分割字符串用法","slug":"JavaSE/字符串分割split","date":"2018-12-30T02:49:33.000Z","updated":"2019-06-22T07:10:51.566Z","comments":true,"path":"2018/12/30/JavaSE/字符串分割split/","link":"","permalink":"http://yoursite.com/2018/12/30/JavaSE/字符串分割split/","excerpt":"","text":"split方法的参数是一个正则表达式，因此遇到正则表达式中的元字符需要进行转义，而java中的特殊字符也需要转义，因此，分隔的字符既是java特殊字符也是元字符就需要二次转义才能正确分割字符串。 1.public string[] split(string regex)这里的参数的名称是 regex ，也就是 regular expression （正则表达式）。这个参数并不是一个简单的分割用的字符，而是一个正则表达式，它对一些特殊的字符可能会出现你预想不到的结果，比如测试下面的代码： （1） 用竖线 | 分隔字符串，你将得不到预期的结果 ​ String[] aa = “aaa|bbb|ccc”.split(“|”); //String[] aa = “aaa|bbb|ccc”.split(“\\\\|”); 这样才能得到正确的结果 for (int i = 0 ; i &lt;aa.length ; i++ ) { System.out.println(“–”+aa); } （2）用竖 * 分隔字符串运行将抛出java.util.regex.PatternSyntaxException异常，用加号 + 也是如此。 ​ String[] aa = “aaabbbccc”.split(“*“); //String[] aa = “aaa|bbb|ccc”.split(“\\\\*”); 这样才能得到正确的结果 for (int i = 0 ; i &lt;aa.length ; i++ ) { System.out.println(“–”+aa);} （3）显然，+ 不是有效的模式匹配规则表达式，用”\\\\“ “\\\\+”转义后即可得到正确的结果。 （4） “|” 分隔串时虽然能够执行，但是却不是预期的目的，”\\\\|”转义后即可得到正确的结果。 （5）还有如果想在串中使用”\\“字符，则也需要转义.首先要表达”aaaa\\bbbb”这个串就应该用”aaaa\\\\bbbb”,如果要分隔就应该这样才能得到正确结果： String[] aa = “aaa\\\\bbb\\\\bccc”.split(“\\\\\\\\“); （6） 还有就是点号”.”，也要首先转义才能得到正确的结果。 2、public String[] split(String regex,int limit)​ 根据匹配给定的正则表达式来拆分此字符串。 此方法返回的数组包含此字符串的每个子字符串，这些子字符串由另一个匹配给定的表达式的子字符串终止或由字符串结束来终止。数组中的子字符串按它们在此字符串中的顺序排列。如果表达式不匹配输入的任何部分，则结果数组只具有一个元素，即此字符串。 3.”|”作为连字符的使用如果在一个字符串中有多个分隔符，可以用”|作为连字符，比如：”acount=? and uu =? or n=?”,把三个都分隔出来，可以用 “acount=? and uu =? or n=?”.split(“and|or”);","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"保存和获取cookie中的中文信息","slug":"Java Web/对cookie中的中文处理","date":"2018-12-29T02:46:17.000Z","updated":"2019-03-13T08:21:01.712Z","comments":true,"path":"2018/12/29/Java Web/对cookie中的中文处理/","link":"","permalink":"http://yoursite.com/2018/12/29/Java Web/对cookie中的中文处理/","excerpt":"","text":"1.保存cookie问题： 出现500错误 解决：设置字符编码 Cookie cookie=new Cookie(“test”,URLEncoder.encode(“中文”,”utf-8”)); 2.获取cookie 问题：出现乱码 解决：设置字符解码 System.out.println(“cookie:”+cookies[i].getName()+”:”+URLDecoder.decode(cookies[i].getValue()))；","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"乱码","slug":"乱码","permalink":"http://yoursite.com/tags/乱码/"}]},{"title":"请求转发与重定向的理解","slug":"Java Web/请求转发与重定向","date":"2018-12-28T08:37:58.000Z","updated":"2020-03-25T09:42:31.611Z","comments":true,"path":"2018/12/28/Java Web/请求转发与重定向/","link":"","permalink":"http://yoursite.com/2018/12/28/Java Web/请求转发与重定向/","excerpt":"","text":"forward（转发）是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,因为这个跳转过程实在服务器实现的，并不是在客户端实现的所以客户端并不知道这个跳转动作，所以它的地址栏还是原来的地址. redirect（重定向）是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL. 区别： 转发是服务器行为，重定向是客户端行为。 1 )请求转发只能将请求转发给同一个WEB应用中的组件，而重定向还可以重新定向到同一站点不同应用程序中的资源，甚至可以定向到一绝对的URL。 2)重定向可以看见目标页面的URL，转发只能看见第一次访问的页面URL，以后的工作都是有服 务器来做的。 3) 请求响应调用者和被调用者之间共享相同的request对象和response对象，重定向调用者和被调用者属于两个独立访问请求和响应过程。 4)请求重定向：不加/是相对于本servlet所在请求的目录，加“/”表示端口号后面的根目录 http：//localhost:8080/ 请求转发：不加/是相对于本servlet，加/表示web应用的根目录http：//localhost:8080/Test/ ———path”/“路径——— —–只要是需要通过浏览器发送请求的地方（比如html代码，sendRedirect方法等）“/“一般代表虚拟主机根目录，即相当于端口号之后的“/”，例：http：//localhost:8080/ ——服务器程序内部跳转，“/”一般代表本web应用的根目录，如请求转发。例：http：//localhost:8080/Test/","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"servlet的乱码问题","slug":"Java Web/sevlet中的乱码","date":"2018-12-28T02:00:47.000Z","updated":"2019-08-01T10:03:57.995Z","comments":true,"path":"2018/12/28/Java Web/sevlet中的乱码/","link":"","permalink":"http://yoursite.com/2018/12/28/Java Web/sevlet中的乱码/","excerpt":"","text":"1.post请求1）jsp等页面编码格式1pageEncoding=&quot;UTF-8&quot; 设置JSP编译成Servlet时使用的编码。 2）设置请求信息的的解码格式1req.setCharacterEncoding(&quot;utf-8&quot;); 用指定的编码集去覆盖request对象中的默认的”ISO-8859-1”编码集 3）设置响应信息的编码格式1resp.setCharacterEncoding(&quot;utf-8&quot;); 设置服务器的响应编码 4）设置浏览器的解码格式1resp.setContentType(&quot;text/html;charset=utf-8&quot;); 浏览器对服务器响应进行解码 2.get请求​ 同post请求所有要求再加上（配置tomcat） 1） 配置tomcat的server.xml​ 在 &lt;Connector connectionTimeout=”20000” port=”8080” ​ protocol=”HTTP/1.1” redirectPort=”8443”/&gt; ​ 中加入 useBodyEncodingForURI=”true” ​ &lt;Connector connectionTimeout=”20000” port=”8080” ​ protocol=”HTTP/1.1” redirectPort=”8443” ​ useBodyEncodingForURI=”true”/&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"乱码","slug":"乱码","permalink":"http://yoursite.com/tags/乱码/"}]},{"title":"修改Hexo主题","slug":"Config/修改Hexo主题","date":"2018-10-12T10:51:13.000Z","updated":"2019-07-08T06:52:53.920Z","comments":true,"path":"2018/10/12/Config/修改Hexo主题/","link":"","permalink":"http://yoursite.com/2018/10/12/Config/修改Hexo主题/","excerpt":"","text":"1.获取主题cd themes 再将yilia主题clone至themes文件夹中 git clone https://github.com/litten/hexo-theme-yilia.git yilia 2.配置：修改hexo根目录下的_config.yml theme:yilia 3.更新:12cd themes/yiliagit pull 4.发布12hexo cleanhexo d -g","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/tags/tools/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-10-11T14:51:01.594Z","updated":"2018-10-11T14:51:01.594Z","comments":true,"path":"2018/10/11/hello-world/","link":"","permalink":"http://yoursite.com/2018/10/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}