{"meta":{"title":"Momentonly","subtitle":null,"description":null,"author":"Moment Only","url":"http://yoursite.com"},"pages":[{"title":"","date":"2019-07-13T02:34:24.788Z","updated":"2018-12-31T06:06:59.363Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"123layout: categoriestitle: categories ---"},{"title":"","date":"2019-07-13T02:34:38.979Z","updated":"2018-12-31T06:06:40.300Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"123layout: tagstitle: tags ---"}],"posts":[{"title":"CSS的学习","slug":"Web/CSS的学习","date":"2019-07-10T14:59:11.000Z","updated":"2019-07-15T06:28:55.114Z","comments":true,"path":"2019/07/10/Web/CSS的学习/","link":"","permalink":"http://yoursite.com/2019/07/10/Web/CSS的学习/","excerpt":"","text":"CSSCSS入门为什么学习CSS(CSS的作用)​ 【1】HTML 虽然可以在一定程度上修饰页面，但是页面的整体还是不够美观 ​ 【2】HTML 进行网页的书写重复的代码比较多，后期的维 护性不好。 什么是CSS(CSS的概念)​ 英文全称：Cascading Style Sheets ​ 层叠样式表（级联样式表） CSS引入​ CSS的引入的三种方式 &lt;!-- CSS引入方式的顺序，就近原则 --&gt; &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;css/css1.css&quot;/&gt; &lt;style&gt; /*p代表标签的名称*/ p{ /*字体颜色*/ color: yellow; /*字体大小*/ font-size: 25px; /*字体加粗*/ font-weight: bold; } &lt;/style&gt; &lt;!-- 外部式（链接式） rel:引入的文件和当前文件的关系 type:引入类型 href:引入文件的 --&gt; &lt;!-- &lt;style&gt; /**导入式(了解即可)*/ @import url(&quot;css/css1.css&quot;); &lt;/style&gt; --&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 1.行内形式 键：值--&gt; &lt;!-- &lt;p style=&quot;color: red;&quot;&gt;我们不一样&lt;/p&gt; --&gt; &lt;!-- 内嵌形式 --&gt; &lt;!-- &lt;p&gt;我们不一样&lt;/p&gt; &lt;p&gt;我们不一样&lt;/p&gt; --&gt; &lt;p&gt;我们不一样&lt;/p&gt; &lt;/body&gt; 外部css 123456789p&#123; /**字体的风格*/ font-family: 宋体; /**字体的样式*/ font-style: italic; color: green;&#125; CSS引入方式的顺序，就近原则，跟随最近的加载的引入 选择器通用选择器/**通用选择器,代表该页面中所有元素*/ *{ color: red; background-color: black; } 元素选择器12345678/**元素选择器*/div&#123; width: 200px; height: 200px; background: blue; /**边框的粗细:1px 边框的风格:solid 边框的颜色*/ border: 1px solid red;&#125; id选择器123456/* id选择器，#后加id名,id的名称保证唯一， id的命名: 由数字、字母、下划线、中划线组成，不能以数字开头*/#div1&#123; background: green;&#125; 类选择器1234/* 类选择器 */.div_1&#123; background: pink;&#125; 选择器的优先级​ id选择器&gt;类选择器&gt;元素选择器&gt;通用选择器权重： 100 10 1 0​ 其他选择器可以使用任意组合（元素选择器，id选择器,类选择器） 后代选择器12345678/**后代选择器:只要包含该标签对象即可*/div span&#123; font-size: 27px; font-family: 宋体; color: green;&#125; ​ 子选择器 ​ 1234/**子选择器：直系子标签*/div&gt;span&#123; color: red;&#125; 兄弟选择器​ 123456789/**兄弟选择器:只会改变下面相邻的元素对象*/ #p_1+p&#123; color: #0000FF;&#125;/**兄弟选择器后面所有的兄弟对象都改变*/#p_1~p&#123; color: red; font-size: 30px;&#125; 伪类选择器1234/**伪类选择器**/a:hover&#123; /*hover:鼠标放上*/ color: red;&#125; 常用的属性常用的属性112345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;style&gt; .top&#123; width: 100%; height: 100px; border: 1px solid red; &#125; .top_a&#123; /**字体颜色*/ color: gray; /**字体大小*/ font-size: 12px; /*字体的加粗*/ /* font-weight: bold; */ /**字体的风格*/ /* font-family: 宋体; */ /**字体的样式*/ font-style: italic; /**去除下划线*/ text-decoration: none; &#125; a:hover&#123; color: red; /**下划线展示*/ text-decoration: underline; &#125; .tips&#123; width: 100%; height: 40px; border: 1px dotted indigo; background-color: pink; /**文本居中*/ text-align: center; /**行高： 行高的高度和div外面的高度一致，这时里面的内容就会垂直居中*/ line-height: 40px; &#125; .center&#123; width: 100%; height: 500px; border: 1px solid red; /**设置背景图片*/ background-image: url(&quot;http://img13.360buyimg.com/da/jfs/t1/43308/30/8709/99646/5d22e91dE4a7f5729/6b8ea2cf39afcbd1.jpg&quot;); /**设置背景图片不重复*/ background-repeat: no-repeat; /**调整背景图片的位置 x值 y值*/ background-position: center; /*调整背景图片的大小 宽 高*/ /* background-size: 1200px 500px; */ /**背景颜色 或者使用rgb(255,0,0)*/ background-color: #37cef5; /**rgba()最后的.1是透明度*/ /* background-color: rgba(255,0,0,.1); */ &#125; &lt;/style&gt; &lt;body&gt; &lt;!-- 顶部的位置 --&gt; &lt;div class=&quot;top&quot;&gt; &lt;a href=&quot;&quot; class=&quot;top_a&quot;&gt;登录页面，调查问卷&lt;/a&gt; &lt;/div&gt; &lt;!-- 中间的提示 --&gt; &lt;div class=&quot;tips&quot;&gt; &lt;span&gt;根据网络安全法，为保障您的账号安全，请完成手机号验证&lt;/span&gt; &lt;/div&gt; &lt;!-- 中间位置 --&gt; &lt;div class=&quot;center&quot;&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 常用的属性21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;&lt;/title&gt; &lt;style&gt; .div_1&#123; width: 200px; height: 200px; background: rgba(255, 0, 0); color: rgba(0,0,255); /**调整透明度（0-1）*/ opacity: 0.4; /**超出：hidden隐藏 auto：自动*/ overflow: hidden; &#125; #span_1&#123; width: 100px; height: 100px; color: red; border: 1px solid red; /**显示： 行内元素转换成块元素 行内元素：inline 块元素:block none：隐藏 */ display: block; &#125; ul&#123; /*向右浮动*/ float: right; &#125; li&#123; /*列表的风格去除*/ list-style: none; /**向左浮动*/ float: left; /*内边距*/ padding-left: 15px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;hao123&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;地图&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;视频&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;贴吧&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;学术&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;hr /&gt; &lt;!-- 行内元素：多个标签位于同一行 span,font,小标签 块元素：标签可以自动换行 div, h1-h6, ul, p --&gt; &lt;div class=&quot;div_1&quot;&gt; 我们都是div我们都是div我们都是div 我们都是div我们都是div 我们都是div我们都是div 我们都是div我们都是div我们都是div 我们都是div我们都是div 我们都是div我们都是div 我们都是div我们都是div我们都是div 我们都是div我们都是div 我们都是div我们都是div我们都是div我们都是div我们都是div 我们都是div我们都是div 我们都是div我们都是div &lt;/div&gt; &lt;hr /&gt; 01&lt;span id=&quot;span_1&quot;&gt;234&lt;/span&gt;56 &lt;/body&gt;&lt;/html&gt; 定位123456789101112131415161718192021222324252627282930313233343536373839/** 绝对定位 absolute:定位离开之后释放的之前的位置 基于外层父级标签 相对定位 relative:定位离开之后不释放之前的位置 基于之前的位置来说 固定定位 fixed:始终是居于浏览器的左上角的定位， 适合做广告 默认定位 static:初始的定位位置 */ .div_1&#123; width: 200px; height: 200px; background-color: red; /* 绝对定位 */ /* position: absolute; top: 300px; left: 300px; */ /* 相对定位 */ /* position: relative; top: 300px; left: 300px; */ /**固定定位*/ position: fixed; top: 150px; left: 150px; /**置于底层*/ z-index: -1; &#125; .div_2&#123; width: 200px; height: 200px; background-color: green; /**相对定位：基于之前的位置*/ /* position: relative; top: 300px; left: 300px; */ &#125; &lt;/style&gt; 盒子模型12345678910111213141516171819202122232425262728293031323334353637383940&lt;style type=&quot;text/css&quot;&gt; /**清除body和html标签的边距**/ body,html&#123; margin: 0px; padding: 0px; &#125; .div_1&#123; width: 300px; height: 300px; background-color: red; /* 内边距 真实div与border之间的距离 30px是上下的距离，50px是指左右的距离 指定四个值：上右下左 padding-left: 30px;在一个方向加 */ /* padding: 30px 50px; */ /* padding-left: 30px; */ /* 外边距 给盒子进行定位*/ /* margin: 50px; */ /* margin-left: 100px; margin-top: 70px; */ margin-bottom: 40px; margin-right: 40px; &#125; .div_2&#123; width: 300px; height: 300px; background-color: green; /* 外边距 垂直的方向会取较大的值 */ margin-top: 70px; /* 外边距 水平方向会合并 */ margin-left: 50px; &#125; div&#123; float: left; &#125; &lt;/style&gt; CSS3新增选择器伪类选择器，伪对象选择器1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;style type=&quot;text/css&quot;&gt; /* 获取class名称是div_1下面的第一个子元素 */ .div_1&gt;p:first-child&#123; color: red; &#125; .div_1&gt;p:last-child&#123; color: blueviolet; &#125; /**获得具体的某一个子元素*/ /* .div_1&gt;p:nth-child(4)&#123; color: brown; &#125; */ /* 单双行 even:双 odd:单*/ /* .div_1&gt;p:nth-child(even)&#123; background-color: red; &#125; .div_1&gt;p:nth-child(odd)&#123; background-color: green; &#125; */ /* 获得空的元素对象 */ .div_1&gt;p:empty&#123; height: 50px; background-color: #8A2BE2; &#125; /* 获得焦点执行的样式 */ /* input:focus&#123; width: 300px; height: 300px; &#125; */ input:checked&#123; width: 20px; height: 20px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;div_1&quot;&gt; &lt;p&gt;1&lt;/p&gt; &lt;p&gt;2&lt;/p&gt; &lt;p&gt;3&lt;/p&gt; &lt;p&gt;&lt;/p&gt; &lt;p&gt;4&lt;/p&gt; &lt;p&gt;5&lt;/p&gt; &lt;/div&gt; &lt;hr /&gt; &lt;input type=&quot;text&quot; /&gt; &lt;hr /&gt; 男:&lt;input type=&quot;radio&quot; name=&quot;sex&quot;/&gt; 女:&lt;input type=&quot;radio&quot; name=&quot;sex&quot; /&gt; &lt;/body&gt; 属性选择器12345678910111213141516171819202122232425262728293031323334353637383940&lt;style type=&quot;text/css&quot;&gt; /* 属性选择器 可以操作任意有属性的标签*/ /* input[type=text]&#123; width: 300px; height: 30px; &#125; */ /* 属性 ^用fom开头的 $用结尾 */ input[name^=fom]&#123; width: 300px; height: 30px; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 选择器的种类 1)基础选择器 * id class 标签 ..... 2)关系选择器 &gt; + ~ ....... 3)伪类选择器 hover ......... 4)伪对象选择器 before after ....... 4)属性选择器 input[type=text] ...... --&gt; &lt;p&gt; 账号：&lt;input type=&quot;text&quot; name=&quot;fom_zh&quot;/&gt; &lt;/p&gt; &lt;p&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;fom_pwd&quot;/&gt; &lt;/p&gt; &lt;p&gt; 邮箱：&lt;input type=&quot;email&quot; name=&quot;fom_email&quot;/&gt; &lt;/p&gt; &lt;p&gt; 年龄：&lt;input type=&quot;number&quot; name=&quot;age&quot; /&gt; &lt;/p&gt; &lt;/body&gt; 新增属性​ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475body&#123; background-color: pink; &#125; .cen&#123; width: 200px; height: 200px; background-color: red; /* 阴影 参数值：水平偏移 垂直偏移 模糊度(值越大越模糊) 颜色 */ box-shadow: 0px 0px 70px red; /* 调用动画 */ /* animation: 1s aj infinite; */ &#125; .lef&#123; /**倒圆角指令*/ border-radius: 100px; /* 左上右下 右上左下 */ /* border-radius: 10px 60px; */ /**左上 右上 右下 左下*/ /* border-radius: 10px 20px 30px 40px; */ position: absolute; top: 200px; left: 200px; animation: 1s aj1 infinite; &#125; .rig&#123; border-radius: 100px; position: absolute; top: 200px; left: 341px; animation: 1s aj1 infinite; &#125; .c&#123; /* 旋转角度 */ transform: rotate(45deg); position: absolute; top: 269px; left: 271px; /* background-color: black; */ animation: 1s aj2 infinite; &#125; div:hover&#123; /* 放大的倍数 */ /* transform: scale(1.3); */ /* translate（水平位移 垂直位移） */ /* transform: translate(0px,-50px); box-shadow: 0px 0px 70px red; */ /* skew：2d旋转 */ /* transform: skew(45deg); */ &#125; /**C3中的动画*/ @keyframes aj1&#123; /* 过程 */ /* form&#123;&#125; to&#123;&#125; */ /* 百分比指定 */ 0%&#123;transform: scale(1);&#125; 50%&#123;transform: scale(1.1);&#125; 100%&#123;transform: scale(1);&#125; &#125; @keyframes aj2&#123; /* 需要旋转 */ 0%&#123;transform: scale(1) rotate(45deg);&#125; 50%&#123;transform: scale(1.1) rotate(45deg);&#125; 100%&#123;transform: scale(1) rotate(45deg);&#125; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 给class起两个名字 --&gt; &lt;div class=&quot;cen lef&quot;&gt;&lt;/div&gt; &lt;div class=&quot;cen c&quot;&gt;&lt;/div&gt; &lt;div class=&quot;cen rig&quot;&gt;&lt;/div&gt; &lt;/body&gt;","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS中的transform属性","slug":"Web/CSS中的transform属性","date":"2019-07-10T14:59:11.000Z","updated":"2019-07-15T07:32:53.450Z","comments":true,"path":"2019/07/10/Web/CSS中的transform属性/","link":"","permalink":"http://yoursite.com/2019/07/10/Web/CSS中的transform属性/","excerpt":"","text":"transform属性一、移动 translate用法：transform: translate(45px) 或者 transform: translate(45px, 150px); 参数表示移动距离，单位px， 一个参数时：表示水平方向的移动距离；两个参数时：第一个参数表示水平方向的移动距离，第二个参数表示垂直方向的移动距离。 二、缩放 scale用法：transform: scale(0.5) 或者 transform: scale(0.5, 2); 参数表示缩放倍数； 一个参数时：表示水平和垂直同时缩放该倍率两个参数时：第一个参数指定水平方向的缩放倍率，第二个参数指定垂直方向的缩放倍率。 三、旋转 rotate用法：transform: rotate(45deg); 围绕旋转中心旋转而不变形的转换，rotate()默认旋转中心为图片的中点。共一个参数“角度”，单位deg为度的意思，正数为顺时针旋转，负数为逆时针旋转，上述代码作用是顺时针旋转45度。 四、倾斜 skew用法：transform: skew(30deg) 或者 transform: skew(30deg, 30deg); 参数表示倾斜角度，单位deg 一个参数时：表示水平方向的倾斜角度； 两个参数时：第一个参数表示水平方向的倾斜角度，第二个参数表示垂直方向的倾斜角度。 旋转举例进行旋转时其对应的坐标系会跟随旋转的角度进行变化。 12341.transform:rotateY(90deg) translateZ(200px) ;该操作会将一个div正向旋转90度，（旋转的角度是根据Y轴的垂直面（x向右，y向上，二维）原来的xyz轴也进行正向旋转90度，因此，Z轴的正向会变成向右的方向， 黑色的x,y轴是旋转角度面 122. transform:rotateY(90deg) translateZ(200px) rotateZ(45deg);该操作会在原来的基础上绕Z轴进行旋转 黑色的x,y轴是旋转角度面","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/tags/CSS/"}]},{"title":"CSS的学习","slug":"Web/JavaScript的学习","date":"2019-07-10T14:59:11.000Z","updated":"2019-07-15T13:53:19.286Z","comments":true,"path":"2019/07/10/Web/JavaScript的学习/","link":"","permalink":"http://yoursite.com/2019/07/10/Web/JavaScript的学习/","excerpt":"","text":"JavaScript的学习JavaScript的简介为什么学习JavaScript​ 1、html+css 只是可以实现静态的页面无法实现动态的效 果 ​ 2、表单的校验 ​ 3、背景图片的更换 ​ 4、操作节点的信息 ​ 5、 小游戏的开发 ​ ………………… JavaScript的概念​ JavaScript 一种直译式脚本语言，是一种动态类型、弱类型、 基于原型的语言，内置支持类型 JavaScript的组成​ 1.ECMAScript：JavaScript的核心 ​ 2.文档对象模型（DOM）：DOM（文档对象模型）是 HTML 和XML 的应用程序接口（API）。DOM 将把整个页面规划成由节点层级构成的文档 3.浏览器对象模型（BOM）对浏览器窗口进行访问和操作 JavaScript的特点1.脚本语言 ​ 脚本语言是一种简单的程序，是由一些ASCII字符构 成，可以使用任何一种文本编辑器编写。一些程序语言（如C、C++、Java等）都必须经过编译，将源 代码编译成二进制的可执行文件之后才能运行，而 脚本语言不需要事先编译，只要有一个与其相适应 的解释器就可以执行。  脚本语言是指在web浏览器内有解释器解释执行的 编程语言，每次运行程序的时候，解释器会把程序 代码翻译成可执行的格式。 2、基于对象的语言 ​  面向对象有三大特点（封装，继承，多态）却一不 可。 ​  通常“基于对象”是使用对象，但是无法利用现有的对象模板产生新的对象类型，也就是说“基于对象” 没有继承的特点。没有了继承的概念也就无从谈论“多态” 3、事件驱动： ​  在网页中执行了某种操作的动作，被称为“事 件”(Event)，比如按下鼠标、移动窗口、选择菜单 等都可以视为事件。当事件发生后，可能会引起相 应的事件响应。 4、简单性 ​  变量类型是采用弱类型，并未使用严格的数据类型。 var a,b,c; a=123; b=“abc”; a=b; 5、安全性 ​  JavaScript不能访问本地的硬盘，不能将数据存入 到服务器上，不能对网络文档进行修改和删除，只 能通过浏览器实现信息浏览或动态交互 6、跨平台性 ​  JavaScript依赖于浏览器本身，与操作平台无关， 只要计算机安装了支持JavaScript 的浏览器（装有 JavaScript解释器），JavaScript 程序就可以正确执行。 ​  缺点 ​  各种浏览器支持JavaScript的程度是不一样的，支 持和不完全支持JavaScript的 浏览器在浏览同一 个带有JavaScript脚本的网页时，效果会有一定的 差距，有时甚至会显示不出来。 JS的声明和引入​","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"HTML的学习","slug":"Web/HTML的学习","date":"2019-07-08T12:27:11.000Z","updated":"2019-07-15T02:21:20.192Z","comments":true,"path":"2019/07/08/Web/HTML的学习/","link":"","permalink":"http://yoursite.com/2019/07/08/Web/HTML的学习/","excerpt":"","text":"HTML入门为什么学习 HTML？需求：（生活中遇到问题） 随着技术的发展，信息量的增大网页的数据信息没有办 法完美的、漂亮的展现到用户的面前。 意义:(作用)： HTML是一种专门对网页信息进行规范化展示的语言。 把网页的信息格式化展现的语言 什么是HTML？ HTML(Hyper Text Markup Language)：超文本标记语言 超文本：文本信息 、图片、声音、视频、超链接等 标记：标签的体现 HTML中的标签Head标签的子标签12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=\"utf-8\"&gt; &lt;title&gt;&lt;/title&gt; &lt;!-- 搜索引擎优化 --&gt; &lt;meta name=\"author\" content=\"朱自清,张三\" /&gt; &lt;meta name=\"description\" content=\"盼望着盼望着东风来了\" /&gt; &lt;meta name=\"keywords\" content=\"东风,盼望\"/&gt; &lt;!-- 自动刷新网页(5s后刷新) --&gt; &lt;meta http-equiv=\"refresh\" content=\"5;https://www.baidu.com\" /&gt; &lt;!-- 禁止网页缓存 --&gt; &lt;meta http-equiv=\"Pragma\" content=\"no-cache\"/&gt; &lt;meta http-equiv=\"Cache-Control\" content=\"no-cache\" /&gt; &lt;meta http-equiv=\"expires\" content=\"0\" /&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; meta标签的组成meta标签共有两个属性，它们分别是http-equiv属性和name属性，不同的属性又有不同的参数值，这些不同的参数值就实现了不同的网页功能。 1、name属性 name属性主要用于描述网页，与之对应的属性值为content，content中的内容主要是便于搜索引擎机器人查找信息和分类信息用的。 meta标签的name属性语法格式是： 1&lt;meta name=&quot;参数&quot; content=&quot;具体的参数值&quot;&gt; 其中name属性主要有以下几种参数： A、Keywords(关键字) 说明：keywords用来告诉搜索引擎你网页的关键字是什么。 举例： 1&lt;meta name=&quot;keywords&quot; content=&quot;science,education,culture,politics,ecnomics，relationships,entertaiment,human&quot;&gt; B、description(网站内容描述) 说明：description用来告诉搜索引擎你的网站主要内容。 举例： 1&lt;meta name=&quot;description&quot; content=&quot;Thispageisaboutthemeaningofscience,education,culture.&quot;&gt; C、robots(机器人向导) 说明：robots用来告诉搜索机器人哪些页面需要索引，哪些页面不需要索引。 content的参数有all,none,index,noindex,follow,nofollow。默认是all。 举例： 1&lt;meta name=&quot;robots&quot; content=&quot;none&quot;&gt; D、author(作者) 说明：标注网页的作者 举例： 1&lt;meta name=&quot;author&quot; content=&quot;root,root@xxxx.com&quot;&gt; 2、http-equiv属性 http-equiv顾名思义，相当于http的文件头作用，它可以向浏览器传回一些有用的信息，以帮助正确和精确地显示网页内容，与之对应的属性值为content，content中的内容其实就是各个参数的变量值。 meta标签的http-equiv属性语法格式是： 1&lt;meta http-equiv=&quot;参数&quot; content=&quot;参数变量值&quot;&gt;； 其中http-equiv属性主要有以下几种参数： A、Expires(期限) 说明：可以用于设定网页的到期时间。一旦网页过期，必须到服务器上重新传输。 用法： 1&lt;meta http-equiv=&quot;expires&quot; content=&quot;Fri,12Jan200118:18:18GMT&quot;&gt; 注意：必须使用GMT的时间格式。 B、Pragma(cache模式) 说明：禁止浏览器从本地计算机的缓存中访问页面内容。 用法： 1&lt;meta http-equiv=&quot;Pragma&quot; content=&quot;no-cache&quot;&gt; 注意：这样设定，访问者将无法脱机浏览。 C、Refresh(刷新) 说明：自动刷新并指向新页面。 用法：&lt; 1metahttp-equiv=&quot;Refresh&quot;content=&quot;2;URL=http://www.jb51.net&quot;&gt; 注意后面的引号，分别在秒数的前面和网址的后面) 注意：其中的2是指停留2秒钟后自动刷新到URL网址。 D、Set-Cookie(cookie设定) 说明：如果网页过期，那么存盘的cookie将被删除。 用法：&lt; 1meta http-equiv=&quot;Set-Cookie&quot; content=&quot;cookievalue=xxx;expires=Friday,12-Jan-200118:18:18GMT；path=/&quot;&gt; 注意：必须使用GMT的时间格式。 E、Window-target(显示窗口的设定) 说明：强制页面在当前窗口以独立页面显示。 用法：&lt;metahttp-equiv=”Window-target”content=”_top”&gt; 注意：用来防止别人在框架里调用自己的页面。 F、content-Type(显示字符集的设定) 说明：设定页面使用的字符集。 用法：&lt;metahttp-equiv=”content-Type”content=”text/html;charset=gb2312”&gt; G、content-Language（显示语言的设定） 用法：&lt;metahttp-equiv=”Content-Language”content=”zh-cn”/&gt; H、Cache-Control指定请求和响应遵循的缓存机制。Cache-Control指定请求和响应遵循的缓存机制。在请求消息或响应消息中设置Cache-Control并不会修改另一个消息处理过程中的缓存处理过程。请求时的缓存指令包括no-cache、no-store、max-age、max-stale、min-fresh、on ly-if-cached，响应消息中的指令包括public、private、no-cache、no-store、no-transform、must-revalidate、proxy-revalidate、max-age。各个消息中的指令含义如下Public指示响应可被任何缓存区缓存Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效no-cache指示请求或响应消息不能缓存no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。 Meta标签使用技巧Meta标签是用来描述网页属性的一种语言，标准的Meta标签可以便于搜索引擎排序，提高搜索引擎网站权重排名。要想网站做的更符合搜索引擎标准就必须了解meta标签，下面由Seoer惜缘于大家讲讲meta标签含义与使用方法： 1、META标签的keywords 写法为：&lt;metaname=”Keywords”content=”信息参数”/&gt; meat标签的Keywords的的信息参数，代表说明网站的关键词是什么。 2、META标签的Description &lt;metaname=”Description”content=”信息参数”/&gt; meta标签的Description的信息参数，代表说明网站的主要内容，概况是什么。 3、META标签的http-equiv=Content-Typecontent=”text/html http-equiv=Content-Type代表的是HTTP的头部协议，提示浏览器网页的信息， &lt;metahttp-equiv=”Content-Type”content=”text/html;charset=信息参数”/&gt; meta标签的charset的信息参数如GB2312时，代表说明网站是采用的编码是简体中文； meta标签的charset的信息参数如BIG5时，代表说明网站是采用的编码是繁体中文； meta标签的charset的信息参数如iso-2022-jp时，代表说明网站是采用的编码是日文； meta标签的charset的信息参数如ks_c_5601时，代表说明网站是采用的编码是韩文； meta标签的charset的信息参数如ISO-8859-1时，代表说明网站是采用的编码是英文； meta标签的charset的信息参数如UTF-8时，代表世界通用的语言编码； 4、META标签的generator &lt;metaname=”generator”content=”信息参数”/&gt; meta标签的generator的信息参数，代表说明网站的采用的什么软件制作。 5、META标签的author &lt;metaname=”author”content=”信息参数”&gt; meta标签的author的信息参数，代表说明网页版权作者信息。 6、META标签的http-equiv=”Refresh” &lt;Metahttp-equiv=”Refresh”Content=”时间;Url=网址参数”&gt; meta标签的Refresh代表多少时间网页自动刷新，加上Url中的网址参数就代表，多长时间自动链接其他网址。 7、META标签的HTTP-EQUIV=”Pragma”CONTENT=”no-cache” &lt;METAHTTP-EQUIV=”Pragma”CONTENT=”no-cache”&gt;代表禁止浏览器从本地计算机的缓存中访问页面内容,这样设定，访问者将无法脱机浏览。 8、META标签的COPYRIGHT &lt;METANAME=”COPYRIGHT”CONTENT=”信息参数”&gt; meta标签的COPYRIGHT的信息参数，代表说明网站版权信息。 9、META标签的http-equiv=”imagetoolbar” &lt;metahttp-equiv=”imagetoolbar”content=”false”/&gt; 指定是否显示图片工具栏，当为false代表不显示，当为true代表显示。 10、META标签的Content-Script-Type &lt;Metahttp-equiv=”Content-Script-Type”Content=”text/javascript”&gt; W3C网页规范，指明页面中脚本的类型。 11、META标签的revisit-after &lt;METAname=”revisit-after”CONTENT=”7days”&gt; revisit-after代表网站重访,7days代表7天，依此类推。 12、META标签的Robots&lt;metaname=”Robots”contect=”信息参数”&gt; Robots代表告诉搜索引擎机器人抓取哪些页面 其中的属性说明如下: 信息参数为all：文件将被检索，且页面上的链接可以被查询； 信息参数为none：文件将不被检索，且页面上的链接不可以被查询； 信息参数为index：文件将被检索； 信息参数为follow：页面上的链接可以被查询； 信息参数为noindex：文件将不被检索，但页面上的链接可以被查询； 信息参数为nofollow：文件将被检索，但页面上的链接不可以被查询； 基本标签标题标签1234&lt;!--标题标签 h1-h6 自动的加粗加黑 会自动的换行align:调整标签的位置 （默认是left） --&gt;【新时代·幸福美丽新边疆】西藏：代代接力守护绿色家园&lt;h1 align=&quot;right&quot;&gt;【新时代·幸福美丽新边疆】&lt;/h1&gt; &lt;h2&gt;【新时代·幸福美丽新边疆】&lt;/h2&gt; &lt;h3&gt;【新时代·幸福美丽新边疆】&lt;/h3&gt; &lt;h4&gt;【新时代·幸福美丽新边疆】&lt;/h4&gt; &lt;h5&gt;【新时代·幸福美丽新边疆】&lt;/h5&gt; &lt;h6&gt;【新时代·幸福美丽新边疆】&lt;/h6&gt; 分割线标签12345&lt;!--分割线标签 width：宽度 500px:像素 color:颜 色 align:位置（默认center） size:垂直方向的大小 --&gt; p段落标签1&lt;!--p段落标签 br:换行 &amp;nbsp;空格--&gt; 预文本标签123&lt;!--预文本标签 按照我们指定的格式输出 （灵活 性比较的大）--&gt; 小标签123456789101112131415161718&lt;!-- 下划线标签 --&gt;&lt;u&gt;北京尚学堂&lt;/u&gt;&lt;!-- 斜体标签 --&gt;&lt;i&gt;北京尚学堂&lt;/i&gt;&lt;!-- 加粗加黑 --&gt;&lt;b&gt;北京尚学堂&lt;/b&gt;&lt;!-- 删除线标签 --&gt;&lt;del&gt;北京尚学堂&lt;/del&gt;&lt;!-- 上标标签 --&gt;2&lt;sup&gt;3&lt;/sup&gt;&lt;!-- 下标标签 --&gt;log&lt;sub&gt;10&lt;/sub&gt;&lt;!-- 放大字体 --&gt;&lt;big&gt;北京尚学堂&lt;/big&gt;&lt;!-- 字体标签 font:指定字体的风格--&gt;&lt;font color=&quot;red&quot; size=&quot;25px&quot; face=&quot;宋体&quot;&gt;北京尚学堂&lt;/font&gt;&lt;!-- --&gt;&lt;span &gt;北京尚学堂&lt;/span&gt; 列表标签12345678910111213141516171819202122232425&lt;!-- 列表标签 1.有序列表 2.无序列表 3.自定义列表 作用: 1.树形菜单 2.导航栏的布局 3. ... --&gt; &lt;!--有序列表--&gt; &lt;ol type = &quot;I&quot;&gt; &lt;li&gt;javase&lt;/li&gt; &lt;li&gt;javaee&lt;/li&gt; &lt;li&gt;javame&lt;/li&gt; &lt;/ol&gt; &lt;!-- 无序列表 --&gt; &lt;ul&gt; &lt;li&gt;javase&lt;/li&gt; &lt;li&gt;javaee&lt;/li&gt; &lt;li&gt;javame&lt;/li&gt; &lt;/ul&gt; &lt;!-- 自定义列表 --&gt; &lt;dl&gt; &lt;dt&gt;java&lt;/dt&gt; &lt;dd&gt;javase&lt;/dd&gt; &lt;dd&gt;javaee&lt;/dd&gt; &lt;dd&gt;javame&lt;/dd&gt; &lt;/dl&gt; 跑马灯标签12&lt;!-- 跑马灯标签 direction:方向 scrollamount：移动像素--&gt; &lt;marquee direction=&quot;right&quot; scrollamount=&quot;40px&quot;&gt;北京尚学堂&lt;/marquee&gt; 超链接标签超链接标签的作用（不会自动换行） 【1】实现不同页面之间的跳转 href:指定跳转到目标资源的位置 target：打开网页的方式 【2】实现锚点功能 1234567&lt;!--跳转到本地的资源位置--&gt;&lt;a href=&quot;02body中常用小标签.html&quot;target=&quot;_blank&quot;&gt;02小标签测试&lt;/a&gt;&lt;!--跳转到网络的位置--&gt;&lt;a href=&quot;http://www.bjsxt.com&quot;&gt;北京尚学堂&lt;/a&gt;锚点功能&lt;a href=&quot;#bottom&quot; name=&quot;top&quot;&gt;返回底部&lt;/a&gt; &lt;a href=&quot;#top&quot; name=&quot;bottom&quot;&gt;返回顶部&lt;/a&gt; 图片标签img (不会自动的换行) src:引入图片的位置{相对路径、绝对路径、网络路径 } title：图片的标题 原始 宽和高 400px 260px 200px 130px border:图片的边框 alt：图片无法正常显示的时候显示的属性 align:图片的位置 ，必须有参照物 123456789101112131415161718&lt;!--相对路径--&gt;&lt;img src=&quot;img/2.jpg&quot; /&gt;&lt;!--绝对路径--&gt;&lt;imgsrc=&quot;C:\\\\Users\\\\my\\\\Documents\\\\HBuilderProjects\\\\01HTML\\\\img\\\\1.jpg&quot; /&gt;&lt;!--网络路径--&gt;&lt;img src=&quot;https://www.baidu.com/img/bd_logo1.png&quot;/&gt;&lt;p&gt;6666&lt;a href=&quot;#&quot;&gt;&lt;img src=&quot;img/1.jpg&quot; title=&quot;图片&quot; width=&quot;200px&quot;height=&quot;200px&quot; border=&quot;2px&quot; alt=&quot;图片显示错误&quot;align=&quot;right&quot;/&gt;&lt;/a&gt;8888&lt;/p&gt; 表格标签hbuilder的快捷键：table&gt;tr3&gt;th3 :声明3行3列的表格 ，再按下table table表格的自适应能力 (align=”center”) width=”300px” height=”300px” cellpadding：内容和单 元格的距离 cellspacing：单元格和单元格的距离 tr:指定height行高属性，行td:指定width的列宽属性，普通列 th:标题列，自动的居中，加黑效果 colspan:列合并 rowspan：行合并 bgcolor：背景颜色 表单标签https://www.baidu.com/s？键1=值1&amp;键2=值2 action：表单提交的位置 method（get/post）：表单提交的方式 GET: (1)参数会依附于url地址之后 (2)利用get方式提交数据，数据的长度有限制 (3)利用get方式提交数据，是不安全的 Post (1)请求不会依附于地址， (2)利用post处理参数不受限制 (3)post提交数据比较安全 12345678910111213141516171819202122232425262728293031323334&lt;form&gt; &lt;!-- 普通文本框 value：默认值， --&gt; 账号:&lt;input type=\"text\" name=\"zh\" value=\"123\"/&gt;&lt;br/&gt; 密码:&lt;input type=\"password\" name=\"pwd\" value=\"123\" /&gt;&lt;br/&gt; &lt;!-- 单选框(指定同一个name属性) value值 checked,默认值--&gt; 男: &lt;input type=\"radio\" name=\"sex\" value=\"0\"/&gt; 女: &lt;input type=\"radio\" name=\"sex\" value=\"1\" checked=\"checked\"/&gt; &lt;!-- 多选框 --&gt; 抽烟: &lt;input type=\"checkbox\" checked=\"checked\"/&gt; 喝酒: &lt;input type=\"checkbox\" checked=\"checked\"/&gt; 烫头: &lt;input type=\"checkbox\" /&gt;&lt;br /&gt; &lt;!-- 多行文本框 --&gt; 个人介绍:&lt;textarea rows=\"15\" cols=\"20\" &gt;你好&lt;/textarea&gt;&lt;br/&gt; &lt;!-- 文件选择 --&gt; &lt;input type=\"file\" name=\"file\" /&gt; &lt;!-- 隐藏框 --&gt; &lt;input type=\"hidden\" name=\"sno\" value=\"20180607\" /&gt; &lt;!-- 下拉框 --&gt; &lt;select name=\"ch\"&gt; &lt;!-- 1,2,3，value是保存在数据库中的 --&gt; &lt;option value=\"1\"&gt;中国&lt;/option&gt; &lt;option value=\"2\"&gt;美国&lt;/option&gt; &lt;!-- selected,默认勾选的属性 --&gt; &lt;option value=\"3\" selected=\"selected\"&gt;日本&lt;/option&gt; &lt;/select&gt; &lt;!-- 提交按钮 --&gt; &lt;input type=\"submit\" value=\"提交\" /&gt;&lt;br/&gt; &lt;!-- 清除按钮,清空写好的内容，回归默认的值 --&gt; &lt;input type=\"reset\" value=\"清除\" /&gt; &lt;!-- 普通按钮 --&gt; &lt;input type=\"button\" value=\"普通按钮\"/&gt;&lt;/form&gt; div标签div本身是没有任何的含义 div：作用就是把网页进行模块化的划分 123456789101112131415&lt;!-- div本身没有任何的含义 div作用就是把网页进行模块化的划分 --&gt; &lt;!-- 头部模块 --&gt; &lt;div class=&quot;top&quot;&gt;&lt;/div&gt; &lt;!-- 中间提示 --&gt; &lt;div class=&quot;tips&quot;&gt;&lt;/div&gt; &lt;!-- 中间的展现 --&gt; &lt;div class=&quot;center&quot;&gt; &lt;div class=&quot;login&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;!-- 底部模块 --&gt;&lt;div class=&quot;bottom&quot;&gt;&lt;/div&gt; HTML5增强的form表单标签123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657&lt;p&gt; &lt;!-- 邮箱 --&gt; 邮箱：&lt;input type=\"email\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;!-- 数字 只支持字母e，科学计数法--&gt; 年龄:&lt;input type=\"number\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;!-- 滑动器 --&gt; 滑动器:&lt;input type=\"range\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;!-- 搜索 --&gt; 搜索:&lt;input type=\"search\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;!-- 日期 --&gt; 日期:&lt;input type=\"date\" /&gt; 日期:&lt;input type=\"week\" /&gt; 日期:&lt;input type=\"month\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;!-- 颜色 --&gt; 颜色:&lt;input type=\"color\" /&gt; &lt;/p&gt; &lt;p&gt; &lt;!-- 网址 --&gt; 网址:&lt;input type=\"url\" /&gt; &lt;/p&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;input type=\"reset\" value=\"重置\" /&gt; &lt;/form&gt; &lt;hr /&gt; &lt;!-- h5中的增强属性 placeholder: autofocus:自动获得焦点 max:最大值 min:最小值 maxlength:最大长度 minlength:最小长度 --&gt; &lt;form&gt; &lt;p&gt; 账号:&lt;input type=\"text\" placeholder=\"手机号/邮箱/账号\" autofocus/&gt; &lt;/p&gt; &lt;p&gt; 密码:&lt;input type=\"password\" maxlength=\"4\" minlength=\"2\" /&gt; &lt;/p&gt; &lt;p&gt; 最大值:&lt;input type=\"number\" max=\"130\" min=\"0\"/&gt; &lt;/p&gt; &lt;input type=\"submit\" value=\"提交\"/&gt; &lt;input type=\"reset\" value=\"重置\" /&gt; &lt;/form&gt; 结构标签12345678910style中引用header&#123; height: 100px; width: 100%; background-color: red;&#125;body中引用&lt;!-- 头部模块 --&gt; &lt;header&gt;&lt;/header&gt; 音频视频标签12345678910111213141516&lt;!-- 音频标签，control:控制条 --&gt; &lt;audio src=&quot;img/1.mp3&quot; controls=&quot;controls&quot;&gt; 该网页不支持媒体标签 &lt;/audio&gt; &lt;audio&gt; &lt;source src=&quot;img/1.mp3&quot;&gt;&lt;/source&gt; &lt;source src=&quot;img/1.ogg&quot;&gt;&lt;/source&gt; 该网页不支持媒体标签 &lt;/audio&gt; &lt;!-- 视频标签 --&gt; &lt;video src=&quot;&quot; controls=&quot;controls&quot; width=&quot;300&quot; height=&quot;300&quot;&gt;&lt;/video&gt; &lt;video&gt; &lt;source src=&quot;&quot;&gt;&lt;/source&gt; &lt;/video&gt; &lt;!-- 多媒体,支持视频音频，自动播放 --&gt; &lt;embed src=&quot;img/1.mp3&quot;&gt;&lt;/embed&gt; 其他标签12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;figure&gt; &lt;img src=&quot;img/2.jpg&quot; /&gt; &lt;figcaption&gt;动漫图片&lt;/figcaption&gt; &lt;/figure&gt; &lt;!-- &lt;dl&gt; &lt;dd&gt; &lt;img src=&quot;img/2.jpg&quot; /&gt; &lt;/dd&gt; &lt;dd&gt; IT程序员 &lt;/dd&gt; &lt;/dl&gt; --&gt; &lt;!-- 展示详细信息 --&gt; &lt;details&gt; &lt;summary&gt;显示详细信息&lt;/summary&gt; &lt;p&gt;中国&lt;/p&gt; &lt;!-- mark标记 --&gt; &lt;mark&gt;中国2&lt;/mark&gt; &lt;p&gt;日本&lt;/p&gt; 美国 &lt;/details&gt; &lt;!-- 刻度 , max,min最大最小值， value默认值， low,high自己定义的最小值，最大值--&gt; &lt;meter max=&quot;100&quot; min=&quot;0&quot; value=&quot;100&quot; low=&quot;20&quot; high=&quot;80&quot;&gt;&lt;/meter&gt; &lt;!-- 进度条 --&gt; &lt;progress max=&quot;100&quot; value=&quot;40&quot;&gt;&lt;/progress&gt; &lt;!-- datalist 中描述了其可能的值 --&gt; &lt;datalist id=&quot;city&quot;&gt; &lt;option value=&quot;IBM&quot;&gt;IBM&lt;/option&gt; &lt;option value=&quot;ORACLE&quot;&gt;ORACLE&lt;/option&gt; &lt;/datalist&gt; &lt;input type=&quot;text&quot; list=&quot;city&quot; /&gt; &lt;!-- 画布标签 --&gt; &lt;canvas id=&quot;mycat&quot;&gt;&lt;/canvas&gt; &lt;script&gt; var ca = document.getElementById(&quot;mycat&quot;); var te = ca.getContext(&quot;2d&quot;); //背景颜色 te.fillStyle = &quot;#FF0000&quot;; //绘制图形的大小 te.fillRect(0,0,80,100); &lt;/script&gt;","categories":[{"name":"web","slug":"web","permalink":"http://yoursite.com/categories/web/"}],"tags":[{"name":"HTML","slug":"HTML","permalink":"http://yoursite.com/tags/HTML/"}]},{"title":"Oracle","slug":"Oracle/oracle的用户","date":"2019-07-01T04:55:01.000Z","updated":"2019-07-01T05:01:12.267Z","comments":true,"path":"2019/07/01/Oracle/oracle的用户/","link":"","permalink":"http://yoursite.com/2019/07/01/Oracle/oracle的用户/","excerpt":"","text":"Oracle用户和登录sys和system1)【sys】所有 oracle 的数据字典的基表和视图都存放在 sys 用户中，这些基表和视图对于 oracle 的运行是至关重要的，由数据库自己维护，任何用户都不能手动更改。 sys 用户拥有 dba ， sysdba ， sysoper 等角色或权限，是 oracle 权限最高的用户。 2)【 system 】 用户用于存放次一级的内部数据，如 oracle 的一些特性或工具的管理信息。 system 用户拥有普通 dba 角色权限。 以normal,sysdba,sysopra身份登录normal 是普通用户 sysdba 拥有最高的系统权限，登陆后是 syssysoper 主要用来启动、关闭数据库， sysoper 登陆后用户是 public 注意:sys只能以sysdba身份登录","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"Oracle","slug":"Oracle","permalink":"http://yoursite.com/tags/Oracle/"}]},{"title":"git提交github仓库","slug":"Config/git提交github仓库","date":"2019-06-28T15:12:26.000Z","updated":"2019-07-08T06:53:16.875Z","comments":true,"path":"2019/06/28/Config/git提交github仓库/","link":"","permalink":"http://yoursite.com/2019/06/28/Config/git提交github仓库/","excerpt":"","text":"git提交github仓库提交1) 本地新建一个文件夹res,作为项目根目录 2) 打开git,进入res, 3) git init 在项目根目录执行git init命令 4)建立远程仓库连接: (use ssh) ​ git remote add origin git@github.com:Momentonly/Java.git ​ git remote add origin git@github.com:账号名/仓库名.git ` 5)查看git状态: git status 6)git add -A 自动添加全部要上传到仓库的文件 7)git commit -m ‘注释’ 8) git push -u origin master 从远程分支拉取master分支并与本地master分支合并。 拉取1)git pull origin master:master 从远程分支拉取master分支并与本地master分支合并。 注意：当发现远程仓库已经有内容并提示先执行git pull，将内容进行合并后再上传，在执行git pull的时候，或者会出现 123456789There is no tracking information for the current branch.Please specify which branch you want to merge with.See git-pull(1) for details git pull &lt;remote&gt; &lt;branch&gt;If you wish to set tracking information for this branch you can do so with: git branch --set-upstream-to=origin/&lt;branch&gt; master 也就是指定当前工作目录工作分支，跟远程的仓库，分支之间的链接关系。然后按照提示输入git branch --set-upstream-to=origin/master master与master分支关联，完成后再执行 git pull 和 git push,","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"log4j的配置","slug":"MyBatis/Log4j的配置","date":"2019-06-25T00:50:30.000Z","updated":"2019-06-25T00:53:37.718Z","comments":true,"path":"2019/06/25/MyBatis/Log4j的配置/","link":"","permalink":"http://yoursite.com/2019/06/25/MyBatis/Log4j的配置/","excerpt":"","text":"log4jEclipse的log4j.properties配置 rootCategory以前的配置，不推荐使用 123456789101112131415161718192021# Set root category priority to INFO and its only appender to CONSOLE. #只打印到控制台，并设置日志级别# log4j.rootCategory=DEBUG, CONSOLE #打印到控制台，日志文件，并设置日志级别为DEBUGlog4j.rootCategory=DEBUG, CONSOLE, LOGFILE # CONSOLE is set to be a ConsoleAppender using a PatternLayout. #控制台的输出格式log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout #指定输出的信息格式 %m:message,%n:换行,%c:class,追踪产生日志的类#%l,包名类名方法名，第几行出现问题,log4j.appender.CONSOLE.layout.ConversionPattern=- %m %c %l%d&#123;yyyy-MM-dd HH:mm:ss&#125;%n # LOGFILE is set to be a File appender using a PatternLayout. #日志文件的输出格式log4j.appender.LOGFILE=org.apache.log4j.FileAppender log4j.appender.LOGFILE.File=d:/test.log log4j.appender.LOGFILE.Append=true log4j.appender.LOGFILE.layout=org.apache.log4j.PatternLayout log4j.appender.LOGFILE.layout.ConversionPattern=- %m %l%n 详细配置详解123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156#配置根日志优先级，及输出位置#语法：log4j.rootLogger = [debug],apppenderName1,appenderName2...log4j.rootLogger = debug,stdout,D #上面定义了两个输出位置名：stdout与D，现分别配置：#配置stdout为调试窗口输出:log4j.appender.stdout = org.apache.log4j.ConsoleAppenderlog4j.appender.stdout.Target=System.out#指定了一个模式表达式的布局log4j.appender.stdout.layout=org.apache.log4j.PatternLayout#设置该模式表达式log4j.appender.stdout.layout.ConversionPattern=[%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n#说明：#[%-5p]:%p设置输出日志优先级，&apos;-&apos;表示左对齐，5表示日志优先级所占字符个数的宽度，取5是为了保持一致。如：[DEBUG]#%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125;,指定了打印日志时间与时间格式，SSS表示？#%l: 输出日志事件的发生位置，见第四部分。%n，输出换行符。%m，输出日志事件发生的方法名。#配置D为输出日志到文件：log4j.appender.D=org.apache.log4j.FileAppenderlog4j.appender.D.File=D:\\\\Program_software\\\\Apache7_0_75\\\\webapps\\\\testLog.loglog4j.appender.D.layout=org.apache.log4j.PatternLayoutlog4j.appender.D.layout.ConversionPattern=[%-5p] %d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125; method:%l%n%m%n####################################################################———————————配置详细说明，共四部分——————————##一、配置log4j.rootLogger#语法：log4j.rootLogger = [debug],apppenderName1,appenderName2...#如：log4j.rootLogger = debug,stdout#二、配置Appeder——输出位置#语法：log4j.appender.appenderName = fully.qualified.name.of.appender.class#完全合法的appenderName 有几类选择#1、控制台：org.apache.log4j.ConsoleAppender#对应选项：#Threshold=WARN:指定日志消息的输出最低层次#ImmediateFlush=true:默认日志立即打印#Target=System.err:默认情况下使用System.out 输出控制台#2、文件：org.apache.log4j.FileAppender#对应选项：#Threshold=WARN:指定日志消息输出最低层次#ImmediateFlush=true:默认日志立即打印#File=mylog.txt:指定输出路径，可以是任何路径#Append=false：默认值是true，为false则覆盖#3、周期产生日志文件：org.apache.log4j.DailyRollingFileAppender#对应选项：#Threshold=WARN:指定日志消息输出最低层次#ImmediateFlush=true:默认日志立即打印#File=a.log:指定消息输出到a.log文件，默认是从web服务器的根路径开始#Append=false：默认为true#DatePattern=&apos;.&apos;yyyy-ww:每周滚动一次文件，即每周产生一个新的文件。#也可指定周期：#&apos;.&apos;yyyy-MM:每月#&apos;.&apos;yyyy-ww:每周#&apos;.&apos;yyyy-MM-dd:每天#&apos;.&apos;yyyy-MM-dd-a：每天两次#&apos;.&apos;yyyy-MM-dd-HH：每小时#&apos;.&apos;yyyy-MM-dd-HH-mm：每分钟#4、指定文件尺寸大小产生日志文件：org.apache.log4j.RollingFileAppender#对应选项：#Threshold=WARN:指定日志消息输出最低层次#ImmediateFlush=true:默认日志立即打印#File=a.log：指定日志文件#Append=false：默认为true#MaxFileSize=100KB：单位可以是KB|MB|GB，日志文件达到最大时，将会自动滚动，即将原来的内容移到mylog.log.1文件#MaxBackupIndex=2：指定可以产生滚动文件的最大数#5、将日志以流格式发送到任意指定的地方：org.apache.log4j.WriterAppender#例如：#log4j.appender.R=org.apache.log4j.DailyRollingFileAppender #log4j.appender.R.File=D:\\\\eclipsespace\\\\testSSH\\\\WebContent\\\\WEB-INF\\\\testlog.log #三、配置日志信息的格式布局(layout)#layout负责格式化Appender 的输出#语法：#log4j.appender.appenderName.layout=fully.qualified.name.of.layout.class#有效的layout类名字有以下几种：#1、org.apache.log4j.HTMLLayout（以HTML表格形式布局） #该选项有以下几种： #LocationInfo=true:默认值是false,输出java文件名称和行号 #Title=my app file: 默认值是 Log4J Log Messages. #2、org.apache.log4j.PatternLayout（可以灵活地指定布局模式） #该选项有以下几种： #ConversionPattern=%m%n :指定怎样格式化指定的消息 #其中%m%n等符号所代表的含义如下： (有问题，暂不管)#－X号: X信息输出时左对齐； #%p: 输出日志信息优先级，即DEBUG，INFO，WARN，ERROR，FATAL, #%d: 输出日志时间点的日期或时间，默认格式为ISO8601，也可以在其后指定格式，比如：%d&#123;yyy MMM dd HH:mm:ss,SSS&#125;，输出类似：2002年10月18日 22：10：28，921 #%r: 输出自应用启动到输出该log信息耗费的毫秒数 #%c: 输出日志信息所属的类目，通常就是所在类的全名 #%t: 输出产生该日志事件的线程名 #%l: 输出日志事件的发生位置，相当于%C.%M(%F:%L)的组合,包括类目名、发生的线程，以及在代码中的行数。举例：Testlog4.main(TestLog4.java:10) #%x: 输出和当前线程相关联的NDC(嵌套诊断环境),尤其用到像java servlets这样的多客户多线程的应用中。 #%%: 输出一个&quot;%&quot;字符 #%F: 输出日志消息产生时所在的文件名称 #%L: 输出代码中的行号 #%m: 输出代码中指定的消息,产生的日志具体信息 #%n: 输出一个回车换行符，Windows平台为&quot;\\r\\n&quot;，Unix平台为&quot;\\n&quot;输出日志信息换行 #可以在%与模式字符之间加上修饰符来控制其最小宽度、最大宽度、和文本的对齐方式。如： #%20c：指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，默认的情况下右对齐。 #%-20c:指定输出category的名称，最小的宽度是20，如果category的名称小于20的话，&quot;-&quot;号指定左对齐。 #%.30c:指定输出category的名称，最大的宽度是30，如果category的名称大于30的话，就会将左边多出的字符截掉，但小于30的话也不会有空格。 #%20.30c:如果category的名称小于20就补空格，并且右对齐，如果其名称长于30字符，就从左边交远销出的字符截掉。 # 如：%-4r %-5p %d&#123;yyyy-MM-dd HH:mm:ssS&#125; %c %m%n [TEST] %p [%t] %C.%M(%L) | %m%n #3、org.apache.log4j.SimpleLayout（包含日志信息的级别和信息字符串） #4、org.apache.log4j.TTCCLayout（包含日志产生的时间、线程、类别等等信息） #四、其他#指定包名下的日志级别#语法：log4j.logger.包名=日志级别#如：#log4j.logger.com.neusoft =DEBUG #指定com.neusoft包下的所有类的等级为DEBUG。 #log4j.logger.com.opensymphony.oscache=ERROR #log4j.logger.net.sf.navigator=ERROR #这两句是把这两个包下出现的错误的等级设为ERROR，如果项目中没有配置EHCache，则不需要这两句。 #log4j.logger.org.apache.commons=ERROR #log4j.logger.org.apache.struts=WARN ## #这两句是struts的包。作者：Liekkas_BX 来源：CSDN 原文：https://blog.csdn.net/qq_19865749/article/details/70306971 版权声明：本文为博主原创文章，转载请附上博文链接！","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"log4j","slug":"log4j","permalink":"http://yoursite.com/tags/log4j/"}]},{"title":"数据源和连接池","slug":"MyBatis/数据源和连接池","date":"2019-06-22T05:24:30.000Z","updated":"2019-06-22T06:51:34.022Z","comments":true,"path":"2019/06/22/MyBatis/数据源和连接池/","link":"","permalink":"http://yoursite.com/2019/06/22/MyBatis/数据源和连接池/","excerpt":"","text":"数据源（1）数据源是一种数据库对编程提供的一个接口，每个数据源对应一个数据库。（2）连接池只是存放数据库连接对象的一个缓冲池，需要数据连接的时候从缓冲池中取就行了。（3）连接池可以管理数据源。 ​ 用TCP来连接你的应用程序与数据库是一件昂贵的事情（很费时的事情），开发者可以通过用连接池来反复的使用数据库的连接。比起每次请求都用TCP来连一次数据库，连接池只有在不存在有效的连接时才新建一个TCP连接。当关闭一个连接的时候，它会被放到池中，它仍然会保持与数据库的连接，这样就可以减少与数据库的TCP连接次数。​ 数据源是指数据的来源，比如数据库。连接池是指这样一个“池子”，池子中的每个东西都是连接数据源的一个“连接”，这样别人想连接数据源的时候可以从这个“池子”里取，用完以后再放回来供以后其他想使用的人使用。我们一般说的数据源指的就是数据库～ 数据源是指数据的来源的概括，包含了数据库位置 和 数据库类型等信息，实际上是一种数据连接的抽象。 也可以说，你要得到的信息存放的地方的概括（包括 存放信息的数据库类型、数据库的地址等等信息的概括） c3p0,dbcp,druid配置数据源也可以说是对整个数据库连接参数的配置（包括各种配置，以及连接池的管理）","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"}]},{"title":"mytabis的学习","slug":"MyBatis/mytabis的学习","date":"2019-06-22T03:07:30.000Z","updated":"2019-06-30T09:19:55.388Z","comments":true,"path":"2019/06/22/MyBatis/mytabis的学习/","link":"","permalink":"http://yoursite.com/2019/06/22/MyBatis/mytabis的学习/","excerpt":"","text":"接口绑定方案MyBatis中，提供了一套接口绑定方案，程序员可以提供一个接口，然后提供对应接口的一个mapper.xml文件。 MyBatis会自动将接口和xml文件进行绑定，实际上就是MyBatis会根据接口和对应的xml文件创建接口的实现类。 可以得到实现类的对象。 实现: 映射文件的命名和接口的命名一致 映射文件的namespace写接口的全限定路径 Mapper接口与Mapper.xml放在同一个包下 mybatis如何通过接口查找对应的mapper.xml及方法执行详解链接:https://www.jb51.net/article/116402.htm mybatis中接口文件Mapper和接口配置文件Mapper.xml不在同一个目录下1：只有单独的Mybatis没有Spring的情况下 a:首先修改*Mapper.xml中的namespace 1&lt;mapper namespace=&quot;cn.gsm.mkm.dao.UserMapper&quot;&gt; 指定到你的*Mapper接口 b:在mybatis总配置文件中指定扫描目标 &lt;mappers&gt; &lt;mapper resource=&quot;cn/gsm/mkm/mapper/UserMapper.xml&quot;&gt;&lt;/mapper&gt; &lt;package name=&quot;cn.gsm.mkm.dao.UserMapper&quot;&gt;&lt;/package&gt;&lt;!-- 指定具体文件--&gt; &lt;/mappers&gt; 需要注意，这样配置必须指定具体的文件。否则dom4j解析会报错SAXParseException。 通过接口绑定解决多参数的传递1)接口中定义方法 1User selByUP(String username, String password); 映射文件中提供对应的标签. 此时, SQL语句中获取方式 有两种, 通过#{index}或#{param+数字}的方式. 12345&lt;select id=*&quot;selByUP&quot;* resultType=*&quot;user&quot;*&gt; select * from t_user where username=#&#123;0&#125; and password=#&#123;1&#125; &lt;/select&gt; 2) 接口中定义方法, 参数中使用@Param 注解设定参数名用 于在 SQL 语句中使用. 1User selByUP(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password); 映射文件中提供对应的标签. 此时, SQL语句中获取方式 有两种, 通过#{参数名称}或#{param+数字}的方式. 1234567&lt;select id=*&quot;selByUP&quot;* resultType=*&quot;user&quot;*&gt; select * from t_user where username=#&#123;username&#125; and password=#&#123;password&#125; &lt;/select&gt; 动态SQL根据条件的不同, SQL 语句也会随之动态的改变. MyBatis 中, 提供了一组标签用于实现动态 SQL. if标签用于进行条件判断, test 属性用于指定判断条件. 为了拼接 条件, 在 SQL 语句后强行添加 1=1 的恒成立条件. 1234567891011121314151617&lt;select id=*&quot;sel&quot;* resultType=*&quot;user&quot;*&gt; select * from t_user where 1=1 &lt;if test=*&quot;username != null and username != &apos;&apos;&quot;*&gt; and username=#&#123;username&#125; &lt;/if&gt; &lt;if test=*&quot;password != null and password != &apos;&apos;&quot;*&gt; and password=#&#123;password&#125; &lt;/if&gt; &lt;/select&gt; if标签中的test属性中取值直接写别名，不能用索引或者param+数字取值，也不用#{别名} 12345&lt;!-- 5.判断字符串是否等于特定字符(比如此处的user) --&gt;&lt;if test=&apos;stringParam != null and stringParam == &quot;user&quot;&apos;&gt;&lt;/if&gt;&lt;if test=&quot;stringParam != null and stringParam != &apos;user&apos;&quot;&gt;&lt;/if&gt; &lt;!-- 如果要用这个写法要 --&gt;&lt;if test=&quot;stringParam != null and stringParam != &apos;user&apos;.toString()&quot;&gt;&lt;/if&gt; where 标签用于管理 where 子句. 有如下功能: a)如果没有条件, 不会生成 where 关键字 b)如果有条件, 会自动添加 where 关键字 c)如果第一个条件中有 and, 去除之 1234567891011&lt;select id=&quot;sel&quot; resultType=&quot;user&quot;&gt;select * from t_user&lt;where&gt; &lt;if test=&quot;username != null and username != &apos;&apos;&quot;&gt; and username=#&#123;username&#125; &lt;/if&gt; &lt;if test=&quot;password != null and password != &apos;&apos;&quot;&gt; and password=#&#123;password&#125; &lt;/if&gt;&lt;/where&gt;&lt;/select&gt; choose,when,otherwise标签这是一套标签, 功能类似于 switch…case…default when只成立一个 12345678910111213141516171819&lt;select id=*&quot;sel&quot;* resultType=*&quot;user&quot;*&gt; select * from t_user &lt;where&gt; &lt;choose&gt; &lt;!-- when 只成立一个--&gt; &lt;when test=*&quot;username != null and username != &apos;&apos;&quot;*&gt; and username = #&#123;username&#125; &lt;/when&gt; &lt;when test=*&quot;password != null and password != &apos;&apos;&quot;*&gt; and password = #&#123;password&#125; &lt;/when&gt; &lt;otherwise&gt; and 1=1 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; Set标签用于维护 update 语句中的 set 子句. 功能如下: a)满足条件时, 会自动添加 set 关键字 b)会去除 set 子句中多余的逗号 c)不满足条件时, 不会生成 set 关键字 Trim标签用于在前后添加或删除一些内容 a)prefix, 在前面添加内容 b)prefixOverrides, 从前面去除内容 c)suffix, 向后面添加内容 d)suffixOverrides, 从后面去除内容 1234567891011121314&lt;update id=*&quot;updUser&quot;* parameterType=*&quot;user&quot;*&gt; update t_user &lt;!-- prefix: 前缀, 表示向前面添加内容 prefixOverrides: 从前面删除内容 suffix: 后缀, 表示向后面添加内容 suffixOverrides: 从后面删除内容 --&gt; &lt;trim prefix=*&quot;set&quot;* prefixOverrides=*&quot;user&quot;* suffix=*&quot;hahaha&quot;* suffixOverrides=*&quot;,&quot;*&gt; username=#&#123;username&#125;, &lt;/trim&gt; where id=#&#123;id&#125; &lt;/update&gt; bind标签用于对数据进行再加工, 用于模糊查询 12345678910&lt;select id=&quot;sel&quot; resultType=&quot;user&quot;&gt; select * from t_user &lt;where&gt; &lt;if test=&quot;username!=null and username!=&apos;&apos;&quot;&gt; &lt;!-- 处理username，将值处理后依旧赋值给username --&gt; &lt;bind name=&quot;username&quot; value=&quot;&apos;%&apos; + username + &apos;%&apos;&quot;/&gt; and username like #&#123;username&#125; &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; foreach标签用于在 SQL 语句中遍历集合参数, 在 in 查询中使用 a)collection: 待遍历的集合 b)open: 设置开始符号 c)item: 迭代变量 d)separator: 项目分隔符 e)close: 设置结束符号 12345678910&lt;select id=&quot;selIn&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt;select * from t_user where id in&lt;!--collection=&quot;list&quot; 指定集合是list--&gt;&lt;foreach collection=&quot;list&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot;item=&quot;item&quot;&gt;#&#123;item&#125;&lt;/foreach&gt;&lt;/select&gt;//接口中起别名listList&lt;User&gt; selIn(@Param(&quot;list&quot;) List&lt;Integer&gt; list); sql,include标签1234567891011121314151617&lt;sql&gt;用于提取 SQL 语句, &lt;include&gt;用于引用 SQL 语句&lt;sql id=&quot;mySql&quot;&gt;id, username, password&lt;/sql&gt; &lt;select id=&quot;selIn&quot; parameterType=&quot;list&quot; resultType=&quot;user&quot;&gt; select &lt;!--引用提取的sql语句--&gt; &lt;include refid=&quot;mySql&quot;/&gt; from t_user where id in &lt;foreach collection=&quot;list&quot; open=&quot;(&quot; separator=&quot;,&quot; close=&quot;)&quot; item=&quot;item&quot;&gt; #&#123;item&#125; &lt;/foreach&gt;&lt;/select&gt; MyBatis的缓存机制a)缓存用于提高查询的效率. b)MyBatis的缓存是使用SQL标签的. 执行相同的标签可以使用缓缓存. c) MyBatis 中有两种缓存机制. 注意:缓存的查询通过id标识，即同一个sql语句(namespace+id) 一级缓存a)默认开启. 线程级别的缓存, SqlSession 的缓存 b)在一个 SqlSession 生命周期中有效. SqlSession 关闭, 缓存清空.sqlSession对象级别的 二级缓存a)进程级别的缓存, SqlSessionFactory 的缓存 b)在一个 SqlSessionFactory 生命周期中有效.可以在多个 SqlSession 生命中期中共享. c)默认关闭, 需要使用的时候, 要为某个命名空间开启二级 缓存(在 mapper.xml 中配置\\&lt;cache>. 12&lt;!-- 开启二级缓存, 要求实体类进行序列化 --&gt;&lt;cache /&gt; 12&lt;!--readOnly只读，实体类可以不实现序列化接口--&gt;&lt;cache readOnly=&quot;true&quot;&gt;&lt;/cache&gt; 解决列名和属性名不一致问题如果查询时使用 resultType 属性, 表示采用 MyBatis 的 Auto-Mapping(自动映射)机制, 即相同的列名和属性名会自 动匹配. 因此, 当数据库表的列名和类的属性名不一致时, 会导致查不到数据. 解决该问题可以有两种方式: 列别名查询时, 可以通过列别名的方式将列名和属性名保持一致, 继续使用自动映射, 从而解决该问题. 但是较为麻烦. 123&lt;select id=&quot;selAll&quot; resultType=&quot;user&quot;&gt;select id id1, username username1, password password2 from t_user&lt;/select&gt; 使用\\&lt;resultMap>\\&lt;resultMap>用于自定义映射关系, 可以由程序员自主制定 列名和属性名的映射关系. 一旦使用 resultMap, 表示不再 采用自动映射机制. 1234567891011&lt;!--type实体类，id标识该resultMap--&gt;&lt;resultMap type=*&quot;user&quot;* id=*&quot;umap&quot;*&gt; &lt;!-- id用于映射主键 --&gt; &lt;id column=*&quot;id&quot;* property=*&quot;id1&quot;* /&gt; &lt;!-- 非主键使用result映射 --&gt; &lt;result column=*&quot;username&quot;* property=*&quot;username1&quot;* /&gt; &lt;result column=*&quot;password&quot;* property=*&quot;password1&quot;* /&gt; &lt;/resultMap&gt; &lt;select id=*&quot;selAll&quot;* resultMap=*&quot;umap&quot;*&gt; select * from t_user &lt;/select&gt; 多表查询resultMap的N+1方式实现多表查询（多对一）resultMap中的association属性用于关联一个对象 1） property: 指定要关联的属性名 2） select: 设定要继续引用的查询, namespace+id 3） column: 查询时需要传递的列 12345678910111213141516&lt;resultMap type=&quot;Student&quot; id=&quot;stumap&quot;&gt; &lt;!-- id用于映射主键 --&gt; &lt;id column=&quot;s_id&quot; property=&quot;id&quot;/&gt; &lt;!-- 非主键使用result映射 --&gt; &lt;result column=&quot;s_name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;s_age&quot; property=&quot;age&quot;/&gt; &lt;result column=&quot;s_gender&quot; property=&quot;gender&quot;/&gt; &lt;result column=&quot;s_c_id&quot; property=&quot;cid&quot;/&gt; &lt;!-- 用于关联一个对象 property:Student实体类中的属性 select:调用一个查询方法 column:使用哪一列的值作为参数传递到select调用的查询方法 注意:column使用数据库列名s_c_id --&gt; &lt;association property=&quot;clazz&quot; select=&quot;com.szxy.mapper.ClazzMapper.selById&quot; column=&quot;s_c_id&quot;&gt;&lt;/association&gt; &lt;/resultMap&gt; 关联查询a)在 StudentMapper.xml 中定义多表连接查询 SQL 语句, 一 次性查到需要的所有数据, 包括对应班级的信息. b)通过resultMap定义映射关系, 并通过association指 定对象属性的映射关系. 可以把association看成一个resultMap使用. javaType 属性表示当前对象, 可以写 全限定路径或别名. 12345678910111213141516171819202122&lt;!-- 关联查询 --&gt; &lt;resultMap type=&quot;Student&quot; id=&quot;smap&quot;&gt; &lt;id column=&quot;sid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;sname&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;s_age&quot; property=&quot;age&quot;/&gt; &lt;result column=&quot;s_gender&quot; property=&quot;gender&quot;/&gt; &lt;result column=&quot;s_c_id&quot; property=&quot;cid&quot;/&gt; &lt;!-- property:Student类的属性名 javaType:是一个类型，Clazz的类型,可以当做association的返回值类型 --&gt; &lt;association property=&quot;clazz&quot; javaType=&quot;Clazz&quot;&gt; &lt;id column=&quot;id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;c_name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;c_room&quot; property=&quot;room&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=&quot;selAll&quot; resultMap=&quot;smap&quot;&gt; select s_id sid,s_name sname,s_age, s_gender,s_c_id cid,c_name cname,c_room from t_student s left join t_class c on s.s_c_id = c_id &lt;/select&gt; resultMap的N+1方式实现多表查询（一对多）​ 提供 ClazzMapper 和 StudentMapper, ClazzMapper 查询所有 班级信息, StudentMapper 根据班级编号查询学生信息. 在 ClazzMapper 中使用\\&lt;collection>设置装配. a)\\&lt;collection>用于关联一个集合  property: 指定要关联的属性名  select: 设定要继续引用的查询, namespace+id  column: 查询时需要传递的列 1234567891011&lt;!-- N+1多对一查询 --&gt; &lt;resultMap type=&quot;Clazz&quot; id=&quot;cmap&quot;&gt; &lt;id column=&quot;c_id&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;c_name&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;c_room&quot; property=&quot;room&quot;/&gt; &lt;!-- 关联一个集合 --&gt; &lt;collection property=&quot;stus&quot; select=&quot;com.szxy.mapper.StudentMapper.selByCid&quot; column=&quot;c_id&quot;&gt;&lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;selAll&quot; resultMap=&quot;cmap&quot;&gt; select * from t_class &lt;/select&gt; resultMap的关联方式实现多表查询（一对多）a)在 ClazzMapper.xml 中定义多表连接查询 SQL 语句, 一次 性查到需要的所有数据, 包括对应学生的信息. b)通过\\&lt;resultMap>定义映射关系, 并通过\\&lt;collection>指 定集合属性泛型的映射关系. 可以把\\&lt;collection>看成一 个\\&lt;resultMap>使用. ofType 属性表示集合的泛型, 可以 写全限定路径或别名. 注:colletion关联一个集合 1）property: Clazz类中的stus属性名 2)javaType: Clazz类中的stus属性的类型 3)ofType:stus属性是List集合，指定泛型 12345678910111213141516171819202122&lt;!-- 关联查询（多对一） --&gt; &lt;resultMap type=&quot;Clazz&quot; id=&quot;clzmap&quot;&gt; &lt;id column=&quot;cid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;cname&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;croom&quot; property=&quot;room&quot;/&gt; &lt;!-- 关联一个集合 ofType:集合的泛型 --&gt; &lt;collection property=&quot;stus&quot; javaType=&quot;list&quot; ofType=&quot;Student&quot;&gt; &lt;id column=&quot;sid&quot; property=&quot;id&quot;/&gt; &lt;result column=&quot;sname&quot; property=&quot;name&quot;/&gt; &lt;result column=&quot;sage&quot; property=&quot;age&quot;/&gt; &lt;result column=&quot;sgender&quot; property=&quot;gender&quot;/&gt; &lt;result column=&quot;cid&quot; property=&quot;cid&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;selAll2&quot; resultMap=&quot;clzmap&quot;&gt; select c.c_id cid,c.c_name cname, c_room croom,s.s_id sid, s.s_name sname,s.s_age sage,s.s_gender sgender from t_class c left join t_student s on c.c_id = s.s_c_id &lt;/select&gt; 通过Auto-Mapping实现多表查询（多对一）a)通过 MyBatis 的 Auto-Mapping 机制及数据库查询时的别 名结合, 可以方便的实现多表查询. b)SQL 语句中, 别名出现特殊符号时, 必须进行处理. MySQL 可以使用()符号, Oracle 可以使用(“”)符号. 123456789&lt;!-- AutoMapping 将别名使用属性名.属性来进行自动映射 --&gt; &lt;select id=&quot;selAutoMapping&quot; resultType=&quot;Student&quot;&gt; select s_id id,s_name name,s_age age,s_gender gender,s_c_id cid,s_c_id `clazz.id`,c_name `clazz.name`,c_room `clazz.room` from t_student s left JOIN t_class c on s.s_c_id = c.c_id &lt;/select&gt; 注解开发a)注解是用于描述代码的代码. 例如: @Test(用于描述方法 进行 junit 测试), @Override(用于描述方法的重写), @Param(用于描述属性的名称) b)注解的使用风格: @xxx(属性), 使用前必须先导包 c)使用注解一般用于简化配置文件. 但是, 注解有时候也不 是很友好(有时候反而更麻烦), 例如动态 SQL. d)关于注解的属性  属性的设定方式是: 属性名=属性值 e)关于属性值的类型  基本类型和 String, 可以直接使用双引号的形式  数组类型, name={值 1, 值 2, …}; 如果数组元素只有 一个, 可以省略大括号  对象类型, name=@对象名(属性)  如果属性是该注解的默认属性, 而且该注解只配置这 一个属性, 可以将属性名省略 f)注解和配置文件可以配合使用 1234567891011@Select(&quot;select * from t_student&quot;) List&lt;Student&gt; selAll(); @Insert(value = &#123;&quot;insert into t_student values(default,#&#123;name&#125;,#&#123;age&#125;,#&#123;gender&#125;,#&#123;cid&#125;)&quot;&#125;) int insStu(Student student); @Update(value = &#123;&quot;update t_student set s_age = #&#123;age&#125; where s_id = #&#123;0&#125;&quot;&#125;) int updStu(int id, @Param(&quot;age&quot;)int age); @Delete(&quot;delete from t_student where s_id = #&#123;0&#125;&quot;) int delStu(int id); 其他注解 1234567@Results: 类似于&lt;resultMap&gt; @Result: 类似于&lt;resultMap&gt;的子标签 @One: 类似于&lt;association&gt; @Many: 类似于&lt;collection&gt; @One 1234567891011121314 //N+1查询@Select(&quot;select * from t_student&quot;)@Results(value = &#123; @Result(column = &quot;s_id&quot;, property = &quot;id&quot;,id = true), @Result(column = &quot;s_name&quot;, property = &quot;name&quot;), @Result(column = &quot;s_age&quot;, property = &quot;age&quot;), @Result(column = &quot;s_gender&quot;, property = &quot;gender&quot;), @Result(column = &quot;s_c_id&quot;, property = &quot;cid&quot;), @Result(property = &quot;clazz&quot;, one = @One(select = &quot;com.szxy.mapper.ClazzMapper.selById&quot;), column = &quot;s_c_id&quot; )&#125;)List&lt;Student&gt; sel(); @Many 1234567891011@Select(&quot;select * from t_class&quot;) @Results(value = &#123; @Result(column = &quot;c_id&quot;, property = &quot;id&quot;, id = true), @Result(column = &quot;c_name&quot;, property = &quot;name&quot;), @Result(column = &quot;c_room&quot;, property = &quot;room&quot;), @Result(property = &quot;stus&quot;, many = @Many(select = &quot;com.szxy.mapper.StudentMapper.selByCid&quot;), column = &quot;c_id&quot; ) &#125;) List&lt;Clazz&gt; selClz(); MyBatis运行原理运行过程中涉及到的类或接口1)Resources(C) 用于加载 MyBatis 核心配置文件 2)XMLConfigBuilder(C) 用于解析 xml 文件(核心配置文件) 3) Configuration(C) 用于存放 xml 文件解析后的结果 4)DefaultSqlSessionFactory(C) 是 SqlSessionFactory(I)的 实 现 类 , 创 建 时 需 要 使 用 Configuration 对象 5) SqlSession(I) 是 MyBatis 操作的核心 6)DefaultSqlSession(C) 是 SqlSession 接口的实现类 7) TransactionFactory(I) 用于生产 Transaction 对象 8) Transaction(I) 用于表示操作数据库的事务对象 9)Executor(I) 是 MyBatis 的核心执行器, 类似于 jdbc 中的 Statement, 常 用的实现类是 SimpleExecutor 描述​ 当Mybatis运行开始时，先要通过Resources加载核心配置文件，之后使用XmlConfigBuilder对配置文件进行 解析，将解析结果封装为Configuration对象。接着，使用Configuration对象构建一个DefaultSqlSessionFactory 对象，至此，SqlSession工厂构建完成。 ​ 接下来，通过工厂对象调用openSession方法创建SqlSession对象。在这个过程中，需要通过TransactionFactory 生产一个Transaction对象，并且，还需要创建核心执行器Executor对象。之后，通过这些对象来创建DefaultSqlSession对象，至此，SqlSession对象创建成功。 ​ 之后，通过SqlSession对象执行相应的操作。如果执行成功，调用commit()方法提交事务；如果失败，调用rollback()方法进行事务回滚。最后，调用close()方法关闭SqlSession资源，以上，就是MyBatis的运行原理。","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"}]},{"title":"mysql配置","slug":"Linux/mysql配置","date":"2019-06-20T14:35:59.000Z","updated":"2019-07-11T06:34:42.827Z","comments":true,"path":"2019/06/20/Linux/mysql配置/","link":"","permalink":"http://yoursite.com/2019/06/20/Linux/mysql配置/","excerpt":"","text":"mysql配置配置远程1.查看表 12345678use mysql;select host,user from user; host | user |+-----------+-----------+| % | root || localhost | mysql.sys || localhost | root | host是主机，root表示主机可以登录的用户，%表示所有主机，但不包括localhost 2.如果没有%,root 12grant all privileges on 库名.表名 to &apos;用户名&apos;@&apos;IP地址&apos; identified by &apos;密码&apos; with grant option;flush privileges; 库名:要远程访问的数据库名称,所有的数据库使用“*”表名:要远程访问的数据库下的表的名称，所有的表使用“*”用户名:要赋给远程访问权限的用户名称IP地址:可以远程访问的电脑的IP地址，所有的地址使用“%” 3.如果配置所有ip可以远程登录root 1234567GRANT ALL PRIVILEGES ON *.* TO &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;123456&apos; WITH GRANT OPTION; 所有的地址都可以使用root用户，密码为123456远程访问所有的数据库和表GRANT ALL PRIVILEGES ON testdb.* TO &apos;lxh&apos;@&apos;172.16.52.225&apos; IDENTIFIED BY &apos;lxh&apos; WITH GRANT OPTION;IP为172.16.52.225的电脑可以使用lxh用户，密码为lxh远程访问数据库testdb的所有表 注意需要注意mysql的配置文件中的bindaddress 的参数和skip-networking 配置 bindaddress : 设定哪些ip地址被配置，使得mysql服务器只回应哪些ip地址的请求),最好注释掉该参数或设置成为127.0.0.1以外的值 skip-networking : 如果设置了该参数项，将导致所有TCP/IP端口没有被监听,也就是说出了本机，其他客户端都无法用网络连接到本mysql服务器，所以应该注释掉该参数 修改密码遇到的坑如果MySQL数据库用户的密码设置过于简单，数据库在用户登录后会提示重置密码，并且不接受简单的密码。 提示需要重置密码： ERROR 1820 (HY000): You must reset your password using ALTER USER statement before executing this statement. 1ALTER USER USER() IDENTIFIED BY &apos;123456&apos;; 以上操作后又遇到新问题：ERROR 1819 (HY000): Your password does NOT satisfy the CURRENT policy requirements。 先设置复杂密码 alter user user() identified by “Aa123456”; flush privileges; 使用以下两个设置简单密码 set global validate_password_policy=0; set global validate_password_length=1; 再设置简单密码 alter user user() identified by “123456”; flush privileges;","categories":[],"tags":[]},{"title":"hostname和hosts的区别","slug":"Linux/hostname和etchosts的区别","date":"2019-06-20T06:43:59.000Z","updated":"2019-07-16T07:44:29.011Z","comments":true,"path":"2019/06/20/Linux/hostname和etchosts的区别/","link":"","permalink":"http://yoursite.com/2019/06/20/Linux/hostname和etchosts的区别/","excerpt":"","text":"很多人一提到更改hostname首先就想到修改/etc/hosts文件，认为hostname的配置文件就是/etc/hosts。其实不是的。hosts文件的作用相当于DNS，提供IP地址hostname的对应。早期的互联网计算机少，单机hosts文件里足够存放所有联网计算机。不过随着互联网的发展，这就远远不够了。于是就出现了分布式的DNS系统。由DNS服务器来提供类似的IP地址到域名的对应。Linux系统在向DNS服务器发出域名解析请求之前会查询/etc/hosts文件，如果里面有相应的记录，就会使用hosts里面的记录。由此，/etc/hosts于设置hostname是没直接关系的，仅仅当你要在本机上用新的hostname来映射自己的IP时候才会用到/etc/hosts文件。两者没有必然的联系。redhat的hostname的配置文件是/etc/sysconfig/network. /etc/hosts内容摘录如下： #Do not remove the following line, or various programs #that require network functionality will fail. 192.168.1.102 localhost.localdomain localhost127.0.0.1 localhost.localdomain localhost::1 localhost6.localdomain6 localhost6对以上内容的解释作用：hosts 文件是用来把主机名字映射到IP地址的方法，这种方法比较简单。但这种映射只是本地映射，也就是说每台机器都是独立的，所有的计算机都不能相互通过hostname来访问。格式： 一般情况下hosts的内容关于主机名(hostname)的定义，每行为一个主机，每行由三部份组成，每个部份由空格隔开。其中#号开头的行做说明，不被系统解释。 第一部份：网络IP地址； 第二部份：主机名.域名，注意主机名和域名之间有个半角的点，比如 localhost.localdomain 第二部份：主机名(主机名别名） ，其实就是主机名；注释：1）127.0.0.1 是回环地址，比如我们不想让局域网的其它机器看到我们测试的网络程序，就可以用回环地址来测试。2）为什么需要定义域名呢？其实理解也简单，比如我们有三台主机，每台做不同的事，一台做MAIL服务器，一台做FTP服务器，一台做SMB服务器，所以我们就可以这样来设计hostname； 127.0.0.1 localhost.localdomain localhost 192.168.1.2 ftp 192.168.1.3 mail.localdomain mail 192.168.1.4 smb.localdomin smb把这上面这个配置文件的内容分别写入每台机器的/etc/hosts内容中，这样这三台局域网的机器就可以通过hostname来访问了。也就是，在局域网中，主机名也是可以解析到IP上的，相当于DNS域名解析。对于主机名的修改有两种方式:hostname和/etc/sysconfig/network [sql] view plaincopyprint?[root@think ~]# hostnamethin[root@think ~]# hostname think[root@think ~]# hostnamethink 通过hostname 这个kernel变量来设置主机名只是临时的，下次重启系统时，此主机名将不会存在.hostname也可用于显示:hostname -i。如果要永久修改RedHat hostname，就修改/etc/sysconfig/network文件，将里面的HOSTNAME这一行修改成HOSTNAME=NEWNAME，其中NEWNAME就是你要设置的hostname。 2./hosts文件可以帮助解决哪些问题2.1 远程登录linux主机过慢问题 有时客户端想远程登录一台linux主机，但每次登录输入密码后都会等很长一段时间才会进入，这是因为linux主机在返回信息时需要解析ip，如果在linux主机的hosts文件事先加入客户端的ip地址，这时再从客户端远程登录linux就会变很快。 注：这里所说的远程登录不仅仅是ssh，还可能是mysql远程登录，或是文件共享的查询等。 2.2 双机互连 当两台主机只是双机互连时，这时两台主机都需要设置自己的ip，同时在对方的hosts文件里加入自己的ip和主机名。 注：不同发行版的主机名称对应文件可以通过man host那么进行查阅 3.关于FQDN FQDN：(Fully Qualified Domain Name)完全合格域名/全称域名，是指主机名加上全路径，全路径中列出了序列中所有域成员。全域名可以从逻辑上准确地表示出主机在什么地方，也可以说全域名是主机名的一种完全表示形式。从全域名中包含的信息可以看出主机在域名树中的位置。DNS解析流程：首先查找本机HOSTS表，有的直接使用表中定义，没有查找网络连接中设置的DNS 服务器由他来解析。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"jdbc中的execute()返回值","slug":"JDBC/jdbc中的execute()返回值","date":"2019-06-20T05:54:47.000Z","updated":"2019-06-22T06:51:51.725Z","comments":true,"path":"2019/06/20/JDBC/jdbc中的execute()返回值/","link":"","permalink":"http://yoursite.com/2019/06/20/JDBC/jdbc中的execute()返回值/","excerpt":"","text":"jdbc中的execute()返回值表示不同的操作 true表示查询 false表示更新或者删除","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"}]},{"title":"centos7配置dhcp和静态Ip","slug":"Linux/centos7配置DHCP和静态IP","date":"2019-06-20T05:19:59.000Z","updated":"2019-07-16T07:44:13.040Z","comments":true,"path":"2019/06/20/Linux/centos7配置DHCP和静态IP/","link":"","permalink":"http://yoursite.com/2019/06/20/Linux/centos7配置DHCP和静态IP/","excerpt":"","text":"vi ifcfg-eth0 TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=static DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=eth0 UUID=85a5000d-dbaa-4a2a-8075-0df5562bf331 DEVICE=eth0 ONBOOT=yes IPADDR=192.168.1.166 NETMASK=255.255.255.0 GATEWAY=192.168.1.1 DNS1=8.8.8.8 DNS2=114.114.114.114 DNS3=223.6.6.6 1.静态IPBOOTPROTO=static #设置static IPADDR=192.168.1.166 #静态ip NETMASK=255.255.255.0 #子网掩码 GATEWAY=192.168.1.1 #网关 2.DHCP​ 12345BOOTPROTO=dhcp #设置dhcp#注释掉配置的静态ip部分#IPADDR=192.168.1.166 #NETMASK=255.255.255.0#GATEWAY=192.168.1.1 配置完成后重启网络 systemctl restart network","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"centos7安装缺少命令","slug":"Linux/安装centos7缺少命令问题","date":"2019-06-20T05:19:59.000Z","updated":"2019-07-16T07:45:09.684Z","comments":true,"path":"2019/06/20/Linux/安装centos7缺少命令问题/","link":"","permalink":"http://yoursite.com/2019/06/20/Linux/安装centos7缺少命令问题/","excerpt":"","text":"没有 ifconfig 、netstat命令： 1yum install -y net-tools 没有命令补全，tab补全命令： 1yum install -y bash-completion 没有killall命令： 1yum install -y psmisc","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"centos7修改网卡名","slug":"Linux/centos7修改网卡名","date":"2019-06-20T03:26:31.000Z","updated":"2019-06-20T05:14:57.104Z","comments":true,"path":"2019/06/20/Linux/centos7修改网卡名/","link":"","permalink":"http://yoursite.com/2019/06/20/Linux/centos7修改网卡名/","excerpt":"","text":"用ifconfig查看网卡名称为ens33，现在要将它修改成eth0 1)编辑配置文件/etc/sysconfig/network-scripts/ifcfg-ens33 将DEVICE=ens33修改成DEVICE=eth0 将NAME=ens33修改成NAME=eth0 保存并退出 2)重命名该配置文件。 [root@remote network-scripts]# cd /etc/sysconfig/network-scripts/ [root@remote network-scripts]# mv ifcfg-ens33 ifcfg-eth0 3)编辑/etc/default/grub并加入“net.ifnames=0 biosdevname=0 ” 示例:GRUB_CMDLINE_LINUX=”crashkernel=auto net.ifnames=0 biosdevname=0 rhgb quiet” 保存并退出 4)运行命令grub2-mkconfig -o /boot/grub2/grub.cfg 来重新生成GRUB配置并更新内核参数 5)使用reboot命令重启操作系统 注意:重启后查看ifcfg-eth0,dhcp可能被修改为static,如果没有配置静态ip网络会出错","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"数据库元数据MetaData","slug":"JDBC/数据库元数据MetaDate","date":"2019-06-19T01:19:47.000Z","updated":"2019-06-22T06:52:17.759Z","comments":true,"path":"2019/06/19/JDBC/数据库元数据MetaDate/","link":"","permalink":"http://yoursite.com/2019/06/19/JDBC/数据库元数据MetaDate/","excerpt":"","text":"本篇介绍数据库方面的元数据（MetaData）的有关知识。元数据在建立框架和架构方面是特别重要的知识，再下一篇我们仿造开源数据库工具类DbUtils就要使用数据库的元数据来创建自定义JDBC框架。 在我们前面使用JDBC来处理数据库的接口主要有三个，即Connection，PreparedStatement和ResultSet这三个，而对于这三个接口，还可以获取不同类型的元数据，通过这些元数据类获得一些数据库的信息。 元数据(MetaData)，即定义数据的数据。打个比方，就好像我们要想搜索一首歌(歌本身是数据)，而我们可以通过歌名，作者，专辑等信息来搜索，那么这些歌名，作者，专辑等等就是这首歌的元数据。因此数据库的元数据就是一些注明数据库信息的数据。 ① 由Connection对象的getMetaData()方法获取的是DatabaseMetaData对象。 ② 由PreparedStatement对象的getParameterMetaData ()方法获取的是ParameterMetaData对象。 ③由ResultSet对象的getMetaData()方法获取的是ResultSetMetaData对象。 一、DatabaseMetaDataDatabaseMetaData是由Connection对象通过getMetaData方法获取而来，主要封装了是对数据库本身的一些整体综合信息，例如数据库的产品名称，数据库的版本号，数据库的URL，是否支持事务等等，能获取的信息比较多，具体可以参考DatabaseMetaData的API文档。 以下有一些关于DatabaseMetaData的常用方法： ·getDatabaseProductName：获取数据库的产品名称 ·getDatabaseProductName：获取数据库的版本号 ·getUserName：获取数据库的用户名 ·getURL：获取数据库连接的URL ·getDriverName：获取数据库的驱动名称 ·driverVersion：获取数据库的驱动版本号 ·isReadOnly：查看数据库是否只允许读操作 ·supportsTransactions：查看数据库是否支持事务 例1： 简单地获取一些常用的数据库综合信息。 二、ParameterMetaData ParameterMetaData是由PreparedStatement对象通过getParameterMetaData方法获取而来，主要是针对PreparedStatement对象和其预编译的SQL命令语句提供一些信息，比如像”insert into account(id,name,money) values(?,?,?)”这样的预编译SQL语句，ParameterMetaData能提供占位符参数的个数，获取指定位置占位符的SQL类型等等，功能也比较多，这里不列举完，详细请看有关ParameterMetaData的API文档。 以下有一些关于ParameterMetaData的常用方法： ·getParameterCount：获取预编译SQL语句中占位符参数的个数 在我看来，ParameterMetaData对象能用的只有获取参数个数的getParameterCount()方法。 注意：ParameterMetaData许多方法MySQL并不友好支持，比如像获取指定参数的SQL类型的getParameterType方法，如果数据库驱动连接URL只是简单的“jdbc:mysql://localhost:3306/jdbcdemo”那么MyEclipse会抛出SQLException异常，必须要将URL修改为“jdbc:mysql://localhost:3306/jdbcdemo?generateSimpleParameterMetadata=true”才行。但是像getParameterType等等与其他的方法也没多好用，因为如下面的例子，这些方法好像只会将所有的参数认为是字符串(VARCHAR)类型。 因为我们的SQL语句为”insert into user(id,name,age) values(?,?,?)”，而我们所有利用ParameterMetaData查询的信息除了参数个数以外，都是查询第一个参数的信息，也就是“id”列，而这个“id”列我们创建时是int整型的，但是利用ParameterMetaData的查询结果都是显示为字符串类型，因此我对ParameterMetaData的功能产生了怀疑。 因此在以后使用参数元数据ParameterMetaData尽量只要使用其getParamterCount()方法获取参数个数，对于该对象其他方法请慎用。 三、ResultSetMetaData ResultSetMetaData是由ResultSet对象通过getMetaData方法获取而来，主要是针对由数据库执行的SQL脚本命令获取的结果集对象ResultSet中提供的一些信息，比如结果集中的列数、指定列的名称、指定列的SQL类型等等，可以说这个是对于框架来说非常重要的一个对象。关于该结果集元数据对象的其他具体功能和方法请查阅有关ResultSetMetaData的API文档。 以下有一些关于ResultSetMetaData的常用方法： ·getColumnCount：获取结果集中列项目的个数 ·getColumnType：获取指定列的SQL类型对应于Java中Types类的字段 ·getColumnTypeName：获取指定列的SQL类型 ·getClassName：获取指定列SQL类型对应于Java中的类型(包名加类名)","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"JDBC操作数据库","slug":"JDBC/JDBC操作数据库","date":"2019-06-17T14:35:47.000Z","updated":"2019-06-22T06:51:44.412Z","comments":true,"path":"2019/06/17/JDBC/JDBC操作数据库/","link":"","permalink":"http://yoursite.com/2019/06/17/JDBC/JDBC操作数据库/","excerpt":"","text":"","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"}]},{"title":"mysql注释的三种写法","slug":"JDBC/mysql注释的三种写法","date":"2019-06-17T08:07:47.000Z","updated":"2019-06-22T06:52:09.230Z","comments":true,"path":"2019/06/17/JDBC/mysql注释的三种写法/","link":"","permalink":"http://yoursite.com/2019/06/17/JDBC/mysql注释的三种写法/","excerpt":"","text":"MySql--三种注释写法 需要特别注意 -- 这种注释后面要加一个空格 #DELETE FROM SeatInformation /DELETE FROM SeatInformation /– DELETE FROM SeatInformation","categories":[{"name":"database","slug":"database","permalink":"http://yoursite.com/categories/database/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"properties文件的读取","slug":"Java Web/properties文件的读取","date":"2019-06-17T02:00:38.000Z","updated":"2019-06-17T02:06:02.317Z","comments":true,"path":"2019/06/17/Java Web/properties文件的读取/","link":"","permalink":"http://yoursite.com/2019/06/17/Java Web/properties文件的读取/","excerpt":"","text":"Java 开发中，需要将一些易变的配置参数放置再 XML 配置文件或者 properties 配置文件中。然而 XML 配置文件需要通过 DOM 或 SAX 方式解析，而读取 properties 配置文件就比较容易。 读取方式1、基于ClassLoder读取配置文件 ​ 注意：该方式只能读取类路径下的配置文件，有局限但是如果配置文件在类路径下比较方便。 2、基于 InputStream 读取配置文件 ​ 注意：该方式的优点在于可以读取任意路径下的配置文件 代码实现db.properties 12user=rootpwd=123 123456789101112131415161718192021222324252627282930313233343536package jdbc.com.szxy.properties;import java.io.File;import java.io.FileInputStream;import java.io.InputStream;import java.util.Properties;/** * 读取properties文件测试 * @author Momentonly */public class ProPertiesTest &#123; public static void main(String[] args) throws Exception &#123; /** * 基于ClassLoder读取配置文件 */ Properties pro1 = new Properties(); //获取资源的输入流,类路径下 InputStream is1 = ProPertiesTest.class.getClassLoader().getResourceAsStream(\"db.properties\"); //读取输入流 pro1.load(is1); // System.out.println(pro1.getProperty(\"user\")); System.out.println(pro1.getProperty(\"pwd\")); /** * 基于 InputStream 读取配置文件 */ Properties pro2 = new Properties(); //获取资源的输入流，相对路径或者绝对路径 InputStream is2 = new FileInputStream(new File(\"src/db.properties\")); pro2.load(is2); System.out.println(pro2.getProperty(\"user\")); System.out.println(pro2.getProperty(\"pwd\")); &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"Linux常用命令2","slug":"Linux/Linux常用命令2","date":"2019-06-16T08:56:55.000Z","updated":"2019-06-20T05:52:21.887Z","comments":true,"path":"2019/06/16/Linux/Linux常用命令2/","link":"","permalink":"http://yoursite.com/2019/06/16/Linux/Linux常用命令2/","excerpt":"","text":"1.scp -r root@39.104.111.122:/usr/local/ /usr/local ​ 将远程39.104.111.122的/usr/local下的文件拷贝到本机/usr/local目录下 ​ -r 复制目录 2.scp -r /usr/local root@39.104.111.122:/usr/local/ ​ 上传本地/usr/local目录到远程39.104.111.122的/usr/local目录 3.du -sh : 查看当前目录总共占的容量。而不单独列出各子项占用的容量 4.du -sh file:查看指定文件的大小 5.userdel -r 用户名 删除一个用户 6.passwd 用户名 修改密码 7.finger 查看登录的终端 8.last 用户名 查看登录记录 9.w -s 查看登录的终端用户 10.ls -lharts 查看文件详细信息 11.pwd 查看当前的路径 12.pgrep 进程名 查看进程的pid 13.ps -ef|grep 进程名 查看进程的pid 14.killall -9 bash 杀掉所有登录的bash 注:killall [参数][进程名] 用来杀掉同名的所有进程","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"手写服务器总结","slug":"Java Web/手写服务器总结","date":"2019-06-16T07:23:02.000Z","updated":"2019-06-16T14:16:50.731Z","comments":true,"path":"2019/06/16/Java Web/手写服务器总结/","link":"","permalink":"http://yoursite.com/2019/06/16/Java Web/手写服务器总结/","excerpt":"","text":"手写服务器总结搭建框架​ ………………… 实现编写web.xml123456789101112&lt;!--servlet处理请求--&gt;&lt;servlet&gt; &lt;!--LoginServlet别名:login --&gt; &lt;servlet-name&gt;login&lt;/servlet-name&gt; &lt;servlet-class&gt;com.szxy.httpserver.servlet.LoginServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!--浏览器的请求路径--&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;login&lt;/servlet-name&gt; &lt;url-pattern&gt;/login&lt;/url-pattern&gt; &lt;url-pattern&gt;/log&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; ​ 实体类保存解析xml中的信息 ​ Entity类:servlet-name,servlet-class ​ Mapping类:servlet-name,url-pattern 解析xmldom4j解析xml​ Entity:servlet-name,servlet-class ​ Entity通过String name，String clazz两个成员变量保存web.xml中的\\servlet-name,servlet-class ​ Mapping:servlet-name,url-pattern， ​ Mapping通过String name，和List urlPattern集合两个成员变量保存web.xml中的\\servlet-name,url-pattern， ServletContext类​ 上下文，是一个容器，描述Entity与Mapping之间的关系 该类的成员变量 12private Map&lt;String, String&gt; servlet; //key是servlet-name,value是servlet-classprivate Map&lt;String, String&gt; mapping; //key是url-pattern,value是servlet-name WebApp类​ 1）将Entity和Mapping中的servlet-name,servlet-class,url-pattern,servlet-name ​ 保存到ServletContext类的成员变量中。 ​ 请求路径作为key,获取servlet-name值，获取servlet-name ​ servlet-name作为key,获取servlet的 全路径名(包名+类名) ​ 1） 反射创建Servlet ​ 可以通过全路径名反射创建Servlet对象 1234567//根据url的key获取servlet-name的值 String servletName = context.getMapping().get(url);//根据servlet-name得到对应的servlet-class String servletClass = context.getServlet().get(servletName); //完整的包名和类名//使用反射创建Servlet对象 Class&lt;?&gt; clazz = Class.forName(servletClass); servlet = (Servlet) clazz.newInstance(); servlet建立抽象类Servlet12345678public abstract class Servlet &#123; public void service(Request req, Response rep)throws Exception&#123; this.doGet(req, rep); this.doPost(req, rep); &#125; public abstract void doGet(Request req, Response rep) throws Exception; public abstract void doPost(Request req, Response rep) throws Exception;&#125; 处理请求的Servlet继承Servlet例：登录LoginServlet 12345678910111213141516171819202122public class LoginServlet extends Servlet&#123;@Overridepublic void doGet(Request req, Response rep) throws Exception &#123; // TODO Auto-generated method stub //获取请求参数 String name = req.getParater(\"username\"); String pwd = req.getParater(\"pwd\"); if(\"bjsxt\".equals(name) &amp;&amp; \"123\".equals(pwd))&#123; //调用响应中的print方法 rep.println(name + \"登录成功\"); &#125;else&#123; rep.println(\"账号或者密码不正确\"); &#125; &#125;@Overridepublic void doPost(Request req, Response rep) throws Exception &#123; // TODO Auto-generated method stub &#125;&#125; 封装Request对象(浏览器的请求)​ 通过输入流获取浏览器的请求信息，然后根据HTTP协议，进行请求信息的处理 从请求信息中获取请求方式，路径，参数， 例：GET请求和POST请求的信息 1234567891011121314151617181920212223GET /log?username=bj&amp;pwd=123&amp;hobby=ball HTTP/1.1Host: localhost:8888Connection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.90 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9POST /log HTTP/1.1Host: localhost:8888Connection: keep-aliveContent-Length: 30Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Origin: nullContent-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.90 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9username=bj&amp;pwd=123&amp;hobby=ball 请求参数的乱码问题 处理中文，因为浏览器对中文进行了编码，因此需要解码服务器端获取到发过来的请求参数默认使用ISO8859-1进行解码操作，中文一定有乱码问题 12//value是请求参数，code是编码return URLDecoder.decode(value, code);//decode(keyValues[1].trim(), &quot;utf-8&quot;) 封装Response对象(服务器的响应)1.严格根据HTTP协议封装响应信息 123456789//响应头//协议，状态码，描述headInfo.append(&quot;HTTP1.1&quot;).append(BLANK).append(code).append(BLANK).append(&quot;&quot;);headInfo.append(CRLF);headInfo.append(&quot;Content-Type:text/html;charset=utf-8&quot;).append(CRLF);headInfo.append(&quot;Content-Length:&quot;+length).append(CRLF);headInfo.append(CRLF);//响应正文content.append(“&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;登录响应&lt;/title&gt;&lt;/head&gt;&lt;body&gt;登录成功&lt;/body&gt;&lt;/html&gt;”).append(CRLF); 2.响应正文可以调用Response类中的println(String info)进行设置 ​ content.append(info).append(CRLF); 封装分发器Dispatcher​ Dispatcher是一个请求与响应,并实现了Runnable接口 ​ 通过客户端连接的对象client,初始化Request和Response对象 12req = new Request(client.getInputStream());rep = new Response(client.getOutputStream()); run()方法实现 1.根据请求信息获取路径， 2.根据路径通过反射创建servlet 3.调用servlet的service()方法处理请求 4.rep.pushToClient(code);//响应，将封装后的Response信息发送给客户端 12345678910111213141516171819public void run() &#123; // TODO Auto-generated method stub //根据不同的url创建指定的servlet对象 Servlet servlet = WebApp.getServlet(req.getUrl()); if(servlet == null)&#123; this.code = 404; //路径找不到 &#125;else&#123; //调用service方法 try &#123; servlet.service(req, rep); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); this.code = 500; &#125; &#125; rep.pushToClient(code); IOCloseUtil.closeAll(client); &#125; ServerSocket服务器​ 创建一个ServelSocket对象，监听8888端口 1server = new ServerSocket(port); ​ 循环接收客户端请求，接收到请求，创建一个线程代理Dispatcher对象处理请求 12345678while(!isShutDown)&#123; //1)监听 Socket client = server.accept(); //创建线程类的对象 Dispatcher dis = new Dispatcher(client); //创建代理，启动线程 new Thread(dis).start();&#125; 解决浏览器请求的icon该请求是浏览器默认发送的:http://localhost:8888/favicon.ico 解决： ​ 1.在web.xml中配置路径 12345678&lt;servlet&gt; &lt;servlet-name&gt;favicon&lt;/servlet-name&gt; &lt;servlet-class&gt;com.szxy.httpserver.servlet.FaviconServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;favicon&lt;/servlet-name&gt; &lt;url-pattern&gt;/favicon.ico&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 2.创建FaviconServlet类继承Servlet ​","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"sublime的package control","slug":"Config/sublime的package control","date":"2019-06-15T07:13:46.000Z","updated":"2019-07-08T06:53:06.768Z","comments":true,"path":"2019/06/15/Config/sublime的package control/","link":"","permalink":"http://yoursite.com/2019/06/15/Config/sublime的package control/","excerpt":"","text":"sublime的package control​ preferences-&gt;package control出现There are no packages available for installation错误 据说是IPv6的原因，如果我们的Intent服务提供者（ISP）不支持IPv6就会引发上述错误，原文如下：This error is happened with IPv6 problem. If your Internet Service Provider (ISP) does not support for IPv6 you got this error. 从上面的描述可以知道首先需要获取sublime.wbond.net网站的IPv4地址，然后修改hosts文件就行了。 C:\\Windows\\System32\\drivers\\etc 修改hosts 50.116.34.243 sublime.wbond.net 50.116.34.243 packagecontrol.io Package control的install packageSublime包管理package control 打开install package报错 There are no packages available for installation 本地下载一个channel_v3.json文件:https://github.com/SuCicada/channel_v3.json 放入本地任意目录，然后打开sublime中的Preferences-&gt;package settings-&gt;package control-&gt;settings user 配置 “channels”: [ “H:\\SoftwarePro\\Sublime Text 3\\channel_v3.json” ], 保存重启","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"sublime","slug":"sublime","permalink":"http://yoursite.com/tags/sublime/"}]},{"title":"ThreadLocal的使用","slug":"JavaSE/ThreadLocal的使用","date":"2019-06-13T09:37:18.000Z","updated":"2019-06-22T07:02:46.818Z","comments":true,"path":"2019/06/13/JavaSE/ThreadLocal的使用/","link":"","permalink":"http://yoursite.com/2019/06/13/JavaSE/ThreadLocal的使用/","excerpt":"","text":"ThreadLocal的使用1.说明​ ThreadLocal 直译为“本地线程”，其实它就是一容器，用于 存放线程的局部变量 ​ 能够保持每一个线程里面的值是相应的，说明这些值已经达到了线程私有的目的。 ​ 当你在一个类中使用 static 成员变量时，一定要问自己这个 static 成员变量需要考虑“线程安全吗？” ​ （也就是说 多个线程需要自己独立的 static 成员变量吗？）如果需要那就需要使用 ThreadLocal。 ​ 作用:为解决多线程程序的并发问题 2.实现机制​ 首先获取当前线程，在获取当前线程的ThreadLocalMap ​ 每个Thread对象内部都维护了一个ThreadLocalMap这样一个ThreadLocal的Map，可以存放若干个 ThreadLocal。 123/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null; ​ 当我们在调用get()方法的时候，先获取当前线程，然后获取到当前线程的ThreadLocalMap对象，如果非空，那么取出ThreadLocal的value，否则进行初始化，初始化就是将initialValue的值set到ThreadLocal中。","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"}]},{"title":"Linux常用命令1","slug":"Linux/Linux常用命令1","date":"2019-06-12T05:51:55.000Z","updated":"2019-06-12T05:54:21.711Z","comments":true,"path":"2019/06/12/Linux/Linux常用命令1/","link":"","permalink":"http://yoursite.com/2019/06/12/Linux/Linux常用命令1/","excerpt":"","text":"文件 &amp; 目录操作（16 个） ls ● ls -a 查看所有文件，包含隐藏文件 ● ls -l 简写 ll，查看详细信息 ● ls -h 文件大小以易读的方式显示 cd ● cd ../ 返回上级目录 ● cd ~ 前往家目录 ● cd - 返回上一次所在目录 cp ● cp -r 复制目录及目录下文件 find ● find / -name ‘target’ 查询根目录下面文件名为 target 的文件 mkdir ● mkdir -p /tmp/test 递归创建目录 mv ● mv -f source destination 强制 pwd ● pwd 显示当前路径 rm ● rm -rf / 强制删除根目录及目录下的文件，就是我们通常所说的删库跑路 touch ● touch target 创建 target 文件，若文件存在则改变文件时间戳 tree ● tree 功能是以树形结构显示目录下的内容 basename ● basename /tmp/1 显示文件名 dirname ● dirname /tmp/1 显示路径 chattr ● chattr +i /tmp/1 加 i 属性，防止文件被修改 lsattr ● lsattr /tmp/1 查看文件的扩展属性 file ● file /tmp/1 显示文件类型 md5 ● md5 /tmp/1 显示文件 MD5 值 查看文件 &amp; 内容处理（18 个） cat ● cat -n 显示行号 ● cat file1 file2 打开文件 1 和 2 more ● more file1 逐页显示 less ● less file1 也是逐页显示，与 more 方向相反 head ● head -n file 显示文件头 n 行 tail ● tail -n file 显示文件尾 n 行 ● tailf file 实时显示文件尾 10 行，常用于跟踪日志信息 cut ● who|cut -b 1-3,5 输出每行的 1 至 3 个字节和第 5 个字节 ● who|cut -c -3 输出每行的 1 至 3 个字符 ● who|cut -c 3- 输出每行的第 3 个字符到行尾 ● who|cut -d ‘ ‘ -f 1 以空格为分隔符，输出第一个域 split ● split -b 10k date.file 将文件分割为 10k 的多个子文件 ● split -b 10k date.file split_file 指定子文件前缀为 split_file paste ● psate file1 file2 file3 将 3 个文件按列合并 sort ● sort -n 按照数值大小排序 ● sort -r 倒序排序 ● sort -t 指定分隔符 ● sort -u 忽略相同行 uniq ● uniq -c 显示出现次数，只有相邻的才算重复 ● uniq -d 只显示重复的行 ● unqi -u 只显示不重复的行 wc ● wc -l 显示列数 diff ● diff file1 file2 比较两个文件差异 rev ● rev file 反向输出文件内容 grep ● grep ‘target’ file 过滤输出文件中包含 target 的行 ● grep -v ‘target’ file 过滤输出文件中不包含 target 的行 ● grep -c ‘target’ file 过滤输出文件中包含 target 的行数 ● grep -i ‘target’ file 忽略大小写 ● egrep ‘[1-9]|a’ file 过滤输出正则匹配到的行 ● seq 10 | grep “5” -A 3 显示匹配某个结果之后的 3 行 ● seq 10 | grep “5” -B 3 显示匹配某个结果之前的 3 行 ● seq 10 | grep “5” -C 3 显示匹配某个结果的前三行和后三行 join ● join file1 file2 将两个文件中，指定栏位内容相同的行连接起来 tr ● cat text | tr ‘\\t’ ‘ ‘ 将制表符替换成空格 vim 三种模式： ● 编辑模式（命令模式） ● 输入模式 ● 末行模式 模式的转换 编辑 -&gt; 输入 i: 在当前光标所在字符的前面，转为输入模式； a: 在当前光标所在字符的后面，转为输入模式； o: 在当前光标所在行的下方，新建一行，并转为输入模式； I：在当前光标所在行的行首，转换为输入模式 A：在当前光标所在行的行尾，转换为输入模式 O：在当前光标所在行的上方，新建一行，并转为输入模式； 输入 -&gt; 编辑 ESC 编辑 -&gt; 末行： : 末行 -&gt; 编辑： ESC,ESC 打开文件 vim +# :打开文件，并定位于第#行 vim +：打开文件，定位至最后一行 vim +/PATTERN : 打开文件，定位至第一次被PATTERN匹配到的行的行首 关闭文件 :q 退出 :wq 保存并退出 :q! 不保存并退出 :w 保存 :w! 强行保存 移动光标（编辑模式） 逐字符移动 h: 左 l: 右 j: 下 k: 上 #h: 移动#个字符 以单词为单位移动 w: 移至下一个单词的词首 e: 跳至当前或下一个单词的词尾 b: 跳至当前或前一个单词的词首 #w: 移动#个单词 行内跳转 0: 绝对行首 ^: 行首的第一个非空白字符 $: 绝对行尾 行间跳转 #G：跳转至第#行 gg: 第一行 G：最后一行 翻屏 Ctrl+f: 向下翻一屏 Ctrl+b: 向上翻一屏 Ctrl+d: 向下翻半屏 Ctrl+u: 向上翻半屏 删除单个字符 x: 删除光标所在处的单个字符 #x: 删除光标所在处及向后的共#个字符 删除命令: d dd: 删除当前光标所在行 #dd: 删除包括当前光标所在行在内的#行； 撤消编辑操作 u：撤消前一次的编辑操作 #u: 直接撤消最近#次编辑操作 连续u命令可撤消此前的n次编辑操作 撤消最近一次撤消操作：Ctrl+r 查找 /PATTERN ?PATTERN n 下一个 N 上一个 文件压缩 &amp; 解压缩（3 个） tar ● tar zxvf FileName.tar.gz 解压 ● tar zcvf FileName.tar.gz DirName 压缩 zip ● zip -r html.zip/home/html 递归压缩 unzip ● unzip test.zip -d /tmp 解压到指定目录下 信息显示（11 个） uname ● uname -a 显示系统全部信息 hostname ● hostname 显示主机名 dmesg ● dmesg 显示开机信息 uptime ● uptime 显示系统运行时间及负载 stat ● stat 显示文件的状态信息 du ● du -sh 显示路径下所有文件大小 ● du -sh local 显示路径下 local 目录文件大小 ● du -sh * 显示路径下所有目录文件大小 df ● df -h 显示系统磁盘空间的使用情况 top ● top 实时显示系统资源使用情况 free ● free -m 以 M 为单位查看系统内存 date ● date +”%Y-%m-%d” 2019-05-28 ● date -d “1 day ago” +”% Y-% m-% d” 输出昨天日期 ● date -d “+1 day” +% Y% m% d 显示前一天的日期 ● date -d “-1 day” +% Y% m% d 显示后一天的日期 ● date -d “-1 month” +% Y% m% d 显示上一月的日期 ● date -d “+1 month” +% Y% m% d 显示下一月的日期 ● date -d “-1 year” +% Y% m% d 显示前一年的日期 ● date -d “+1 year” +% Y% m% d 显示下一年的日期 cal ● cal 日历信息 搜索文件（4 个） which ● which pwd 显示命令路径 find ● find /-name ‘target’ 查询根目录下面文件名为 target 的文件 whereis ● whereis php 查找二进制命令 locate ● locate target 从数据库 (/var/lib/mlocate/mlocate.db) 查找目标文件，使用 updatedb 更新库 进程管理（11 个） jobs ● jobs 查看当前有多少在后台运行的命令 bg ● bg 1 将一个在后台暂停的命令，继续执行，1 为作业号 ● （ctrl+z）可以挂起程序，返回作业号 fg ● fg 1 将后台中的命令调至前台继续运行 ，1 为作业号 kill ● kill 进程号 杀进程 ● kill -9 进程号 强杀进程 ● killall ● killall php 通过进程名字杀进程 ● killall -9 php 通过进程名字强杀进程 pkill ● 用法同上 crontab ● crontab -l 查看定时任务 ● crontab -e 编辑定时任务 ● crontab -l -u user1 查看 user1 定时任务，只有 root 才有权限 ● crontab -e -u user1 编辑 user1 定时任务，只有 root 才有权限 ps ● ps -ef 查看进程，显示 UID,PPIP,C 与 STIME，每个程序所使用的环境变量栏位 ● ps -axu 查看所有进程，并显示属于用户 pstree ● pstree -p 显示当前所有进程的进程号和进程 id 树 ● pstree -a 显示所有进程的所有详细信息树 nohup ● nohup command &amp; 退出账户时不挂断程序，仍在后台运行 pgrep ● pgrep -l httpd 查找 http 相关的进程号 用户管理（7 个） useradd ● useradd boy -u 888 建立一个新用户账户，并设置 ID ● useradd –g sales jack –G company,employees ● -g：加入主要组 -G：加入次要组 usermod ● usermod -G staff newuser2 将 newuser2 添加到组 staff 中 ● usermod -l newuser1 newuser 修改 newuser 的用户名为 newuser1 ● usermod -L newuser1 锁定账号 newuser1 ● usermod -U newuser1 解除对 newuser1 的锁定 userdel ● userdel -f user1 强制删除用户 ● userdel -r user1 删除用户的同时，删除与用户相关的所有文件 groupadd ● groupadd -g 1000 group1 建立一个新组，并设置组 ID 加入系统 passwd ● passwd user1 修改 user1 密码 ● passwd -l user1 锁住密码 ● passwd -d user1 删除密码 su ● su root 切换身份 sudo ● sudo command 已管理员身份运行命令 网络操作（11 个） telnet ● telnet 127.0.0.1 登录远程主机 ssh ● ssh root@127.0.0.1 -p22 登录远程主机 scp ● scp local_file remote_username@remote_ip:remote_folder 本地拷贝到远程 ● scp remote_username@remote_ip:remote_folder local_file 远程拷贝到本地 wget ● wget url 下载一个文件 ● wget –limit-rate=300k url 限速下载 ● wget -c url 断点续传 ● wget -b url 后台下载 ping ● ping www.baidu.com -c 2 收到两个包就结束 route ● route 显示当前路由 ifconfig ● ifconfig 查看、配置、启用或禁用网络接口 ifup ● ifup eth0 开启 eth0 网卡 ● ifdown ● ifdown eth0 关闭 eth0 网卡 netstat ● netstat -at 列出所有 tcp 端口 ● netstat -au 列出所有 udp 端口 ● netstat -l 只显示监听端口 ss ● ss -t -a 显示所有 tcp 链接 ● ss -l 显示处于监听状态的套接字 磁盘 &amp; 文件系统（7 个） mount ● mount /dev/hda1 /mnt 将 /dev/hda1 挂载到 /mnt 目录下 ● umount ● umount -v /mnt/mymount/ 卸载 /mnt/mymount/ fsck ● fsck -y /dev/hda2 检查并修复 Linux 文件系统 dumpe2fs ● dumpe2fs /dev/hda1 查看文件系统信息 dump ● ‍dump -0u -f /tmp/homeback.bak /home 将 /home 目录所有内容备份到 /tmp/homeback.bak 文件中，备份层级为 0 并在 /etc/dumpdates 中记录相关信息 fdisk ● fdisk /dev/sdb 输入 m 列出可以执行的命令 输入 p 列出磁盘目前的分区情况 输入 d 然后选择分区，删除现有分区 输入 print 查看分区情况，确认分区已经删除 输入 n 建立新的磁盘分区 输入 w 最后对分区操作进行保存 mkfs ● mkfs -t ext3 /dev/sda6 将 sda6 分区格式化为 ext3 格式 系统权限（3 个） chmod ● chmod 777 file1 修改 file1 文件权限为 777 ● chmod u+x,g+w file1 为 file1 设置自己可以执行，组员可以写入的权限 chown ● chown -R root /usr/meng 修改将目录 /usr/meng 及其下面的所有文件、子目录的文件主改成 root chgrp ● chgrp -R mengxin /usr/meng 将 /usr/meng 及其子目录下的所有文件的用户组改为 mengxin 关机重启（5 个） shutdown ● shutdown -h now 立即关机 ● shutdown +5 “System will shutdown after 5 minutes” 指定 5 分钟后关机，同时送出警告信息给登入用户 halt ● halt -p 关闭系统后关闭电源 ● halt -d 关闭系统，但不留下纪录 poweroff ● poweroff -f 强制关闭操作系统 logout ● logout 退出当前登录的 Shell exit ● exit 退出当前登录的 Shell 其他（6 个） echo ● echo ‘hello’ 打印字符串、变量 print ● printf ‘hell0’ 格式化输出字符串 rpm ● rpm -ivh your-package.rpm 安装 rpm 包 ● rpm -Uvh your-package.rpm 升级 rpm 包 ● rpm -e package 卸载 ● rpm -qa 列出所有安装过的包 ● rpm -ql 包名 rpm 包中的文件安装到那里去 yum ● yum install php 安装 php ● yum remove php 卸载 php clear ● clear 清屏 history ● history 10 最近使用的 10 条历史命令","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"c语言二维数组传递一维数组参数","slug":"C/c语言二维数组传递一维数组参数","date":"2019-06-09T07:46:09.000Z","updated":"2019-06-09T07:49:01.642Z","comments":true,"path":"2019/06/09/C/c语言二维数组传递一维数组参数/","link":"","permalink":"http://yoursite.com/2019/06/09/C/c语言二维数组传递一维数组参数/","excerpt":"","text":"123456789101112131415161718#include&lt;stdio.h&gt;void test(int a[]);int main()&#123; int a[2][2]; a[0][0] = 0; a[0][1] = 1; a[1][0] = 2; a[1][1] = 3; //printf(\"%d,%d,%d,%d\",a[0][0],a[0][1],a[1][0],a[1][1]); test(a[0]); //传递一维数组 test(a[1]); return 0;&#125;void test(int a[])&#123; printf(\"%d,%d\\n\",a[0],a[1]);&#125; 打印 : 0,1 ​ 2,3","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"IDEA的工作区间","slug":"Tools/IDEA的工作区间","date":"2019-06-05T15:09:08.000Z","updated":"2019-07-08T06:51:45.187Z","comments":true,"path":"2019/06/05/Tools/IDEA的工作区间/","link":"","permalink":"http://yoursite.com/2019/06/05/Tools/IDEA的工作区间/","excerpt":"","text":"IDEA中的项目概念与eclipse是不同的，IDEA的项目等同于eclipse中的workspace。Idea的module等同于eclipse中的project。所以我们要实现在一个项目倒入多个module。 具体操作如下： File–&gt;Project Structure Import Module，然后选中自己要导入的项目即可 作者：wzz87来源：CSDN原文：https://blog.csdn.net/wzz87/article/details/80234880版权声明：本文为博主原创文章，转载请附上博文链接！","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/tags/tools/"}]},{"title":"重启eclipse color theme失效的解决办法","slug":"Config/Eclipse主题重启失效","date":"2019-06-02T09:22:09.000Z","updated":"2019-07-08T06:53:36.362Z","comments":true,"path":"2019/06/02/Config/Eclipse主题重启失效/","link":"","permalink":"http://yoursite.com/2019/06/02/Config/Eclipse主题重启失效/","excerpt":"","text":"重启eclipse color theme失效的解决办法** 1、在eclipse菜单栏 选择 windows &gt; Perferences； 2、找到Oomph &gt; Setup Task &gt; Perference Recorder选项； 3、将上方的Record Into勾选上，点恢复默认值(Restore Defaults)再应用(apply)-确定(Ok) 4.重启Eclipse主题生效 注：Perference Recorder可以同步Eclipse的配置参数","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"eclipse","slug":"eclipse","permalink":"http://yoursite.com/tags/eclipse/"}]},{"title":"C中的void与void*类型","slug":"C/C中的oid类型与void指针类型","date":"2019-04-24T00:38:14.000Z","updated":"2019-04-24T00:48:20.093Z","comments":true,"path":"2019/04/24/C/C中的oid类型与void指针类型/","link":"","permalink":"http://yoursite.com/2019/04/24/C/C中的oid类型与void指针类型/","excerpt":"","text":"c中的void表示不确定类型1.void类型​ int main(void)表示不可传递参数 ​ void类型不能定义变量 2. void*类型​ void*类型可与任意类型进行强制转换 1234int* p = NULL;*p = 10;void* v = (void *)p; //将int*类型的p强制转换为void*类型int k = *(int *)v; //将void*类型的v强制转换为int*类型 注：void类型强转后的类型需要与原来的类型保持一致*","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Java中serialVersionUID的解释及两种生成方式的区别","slug":"JavaSE/Java中serialVersionUID的解释及两种生成方式的区别","date":"2019-04-07T15:26:33.000Z","updated":"2019-06-22T07:02:25.250Z","comments":true,"path":"2019/04/07/JavaSE/Java中serialVersionUID的解释及两种生成方式的区别/","link":"","permalink":"http://yoursite.com/2019/04/07/JavaSE/Java中serialVersionUID的解释及两种生成方式的区别/","excerpt":"","text":"serialVersionUID作用： 序列化时为了保持版本的兼容性，即在版本升级时反序列化仍保持对象的唯一性。有两种生成方式： 一个是默认的1L，比如：private static final long serialVersionUID = 1L; 一个是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段，比如： private static final long serialVersionUID = xxxxL;关于其定义，可参考JDK文档：http://download.oracle.com/javase/1.5.0/docs/api/java/io/Serializable.html 在Eclipse中，提供两种方式让我们快速添加SerialVersionUid。 add default serial version ID：Adds a default serial version ID to the selected typeUse this option to add a user-defined ID in combination with custom serialization code if the type did undergo structural change since its first release. add generated serial version ID：Adds a generated serial version ID to the selected typeUse this option to add a compiler-generated ID if the type didnot undergo structural change since its first release. 一种就是1L，一种是生成一个很大的数，这两种有什么区别呢？ 看上去，好像每个类的这个类不同，似乎这个SerialVersionUid在类之间有某种关联。其实不然，两种都可以，从JDK文档也看不出这一点。我们只要保证在同一个类中，不同版本根据兼容需要，是否更改SerialVersionUid即可。 对于第一种，需要了解哪些情况是可兼容的，哪些根本就不兼容。 参考文档：http://java.sun.com/j2se/1.4/pdf/serial-spec.pdf 在可兼容的前提下，可以保留旧版本号，如果不兼容，或者想让它不兼容，就手工递增版本号。 1-&gt;2-&gt;3….. 第二种方式，是根据类的结构产生的hash值。增减一个属性、方法等，都可能导致这个值产生变化。我想这种方式适用于这样的场景： 开发者认为每次修改类后就需要生成新的版本号，不想向下兼容，操作就是删除原有serialVesionUid声明语句，再自动生成一下。 个人认为，一般采用第一种就行了，简单。第二种能够保证每次更改类结构后改变版本号，但还是要手工去生成，并不是修改了类，会提示你要去更新这个SerialVersionUid，所以虽然看上去很cool，实际上让人很迷惑。 参考： 1.一篇较好的关于serialVesionUid的说明： http://www.mkyong.com/java-best-practices/understand-the-serialversionuid/","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"java类初始化顺序","slug":"JavaSE/Java类初始化顺序","date":"2019-03-13T09:20:20.000Z","updated":"2019-06-22T07:02:14.169Z","comments":true,"path":"2019/03/13/JavaSE/Java类初始化顺序/","link":"","permalink":"http://yoursite.com/2019/03/13/JavaSE/Java类初始化顺序/","excerpt":"","text":"Java的类初始化顺序 123456789101112131415161718192021222324252627282930313233343536373839404142package com.szxy;/** * * @author Administrator * */public class InitClassTest &#123; public static void main(String[] args) &#123; new B(); &#125;&#125;class A&#123; static A a = new A(); //1) static&#123; System.out.println(\"A:static\"); //2) &#125; C c = new C(); //5) &#123; //6) System.out.println(\"A:not static\"); &#125; public A() &#123; //7) System.out.println(\"A:constructor\"); &#125;&#125;class B extends A &#123; static&#123; System.out.println(\"B:static\"); //3) &#125; static B b = new B(); //4) &#123; //8) System.out.println(\"B:not static\"); &#125; public B() &#123; //9) System.out.println(\"B:constructor\"); &#125;&#125;class C&#123; public C() &#123; System.out.println(\"C\"); &#125;&#125; console打印 123456789101112131415C //1)A:not static //1)A:constructor //1)A:static //2)B:static //3)C //4)A:not static //4)A:constructor //4)B:not static //4)B:constructor //4)C //5)A:not static //6)A:constructor //7)B:not static //8)B:constructor //9) 根据打印结果：父类静态变量（静态代码块）-&gt; 子类静态变量（静态代码块） ​ -&gt; 父类成员变量（非静态代码块）-&gt; 父类构造方法 -&gt;子类成员变量（非静态代码块） ​ -&gt; 子类构造方法 ps：静态变量和静态代码块属于平级，谁在前谁先初始化； ​ 非静态代码块和成员变量属于平级，谁在前谁先初始化","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"性能测试工具locust","slug":"Python/性能测试工具locust","date":"2019-03-13T08:20:20.000Z","updated":"2019-06-22T06:49:27.911Z","comments":true,"path":"2019/03/13/Python/性能测试工具locust/","link":"","permalink":"http://yoursite.com/2019/03/13/Python/性能测试工具locust/","excerpt":"","text":"An open source load testing tool. 一个开源性能测试工具。 define user behaviour with python code, and swarm your system with millions of simultaneous users. 使用Python代码来定义用户行为。用它可以模拟百万计的并发用户访问你的系统。 1.安装Python2.安装Locustpip install locust 3.安装成功，CMD敲入命令验证。​ locust –help 4.创建load_test.py文件，通过Python编写性能测试脚本。123456789101112from locust import HttpLocust, TaskSet, taskclass UserBehavior(TaskSet): @task(1) def indesx(self): self.client.get(\"/\")class WebsiteUser(HttpLocust): task_set = UserBehavior min_wait = 3000 max_wait = 6000 创建UserBehavior()类继承TaskSet类，为用户行为类。 ​ 创建index() 方法表示一个行为。用@task() 装饰该方法为一个任务。1表示一个Locust实例被挑选执行的权重，数值越大，执行频率越高。在当前UserBehavior()行为下只有一个index()任务，所以，这里的权重设置为几，并无影响。 WebsiteUser()类用于设置性能测试。 task_set ：指向一个定义了的用户行为类。 min_wait ：用户执行任务之间等待时间的下界，单位：毫秒。 max_wait ：用户执行任务之间等待时间的上界，单位：毫秒。 5.命令行切换到性能测试脚本所在的目录，启动性能测试：1locust -f load_test.py --host=https://www.baidu.com ​ load_test.py 为测试脚本，https://www.baidu.com 为测试的网站。 ​ 打开浏览器访问：http://127.0.0.1:8089或者http://localhost:8089 ps:在pycharm中运行脚本 123if __name__ == '__main__':import osos.system(\"locust -f load_test.py --host=https://www.baidu.com\")","categories":[],"tags":[{"name":"python","slug":"python","permalink":"http://yoursite.com/tags/python/"}]},{"title":"java的Package","slug":"JavaSE/java的Package","date":"2019-03-03T04:35:23.000Z","updated":"2019-06-22T07:01:48.575Z","comments":true,"path":"2019/03/03/JavaSE/java的Package/","link":"","permalink":"http://yoursite.com/2019/03/03/JavaSE/java的Package/","excerpt":"","text":"Java的Package没有包含关系 例如： com.szxy和com.szxy.test import com.szxy.*，则只能用com.szxy目录下的类 import com.szxy.test.*,则只能用com.szxy.test目录下的类","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"带标签的break和continue","slug":"JavaSE/带标签的break和continue","date":"2019-03-02T05:00:20.000Z","updated":"2019-06-22T07:09:16.364Z","comments":true,"path":"2019/03/02/JavaSE/带标签的break和continue/","link":"","permalink":"http://yoursite.com/2019/03/02/JavaSE/带标签的break和continue/","excerpt":"","text":"1.不带标签的break和continue break：跳出当前的循环 continue:跳出本次循环 2.带标签的break和continuebreak label:跳出到label，并且不再执行该循环。即跳出label标签下的所有循环 12345678label: for(int i = 0; i &lt; 10; i++) &#123; for(int j = 0; j &lt; 10; j++) &#123; if(i == 5) &#123; break label; &#125; System.out.println(i + \"\\t\" + j); &#125; &#125; continue label:跳出到label,继续执行该label标签后的循环。 12345678label: for(int i = 0; i &lt; 10; i++) &#123; for(int j = 0; j &lt; 10; j++) &#123; if(i == 5) &#123; continue label; &#125; System.out.println(i + \"\\t\" + j); &#125; &#125;","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java 内部类中使用局部变量必须是final","slug":"JavaSE/Java 内部类中使用局部变量必须是final(jdk1.8之前)","date":"2019-02-24T10:22:33.000Z","updated":"2019-06-22T07:01:28.426Z","comments":true,"path":"2019/02/24/JavaSE/Java 内部类中使用局部变量必须是final(jdk1.8之前)/","link":"","permalink":"http://yoursite.com/2019/02/24/JavaSE/Java 内部类中使用局部变量必须是final(jdk1.8之前)/","excerpt":"","text":"注：jdk1.8新特性，Java 内部类中使用局部变量可以不用final修饰 在java中， 方法的内部类可以访问方法中的局部变量，但必须用final修饰才能访问。原因：1.当方法被调用运行完毕之后，局部变量就已消亡了。但内部类对象可能还存在， 直到没有被引用时才会消亡。此时就会出现一种情况，就是内部类要访问一个不存在的局部变量。 2.解决这一问题的办法就是使用final修饰局部变量，通过将final局部变量”复制”一份,复制品直接作为方法内部类中的数据成员，这事方法内部类访问的其实是这个局部变量的复制品！ 而且，由于被final修饰的变量赋值后不能再修改，所以就保证了复制品与原始变量的一致。 3.原因二的功能能实现的原因是：Java采用了一种copy local variable(复制局部变量)的方式来实现，也就是说把定义为final的局部变量拷贝过来用，而引用的也可以拿过来用，只是不能重新赋值。从而造成了可以access local variable(访问局部变量)的假象，而这个时候由于不能重新赋值，所以一般不会造成不可预料的事情发生。 使用final修饰符不仅会保持对象的引用不会改变, 而且编译器还会持续维护这个对象在回调方法中的生命周期. 所以这才是final变量和final参数的根本意义. 作者：姚瑶大坏蛋2007来源：CSDN原文：https://blog.csdn.net/tongnuxie/article/details/50111485版权声明：本文为博主原创文章，转载请附上博文链接！","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"JavaIO流中InputStream中的read()方法返回int","slug":"JavaSE/javaIO流中的InputStream中的read()方法返回int","date":"2019-02-17T07:20:20.000Z","updated":"2019-06-22T07:01:37.529Z","comments":true,"path":"2019/02/17/JavaSE/javaIO流中的InputStream中的read()方法返回int/","link":"","permalink":"http://yoursite.com/2019/02/17/JavaSE/javaIO流中的InputStream中的read()方法返回int/","excerpt":"","text":"public abstract int read()throws IOExceptior从输入流中读取数据的下一个字节。返回0到255范围内的int字节值。如果因为已经到达流末尾而没有可用的字节,则返回值-1,数据可用、检测到流末尾或者抛出异常前,此方法一直阻塞。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.io.*;class MyBufferedInputStream//自定义BuffereedInputStream类&#123; //装饰设计模式 private InputStream in; private byte[] buffer=new byte[1024]; private int count=0; private int pos=0; MyBufferedInputStream(InputStream in)//构造器 &#123; this.in=in; &#125; //模拟read方法 public int Myread()throws IOException &#123; if(count==0) &#123; count=in.read(buffer); //计数器记录通过public int read(byte[] b)方法存 //到数组缓冲区的数据的总字节数 pos=0;//如果计数器为0，则位置指针归零 if(count&lt;0) return -1; &#125; byte b=buffer[pos]; pos++; count--; //return b&amp;255; return b&amp;0xff;//关键在此，为什么要返回b和0xff的与呢？ &#125; //重写close方法 public void Myclose()throws IOException &#123; in.close(); &#125;&#125;class Demo&#123; //为了代码简洁，这里直接抛IO异常了，正确的做法是try，catch。 public static void main(String[] args)throws IOException &#123; long start=System.currentTimeMillis(); Copy(); long end=System.currentTimeMillis(); System.out.println(&quot;runtime:&quot;+(end-start)+&quot;ms&quot;);//获取运行时间 &#125; public static void Copy()throws IOException//拷贝功能封装在Copy方法体里面 &#123; MyBufferedInputStream mb=new MyBufferedInputStream(new FileInputStream(&quot;3.mp3&quot;)); BufferedOutputStream bo=new BufferedOutputStream(new FileOutputStream(&quot;copy_1.mp3&quot;)); int ch=0; while((ch=mb.Myread())!=-1) bo.write(ch); bo.close(); mb.Myclose(); &#125;&#125; 为什么myread方法返回的是b和0xff的与呢？ read方法返回int的原因: 首先我们知道，mp3文件全部为二进制数据组成的。这就有一个问题，如果恰好read方法读取的字节是1111-1111（即byte型的-1）怎么办？这时候返回的是-1.那这样的话Copy方法中的while循环就会停止，也就没有复制。 解决方法： 我们伟大的程序员采取了一个办法.那就是返回int型 1111-1111如果变成int型的话，应该是int型的-1，即11111111-11111111-11111111-11111111， 我们将int型的-1和0xff &amp;一下， 11111111 11111111 -11111111 -11111111 &amp;00000000-00000000-00000000-11111111（int型的255） 00000000-00000000-00000000-11111111 这样返回的就是有效字节了，而且不会出现-1的情况。 read方法做了一个类型提升，其实write方法每次也是强转，将int型的数据再转换为byte，这样获取的还是有效字节。 作者：rowandjj来源：CSDN原文：https://blog.csdn.net/chdjj/article/details/8577861版权声明：本文为博主原创文章，转载请附上博文链接！","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"JAVA中类、实例与Class对象","slug":"JavaSE/JAVA中类、实例与Class对象","date":"2019-01-26T12:20:33.000Z","updated":"2019-06-22T07:02:33.476Z","comments":true,"path":"2019/01/26/JavaSE/JAVA中类、实例与Class对象/","link":"","permalink":"http://yoursite.com/2019/01/26/JavaSE/JAVA中类、实例与Class对象/","excerpt":"","text":"类​ 类是面向对象编程语言的一个重要概念，它是对一项事物的抽象概括，可以包含该事物的一些属性定义，以及操作属性的方法。面向对象编程中，我们都是以类来编码。 实例简单理解，就是new，就是对类的实例化，创建这个类对应的实际对象，类只是对事物的描述，而实例化就相当于为这个描述新开辟了一块内存，可以改变这块区域里的各种属性（成员变量），当然，也可以实例化多块区域，只是不同的对象而已。 Class注意这里C大写了，与类概念区分开，在java里，Class是一个实实在在的类，在包 java.lang 下，有这样一个Class.java文件，它跟我们自己定义的类一样，是一个实实在在的类，Class对象就是这个Class类的实例了。在Java里，所有的类的根源都是Object类，而Class也不例外，它是继承自Object的一个特殊的类，它内部可以记录类的成员、接口等信息，也就是在Java里，Class是一个用来表示类的类。Class是一个实实在在的类，可以为它创建实例，也就是本文后面提到的Class对象，也看叫做Class实例）。 java提供了下面几种获取到类的Class对象的方法： 1) 利用对象实例调用getClass()方法获取该对象的Class实例； ​ Class c=对象.getClass(); ​ 2) 使用Class类的静态方法forName(“包名+类名”)，用类的名字获取一个Class实例 ​ Class c=Class.forName(“包名+类名”); ​ 3)运用 类名.class 的方式来获取Class实例； ​ Class c = 类名.class 我们知道java世界是运行在JVM之上的，我们编写的类代码，在经过编译器编译之后，会为每个类生成对应的.class文件，这个就是JVM可以加载执行的字节码。运行时期间，当我们需要实例化任何一个类时，JVM会首先尝试看看在内存中是否有这个类，如果有，那么会直接创建类实例；如果没有，那么就会根据类名去加载这个类，当加载一个类，或者当加载器(class loader)的defineClass()被JVM调用，便会为这个类产生一个Class对象（一个Class类的实例），用来表达这个类，该类的所有实例都共同拥有着这个Class对象，而且是唯一的。 总结 在java里，类只是信息描述的，写明了有哪些内部属性及接口，你可以理解为是定义了一套规则；而Class对象在java里被用来对类的情况进行表述的一个实例，也就是是类的实际表征，可以理解为是对规则的图表化，这样JVM才能直观的看懂，可以看做是一个模版；而类的实例化对象，就是通过模版，开辟出的一块内存进行实际的使用。","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"关于XML文档的xmlns、xmlns:xsi和xsi:schemaLocation","slug":"Java Web/关于XML文档的xmlns、xmlnsxsi和xsischemaLocation","date":"2019-01-22T08:30:23.000Z","updated":"2019-03-13T08:20:08.603Z","comments":true,"path":"2019/01/22/Java Web/关于XML文档的xmlns、xmlnsxsi和xsischemaLocation/","link":"","permalink":"http://yoursite.com/2019/01/22/Java Web/关于XML文档的xmlns、xmlnsxsi和xsischemaLocation/","excerpt":"","text":"摘要： 相信很多人和我一样，在编写Spring或者Maven或者其他需要用到XML文档的程序时，通常都是将这些XML文档头拷贝过来，并没有理解其中元素 （比如xmlns，xmlns:xsi，xsi:schemaLocation）的真正含义，不知道哪些元素是多余的，也不知道为什么要加那些元素。相信很多人和我一样，在编写Spring或者Maven或者其他需要用到XML文档的程序时，通常都是将这些XML文档头拷贝过来，并没有理解其中元素（比 如xmlns，xmlns:xsi，xsi:schemaLocation）的真正含义，不知道哪些元素是多余的，也不知道为什么要加那些元素。这样当有 时候网上Copy的XML头有错的时候自己却不知道怎么下手。我也是这样的，于是今天花了点时间好好的理解了一下这些元素及其用法，现整理与此，在此谢谢 各位前辈的经验，如有总结的不对或者不好的地方，欢迎留言提出各位的宝贵意见。 话不多说，先来一段Spring的XML样本，相信大家都很眼熟： 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;context:component-scan base-package=\"xxx.xxx.controller\" /&gt; &lt;context:annotation-config/&gt; &lt;mvc:default-servlet-handler/&gt; &lt;mvc:annotation-driven/&gt; &lt;mvc:resources mapping=\"/images/**\" location=\"/images/\" /&gt; &lt;bean id=\"xxx\" class=\"xxx.xxx.xxx.Xxx\"&gt; &lt;property name=\"xxx\" value=\"xxxx\"/&gt; &lt;/bean&gt;&lt;/beans&gt; ​ 这 个文档中，根元素就不用说了，接下来是xmlns。那么什么是xmlns呢？xmlns其实是XML Namespace的缩写，可译为“XML命名空间”，但个人觉得，翻译后的名字反而不好理解，所以我们就叫它为XML Namespace吧。 ​ 为什么需要xmlns？​ 考虑这样两个XML文档：表示HTML表格元素的： 123456&lt;table&gt; &lt;tr&gt; &lt;td&gt;Apples&lt;/td&gt; &lt;td&gt;Bananas&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; ​ 和描述一张桌子的： 12345&lt;table&gt; &lt;name&gt;African Coffee Table&lt;/name&gt; &lt;width&gt;80&lt;/width&gt; &lt;length&gt;120&lt;/length&gt;&lt;/table&gt; ​ 假如这两个 XML 文档被一起使用，由于两个文档都包含带有不同内容和定义的 元素，就会发生命名冲突。XML 解析器是无法确定如何处理这类冲突。为了解决上述问题，xmlns就产生了。 ​ 如何是用xmlns？​ 很简单，使用语法： xmlns:namespace-prefix=”namespaceURI”。其中namespace-prefix为自定义前缀，只要在这个XML文档中保证前缀不重复即可；namespaceURI是这个前缀对应的XML Namespace的定义。例如， 1xmlns:context=&quot;http://www.springframework.org/schema/context&quot; ​ 这一句定义了一个http://www.springframwork.org/schema/context的Namespace（这和Java类中的包的声明很相似），并将其和前缀context绑定。所以上面的Spring XML文档中会有这么一句： 1&lt;context:component-scan base-package=&quot;xxx.xxx.controller&quot;/&gt; ​ 这里的元素就来自别名为context的XML Namespace，也就是在http://www.springframework.org/schema/context中定义的。 ​ 我们还可以将前缀定义为abc： 1xmlns:abc=&quot;namespaceURI&quot; ​ 这样再使用这个namespaceURI中的元素时，需要以abc为前缀，例如：abc:xxx/。再拿上面的例子解释怎么使用xmlns： 123456&lt;!-- 这里xmlns:h=&quot;url1&quot;表示这个table是用h作为标记，table的写法在url1中定义 --&gt;&lt;h:table xmlns:h=&quot;url1&quot;&gt; &lt;h:tr&gt; &lt;h:td&gt;Apples&lt;/h:td&gt; &lt;h:td&gt;Bananas&lt;/h:td&gt; &lt;/h:tr&gt;&lt;/h:table&gt; ​ 和： 12345&lt;!-- 这里xmlns:f=&quot;url2&quot;表示这个table是用f作为标记，table的写法在url2中定义 --&gt;&lt;f:table xmlns:f=&quot;url2&quot;&gt; &lt;f:name&gt;African Coffee Table&lt;/f:name&gt; &lt;f:width&gt;80&lt;/f:width&gt; &lt;f:length&gt;120&lt;/f:length&gt;&lt;/f:table&gt; ​ 后者与前者仅仅使用不同前缀，我们为 标签添加了一个 xmlns 属性，这样就为前缀赋予了一个与某个命名空间相关联的限定名称。此时再把它们放在一起，XML解析器就不会报错了。 ​ 注意：当xmlns被定义在元素的开始标签中（如这里的&lt;f:table/&gt;）时，所有带有相同前缀的子元素都会与同一个Namespace相关联（即&lt;f:table/&gt;里面的&lt;f:name/&gt;和&lt;f:width/&gt;也会使用url2定义的写法）。 ​ xmlns和xmlns:xsi有什么不同？​ xmlns表示默认的Namespace。例如Spring XML文档中的 1xmlns=&quot;http://www.springframework.org/schema/beans&quot; ​ 这一句表示该文档默认的XML Namespace为http://www.springframwork.org/schema/beans。**对于默认的Namespace中的元素，可以不使用前缀**。例如Spring XML文档中的 123&lt;bean id=&quot;xxx&quot; class=&quot;xxx.xxx.xxx.Xxx&quot;&gt; &lt;property name=&quot;xxx&quot; value=&quot;xxxx&quot;/&gt;&lt;/bean&gt; ​ xmlns:xsi表示使用xsi作为前缀的Namespace，当然前缀xsi需要在文档中声明。 xsi:**schemaLocation有何作用？**​ xsi:schemaLocation属性其实是Namespace为http://www.w3.org/2001/XMLSchema-instance里的schemaLocation属性，正是因为我们一开始声明了 1xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; ​ 这里才写作xsi:schemaLocation（当然一般都使用这个前缀）。它定义了XML Namespace和对应的 XSD（Xml Schema Definition）文档的位置的关系。它的值由一个或多个URI引用对组成，两个URI之间以空白符分隔（空格和换行均可）。第一个URI是定义的 XML Namespace的值，第二个URI给出Schema文档的位置，Schema处理器将从这个位置读取Schema文档，该文档的targetNamespace必须与第一个URI相匹配。例如： 12xsi:schemaLocation=&quot;http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot; ​ 这里表示Namespace为http://www.springframework.org/schema/context的Schema的位置为[http://www.springframework.org/schema/context/spring-context.xsd](http://www.springframework.org/schema/context/spring-context.xsd?spm=5176.100239.blogcont40353.18.KFHYwA&amp;file=spring-context.xsd)。这里我们可以打开这个Schema的位置，下面是这个文档的开始部分： 12345678&lt;xsd:schema xmlns=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:beans=&quot;http://www.springframework.org/schema/beans&quot; xmlns:tool=&quot;http://www.springframework.org/schema/tool&quot; &lt;!-- 这里的targetNamespace和上方xsi:schemaLocation中的第一个URI匹配 --&gt; targetNamespace=&quot;http://www.springframework.org/schema/context&quot; elementFormDefault=&quot;qualified&quot; attributeFormDefault=&quot;unqualified&quot;&gt; ​ xmlns=”http://www.w3.org/2001/XMLSchema&quot; ​ 表示当前xml文件是一个schema约束文件（这个属性的值是确定的，不能改变，这个就是一个标志） targetNamespace=”http://www.springframework.org/schema/context&quot; ​ 定义schema地址，被约束文件可以通过这个地址引入使用 xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance&quot; - 表示这是一个被约束的xml文件（标志） - :xsi 这个是别名，为了区分下面的xmlsn属性 xmlns=”http://www.springframework.org/schema/context&quot; - 这个就是引入schema文件，这个值就是schema的地址（包名） xsi:schemaLocation=”http://www.example.org/1 1.xsd” - schema地址 空格 schema路径 ​ 有了上面的说明后，再去理解开始的Spring XML文档，一定会有不一样的感觉！ ​ 最后再次感谢各位前辈的宝贵经验。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"XML","slug":"XML","permalink":"http://yoursite.com/tags/XML/"}]},{"title":"Java多线程之this与Thread.currentThread()的区别","slug":"JavaSE/Java多线程this与Thread.currentThread()的区别","date":"2019-01-18T12:11:44.000Z","updated":"2019-06-22T07:02:06.556Z","comments":true,"path":"2019/01/18/JavaSE/Java多线程this与Thread.currentThread()的区别/","link":"","permalink":"http://yoursite.com/2019/01/18/JavaSE/Java多线程this与Thread.currentThread()的区别/","excerpt":"","text":"this是当前代码所处的对象的线程，Thread.currentThread()是运行当前代码的线程。 12345678910111213141516171819202122232425262728293031public class CountOperate extends Thread&#123; public CountOperate() &#123; System.out.println(\"CountOperate.CountOperate()\"); System.out.println(\"Thread-currentThread.getName()\"+Thread.currentThread().getName()); System.out.println(\"Thread-currentThread.isAlive()\"+Thread.currentThread().isAlive()); System.out.println(\"this.getName()\"+this.getName()); System.out.println(\"this.isAlive()\"+this.isAlive()); System.out.println(\"Thread-currentThread==this\"+(Thread.currentThread()==this)); System.out.println(\"CountOperate.CountOperate()\"); &#125; @Override public void run() &#123; System.out.println(\"CountOperate.run()\"+Thread.currentThread().getName()); System.out.println(\"Thread-currentThread.getName()\"+Thread.currentThread().getName()); System.out.println(\"Thread-currentThread.isAlive()\"+Thread.currentThread().isAlive()); System.out.println(\"this.getName()\"+this.getName()); System.out.println(\"this.isAlive()\"+this.isAlive()); System.out.println(\"Thread-currentThread==this\"+(Thread.currentThread()==this)); System.out.println(\"CountOperate.run()\"); &#125; public static void main(String[] args) &#123; CountOperate c=new CountOperate(); c.start(); Thread t1=new Thread(c); System.out.println(\"main t1.isAlive()\"+t1.isAlive()); t1.setName(\"t1\"); t1.start(); System.out.println(\"main t1.isAlive()\"+t1.isAlive()); &#125;&#125; 打印的log 123456789101112131415161718192021222324252627//-----------------------------------------------CountOperate.CountOperate() //new CountOperate()的构造函数Thread-currentThread.getName()main //jvm创建一个进程，默认有一个线程调用mainThread-currentThread.isAlive()true this.getName()Thread-0 //当前new的CountOperate()对象的线程this.isAlive()falseThread-currentThread==thisfalseCountOperate.CountOperate()//------------------------------------------------main t1.isAlive()false //t1没有调用start()方法main t1.isAlive()true //t1调用过start()方法//------------------------------------------------CountOperate.run()Thread-0 //c.start()调用run()Thread-currentThread.getName()Thread-0Thread-currentThread.isAlive()truethis.getName()Thread-0 //this当前线程this.isAlive()trueThread-currentThread==thistrueCountOperate.run()//------------------------------------------------CountOperate.run()t1 Thread-currentThread.getName()t1 //Thread t1=new Thread(参数),Thread-currentThread.isAlive()true //t1是new的Thread，与传递的参数无关this.getName()Thread-0 //传过来的c对象参数，当执行t1.start(),this.isAlive()false //会调用c的run()方法Thread-currentThread==thisfalseCountOperate.run() 根据打印的Log可以知道调用CountOperate构造函数的是main线程，因此打印出 Thread.currentThread().getName()=mainThread.currentThread().isAlive()=true而此时还没有启动CountOperate子线程所以打印出this.getName=Thread-0this.isAlive()=false 此时this代表的是CountOperate对象实例，所以Thread.currentThread()==this :false 这里比较让人疑惑的是“this.getName() = Thread-0”，这个Thread-0是什么东西？？？通过查看Thread源码发现，在Thread类的构造方法中，会自动给name赋值，赋值代码： 123public Thread() &#123; init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0); &#125; 然后执行到:Thread t1 = new Thread(c);System.out.println(“main begin t1 isAlive=” + t1.isAlive());t1.setName(“t1”);t1.start(); 打印：Thread-currentThread.getName()t1Thread-currentThread.isAlive()trueThread.currentThread()==this :falsethis.getName()=Thread-0this.isAlive()=false说明此时的this和Thread.currentThread()指向不是同一个线程实例 也就是说，this指向的还是new CountOperate()创建的那个线程实例，而不是new Thread(thread)创建的那个实例即t1。查看源代码可以知道 123public Thread(Runnable target) &#123; init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0); &#125; 实际上new Thread(thread)会将thread应用的对象绑定到一个pravite变量target上，在t1被执行的时候即t1.run()被调用的时候，它会调用target.run()方法，也就是说它是直接调用thread对象的run方法，再确切的说，在run方法被执行的时候，this.getName()实际上返回的是target.getName()，而Thread.currentThread().getName()实际上是t1.getName()。","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java理解  子类成员变量与父类成员变量同名   方法的重写","slug":"JavaSE/成员变量的同名和方法的重写","date":"2019-01-17T14:53:34.000Z","updated":"2019-06-22T07:09:01.165Z","comments":true,"path":"2019/01/17/JavaSE/成员变量的同名和方法的重写/","link":"","permalink":"http://yoursite.com/2019/01/17/JavaSE/成员变量的同名和方法的重写/","excerpt":"","text":"1.子类父类成员变量同名1.子类的成员变量与父类成员变量同名时,在子类中父类成员变量被”隐藏”2.要想访问与父类的同名的成员变量, 两种方法 ①: 在子类中是用 super ②:将该变量强转成父类的类 3.对象是什么类型的(不是new的那个类型), 成员变量是什么类型. 2.子类对父类方法的重写子类的方法与父类的方法重名时(我们讲得是重写的情况, 方法名一致, 形参一致, 与返回值无关)叫做重写(覆盖), 顾名思义, 把父类的方法重写了. 所以怎么转换, 都是子类的方法.","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"String.split()分割字符串用法","slug":"JavaSE/字符串分割split","date":"2018-12-30T02:49:33.000Z","updated":"2019-06-22T07:10:51.566Z","comments":true,"path":"2018/12/30/JavaSE/字符串分割split/","link":"","permalink":"http://yoursite.com/2018/12/30/JavaSE/字符串分割split/","excerpt":"","text":"split方法的参数是一个正则表达式，因此遇到正则表达式中的元字符需要进行转义，而java中的特殊字符也需要转义，因此，分隔的字符既是java特殊字符也是元字符就需要二次转义才能正确分割字符串。 1.public string[] split(string regex)这里的参数的名称是 regex ，也就是 regular expression （正则表达式）。这个参数并不是一个简单的分割用的字符，而是一个正则表达式，它对一些特殊的字符可能会出现你预想不到的结果，比如测试下面的代码： （1） 用竖线 | 分隔字符串，你将得不到预期的结果 ​ String[] aa = “aaa|bbb|ccc”.split(“|”); //String[] aa = “aaa|bbb|ccc”.split(“\\\\|”); 这样才能得到正确的结果 for (int i = 0 ; i &lt;aa.length ; i++ ) { System.out.println(“–”+aa); } （2）用竖 * 分隔字符串运行将抛出java.util.regex.PatternSyntaxException异常，用加号 + 也是如此。 ​ String[] aa = “aaabbbccc”.split(“*“); //String[] aa = “aaa|bbb|ccc”.split(“\\\\*”); 这样才能得到正确的结果 for (int i = 0 ; i &lt;aa.length ; i++ ) { System.out.println(“–”+aa);} （3）显然，+ 不是有效的模式匹配规则表达式，用”\\\\“ “\\\\+”转义后即可得到正确的结果。 （4） “|” 分隔串时虽然能够执行，但是却不是预期的目的，”\\\\|”转义后即可得到正确的结果。 （5）还有如果想在串中使用”\\“字符，则也需要转义.首先要表达”aaaa\\bbbb”这个串就应该用”aaaa\\\\bbbb”,如果要分隔就应该这样才能得到正确结果： String[] aa = “aaa\\\\bbb\\\\bccc”.split(“\\\\\\\\“); （6） 还有就是点号”.”，也要首先转义才能得到正确的结果。 2、public String[] split(String regex,int limit)​ 根据匹配给定的正则表达式来拆分此字符串。 此方法返回的数组包含此字符串的每个子字符串，这些子字符串由另一个匹配给定的表达式的子字符串终止或由字符串结束来终止。数组中的子字符串按它们在此字符串中的顺序排列。如果表达式不匹配输入的任何部分，则结果数组只具有一个元素，即此字符串。 3.”|”作为连字符的使用如果在一个字符串中有多个分隔符，可以用”|作为连字符，比如：”acount=? and uu =? or n=?”,把三个都分隔出来，可以用 “acount=? and uu =? or n=?”.split(“and|or”);","categories":[{"name":"JavaSE","slug":"JavaSE","permalink":"http://yoursite.com/categories/JavaSE/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"保存和获取cookie中的中文信息","slug":"Java Web/对cookie中的中文处理","date":"2018-12-29T02:46:17.000Z","updated":"2019-03-13T08:21:01.712Z","comments":true,"path":"2018/12/29/Java Web/对cookie中的中文处理/","link":"","permalink":"http://yoursite.com/2018/12/29/Java Web/对cookie中的中文处理/","excerpt":"","text":"1.保存cookie问题： 出现500错误 解决：设置字符编码 Cookie cookie=new Cookie(“test”,URLEncoder.encode(“中文”,”utf-8”)); 2.获取cookie 问题：出现乱码 解决：设置字符解码 System.out.println(“cookie:”+cookies[i].getName()+”:”+URLDecoder.decode(cookies[i].getValue()))；","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"乱码","slug":"乱码","permalink":"http://yoursite.com/tags/乱码/"}]},{"title":"请求转发与重定向的理解","slug":"Java Web/请求转发与重定向","date":"2018-12-28T08:37:58.000Z","updated":"2019-06-17T02:41:24.294Z","comments":true,"path":"2018/12/28/Java Web/请求转发与重定向/","link":"","permalink":"http://yoursite.com/2018/12/28/Java Web/请求转发与重定向/","excerpt":"","text":"1.forward（转发）是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,因为这个跳转过程实在服务器实现的，并不是在客户端实现的所以客户端并不知道这个跳转动作，所以它的地址栏还是原来的地址. 2.redirect（重定向）是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL. 区别： 转发是服务器行为，重定向是客户端行为。 1 )请求转发只能将请求转发给同一个WEB应用中的组件，而重定向还可以重新定向到同一站点不同应用程序中的资源，甚至可以定向到一绝对的URL。 2)重定向可以看见目标页面的URL，转发只能看见第一次访问的页面URL，以后的工作都是有服 务器来做的。 3) 请求响应调用者和被调用者之间共享相同的request对象和response对象，重定向调用者和被调用者属于两个独立访问请求和响应过程。 4)请求重定向：不加/是相对于本servlet所在请求的目录，加“/”表示端口号后面的根目录 http：//localhost:8080/ 请求转发：不加/是相对于本servlet，加/表示web应用的根目录http：//localhost:8080/Test/ ———path”/“路径——— —–只要是需要通过浏览器发送请求的地方（比如html代码，sendRedirect方法等）“/“一般代表虚拟主机根目录，即相当于端口号之后的“/”，例：http：//localhost:8080/ ——服务器程序内部跳转，“/”一般代表本web应用的根目录，如请求转发。例：http：//localhost:8080/Test/","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"servlet的乱码问题","slug":"Java Web/sevlet中的乱码","date":"2018-12-28T02:00:47.000Z","updated":"2019-03-13T08:21:17.519Z","comments":true,"path":"2018/12/28/Java Web/sevlet中的乱码/","link":"","permalink":"http://yoursite.com/2018/12/28/Java Web/sevlet中的乱码/","excerpt":"","text":"1.post请求1）html、jsp等页面编码格式1pageEncoding=&quot;UTF-8&quot; 2）设置请求信息的的解码格式1req.setCharacterEncoding(&quot;utf-8&quot;); 3）设置响应信息的编码格式1resp.setCharacterEncoding(&quot;utf-8&quot;); 4）设置浏览器的解码格式1resp.setContentType(&quot;text/html;charset=utf-8&quot;); 2.get请求​ 同post请求所有要求再加上 1) 1） 配置tomcat的server.xml​ 在 &lt;Connector connectionTimeout=”20000” port=”8080” ​ protocol=”HTTP/1.1” redirectPort=”8443”/&gt; ​ 中加入 useBodyEncodingForURI=”true” ​ 加入后&lt;Connector connectionTimeout=”20000” port=”8080” ​ protocol=”HTTP/1.1” redirectPort=”8443” ​ useBodyEncodingForURI=”true”/&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"},{"name":"乱码","slug":"乱码","permalink":"http://yoursite.com/tags/乱码/"}]},{"title":"修改Hexo主题","slug":"Config/修改Hexo主题","date":"2018-10-12T10:51:13.000Z","updated":"2019-07-08T06:52:53.920Z","comments":true,"path":"2018/10/12/Config/修改Hexo主题/","link":"","permalink":"http://yoursite.com/2018/10/12/Config/修改Hexo主题/","excerpt":"","text":"1.获取主题cd themes 再将yilia主题clone至themes文件夹中 git clone https://github.com/litten/hexo-theme-yilia.git yilia 2.配置：修改hexo根目录下的_config.yml theme:yilia 3.更新:12cd themes/yiliagit pull 4.发布12hexo cleanhexo d -g","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/tags/tools/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-10-11T14:51:01.594Z","updated":"2018-10-11T14:51:01.594Z","comments":true,"path":"2018/10/11/hello-world/","link":"","permalink":"http://yoursite.com/2018/10/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}