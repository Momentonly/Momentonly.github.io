{"meta":{"title":"Momentonly","subtitle":null,"description":null,"author":"Moment Only","url":"http://yoursite.com"},"pages":[{"title":"","date":"2019-04-17T02:54:56.207Z","updated":"2018-12-31T06:06:59.363Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":"123layout: categoriestitle: categories ---"},{"title":"","date":"2019-04-17T02:54:56.223Z","updated":"2018-12-31T06:06:40.300Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":"123layout: tagstitle: tags ---"}],"posts":[{"title":"","slug":"temp/数据源和连接池","date":"2019-06-21T07:19:43.556Z","updated":"2019-06-21T14:29:17.529Z","comments":true,"path":"2019/06/21/temp/数据源和连接池/","link":"","permalink":"http://yoursite.com/2019/06/21/temp/数据源和连接池/","excerpt":"","text":"数据源（1）数据源是一种数据库对编程提供的一个接口，每个数据源对应一个数据库。（2）连接池只是存放数据库连接对象的一个缓冲池，需要数据连接的时候从缓冲池中取就行了。（3）连接池可以管理数据源。 ​ 用TCP来连接你的应用程序与数据库是一件昂贵的事情（很费时的事情），开发者可以通过用连接池来反复的使用数据库的连接。比起每次请求都用TCP来连一次数据库，连接池只有在不存在有效的连接时才新建一个TCP连接。当关闭一个连接的时候，它会被放到池中，它仍然会保持与数据库的连接，这样就可以减少与数据库的TCP连接次数。​ 数据源是指数据的来源，比如数据库。连接池是指这样一个“池子”，池子中的每个东西都是连接数据源的一个“连接”，这样别人想连接数据源的时候可以从这个“池子”里取，用完以后再放回来供以后其他想使用的人使用。我们一般说的数据源指的就是数据库～ 数据源是指数据的来源的概括，包含了数据库位置 和 数据库类型等信息，实际上是一种数据连接的抽象。 也可以说，你要得到的信息存放的地方的概括（包括 存放信息的数据库类型、数据库的地址等等信息的概括） c3p0,dbcp,druid配置数据源也可以说是对整个数据库连接参数的配置（包括各种配置，以及连接池的管理）","categories":[],"tags":[]},{"title":"mysql配置远程登录","slug":"Linux/mysql配置远程登录","date":"2019-06-20T14:35:59.000Z","updated":"2019-06-21T04:28:51.029Z","comments":true,"path":"2019/06/20/Linux/mysql配置远程登录/","link":"","permalink":"http://yoursite.com/2019/06/20/Linux/mysql配置远程登录/","excerpt":"","text":"mysql配置远程登录 1.查看表 use mysql; select host,user from user; host | user |+———–+———–+| % | root || localhost | mysql.sys || localhost | root | host是主机，root表示主机可以登录的用户，%表示所有主机，但不包括localhost 2.如果没有%,root grant all privileges on 库名.表名 to ‘用户名‘@’IP地址’ identified by ‘密码’ with grant option;flush privileges; 库名:要远程访问的数据库名称,所有的数据库使用“*”表名:要远程访问的数据库下的表的名称，所有的表使用“*”用户名:要赋给远程访问权限的用户名称IP地址:可以远程访问的电脑的IP地址，所有的地址使用“%” 3.如果配置所有ip可以远程登录root GRANT ALL PRIVILEGES ON *.* TO ‘root‘@’%’ IDENTIFIED BY ‘123456’ WITH GRANT OPTION; 所有的地址都可以使用root用户，密码为123456远程访问所有的数据库和表 GRANT ALL PRIVILEGES ON testdb.* TO ‘lxh‘@’172.16.52.225’ IDENTIFIED BY ‘lxh’ WITH GRANT OPTION; IP为172.16.52.225的电脑可以使用lxh用户，密码为lxh远程访问数据库testdb的所有表 注意需要注意mysql的配置文件中的bindaddress 的参数和skip-networking 配置 bindaddress : 设定哪些ip地址被配置，使得mysql服务器只回应哪些ip地址的请求),最好注释掉该参数或设置成为127.0.0.1以外的值 skip-networking : 如果设置了该参数项，将导致所有TCP/IP端口没有被监听,也就是说出了本机，其他客户端都无法用网络连接到本mysql服务器，所以应该注释掉该参数","categories":[],"tags":[]},{"title":"hostname和etchosts的区别","slug":"Linux/hostname和etchosts的区别","date":"2019-06-20T06:43:59.000Z","updated":"2019-06-20T06:46:59.622Z","comments":true,"path":"2019/06/20/Linux/hostname和etchosts的区别/","link":"","permalink":"http://yoursite.com/2019/06/20/Linux/hostname和etchosts的区别/","excerpt":"","text":"很多人一提到更改hostname首先就想到修改/etc/hosts文件，认为hostname的配置文件就是/etc/hosts。其实不是的。hosts文件的作用相当于DNS，提供IP地址hostname的对应。早期的互联网计算机少，单机hosts文件里足够存放所有联网计算机。不过随着互联网的发展，这就远远不够了。于是就出现了分布式的DNS系统。由DNS服务器来提供类似的IP地址到域名的对应。Linux系统在向DNS服务器发出域名解析请求之前会查询/etc/hosts文件，如果里面有相应的记录，就会使用hosts里面的记录。由此，/etc/hosts于设置hostname是没直接关系的，仅仅当你要在本机上用新的hostname来映射自己的IP时候才会用到/etc/hosts文件。两者没有必然的联系。redhat的hostname的配置文件是/etc/sysconfig/network. /etc/hosts内容摘录如下： #Do not remove the following line, or various programs #that require network functionality will fail. 192.168.1.102 localhost.localdomain localhost127.0.0.1 localhost.localdomain localhost::1 localhost6.localdomain6 localhost6对以上内容的解释作用：hosts 文件是用来把主机名字映射到IP地址的方法，这种方法比较简单。但这种映射只是本地映射，也就是说每台机器都是独立的，所有的计算机都不能相互通过hostname来访问。格式： 一般情况下hosts的内容关于主机名(hostname)的定义，每行为一个主机，每行由三部份组成，每个部份由空格隔开。其中#号开头的行做说明，不被系统解释。 第一部份：网络IP地址； 第二部份：主机名.域名，注意主机名和域名之间有个半角的点，比如 localhost.localdomain 第二部份：主机名(主机名别名） ，其实就是主机名；注释：1）127.0.0.1 是回环地址，比如我们不想让局域网的其它机器看到我们测试的网络程序，就可以用回环地址来测试。2）为什么需要定义域名呢？其实理解也简单，比如我们有三台主机，每台做不同的事，一台做MAIL服务器，一台做FTP服务器，一台做SMB服务器，所以我们就可以这样来设计hostname； 127.0.0.1 localhost.localdomain localhost 192.168.1.2 ftp 192.168.1.3 mail.localdomain mail 192.168.1.4 smb.localdomin smb把这上面这个配置文件的内容分别写入每台机器的/etc/hosts内容中，这样这三台局域网的机器就可以通过hostname来访问了。也就是，在局域网中，主机名也是可以解析到IP上的，相当于DNS域名解析。对于主机名的修改有两种方式:hostname和/etc/sysconfig/network [sql] view plaincopyprint?[root@think ~]# hostnamethin[root@think ~]# hostname think[root@think ~]# hostnamethink 通过hostname 这个kernel变量来设置主机名只是临时的，下次重启系统时，此主机名将不会存在.hostname也可用于显示:hostname -i。如果要永久修改RedHat hostname，就修改/etc/sysconfig/network文件，将里面的HOSTNAME这一行修改成HOSTNAME=NEWNAME，其中NEWNAME就是你要设置的hostname。 2./hosts文件可以帮助解决哪些问题2.1 远程登录linux主机过慢问题 有时客户端想远程登录一台linux主机，但每次登录输入密码后都会等很长一段时间才会进入，这是因为linux主机在返回信息时需要解析ip，如果在linux主机的hosts文件事先加入客户端的ip地址，这时再从客户端远程登录linux就会变很快。 注：这里所说的远程登录不仅仅是ssh，还可能是mysql远程登录，或是文件共享的查询等。 2.2 双机互连 当两台主机只是双机互连时，这时两台主机都需要设置自己的ip，同时在对方的hosts文件里加入自己的ip和主机名。 注：不同发行版的主机名称对应文件可以通过man host那么进行查阅 3.关于FQDN FQDN：(Fully Qualified Domain Name)完全合格域名/全称域名，是指主机名加上全路径，全路径中列出了序列中所有域成员。全域名可以从逻辑上准确地表示出主机在什么地方，也可以说全域名是主机名的一种完全表示形式。从全域名中包含的信息可以看出主机在域名树中的位置。DNS解析流程：首先查找本机HOSTS表，有的直接使用表中定义，没有查找网络连接中设置的DNS 服务器由他来解析。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[]},{"title":"jdbc中的execute()返回值","slug":"JDBC/jdbc中的execute()返回值","date":"2019-06-20T05:54:47.000Z","updated":"2019-06-20T05:54:22.223Z","comments":true,"path":"2019/06/20/JDBC/jdbc中的execute()返回值/","link":"","permalink":"http://yoursite.com/2019/06/20/JDBC/jdbc中的execute()返回值/","excerpt":"","text":"jdbc中的execute()返回值表示不同的操作 true表示查询 false表示更新或者删除","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"}]},{"title":"centos7配置dhcp和静态Ip","slug":"Linux/centos7配置DHCP和静态IP","date":"2019-06-20T05:19:59.000Z","updated":"2019-06-20T05:47:21.258Z","comments":true,"path":"2019/06/20/Linux/centos7配置DHCP和静态IP/","link":"","permalink":"http://yoursite.com/2019/06/20/Linux/centos7配置DHCP和静态IP/","excerpt":"","text":"vi ifcfg-eth0 TYPE=Ethernet PROXY_METHOD=none BROWSER_ONLY=no BOOTPROTO=static DEFROUTE=yes IPV4_FAILURE_FATAL=no IPV6INIT=yes IPV6_AUTOCONF=yes IPV6_DEFROUTE=yes IPV6_FAILURE_FATAL=no IPV6_ADDR_GEN_MODE=stable-privacy NAME=eth0 UUID=85a5000d-dbaa-4a2a-8075-0df5562bf331 DEVICE=eth0 ONBOOT=yes IPADDR=192.168.1.166 NETMASK=255.255.255.0 GATEWAY=192.168.1.1 DNS1=8.8.8.8 DNS2=114.114.114.114 DNS3=223.6.6.6 1.静态IPBOOTPROTO=static #设置static IPADDR=192.168.1.166 #静态ip NETMASK=255.255.255.0 #子网掩码 GATEWAY=192.168.1.1 #网关 2.DHCP​ 12345BOOTPROTO=dhcp #设置dhcp#注释掉配置的静态ip部分#IPADDR=192.168.1.166 #NETMASK=255.255.255.0#GATEWAY=192.168.1.1 配置完成后重启网络 systemctl restart network","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[]},{"title":"centos7安装缺少命令","slug":"Linux/安装centos7缺少命令问题","date":"2019-06-20T05:19:59.000Z","updated":"2019-06-20T05:51:58.626Z","comments":true,"path":"2019/06/20/Linux/安装centos7缺少命令问题/","link":"","permalink":"http://yoursite.com/2019/06/20/Linux/安装centos7缺少命令问题/","excerpt":"","text":"没有 ifconfig 、netstat命令： 1yum install -y net-tools 没有命令补全，tab补全命令： 1yum install -y bash-completion 没有killall命令： 1yum install -y psmisc","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[]},{"title":"centos7修改网卡名","slug":"Linux/centos7修改网卡名","date":"2019-06-20T03:26:31.000Z","updated":"2019-06-20T05:14:57.104Z","comments":true,"path":"2019/06/20/Linux/centos7修改网卡名/","link":"","permalink":"http://yoursite.com/2019/06/20/Linux/centos7修改网卡名/","excerpt":"","text":"用ifconfig查看网卡名称为ens33，现在要将它修改成eth0 1)编辑配置文件/etc/sysconfig/network-scripts/ifcfg-ens33 将DEVICE=ens33修改成DEVICE=eth0 将NAME=ens33修改成NAME=eth0 保存并退出 2)重命名该配置文件。 [root@remote network-scripts]# cd /etc/sysconfig/network-scripts/ [root@remote network-scripts]# mv ifcfg-ens33 ifcfg-eth0 3)编辑/etc/default/grub并加入“net.ifnames=0 biosdevname=0 ” 示例:GRUB_CMDLINE_LINUX=”crashkernel=auto net.ifnames=0 biosdevname=0 rhgb quiet” 保存并退出 4)运行命令grub2-mkconfig -o /boot/grub2/grub.cfg 来重新生成GRUB配置并更新内核参数 5)使用reboot命令重启操作系统 注意:重启后查看ifcfg-eth0,dhcp可能被修改为static,如果没有配置静态ip网络会出错","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"数据库元数据MetaData","slug":"JDBC/数据库元数据MetaDate","date":"2019-06-19T01:19:47.000Z","updated":"2019-06-19T01:10:08.727Z","comments":true,"path":"2019/06/19/JDBC/数据库元数据MetaDate/","link":"","permalink":"http://yoursite.com/2019/06/19/JDBC/数据库元数据MetaDate/","excerpt":"","text":"本篇介绍数据库方面的元数据（MetaData）的有关知识。元数据在建立框架和架构方面是特别重要的知识，再下一篇我们仿造开源数据库工具类DbUtils就要使用数据库的元数据来创建自定义JDBC框架。 在我们前面使用JDBC来处理数据库的接口主要有三个，即Connection，PreparedStatement和ResultSet这三个，而对于这三个接口，还可以获取不同类型的元数据，通过这些元数据类获得一些数据库的信息。 元数据(MetaData)，即定义数据的数据。打个比方，就好像我们要想搜索一首歌(歌本身是数据)，而我们可以通过歌名，作者，专辑等信息来搜索，那么这些歌名，作者，专辑等等就是这首歌的元数据。因此数据库的元数据就是一些注明数据库信息的数据。 ① 由Connection对象的getMetaData()方法获取的是DatabaseMetaData对象。 ② 由PreparedStatement对象的getParameterMetaData ()方法获取的是ParameterMetaData对象。 ③由ResultSet对象的getMetaData()方法获取的是ResultSetMetaData对象。 一、DatabaseMetaDataDatabaseMetaData是由Connection对象通过getMetaData方法获取而来，主要封装了是对数据库本身的一些整体综合信息，例如数据库的产品名称，数据库的版本号，数据库的URL，是否支持事务等等，能获取的信息比较多，具体可以参考DatabaseMetaData的API文档。 以下有一些关于DatabaseMetaData的常用方法： ·getDatabaseProductName：获取数据库的产品名称 ·getDatabaseProductName：获取数据库的版本号 ·getUserName：获取数据库的用户名 ·getURL：获取数据库连接的URL ·getDriverName：获取数据库的驱动名称 ·driverVersion：获取数据库的驱动版本号 ·isReadOnly：查看数据库是否只允许读操作 ·supportsTransactions：查看数据库是否支持事务 例1： 简单地获取一些常用的数据库综合信息。 二、ParameterMetaData ParameterMetaData是由PreparedStatement对象通过getParameterMetaData方法获取而来，主要是针对PreparedStatement对象和其预编译的SQL命令语句提供一些信息，比如像”insert into account(id,name,money) values(?,?,?)”这样的预编译SQL语句，ParameterMetaData能提供占位符参数的个数，获取指定位置占位符的SQL类型等等，功能也比较多，这里不列举完，详细请看有关ParameterMetaData的API文档。 以下有一些关于ParameterMetaData的常用方法： ·getParameterCount：获取预编译SQL语句中占位符参数的个数 在我看来，ParameterMetaData对象能用的只有获取参数个数的getParameterCount()方法。 注意：ParameterMetaData许多方法MySQL并不友好支持，比如像获取指定参数的SQL类型的getParameterType方法，如果数据库驱动连接URL只是简单的“jdbc:mysql://localhost:3306/jdbcdemo”那么MyEclipse会抛出SQLException异常，必须要将URL修改为“jdbc:mysql://localhost:3306/jdbcdemo?generateSimpleParameterMetadata=true”才行。但是像getParameterType等等与其他的方法也没多好用，因为如下面的例子，这些方法好像只会将所有的参数认为是字符串(VARCHAR)类型。 因为我们的SQL语句为”insert into user(id,name,age) values(?,?,?)”，而我们所有利用ParameterMetaData查询的信息除了参数个数以外，都是查询第一个参数的信息，也就是“id”列，而这个“id”列我们创建时是int整型的，但是利用ParameterMetaData的查询结果都是显示为字符串类型，因此我对ParameterMetaData的功能产生了怀疑。 因此在以后使用参数元数据ParameterMetaData尽量只要使用其getParamterCount()方法获取参数个数，对于该对象其他方法请慎用。 三、ResultSetMetaData ResultSetMetaData是由ResultSet对象通过getMetaData方法获取而来，主要是针对由数据库执行的SQL脚本命令获取的结果集对象ResultSet中提供的一些信息，比如结果集中的列数、指定列的名称、指定列的SQL类型等等，可以说这个是对于框架来说非常重要的一个对象。关于该结果集元数据对象的其他具体功能和方法请查阅有关ResultSetMetaData的API文档。 以下有一些关于ResultSetMetaData的常用方法： ·getColumnCount：获取结果集中列项目的个数 ·getColumnType：获取指定列的SQL类型对应于Java中Types类的字段 ·getColumnTypeName：获取指定列的SQL类型 ·getClassName：获取指定列SQL类型对应于Java中的类型(包名加类名)","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"JDBC操作数据库","slug":"JDBC/JDBC操作数据库","date":"2019-06-17T14:35:47.000Z","updated":"2019-06-17T14:36:07.517Z","comments":true,"path":"2019/06/17/JDBC/JDBC操作数据库/","link":"","permalink":"http://yoursite.com/2019/06/17/JDBC/JDBC操作数据库/","excerpt":"","text":"","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JDBC","slug":"JDBC","permalink":"http://yoursite.com/tags/JDBC/"}]},{"title":"","slug":"JDBC/jdbc中的execute()返回值表示不同的","date":"2019-06-17T08:53:00.466Z","updated":"2019-06-17T12:07:04.718Z","comments":true,"path":"2019/06/17/JDBC/jdbc中的execute()返回值表示不同的/","link":"","permalink":"http://yoursite.com/2019/06/17/JDBC/jdbc中的execute()返回值表示不同的/","excerpt":"","text":"jdbc中的execute()返回值表示不同的操作 true表示查询 false表示更新或者删除","categories":[],"tags":[]},{"title":"mysql注释的三种写法","slug":"JDBC/mysql注释的三种写法","date":"2019-06-17T08:07:47.000Z","updated":"2019-06-17T13:47:18.166Z","comments":true,"path":"2019/06/17/JDBC/mysql注释的三种写法/","link":"","permalink":"http://yoursite.com/2019/06/17/JDBC/mysql注释的三种写法/","excerpt":"","text":"MySql--三种注释写法 需要特别注意 -- 这种注释后面要加一个空格 #DELETE FROM SeatInformation /DELETE FROM SeatInformation /– DELETE FROM SeatInformation","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"}]},{"title":"properties文件的读取","slug":"Java Web/properties文件的读取","date":"2019-06-17T02:00:38.000Z","updated":"2019-06-17T02:06:02.317Z","comments":true,"path":"2019/06/17/Java Web/properties文件的读取/","link":"","permalink":"http://yoursite.com/2019/06/17/Java Web/properties文件的读取/","excerpt":"","text":"Java 开发中，需要将一些易变的配置参数放置再 XML 配置文件或者 properties 配置文件中。然而 XML 配置文件需要通过 DOM 或 SAX 方式解析，而读取 properties 配置文件就比较容易。 读取方式1、基于ClassLoder读取配置文件 ​ 注意：该方式只能读取类路径下的配置文件，有局限但是如果配置文件在类路径下比较方便。 2、基于 InputStream 读取配置文件 ​ 注意：该方式的优点在于可以读取任意路径下的配置文件 代码实现db.properties 12user=rootpwd=123 123456789101112131415161718192021222324252627282930313233343536package jdbc.com.szxy.properties;import java.io.File;import java.io.FileInputStream;import java.io.InputStream;import java.util.Properties;/** * 读取properties文件测试 * @author Momentonly */public class ProPertiesTest &#123; public static void main(String[] args) throws Exception &#123; /** * 基于ClassLoder读取配置文件 */ Properties pro1 = new Properties(); //获取资源的输入流,类路径下 InputStream is1 = ProPertiesTest.class.getClassLoader().getResourceAsStream(\"db.properties\"); //读取输入流 pro1.load(is1); // System.out.println(pro1.getProperty(\"user\")); System.out.println(pro1.getProperty(\"pwd\")); /** * 基于 InputStream 读取配置文件 */ Properties pro2 = new Properties(); //获取资源的输入流，相对路径或者绝对路径 InputStream is2 = new FileInputStream(new File(\"src/db.properties\")); pro2.load(is2); System.out.println(pro2.getProperty(\"user\")); System.out.println(pro2.getProperty(\"pwd\")); &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"Linux常用命令2","slug":"Linux/Linux常用命令2","date":"2019-06-16T08:56:55.000Z","updated":"2019-06-20T05:52:21.887Z","comments":true,"path":"2019/06/16/Linux/Linux常用命令2/","link":"","permalink":"http://yoursite.com/2019/06/16/Linux/Linux常用命令2/","excerpt":"","text":"1.scp -r root@39.104.111.122:/usr/local/ /usr/local ​ 将远程39.104.111.122的/usr/local下的文件拷贝到本机/usr/local目录下 ​ -r 复制目录 2.scp -r /usr/local root@39.104.111.122:/usr/local/ ​ 上传本地/usr/local目录到远程39.104.111.122的/usr/local目录 3.du -sh : 查看当前目录总共占的容量。而不单独列出各子项占用的容量 4.du -sh file:查看指定文件的大小 5.userdel -r 用户名 删除一个用户 6.passwd 用户名 修改密码 7.finger 查看登录的终端 8.last 用户名 查看登录记录 9.w -s 查看登录的终端用户 10.ls -lharts 查看文件详细信息 11.pwd 查看当前的路径 12.pgrep 进程名 查看进程的pid 13.ps -ef|grep 进程名 查看进程的pid 14.killall -9 bash 杀掉所有登录的bash 注:killall [参数][进程名] 用来杀掉同名的所有进程","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"手写服务器总结","slug":"Java Web/手写服务器总结","date":"2019-06-16T07:23:02.000Z","updated":"2019-06-16T14:16:50.731Z","comments":true,"path":"2019/06/16/Java Web/手写服务器总结/","link":"","permalink":"http://yoursite.com/2019/06/16/Java Web/手写服务器总结/","excerpt":"","text":"手写服务器总结搭建框架​ ………………… 实现编写web.xml123456789101112&lt;!--servlet处理请求--&gt;&lt;servlet&gt; &lt;!--LoginServlet别名:login --&gt; &lt;servlet-name&gt;login&lt;/servlet-name&gt; &lt;servlet-class&gt;com.szxy.httpserver.servlet.LoginServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;!--浏览器的请求路径--&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;login&lt;/servlet-name&gt; &lt;url-pattern&gt;/login&lt;/url-pattern&gt; &lt;url-pattern&gt;/log&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; ​ 实体类保存解析xml中的信息 ​ Entity类:servlet-name,servlet-class ​ Mapping类:servlet-name,url-pattern 解析xmldom4j解析xml​ Entity:servlet-name,servlet-class ​ Entity通过String name，String clazz两个成员变量保存web.xml中的\\servlet-name,servlet-class ​ Mapping:servlet-name,url-pattern， ​ Mapping通过String name，和List urlPattern集合两个成员变量保存web.xml中的\\servlet-name,url-pattern， ServletContext类​ 上下文，是一个容器，描述Entity与Mapping之间的关系 该类的成员变量 12private Map&lt;String, String&gt; servlet; //key是servlet-name,value是servlet-classprivate Map&lt;String, String&gt; mapping; //key是url-pattern,value是servlet-name WebApp类​ 1）将Entity和Mapping中的servlet-name,servlet-class,url-pattern,servlet-name ​ 保存到ServletContext类的成员变量中。 ​ 请求路径作为key,获取servlet-name值，获取servlet-name ​ servlet-name作为key,获取servlet的 全路径名(包名+类名) ​ 1） 反射创建Servlet ​ 可以通过全路径名反射创建Servlet对象 1234567//根据url的key获取servlet-name的值 String servletName = context.getMapping().get(url);//根据servlet-name得到对应的servlet-class String servletClass = context.getServlet().get(servletName); //完整的包名和类名//使用反射创建Servlet对象 Class&lt;?&gt; clazz = Class.forName(servletClass); servlet = (Servlet) clazz.newInstance(); servlet建立抽象类Servlet12345678public abstract class Servlet &#123; public void service(Request req, Response rep)throws Exception&#123; this.doGet(req, rep); this.doPost(req, rep); &#125; public abstract void doGet(Request req, Response rep) throws Exception; public abstract void doPost(Request req, Response rep) throws Exception;&#125; 处理请求的Servlet继承Servlet例：登录LoginServlet 12345678910111213141516171819202122public class LoginServlet extends Servlet&#123;@Overridepublic void doGet(Request req, Response rep) throws Exception &#123; // TODO Auto-generated method stub //获取请求参数 String name = req.getParater(\"username\"); String pwd = req.getParater(\"pwd\"); if(\"bjsxt\".equals(name) &amp;&amp; \"123\".equals(pwd))&#123; //调用响应中的print方法 rep.println(name + \"登录成功\"); &#125;else&#123; rep.println(\"账号或者密码不正确\"); &#125; &#125;@Overridepublic void doPost(Request req, Response rep) throws Exception &#123; // TODO Auto-generated method stub &#125;&#125; 封装Request对象(浏览器的请求)​ 通过输入流获取浏览器的请求信息，然后根据HTTP协议，进行请求信息的处理 从请求信息中获取请求方式，路径，参数， 例：GET请求和POST请求的信息 1234567891011121314151617181920212223GET /log?username=bj&amp;pwd=123&amp;hobby=ball HTTP/1.1Host: localhost:8888Connection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.90 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9POST /log HTTP/1.1Host: localhost:8888Connection: keep-aliveContent-Length: 30Cache-Control: max-age=0Upgrade-Insecure-Requests: 1Origin: nullContent-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/75.0.3770.90 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9username=bj&amp;pwd=123&amp;hobby=ball 请求参数的乱码问题 处理中文，因为浏览器对中文进行了编码，因此需要解码服务器端获取到发过来的请求参数默认使用ISO8859-1进行解码操作，中文一定有乱码问题 12//value是请求参数，code是编码return URLDecoder.decode(value, code);//decode(keyValues[1].trim(), &quot;utf-8&quot;) 封装Response对象(服务器的响应)1.严格根据HTTP协议封装响应信息 123456789//响应头//协议，状态码，描述headInfo.append(&quot;HTTP1.1&quot;).append(BLANK).append(code).append(BLANK).append(&quot;&quot;);headInfo.append(CRLF);headInfo.append(&quot;Content-Type:text/html;charset=utf-8&quot;).append(CRLF);headInfo.append(&quot;Content-Length:&quot;+length).append(CRLF);headInfo.append(CRLF);//响应正文content.append(“&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;登录响应&lt;/title&gt;&lt;/head&gt;&lt;body&gt;登录成功&lt;/body&gt;&lt;/html&gt;”).append(CRLF); 2.响应正文可以调用Response类中的println(String info)进行设置 ​ content.append(info).append(CRLF); 封装分发器Dispatcher​ Dispatcher是一个请求与响应,并实现了Runnable接口 ​ 通过客户端连接的对象client,初始化Request和Response对象 12req = new Request(client.getInputStream());rep = new Response(client.getOutputStream()); run()方法实现 1.根据请求信息获取路径， 2.根据路径通过反射创建servlet 3.调用servlet的service()方法处理请求 4.rep.pushToClient(code);//响应，将封装后的Response信息发送给客户端 12345678910111213141516171819public void run() &#123; // TODO Auto-generated method stub //根据不同的url创建指定的servlet对象 Servlet servlet = WebApp.getServlet(req.getUrl()); if(servlet == null)&#123; this.code = 404; //路径找不到 &#125;else&#123; //调用service方法 try &#123; servlet.service(req, rep); &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); this.code = 500; &#125; &#125; rep.pushToClient(code); IOCloseUtil.closeAll(client); &#125; ServerSocket服务器​ 创建一个ServelSocket对象，监听8888端口 1server = new ServerSocket(port); ​ 循环接收客户端请求，接收到请求，创建一个线程代理Dispatcher对象处理请求 12345678while(!isShutDown)&#123; //1)监听 Socket client = server.accept(); //创建线程类的对象 Dispatcher dis = new Dispatcher(client); //创建代理，启动线程 new Thread(dis).start();&#125; 解决浏览器请求的icon该请求是浏览器默认发送的:http://localhost:8888/favicon.ico 解决： ​ 1.在web.xml中配置路径 12345678&lt;servlet&gt; &lt;servlet-name&gt;favicon&lt;/servlet-name&gt; &lt;servlet-class&gt;com.szxy.httpserver.servlet.FaviconServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;favicon&lt;/servlet-name&gt; &lt;url-pattern&gt;/favicon.ico&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 2.创建FaviconServlet类继承Servlet ​","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"sublime的package control","slug":"Config/sublime的package control","date":"2019-06-15T07:13:46.000Z","updated":"2019-06-15T07:33:57.858Z","comments":true,"path":"2019/06/15/Config/sublime的package control/","link":"","permalink":"http://yoursite.com/2019/06/15/Config/sublime的package control/","excerpt":"","text":"sublime的package control​ preferences-&gt;package control出现There are no packages available for installation错误 据说是IPv6的原因，如果我们的Intent服务提供者（ISP）不支持IPv6就会引发上述错误，原文如下：This error is happened with IPv6 problem. If your Internet Service Provider (ISP) does not support for IPv6 you got this error. 从上面的描述可以知道首先需要获取sublime.wbond.net网站的IPv4地址，然后修改hosts文件就行了。 C:\\Windows\\System32\\drivers\\etc 修改hosts 50.116.34.243 sublime.wbond.net 50.116.34.243 packagecontrol.io Package control的install packageSublime包管理package control 打开install package报错 There are no packages available for installation 本地下载一个channel_v3.json文件:https://github.com/SuCicada/channel_v3.json 放入本地任意目录，然后打开sublime中的Preferences-&gt;package settings-&gt;package control-&gt;settings user 配置 “channels”: [ “H:\\SoftwarePro\\Sublime Text 3\\channel_v3.json” ], 保存重启","categories":[{"name":"config","slug":"config","permalink":"http://yoursite.com/categories/config/"}],"tags":[{"name":"config","slug":"config","permalink":"http://yoursite.com/tags/config/"}]},{"title":"ThreadLocal的使用","slug":"SXTJavaSE/ThreadLocal的使用","date":"2019-06-13T09:37:18.000Z","updated":"2019-06-13T09:39:16.743Z","comments":true,"path":"2019/06/13/SXTJavaSE/ThreadLocal的使用/","link":"","permalink":"http://yoursite.com/2019/06/13/SXTJavaSE/ThreadLocal的使用/","excerpt":"","text":"ThreadLocal的使用1.说明​ ThreadLocal 直译为“本地线程”，其实它就是一容器，用于 存放线程的局部变量 ​ 能够保持每一个线程里面的值是相应的，说明这些值已经达到了线程私有的目的。 ​ 当你在一个类中使用 static 成员变量时，一定要问自己这个 static 成员变量需要考虑“线程安全吗？” ​ （也就是说 多个线程需要自己独立的 static 成员变量吗？）如果需要那就需要使用 ThreadLocal。 ​ 作用:为解决多线程程序的并发问题 2.实现机制​ 首先获取当前线程，在获取当前线程的ThreadLocalMap ​ 每个Thread对象内部都维护了一个ThreadLocalMap这样一个ThreadLocal的Map，可以存放若干个 ThreadLocal。 123/* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ThreadLocal.ThreadLocalMap threadLocals = null; ​ 当我们在调用get()方法的时候，先获取当前线程，然后获取到当前线程的ThreadLocalMap对象，如果非空，那么取出ThreadLocal的value，否则进行初始化，初始化就是将initialValue的值set到ThreadLocal中。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://yoursite.com/tags/JAVA/"}]},{"title":"Linux常用命令1","slug":"Linux/Linux常用命令1","date":"2019-06-12T05:51:55.000Z","updated":"2019-06-12T05:54:21.711Z","comments":true,"path":"2019/06/12/Linux/Linux常用命令1/","link":"","permalink":"http://yoursite.com/2019/06/12/Linux/Linux常用命令1/","excerpt":"","text":"文件 &amp; 目录操作（16 个） ls ● ls -a 查看所有文件，包含隐藏文件 ● ls -l 简写 ll，查看详细信息 ● ls -h 文件大小以易读的方式显示 cd ● cd ../ 返回上级目录 ● cd ~ 前往家目录 ● cd - 返回上一次所在目录 cp ● cp -r 复制目录及目录下文件 find ● find / -name ‘target’ 查询根目录下面文件名为 target 的文件 mkdir ● mkdir -p /tmp/test 递归创建目录 mv ● mv -f source destination 强制 pwd ● pwd 显示当前路径 rm ● rm -rf / 强制删除根目录及目录下的文件，就是我们通常所说的删库跑路 touch ● touch target 创建 target 文件，若文件存在则改变文件时间戳 tree ● tree 功能是以树形结构显示目录下的内容 basename ● basename /tmp/1 显示文件名 dirname ● dirname /tmp/1 显示路径 chattr ● chattr +i /tmp/1 加 i 属性，防止文件被修改 lsattr ● lsattr /tmp/1 查看文件的扩展属性 file ● file /tmp/1 显示文件类型 md5 ● md5 /tmp/1 显示文件 MD5 值 查看文件 &amp; 内容处理（18 个） cat ● cat -n 显示行号 ● cat file1 file2 打开文件 1 和 2 more ● more file1 逐页显示 less ● less file1 也是逐页显示，与 more 方向相反 head ● head -n file 显示文件头 n 行 tail ● tail -n file 显示文件尾 n 行 ● tailf file 实时显示文件尾 10 行，常用于跟踪日志信息 cut ● who|cut -b 1-3,5 输出每行的 1 至 3 个字节和第 5 个字节 ● who|cut -c -3 输出每行的 1 至 3 个字符 ● who|cut -c 3- 输出每行的第 3 个字符到行尾 ● who|cut -d ‘ ‘ -f 1 以空格为分隔符，输出第一个域 split ● split -b 10k date.file 将文件分割为 10k 的多个子文件 ● split -b 10k date.file split_file 指定子文件前缀为 split_file paste ● psate file1 file2 file3 将 3 个文件按列合并 sort ● sort -n 按照数值大小排序 ● sort -r 倒序排序 ● sort -t 指定分隔符 ● sort -u 忽略相同行 uniq ● uniq -c 显示出现次数，只有相邻的才算重复 ● uniq -d 只显示重复的行 ● unqi -u 只显示不重复的行 wc ● wc -l 显示列数 diff ● diff file1 file2 比较两个文件差异 rev ● rev file 反向输出文件内容 grep ● grep ‘target’ file 过滤输出文件中包含 target 的行 ● grep -v ‘target’ file 过滤输出文件中不包含 target 的行 ● grep -c ‘target’ file 过滤输出文件中包含 target 的行数 ● grep -i ‘target’ file 忽略大小写 ● egrep ‘[1-9]|a’ file 过滤输出正则匹配到的行 ● seq 10 | grep “5” -A 3 显示匹配某个结果之后的 3 行 ● seq 10 | grep “5” -B 3 显示匹配某个结果之前的 3 行 ● seq 10 | grep “5” -C 3 显示匹配某个结果的前三行和后三行 join ● join file1 file2 将两个文件中，指定栏位内容相同的行连接起来 tr ● cat text | tr ‘\\t’ ‘ ‘ 将制表符替换成空格 vim 三种模式： ● 编辑模式（命令模式） ● 输入模式 ● 末行模式 模式的转换 编辑 -&gt; 输入 i: 在当前光标所在字符的前面，转为输入模式； a: 在当前光标所在字符的后面，转为输入模式； o: 在当前光标所在行的下方，新建一行，并转为输入模式； I：在当前光标所在行的行首，转换为输入模式 A：在当前光标所在行的行尾，转换为输入模式 O：在当前光标所在行的上方，新建一行，并转为输入模式； 输入 -&gt; 编辑 ESC 编辑 -&gt; 末行： : 末行 -&gt; 编辑： ESC,ESC 打开文件 vim +# :打开文件，并定位于第#行 vim +：打开文件，定位至最后一行 vim +/PATTERN : 打开文件，定位至第一次被PATTERN匹配到的行的行首 关闭文件 :q 退出 :wq 保存并退出 :q! 不保存并退出 :w 保存 :w! 强行保存 移动光标（编辑模式） 逐字符移动 h: 左 l: 右 j: 下 k: 上 #h: 移动#个字符 以单词为单位移动 w: 移至下一个单词的词首 e: 跳至当前或下一个单词的词尾 b: 跳至当前或前一个单词的词首 #w: 移动#个单词 行内跳转 0: 绝对行首 ^: 行首的第一个非空白字符 $: 绝对行尾 行间跳转 #G：跳转至第#行 gg: 第一行 G：最后一行 翻屏 Ctrl+f: 向下翻一屏 Ctrl+b: 向上翻一屏 Ctrl+d: 向下翻半屏 Ctrl+u: 向上翻半屏 删除单个字符 x: 删除光标所在处的单个字符 #x: 删除光标所在处及向后的共#个字符 删除命令: d dd: 删除当前光标所在行 #dd: 删除包括当前光标所在行在内的#行； 撤消编辑操作 u：撤消前一次的编辑操作 #u: 直接撤消最近#次编辑操作 连续u命令可撤消此前的n次编辑操作 撤消最近一次撤消操作：Ctrl+r 查找 /PATTERN ?PATTERN n 下一个 N 上一个 文件压缩 &amp; 解压缩（3 个） tar ● tar zxvf FileName.tar.gz 解压 ● tar zcvf FileName.tar.gz DirName 压缩 zip ● zip -r html.zip/home/html 递归压缩 unzip ● unzip test.zip -d /tmp 解压到指定目录下 信息显示（11 个） uname ● uname -a 显示系统全部信息 hostname ● hostname 显示主机名 dmesg ● dmesg 显示开机信息 uptime ● uptime 显示系统运行时间及负载 stat ● stat 显示文件的状态信息 du ● du -sh 显示路径下所有文件大小 ● du -sh local 显示路径下 local 目录文件大小 ● du -sh * 显示路径下所有目录文件大小 df ● df -h 显示系统磁盘空间的使用情况 top ● top 实时显示系统资源使用情况 free ● free -m 以 M 为单位查看系统内存 date ● date +”%Y-%m-%d” 2019-05-28 ● date -d “1 day ago” +”% Y-% m-% d” 输出昨天日期 ● date -d “+1 day” +% Y% m% d 显示前一天的日期 ● date -d “-1 day” +% Y% m% d 显示后一天的日期 ● date -d “-1 month” +% Y% m% d 显示上一月的日期 ● date -d “+1 month” +% Y% m% d 显示下一月的日期 ● date -d “-1 year” +% Y% m% d 显示前一年的日期 ● date -d “+1 year” +% Y% m% d 显示下一年的日期 cal ● cal 日历信息 搜索文件（4 个） which ● which pwd 显示命令路径 find ● find /-name ‘target’ 查询根目录下面文件名为 target 的文件 whereis ● whereis php 查找二进制命令 locate ● locate target 从数据库 (/var/lib/mlocate/mlocate.db) 查找目标文件，使用 updatedb 更新库 进程管理（11 个） jobs ● jobs 查看当前有多少在后台运行的命令 bg ● bg 1 将一个在后台暂停的命令，继续执行，1 为作业号 ● （ctrl+z）可以挂起程序，返回作业号 fg ● fg 1 将后台中的命令调至前台继续运行 ，1 为作业号 kill ● kill 进程号 杀进程 ● kill -9 进程号 强杀进程 ● killall ● killall php 通过进程名字杀进程 ● killall -9 php 通过进程名字强杀进程 pkill ● 用法同上 crontab ● crontab -l 查看定时任务 ● crontab -e 编辑定时任务 ● crontab -l -u user1 查看 user1 定时任务，只有 root 才有权限 ● crontab -e -u user1 编辑 user1 定时任务，只有 root 才有权限 ps ● ps -ef 查看进程，显示 UID,PPIP,C 与 STIME，每个程序所使用的环境变量栏位 ● ps -axu 查看所有进程，并显示属于用户 pstree ● pstree -p 显示当前所有进程的进程号和进程 id 树 ● pstree -a 显示所有进程的所有详细信息树 nohup ● nohup command &amp; 退出账户时不挂断程序，仍在后台运行 pgrep ● pgrep -l httpd 查找 http 相关的进程号 用户管理（7 个） useradd ● useradd boy -u 888 建立一个新用户账户，并设置 ID ● useradd –g sales jack –G company,employees ● -g：加入主要组 -G：加入次要组 usermod ● usermod -G staff newuser2 将 newuser2 添加到组 staff 中 ● usermod -l newuser1 newuser 修改 newuser 的用户名为 newuser1 ● usermod -L newuser1 锁定账号 newuser1 ● usermod -U newuser1 解除对 newuser1 的锁定 userdel ● userdel -f user1 强制删除用户 ● userdel -r user1 删除用户的同时，删除与用户相关的所有文件 groupadd ● groupadd -g 1000 group1 建立一个新组，并设置组 ID 加入系统 passwd ● passwd user1 修改 user1 密码 ● passwd -l user1 锁住密码 ● passwd -d user1 删除密码 su ● su root 切换身份 sudo ● sudo command 已管理员身份运行命令 网络操作（11 个） telnet ● telnet 127.0.0.1 登录远程主机 ssh ● ssh root@127.0.0.1 -p22 登录远程主机 scp ● scp local_file remote_username@remote_ip:remote_folder 本地拷贝到远程 ● scp remote_username@remote_ip:remote_folder local_file 远程拷贝到本地 wget ● wget url 下载一个文件 ● wget –limit-rate=300k url 限速下载 ● wget -c url 断点续传 ● wget -b url 后台下载 ping ● ping www.baidu.com -c 2 收到两个包就结束 route ● route 显示当前路由 ifconfig ● ifconfig 查看、配置、启用或禁用网络接口 ifup ● ifup eth0 开启 eth0 网卡 ● ifdown ● ifdown eth0 关闭 eth0 网卡 netstat ● netstat -at 列出所有 tcp 端口 ● netstat -au 列出所有 udp 端口 ● netstat -l 只显示监听端口 ss ● ss -t -a 显示所有 tcp 链接 ● ss -l 显示处于监听状态的套接字 磁盘 &amp; 文件系统（7 个） mount ● mount /dev/hda1 /mnt 将 /dev/hda1 挂载到 /mnt 目录下 ● umount ● umount -v /mnt/mymount/ 卸载 /mnt/mymount/ fsck ● fsck -y /dev/hda2 检查并修复 Linux 文件系统 dumpe2fs ● dumpe2fs /dev/hda1 查看文件系统信息 dump ● ‍dump -0u -f /tmp/homeback.bak /home 将 /home 目录所有内容备份到 /tmp/homeback.bak 文件中，备份层级为 0 并在 /etc/dumpdates 中记录相关信息 fdisk ● fdisk /dev/sdb 输入 m 列出可以执行的命令 输入 p 列出磁盘目前的分区情况 输入 d 然后选择分区，删除现有分区 输入 print 查看分区情况，确认分区已经删除 输入 n 建立新的磁盘分区 输入 w 最后对分区操作进行保存 mkfs ● mkfs -t ext3 /dev/sda6 将 sda6 分区格式化为 ext3 格式 系统权限（3 个） chmod ● chmod 777 file1 修改 file1 文件权限为 777 ● chmod u+x,g+w file1 为 file1 设置自己可以执行，组员可以写入的权限 chown ● chown -R root /usr/meng 修改将目录 /usr/meng 及其下面的所有文件、子目录的文件主改成 root chgrp ● chgrp -R mengxin /usr/meng 将 /usr/meng 及其子目录下的所有文件的用户组改为 mengxin 关机重启（5 个） shutdown ● shutdown -h now 立即关机 ● shutdown +5 “System will shutdown after 5 minutes” 指定 5 分钟后关机，同时送出警告信息给登入用户 halt ● halt -p 关闭系统后关闭电源 ● halt -d 关闭系统，但不留下纪录 poweroff ● poweroff -f 强制关闭操作系统 logout ● logout 退出当前登录的 Shell exit ● exit 退出当前登录的 Shell 其他（6 个） echo ● echo ‘hello’ 打印字符串、变量 print ● printf ‘hell0’ 格式化输出字符串 rpm ● rpm -ivh your-package.rpm 安装 rpm 包 ● rpm -Uvh your-package.rpm 升级 rpm 包 ● rpm -e package 卸载 ● rpm -qa 列出所有安装过的包 ● rpm -ql 包名 rpm 包中的文件安装到那里去 yum ● yum install php 安装 php ● yum remove php 卸载 php clear ● clear 清屏 history ● history 10 最近使用的 10 条历史命令","categories":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://yoursite.com/tags/Linux/"}]},{"title":"c语言二维数组传递一维数组参数","slug":"C/c语言二维数组传递一维数组参数","date":"2019-06-09T07:46:09.000Z","updated":"2019-06-09T07:49:01.642Z","comments":true,"path":"2019/06/09/C/c语言二维数组传递一维数组参数/","link":"","permalink":"http://yoursite.com/2019/06/09/C/c语言二维数组传递一维数组参数/","excerpt":"","text":"123456789101112131415161718#include&lt;stdio.h&gt;void test(int a[]);int main()&#123; int a[2][2]; a[0][0] = 0; a[0][1] = 1; a[1][0] = 2; a[1][1] = 3; //printf(\"%d,%d,%d,%d\",a[0][0],a[0][1],a[1][0],a[1][1]); test(a[0]); //传递一维数组 test(a[1]); return 0;&#125;void test(int a[])&#123; printf(\"%d,%d\\n\",a[0],a[1]);&#125; 打印 : 0,1 ​ 2,3","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"IDEA的工作区间","slug":"IDEA/IDEA的工作区间","date":"2019-06-05T15:09:08.000Z","updated":"2019-06-05T15:12:51.507Z","comments":true,"path":"2019/06/05/IDEA/IDEA的工作区间/","link":"","permalink":"http://yoursite.com/2019/06/05/IDEA/IDEA的工作区间/","excerpt":"","text":"IDEA中的项目概念与eclipse是不同的，IDEA的项目等同于eclipse中的workspace。Idea的module等同于eclipse中的project。所以我们要实现在一个项目倒入多个module。 具体操作如下： File–&gt;Project Structure Import Module，然后选中自己要导入的项目即可 作者：wzz87来源：CSDN原文：https://blog.csdn.net/wzz87/article/details/80234880版权声明：本文为博主原创文章，转载请附上博文链接！","categories":[],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"http://yoursite.com/tags/IDEA/"}]},{"title":"重启eclipse color theme失效的解决办法","slug":"Config/Eclipse主题重启失效","date":"2019-06-02T09:22:09.000Z","updated":"2019-06-02T09:33:51.283Z","comments":true,"path":"2019/06/02/Config/Eclipse主题重启失效/","link":"","permalink":"http://yoursite.com/2019/06/02/Config/Eclipse主题重启失效/","excerpt":"","text":"重启eclipse color theme失效的解决办法** 1、在eclipse菜单栏 选择 windows &gt; Perferences； 2、找到Oomph &gt; Setup Task &gt; Perference Recorder选项； 3、将上方的Record Into勾选上，点恢复默认值(Restore Defaults)再应用(apply)-确定(Ok) 4.重启Eclipse主题生效 注：Perference Recorder可以同步Eclipse的配置参数","categories":[{"name":"config","slug":"config","permalink":"http://yoursite.com/categories/config/"}],"tags":[{"name":"config","slug":"config","permalink":"http://yoursite.com/tags/config/"}]},{"title":"C中的void与void*类型","slug":"C/C中的oid类型与void指针类型","date":"2019-04-24T00:38:14.000Z","updated":"2019-04-24T00:48:20.093Z","comments":true,"path":"2019/04/24/C/C中的oid类型与void指针类型/","link":"","permalink":"http://yoursite.com/2019/04/24/C/C中的oid类型与void指针类型/","excerpt":"","text":"c中的void表示不确定类型1.void类型​ int main(void)表示不可传递参数 ​ void类型不能定义变量 2. void*类型​ void*类型可与任意类型进行强制转换 1234int* p = NULL;*p = 10;void* v = (void *)p; //将int*类型的p强制转换为void*类型int k = *(int *)v; //将void*类型的v强制转换为int*类型 注：void类型强转后的类型需要与原来的类型保持一致*","categories":[],"tags":[{"name":"C","slug":"C","permalink":"http://yoursite.com/tags/C/"}]},{"title":"Java中serialVersionUID的解释及两种生成方式的区别","slug":"JAVA/Java中serialVersionUID的解释及两种生成方式的区别","date":"2019-04-07T15:26:33.000Z","updated":"2019-04-07T15:26:32.686Z","comments":true,"path":"2019/04/07/JAVA/Java中serialVersionUID的解释及两种生成方式的区别/","link":"","permalink":"http://yoursite.com/2019/04/07/JAVA/Java中serialVersionUID的解释及两种生成方式的区别/","excerpt":"","text":"serialVersionUID作用： 序列化时为了保持版本的兼容性，即在版本升级时反序列化仍保持对象的唯一性。有两种生成方式： 一个是默认的1L，比如：private static final long serialVersionUID = 1L; 一个是根据类名、接口名、成员方法及属性等来生成一个64位的哈希字段，比如： private static final long serialVersionUID = xxxxL;关于其定义，可参考JDK文档：http://download.oracle.com/javase/1.5.0/docs/api/java/io/Serializable.html 在Eclipse中，提供两种方式让我们快速添加SerialVersionUid。 add default serial version ID：Adds a default serial version ID to the selected typeUse this option to add a user-defined ID in combination with custom serialization code if the type did undergo structural change since its first release. add generated serial version ID：Adds a generated serial version ID to the selected typeUse this option to add a compiler-generated ID if the type didnot undergo structural change since its first release. 一种就是1L，一种是生成一个很大的数，这两种有什么区别呢？ 看上去，好像每个类的这个类不同，似乎这个SerialVersionUid在类之间有某种关联。其实不然，两种都可以，从JDK文档也看不出这一点。我们只要保证在同一个类中，不同版本根据兼容需要，是否更改SerialVersionUid即可。 对于第一种，需要了解哪些情况是可兼容的，哪些根本就不兼容。 参考文档：http://java.sun.com/j2se/1.4/pdf/serial-spec.pdf 在可兼容的前提下，可以保留旧版本号，如果不兼容，或者想让它不兼容，就手工递增版本号。 1-&gt;2-&gt;3….. 第二种方式，是根据类的结构产生的hash值。增减一个属性、方法等，都可能导致这个值产生变化。我想这种方式适用于这样的场景： 开发者认为每次修改类后就需要生成新的版本号，不想向下兼容，操作就是删除原有serialVesionUid声明语句，再自动生成一下。 个人认为，一般采用第一种就行了，简单。第二种能够保证每次更改类结构后改变版本号，但还是要手工去生成，并不是修改了类，会提示你要去更新这个SerialVersionUid，所以虽然看上去很cool，实际上让人很迷惑。 参考： 1.一篇较好的关于serialVesionUid的说明： http://www.mkyong.com/java-best-practices/understand-the-serialversionuid/","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"java类初始化顺序","slug":"JAVA/Java类初始化顺序","date":"2019-03-13T09:20:20.000Z","updated":"2019-03-13T09:29:52.938Z","comments":true,"path":"2019/03/13/JAVA/Java类初始化顺序/","link":"","permalink":"http://yoursite.com/2019/03/13/JAVA/Java类初始化顺序/","excerpt":"","text":"Java的类初始化顺序 123456789101112131415161718192021222324252627282930313233343536373839404142package com.szxy;/** * * @author Administrator * */public class InitClassTest &#123; public static void main(String[] args) &#123; new B(); &#125;&#125;class A&#123; static A a = new A(); //1) static&#123; System.out.println(\"A:static\"); //2) &#125; C c = new C(); //5) &#123; //6) System.out.println(\"A:not static\"); &#125; public A() &#123; //7) System.out.println(\"A:constructor\"); &#125;&#125;class B extends A &#123; static&#123; System.out.println(\"B:static\"); //3) &#125; static B b = new B(); //4) &#123; //8) System.out.println(\"B:not static\"); &#125; public B() &#123; //9) System.out.println(\"B:constructor\"); &#125;&#125;class C&#123; public C() &#123; System.out.println(\"C\"); &#125;&#125; console打印 123456789101112131415C //1)A:not static //1)A:constructor //1)A:static //2)B:static //3)C //4)A:not static //4)A:constructor //4)B:not static //4)B:constructor //4)C //5)A:not static //6)A:constructor //7)B:not static //8)B:constructor //9) 根据打印结果：父类静态变量（静态代码块）-&gt; 子类静态变量（静态代码块） ​ -&gt; 父类成员变量（非静态代码块）-&gt; 父类构造方法 -&gt;子类成员变量（非静态代码块） ​ -&gt; 子类构造方法 ps：静态变量和静态代码块属于平级，谁在前谁先初始化； ​ 非静态代码块和成员变量属于平级，谁在前谁先初始化","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"性能测试工具locust","slug":"Python/性能测试工具locust","date":"2019-03-13T08:20:20.000Z","updated":"2019-03-13T08:41:41.235Z","comments":true,"path":"2019/03/13/Python/性能测试工具locust/","link":"","permalink":"http://yoursite.com/2019/03/13/Python/性能测试工具locust/","excerpt":"","text":"An open source load testing tool. 一个开源性能测试工具。 define user behaviour with python code, and swarm your system with millions of simultaneous users. 使用Python代码来定义用户行为。用它可以模拟百万计的并发用户访问你的系统。 1.安装Python2.安装Locustpip install locust 3.安装成功，CMD敲入命令验证。​ locust –help 4.创建load_test.py文件，通过Python编写性能测试脚本。123456789101112from locust import HttpLocust, TaskSet, taskclass UserBehavior(TaskSet): @task(1) def indesx(self): self.client.get(\"/\")class WebsiteUser(HttpLocust): task_set = UserBehavior min_wait = 3000 max_wait = 6000 创建UserBehavior()类继承TaskSet类，为用户行为类。 ​ 创建index() 方法表示一个行为。用@task() 装饰该方法为一个任务。1表示一个Locust实例被挑选执行的权重，数值越大，执行频率越高。在当前UserBehavior()行为下只有一个index()任务，所以，这里的权重设置为几，并无影响。 WebsiteUser()类用于设置性能测试。 task_set ：指向一个定义了的用户行为类。 min_wait ：用户执行任务之间等待时间的下界，单位：毫秒。 max_wait ：用户执行任务之间等待时间的上界，单位：毫秒。 5.命令行切换到性能测试脚本所在的目录，启动性能测试：1locust -f load_test.py --host=https://www.baidu.com ​ load_test.py 为测试脚本，https://www.baidu.com 为测试的网站。 ​ 打开浏览器访问：http://127.0.0.1:8089或者http://localhost:8089 ps:在pycharm中运行脚本 123if __name__ == '__main__':import osos.system(\"locust -f load_test.py --host=https://www.baidu.com\")","categories":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://yoursite.com/tags/tools/"}]},{"title":"java的Package","slug":"JAVA/java的Package","date":"2019-03-03T04:35:23.000Z","updated":"2019-03-03T04:42:43.925Z","comments":true,"path":"2019/03/03/JAVA/java的Package/","link":"","permalink":"http://yoursite.com/2019/03/03/JAVA/java的Package/","excerpt":"","text":"Java的Package没有包含关系 例如： com.szxy和com.szxy.test import com.szxy.*，则只能用com.szxy目录下的类 import com.szxy.test.*,则只能用com.szxy.test目录下的类","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"带标签的break和continue","slug":"JAVA/带标签的break和continue","date":"2019-03-02T05:00:20.000Z","updated":"2019-03-02T05:46:44.676Z","comments":true,"path":"2019/03/02/JAVA/带标签的break和continue/","link":"","permalink":"http://yoursite.com/2019/03/02/JAVA/带标签的break和continue/","excerpt":"","text":"1.不带标签的break和continue break：跳出当前的循环 continue:跳出本次循环 2.带标签的break和continuebreak label:跳出到label，并且不再执行该循环。即跳出label标签下的所有循环 12345678label: for(int i = 0; i &lt; 10; i++) &#123; for(int j = 0; j &lt; 10; j++) &#123; if(i == 5) &#123; break label; &#125; System.out.println(i + \"\\t\" + j); &#125; &#125; continue label:跳出到label,继续执行该label标签后的循环。 12345678label: for(int i = 0; i &lt; 10; i++) &#123; for(int j = 0; j &lt; 10; j++) &#123; if(i == 5) &#123; continue label; &#125; System.out.println(i + \"\\t\" + j); &#125; &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java 内部类中使用局部变量必须是final","slug":"JAVA/Java 内部类中使用局部变量必须是final(jdk1.8之前)","date":"2019-02-24T10:22:33.000Z","updated":"2019-03-11T05:06:53.693Z","comments":true,"path":"2019/02/24/JAVA/Java 内部类中使用局部变量必须是final(jdk1.8之前)/","link":"","permalink":"http://yoursite.com/2019/02/24/JAVA/Java 内部类中使用局部变量必须是final(jdk1.8之前)/","excerpt":"","text":"注：jdk1.8新特性，Java 内部类中使用局部变量可以不用final修饰 在java中， 方法的内部类可以访问方法中的局部变量，但必须用final修饰才能访问。原因：1.当方法被调用运行完毕之后，局部变量就已消亡了。但内部类对象可能还存在， 直到没有被引用时才会消亡。此时就会出现一种情况，就是内部类要访问一个不存在的局部变量。 2.解决这一问题的办法就是使用final修饰局部变量，通过将final局部变量”复制”一份,复制品直接作为方法内部类中的数据成员，这事方法内部类访问的其实是这个局部变量的复制品！ 而且，由于被final修饰的变量赋值后不能再修改，所以就保证了复制品与原始变量的一致。 3.原因二的功能能实现的原因是：Java采用了一种copy local variable(复制局部变量)的方式来实现，也就是说把定义为final的局部变量拷贝过来用，而引用的也可以拿过来用，只是不能重新赋值。从而造成了可以access local variable(访问局部变量)的假象，而这个时候由于不能重新赋值，所以一般不会造成不可预料的事情发生。 使用final修饰符不仅会保持对象的引用不会改变, 而且编译器还会持续维护这个对象在回调方法中的生命周期. 所以这才是final变量和final参数的根本意义. 作者：姚瑶大坏蛋2007来源：CSDN原文：https://blog.csdn.net/tongnuxie/article/details/50111485版权声明：本文为博主原创文章，转载请附上博文链接！","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"JavaIO流中InputStream中的read()方法返回int","slug":"JAVA/javaIO流中的InputStream中的read()方法返回int","date":"2019-02-17T07:20:20.000Z","updated":"2019-02-17T07:13:35.549Z","comments":true,"path":"2019/02/17/JAVA/javaIO流中的InputStream中的read()方法返回int/","link":"","permalink":"http://yoursite.com/2019/02/17/JAVA/javaIO流中的InputStream中的read()方法返回int/","excerpt":"","text":"public abstract int read()throws IOExceptior从输入流中读取数据的下一个字节。返回0到255范围内的int字节值。如果因为已经到达流末尾而没有可用的字节,则返回值-1,数据可用、检测到流末尾或者抛出异常前,此方法一直阻塞。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859import java.io.*;class MyBufferedInputStream//自定义BuffereedInputStream类&#123; //装饰设计模式 private InputStream in; private byte[] buffer=new byte[1024]; private int count=0; private int pos=0; MyBufferedInputStream(InputStream in)//构造器 &#123; this.in=in; &#125; //模拟read方法 public int Myread()throws IOException &#123; if(count==0) &#123; count=in.read(buffer); //计数器记录通过public int read(byte[] b)方法存 //到数组缓冲区的数据的总字节数 pos=0;//如果计数器为0，则位置指针归零 if(count&lt;0) return -1; &#125; byte b=buffer[pos]; pos++; count--; //return b&amp;255; return b&amp;0xff;//关键在此，为什么要返回b和0xff的与呢？ &#125; //重写close方法 public void Myclose()throws IOException &#123; in.close(); &#125;&#125;class Demo&#123; //为了代码简洁，这里直接抛IO异常了，正确的做法是try，catch。 public static void main(String[] args)throws IOException &#123; long start=System.currentTimeMillis(); Copy(); long end=System.currentTimeMillis(); System.out.println(&quot;runtime:&quot;+(end-start)+&quot;ms&quot;);//获取运行时间 &#125; public static void Copy()throws IOException//拷贝功能封装在Copy方法体里面 &#123; MyBufferedInputStream mb=new MyBufferedInputStream(new FileInputStream(&quot;3.mp3&quot;)); BufferedOutputStream bo=new BufferedOutputStream(new FileOutputStream(&quot;copy_1.mp3&quot;)); int ch=0; while((ch=mb.Myread())!=-1) bo.write(ch); bo.close(); mb.Myclose(); &#125;&#125; 为什么myread方法返回的是b和0xff的与呢？ read方法返回int的原因: 首先我们知道，mp3文件全部为二进制数据组成的。这就有一个问题，如果恰好read方法读取的字节是1111-1111（即byte型的-1）怎么办？这时候返回的是-1.那这样的话Copy方法中的while循环就会停止，也就没有复制。 解决方法： 我们伟大的程序员采取了一个办法.那就是返回int型 1111-1111如果变成int型的话，应该是int型的-1，即11111111-11111111-11111111-11111111， 我们将int型的-1和0xff &amp;一下， 11111111 11111111 -11111111 -11111111 &amp;00000000-00000000-00000000-11111111（int型的255） 00000000-00000000-00000000-11111111 这样返回的就是有效字节了，而且不会出现-1的情况。 read方法做了一个类型提升，其实write方法每次也是强转，将int型的数据再转换为byte，这样获取的还是有效字节。 作者：rowandjj来源：CSDN原文：https://blog.csdn.net/chdjj/article/details/8577861版权声明：本文为博主原创文章，转载请附上博文链接！","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"JAVA中类、实例与Class对象","slug":"JAVA/JAVA中类、实例与Class对象","date":"2019-01-26T12:20:33.000Z","updated":"2019-02-16T07:28:52.479Z","comments":true,"path":"2019/01/26/JAVA/JAVA中类、实例与Class对象/","link":"","permalink":"http://yoursite.com/2019/01/26/JAVA/JAVA中类、实例与Class对象/","excerpt":"","text":"类​ 类是面向对象编程语言的一个重要概念，它是对一项事物的抽象概括，可以包含该事物的一些属性定义，以及操作属性的方法。面向对象编程中，我们都是以类来编码。 实例简单理解，就是new，就是对类的实例化，创建这个类对应的实际对象，类只是对事物的描述，而实例化就相当于为这个描述新开辟了一块内存，可以改变这块区域里的各种属性（成员变量），当然，也可以实例化多块区域，只是不同的对象而已。 Class注意这里C大写了，与类概念区分开，在java里，Class是一个实实在在的类，在包 java.lang 下，有这样一个Class.java文件，它跟我们自己定义的类一样，是一个实实在在的类，Class对象就是这个Class类的实例了。在Java里，所有的类的根源都是Object类，而Class也不例外，它是继承自Object的一个特殊的类，它内部可以记录类的成员、接口等信息，也就是在Java里，Class是一个用来表示类的类。Class是一个实实在在的类，可以为它创建实例，也就是本文后面提到的Class对象，也看叫做Class实例）。 java提供了下面几种获取到类的Class对象的方法： 1) 利用对象实例调用getClass()方法获取该对象的Class实例； ​ Class c=对象.getClass(); ​ 2) 使用Class类的静态方法forName(“包名+类名”)，用类的名字获取一个Class实例 ​ Class c=Class.forName(“包名+类名”); ​ 3)运用 类名.class 的方式来获取Class实例； ​ Class c = 类名.class 我们知道java世界是运行在JVM之上的，我们编写的类代码，在经过编译器编译之后，会为每个类生成对应的.class文件，这个就是JVM可以加载执行的字节码。运行时期间，当我们需要实例化任何一个类时，JVM会首先尝试看看在内存中是否有这个类，如果有，那么会直接创建类实例；如果没有，那么就会根据类名去加载这个类，当加载一个类，或者当加载器(class loader)的defineClass()被JVM调用，便会为这个类产生一个Class对象（一个Class类的实例），用来表达这个类，该类的所有实例都共同拥有着这个Class对象，而且是唯一的。 总结 在java里，类只是信息描述的，写明了有哪些内部属性及接口，你可以理解为是定义了一套规则；而Class对象在java里被用来对类的情况进行表述的一个实例，也就是是类的实际表征，可以理解为是对规则的图表化，这样JVM才能直观的看懂，可以看做是一个模版；而类的实例化对象，就是通过模版，开辟出的一块内存进行实际的使用。","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"关于XML文档的xmlns、xmlns:xsi和xsi:schemaLocation","slug":"Java Web/关于XML文档的xmlns、xmlnsxsi和xsischemaLocation","date":"2019-01-22T08:30:23.000Z","updated":"2019-03-13T08:20:08.603Z","comments":true,"path":"2019/01/22/Java Web/关于XML文档的xmlns、xmlnsxsi和xsischemaLocation/","link":"","permalink":"http://yoursite.com/2019/01/22/Java Web/关于XML文档的xmlns、xmlnsxsi和xsischemaLocation/","excerpt":"","text":"摘要： 相信很多人和我一样，在编写Spring或者Maven或者其他需要用到XML文档的程序时，通常都是将这些XML文档头拷贝过来，并没有理解其中元素 （比如xmlns，xmlns:xsi，xsi:schemaLocation）的真正含义，不知道哪些元素是多余的，也不知道为什么要加那些元素。相信很多人和我一样，在编写Spring或者Maven或者其他需要用到XML文档的程序时，通常都是将这些XML文档头拷贝过来，并没有理解其中元素（比 如xmlns，xmlns:xsi，xsi:schemaLocation）的真正含义，不知道哪些元素是多余的，也不知道为什么要加那些元素。这样当有 时候网上Copy的XML头有错的时候自己却不知道怎么下手。我也是这样的，于是今天花了点时间好好的理解了一下这些元素及其用法，现整理与此，在此谢谢 各位前辈的经验，如有总结的不对或者不好的地方，欢迎留言提出各位的宝贵意见。 话不多说，先来一段Spring的XML样本，相信大家都很眼熟： 12345678910111213141516171819202122&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;context:component-scan base-package=\"xxx.xxx.controller\" /&gt; &lt;context:annotation-config/&gt; &lt;mvc:default-servlet-handler/&gt; &lt;mvc:annotation-driven/&gt; &lt;mvc:resources mapping=\"/images/**\" location=\"/images/\" /&gt; &lt;bean id=\"xxx\" class=\"xxx.xxx.xxx.Xxx\"&gt; &lt;property name=\"xxx\" value=\"xxxx\"/&gt; &lt;/bean&gt;&lt;/beans&gt; ​ 这 个文档中，根元素就不用说了，接下来是xmlns。那么什么是xmlns呢？xmlns其实是XML Namespace的缩写，可译为“XML命名空间”，但个人觉得，翻译后的名字反而不好理解，所以我们就叫它为XML Namespace吧。 ​ 为什么需要xmlns？​ 考虑这样两个XML文档：表示HTML表格元素的： 123456&lt;table&gt; &lt;tr&gt; &lt;td&gt;Apples&lt;/td&gt; &lt;td&gt;Bananas&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; ​ 和描述一张桌子的： 12345&lt;table&gt; &lt;name&gt;African Coffee Table&lt;/name&gt; &lt;width&gt;80&lt;/width&gt; &lt;length&gt;120&lt;/length&gt;&lt;/table&gt; ​ 假如这两个 XML 文档被一起使用，由于两个文档都包含带有不同内容和定义的 元素，就会发生命名冲突。XML 解析器是无法确定如何处理这类冲突。为了解决上述问题，xmlns就产生了。 ​ 如何是用xmlns？​ 很简单，使用语法： xmlns:namespace-prefix=”namespaceURI”。其中namespace-prefix为自定义前缀，只要在这个XML文档中保证前缀不重复即可；namespaceURI是这个前缀对应的XML Namespace的定义。例如， 1xmlns:context=&quot;http://www.springframework.org/schema/context&quot; ​ 这一句定义了一个http://www.springframwork.org/schema/context的Namespace（这和Java类中的包的声明很相似），并将其和前缀context绑定。所以上面的Spring XML文档中会有这么一句： 1&lt;context:component-scan base-package=&quot;xxx.xxx.controller&quot;/&gt; ​ 这里的元素就来自别名为context的XML Namespace，也就是在http://www.springframework.org/schema/context中定义的。 ​ 我们还可以将前缀定义为abc： 1xmlns:abc=&quot;namespaceURI&quot; ​ 这样再使用这个namespaceURI中的元素时，需要以abc为前缀，例如：abc:xxx/。再拿上面的例子解释怎么使用xmlns： 123456&lt;!-- 这里xmlns:h=&quot;url1&quot;表示这个table是用h作为标记，table的写法在url1中定义 --&gt;&lt;h:table xmlns:h=&quot;url1&quot;&gt; &lt;h:tr&gt; &lt;h:td&gt;Apples&lt;/h:td&gt; &lt;h:td&gt;Bananas&lt;/h:td&gt; &lt;/h:tr&gt;&lt;/h:table&gt; ​ 和： 12345&lt;!-- 这里xmlns:f=&quot;url2&quot;表示这个table是用f作为标记，table的写法在url2中定义 --&gt;&lt;f:table xmlns:f=&quot;url2&quot;&gt; &lt;f:name&gt;African Coffee Table&lt;/f:name&gt; &lt;f:width&gt;80&lt;/f:width&gt; &lt;f:length&gt;120&lt;/f:length&gt;&lt;/f:table&gt; ​ 后者与前者仅仅使用不同前缀，我们为 标签添加了一个 xmlns 属性，这样就为前缀赋予了一个与某个命名空间相关联的限定名称。此时再把它们放在一起，XML解析器就不会报错了。 ​ 注意：当xmlns被定义在元素的开始标签中（如这里的&lt;f:table/&gt;）时，所有带有相同前缀的子元素都会与同一个Namespace相关联（即&lt;f:table/&gt;里面的&lt;f:name/&gt;和&lt;f:width/&gt;也会使用url2定义的写法）。 ​ xmlns和xmlns:xsi有什么不同？​ xmlns表示默认的Namespace。例如Spring XML文档中的 1xmlns=&quot;http://www.springframework.org/schema/beans&quot; ​ 这一句表示该文档默认的XML Namespace为http://www.springframwork.org/schema/beans。**对于默认的Namespace中的元素，可以不使用前缀**。例如Spring XML文档中的 123&lt;bean id=&quot;xxx&quot; class=&quot;xxx.xxx.xxx.Xxx&quot;&gt; &lt;property name=&quot;xxx&quot; value=&quot;xxxx&quot;/&gt;&lt;/bean&gt; ​ xmlns:xsi表示使用xsi作为前缀的Namespace，当然前缀xsi需要在文档中声明。 xsi:**schemaLocation有何作用？**​ xsi:schemaLocation属性其实是Namespace为http://www.w3.org/2001/XMLSchema-instance里的schemaLocation属性，正是因为我们一开始声明了 1xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; ​ 这里才写作xsi:schemaLocation（当然一般都使用这个前缀）。它定义了XML Namespace和对应的 XSD（Xml Schema Definition）文档的位置的关系。它的值由一个或多个URI引用对组成，两个URI之间以空白符分隔（空格和换行均可）。第一个URI是定义的 XML Namespace的值，第二个URI给出Schema文档的位置，Schema处理器将从这个位置读取Schema文档，该文档的targetNamespace必须与第一个URI相匹配。例如： 12xsi:schemaLocation=&quot;http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot; ​ 这里表示Namespace为http://www.springframework.org/schema/context的Schema的位置为[http://www.springframework.org/schema/context/spring-context.xsd](http://www.springframework.org/schema/context/spring-context.xsd?spm=5176.100239.blogcont40353.18.KFHYwA&amp;file=spring-context.xsd)。这里我们可以打开这个Schema的位置，下面是这个文档的开始部分： 12345678&lt;xsd:schema xmlns=&quot;http://www.springframework.org/schema/context&quot; xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot; xmlns:beans=&quot;http://www.springframework.org/schema/beans&quot; xmlns:tool=&quot;http://www.springframework.org/schema/tool&quot; &lt;!-- 这里的targetNamespace和上方xsi:schemaLocation中的第一个URI匹配 --&gt; targetNamespace=&quot;http://www.springframework.org/schema/context&quot; elementFormDefault=&quot;qualified&quot; attributeFormDefault=&quot;unqualified&quot;&gt; ​ xmlns=”http://www.w3.org/2001/XMLSchema&quot; ​ 表示当前xml文件是一个schema约束文件（这个属性的值是确定的，不能改变，这个就是一个标志） targetNamespace=”http://www.springframework.org/schema/context&quot; ​ 定义schema地址，被约束文件可以通过这个地址引入使用 xmlns:xsi=”http://www.w3.org/2001/XMLSchema-instance&quot; - 表示这是一个被约束的xml文件（标志） - :xsi 这个是别名，为了区分下面的xmlsn属性 xmlns=”http://www.springframework.org/schema/context&quot; - 这个就是引入schema文件，这个值就是schema的地址（包名） xsi:schemaLocation=”http://www.example.org/1 1.xsd” - schema地址 空格 schema路径 ​ 有了上面的说明后，再去理解开始的Spring XML文档，一定会有不一样的感觉！ ​ 最后再次感谢各位前辈的宝贵经验。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"XML","slug":"XML","permalink":"http://yoursite.com/tags/XML/"}]},{"title":"Java多线程之this与Thread.currentThread()的区别","slug":"JAVA/Java多线程this与Thread.currentThread()的区别","date":"2019-01-18T12:11:44.000Z","updated":"2019-01-19T06:18:26.806Z","comments":true,"path":"2019/01/18/JAVA/Java多线程this与Thread.currentThread()的区别/","link":"","permalink":"http://yoursite.com/2019/01/18/JAVA/Java多线程this与Thread.currentThread()的区别/","excerpt":"","text":"this是当前代码所处的对象的线程，Thread.currentThread()是运行当前代码的线程。 12345678910111213141516171819202122232425262728293031public class CountOperate extends Thread&#123; public CountOperate() &#123; System.out.println(\"CountOperate.CountOperate()\"); System.out.println(\"Thread-currentThread.getName()\"+Thread.currentThread().getName()); System.out.println(\"Thread-currentThread.isAlive()\"+Thread.currentThread().isAlive()); System.out.println(\"this.getName()\"+this.getName()); System.out.println(\"this.isAlive()\"+this.isAlive()); System.out.println(\"Thread-currentThread==this\"+(Thread.currentThread()==this)); System.out.println(\"CountOperate.CountOperate()\"); &#125; @Override public void run() &#123; System.out.println(\"CountOperate.run()\"+Thread.currentThread().getName()); System.out.println(\"Thread-currentThread.getName()\"+Thread.currentThread().getName()); System.out.println(\"Thread-currentThread.isAlive()\"+Thread.currentThread().isAlive()); System.out.println(\"this.getName()\"+this.getName()); System.out.println(\"this.isAlive()\"+this.isAlive()); System.out.println(\"Thread-currentThread==this\"+(Thread.currentThread()==this)); System.out.println(\"CountOperate.run()\"); &#125; public static void main(String[] args) &#123; CountOperate c=new CountOperate(); c.start(); Thread t1=new Thread(c); System.out.println(\"main t1.isAlive()\"+t1.isAlive()); t1.setName(\"t1\"); t1.start(); System.out.println(\"main t1.isAlive()\"+t1.isAlive()); &#125;&#125; 打印的log 123456789101112131415161718192021222324252627//-----------------------------------------------CountOperate.CountOperate() //new CountOperate()的构造函数Thread-currentThread.getName()main //jvm创建一个进程，默认有一个线程调用mainThread-currentThread.isAlive()true this.getName()Thread-0 //当前new的CountOperate()对象的线程this.isAlive()falseThread-currentThread==thisfalseCountOperate.CountOperate()//------------------------------------------------main t1.isAlive()false //t1没有调用start()方法main t1.isAlive()true //t1调用过start()方法//------------------------------------------------CountOperate.run()Thread-0 //c.start()调用run()Thread-currentThread.getName()Thread-0Thread-currentThread.isAlive()truethis.getName()Thread-0 //this当前线程this.isAlive()trueThread-currentThread==thistrueCountOperate.run()//------------------------------------------------CountOperate.run()t1 Thread-currentThread.getName()t1 //Thread t1=new Thread(参数),Thread-currentThread.isAlive()true //t1是new的Thread，与传递的参数无关this.getName()Thread-0 //传过来的c对象参数，当执行t1.start(),this.isAlive()false //会调用c的run()方法Thread-currentThread==thisfalseCountOperate.run() 根据打印的Log可以知道调用CountOperate构造函数的是main线程，因此打印出 Thread.currentThread().getName()=mainThread.currentThread().isAlive()=true而此时还没有启动CountOperate子线程所以打印出this.getName=Thread-0this.isAlive()=false 此时this代表的是CountOperate对象实例，所以Thread.currentThread()==this :false 这里比较让人疑惑的是“this.getName() = Thread-0”，这个Thread-0是什么东西？？？通过查看Thread源码发现，在Thread类的构造方法中，会自动给name赋值，赋值代码： 123public Thread() &#123; init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0); &#125; 然后执行到:Thread t1 = new Thread(c);System.out.println(“main begin t1 isAlive=” + t1.isAlive());t1.setName(“t1”);t1.start(); 打印：Thread-currentThread.getName()t1Thread-currentThread.isAlive()trueThread.currentThread()==this :falsethis.getName()=Thread-0this.isAlive()=false说明此时的this和Thread.currentThread()指向不是同一个线程实例 也就是说，this指向的还是new CountOperate()创建的那个线程实例，而不是new Thread(thread)创建的那个实例即t1。查看源代码可以知道 123public Thread(Runnable target) &#123; init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0); &#125; 实际上new Thread(thread)会将thread应用的对象绑定到一个pravite变量target上，在t1被执行的时候即t1.run()被调用的时候，它会调用target.run()方法，也就是说它是直接调用thread对象的run方法，再确切的说，在run方法被执行的时候，this.getName()实际上返回的是target.getName()，而Thread.currentThread().getName()实际上是t1.getName()。","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Java理解  子类成员变量与父类成员变量同名     方法的重写","slug":"JAVA/成员变量的同名和方法的重写","date":"2019-01-17T14:53:34.000Z","updated":"2019-01-18T03:11:55.968Z","comments":true,"path":"2019/01/17/JAVA/成员变量的同名和方法的重写/","link":"","permalink":"http://yoursite.com/2019/01/17/JAVA/成员变量的同名和方法的重写/","excerpt":"","text":"1.子类父类成员变量同名1.子类的成员变量与父类成员变量同名时,在子类中父类成员变量被”隐藏”2.要想访问与父类的同名的成员变量, 两种方法 ①: 在子类中是用 super ②:将该变量强转成父类的类 3.对象是什么类型的(不是new的那个类型), 成员变量是什么类型. 2.子类对父类方法的重写子类的方法与父类的方法重名时(我们讲得是重写的情况, 方法名一致, 形参一致, 与返回值无关)叫做重写(覆盖), 顾名思义, 把父类的方法重写了. 所以怎么转换, 都是子类的方法.","categories":[],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"String.split()分割字符串用法","slug":"JAVA/字符串分割split","date":"2018-12-30T02:49:33.000Z","updated":"2019-01-01T07:38:22.042Z","comments":true,"path":"2018/12/30/JAVA/字符串分割split/","link":"","permalink":"http://yoursite.com/2018/12/30/JAVA/字符串分割split/","excerpt":"","text":"split方法的参数是一个正则表达式，因此遇到正则表达式中的元字符需要进行转义，而java中的特殊字符也需要转义，因此，分隔的字符既是java特殊字符也是元字符就需要二次转义才能正确分割字符串。 1.public string[] split(string regex)这里的参数的名称是 regex ，也就是 regular expression （正则表达式）。这个参数并不是一个简单的分割用的字符，而是一个正则表达式，它对一些特殊的字符可能会出现你预想不到的结果，比如测试下面的代码： （1） 用竖线 | 分隔字符串，你将得不到预期的结果 ​ String[] aa = “aaa|bbb|ccc”.split(“|”); //String[] aa = “aaa|bbb|ccc”.split(“\\\\|”); 这样才能得到正确的结果 for (int i = 0 ; i &lt;aa.length ; i++ ) { System.out.println(“–”+aa); } （2）用竖 * 分隔字符串运行将抛出java.util.regex.PatternSyntaxException异常，用加号 + 也是如此。 ​ String[] aa = “aaabbbccc”.split(“*“); //String[] aa = “aaa|bbb|ccc”.split(“\\\\*”); 这样才能得到正确的结果 for (int i = 0 ; i &lt;aa.length ; i++ ) { System.out.println(“–”+aa);} （3）显然，+ 不是有效的模式匹配规则表达式，用”\\\\“ “\\\\+”转义后即可得到正确的结果。 （4） “|” 分隔串时虽然能够执行，但是却不是预期的目的，”\\\\|”转义后即可得到正确的结果。 （5）还有如果想在串中使用”\\“字符，则也需要转义.首先要表达”aaaa\\bbbb”这个串就应该用”aaaa\\\\bbbb”,如果要分隔就应该这样才能得到正确结果： String[] aa = “aaa\\\\bbb\\\\bccc”.split(“\\\\\\\\“); （6） 还有就是点号”.”，也要首先转义才能得到正确的结果。 2、public String[] split(String regex,int limit)​ 根据匹配给定的正则表达式来拆分此字符串。 此方法返回的数组包含此字符串的每个子字符串，这些子字符串由另一个匹配给定的表达式的子字符串终止或由字符串结束来终止。数组中的子字符串按它们在此字符串中的顺序排列。如果表达式不匹配输入的任何部分，则结果数组只具有一个元素，即此字符串。 3.”|”作为连字符的使用如果在一个字符串中有多个分隔符，可以用”|作为连字符，比如：”acount=? and uu =? or n=?”,把三个都分隔出来，可以用 “acount=? and uu =? or n=?”.split(“and|or”);","categories":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"保存和获取cookie中的中文信息","slug":"Java Web/对cookie中的中文处理","date":"2018-12-29T02:46:17.000Z","updated":"2019-03-13T08:21:01.712Z","comments":true,"path":"2018/12/29/Java Web/对cookie中的中文处理/","link":"","permalink":"http://yoursite.com/2018/12/29/Java Web/对cookie中的中文处理/","excerpt":"","text":"1.保存cookie问题： 出现500错误 解决：设置字符编码 Cookie cookie=new Cookie(“test”,URLEncoder.encode(“中文”,”utf-8”)); 2.获取cookie 问题：出现乱码 解决：设置字符解码 System.out.println(“cookie:”+cookies[i].getName()+”:”+URLDecoder.decode(cookies[i].getValue()))；","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"乱码","slug":"乱码","permalink":"http://yoursite.com/tags/乱码/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"请求转发与重定向的理解","slug":"Java Web/请求转发与重定向","date":"2018-12-28T08:37:58.000Z","updated":"2019-06-17T02:41:24.294Z","comments":true,"path":"2018/12/28/Java Web/请求转发与重定向/","link":"","permalink":"http://yoursite.com/2018/12/28/Java Web/请求转发与重定向/","excerpt":"","text":"1.forward（转发）是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,因为这个跳转过程实在服务器实现的，并不是在客户端实现的所以客户端并不知道这个跳转动作，所以它的地址栏还是原来的地址. 2.redirect（重定向）是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL. 区别： 转发是服务器行为，重定向是客户端行为。 1 )请求转发只能将请求转发给同一个WEB应用中的组件，而重定向还可以重新定向到同一站点不同应用程序中的资源，甚至可以定向到一绝对的URL。 2)重定向可以看见目标页面的URL，转发只能看见第一次访问的页面URL，以后的工作都是有服 务器来做的。 3) 请求响应调用者和被调用者之间共享相同的request对象和response对象，重定向调用者和被调用者属于两个独立访问请求和响应过程。 4)请求重定向：不加/是相对于本servlet所在请求的目录，加“/”表示端口号后面的根目录 http：//localhost:8080/ 请求转发：不加/是相对于本servlet，加/表示web应用的根目录http：//localhost:8080/Test/ ———path”/“路径——— —–只要是需要通过浏览器发送请求的地方（比如html代码，sendRedirect方法等）“/“一般代表虚拟主机根目录，即相当于端口号之后的“/”，例：http：//localhost:8080/ ——服务器程序内部跳转，“/”一般代表本web应用的根目录，如请求转发。例：http：//localhost:8080/Test/","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"servlet的乱码问题","slug":"Java Web/sevlet中的乱码","date":"2018-12-28T02:00:47.000Z","updated":"2019-03-13T08:21:17.519Z","comments":true,"path":"2018/12/28/Java Web/sevlet中的乱码/","link":"","permalink":"http://yoursite.com/2018/12/28/Java Web/sevlet中的乱码/","excerpt":"","text":"1.post请求1）html、jsp等页面编码格式1pageEncoding=&quot;UTF-8&quot; 2）设置请求信息的的解码格式1req.setCharacterEncoding(&quot;utf-8&quot;); 3）设置响应信息的编码格式1resp.setCharacterEncoding(&quot;utf-8&quot;); 4）设置浏览器的解码格式1resp.setContentType(&quot;text/html;charset=utf-8&quot;); 2.get请求​ 同post请求所有要求再加上 1) 1） 配置tomcat的server.xml​ 在 &lt;Connector connectionTimeout=”20000” port=”8080” ​ protocol=”HTTP/1.1” redirectPort=”8443”/&gt; ​ 中加入 useBodyEncodingForURI=”true” ​ 加入后&lt;Connector connectionTimeout=”20000” port=”8080” ​ protocol=”HTTP/1.1” redirectPort=”8443” ​ useBodyEncodingForURI=”true”/&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/categories/JavaWeb/"}],"tags":[{"name":"乱码","slug":"乱码","permalink":"http://yoursite.com/tags/乱码/"},{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://yoursite.com/tags/JavaWeb/"}]},{"title":"change themes","slug":"Config/修改Hexo主题","date":"2018-10-12T10:51:13.000Z","updated":"2019-06-02T09:30:50.931Z","comments":true,"path":"2018/10/12/Config/修改Hexo主题/","link":"","permalink":"http://yoursite.com/2018/10/12/Config/修改Hexo主题/","excerpt":"","text":"1.获取主题cd themes 再将yilia主题clone至themes文件夹中 git clone https://github.com/litten/hexo-theme-yilia.git yilia 2.配置：修改hexo根目录下的_config.yml theme:yilia 3.更新:12cd themes/yiliagit pull 4.发布12hexo cleanhexo d -g","categories":[{"name":"config","slug":"config","permalink":"http://yoursite.com/categories/config/"}],"tags":[{"name":"config","slug":"config","permalink":"http://yoursite.com/tags/config/"}]},{"title":"Hello World","slug":"hello-world","date":"2018-10-11T14:51:01.594Z","updated":"2018-10-11T14:51:01.594Z","comments":true,"path":"2018/10/11/hello-world/","link":"","permalink":"http://yoursite.com/2018/10/11/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}