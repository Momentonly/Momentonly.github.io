<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java多线程之this与Thread.currentThread()的区别]]></title>
    <url>%2F2019%2F01%2F18%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8Bthis%E4%B8%8EThread.currentThread()%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[this是当前代码所处的对象的线程，Thread.currentThread()是运行当前代码的线程。 12345678910111213141516171819202122232425262728293031public class CountOperate extends Thread&#123; public CountOperate() &#123; System.out.println("CountOperate.CountOperate()"); System.out.println("Thread-currentThread.getName()"+Thread.currentThread().getName()); System.out.println("Thread-currentThread.isAlive()"+Thread.currentThread().isAlive()); System.out.println("this.getName()"+this.getName()); System.out.println("this.isAlive()"+this.isAlive()); System.out.println("Thread-currentThread==this"+(Thread.currentThread()==this)); System.out.println("CountOperate.CountOperate()"); &#125; @Override public void run() &#123; System.out.println("CountOperate.run()"+Thread.currentThread().getName()); System.out.println("Thread-currentThread.getName()"+Thread.currentThread().getName()); System.out.println("Thread-currentThread.isAlive()"+Thread.currentThread().isAlive()); System.out.println("this.getName()"+this.getName()); System.out.println("this.isAlive()"+this.isAlive()); System.out.println("Thread-currentThread==this"+(Thread.currentThread()==this)); System.out.println("CountOperate.run()"); &#125; public static void main(String[] args) &#123; CountOperate c=new CountOperate(); c.start(); Thread t1=new Thread(c); System.out.println("main t1.isAlive()"+t1.isAlive()); t1.setName("t1"); t1.start(); System.out.println("main t1.isAlive()"+t1.isAlive()); &#125;&#125; 打印的log 123456789101112131415161718192021222324252627//-----------------------------------------------CountOperate.CountOperate() //new CountOperate()的构造函数Thread-currentThread.getName()main //jvm创建一个进程，默认有一个线程调用mainThread-currentThread.isAlive()true this.getName()Thread-0 //当前new的CountOperate()对象的线程this.isAlive()falseThread-currentThread==thisfalseCountOperate.CountOperate()//------------------------------------------------main t1.isAlive()false //t1没有调用start()方法main t1.isAlive()true //t1调用过start()方法//------------------------------------------------CountOperate.run()Thread-0 //c.start()调用run()Thread-currentThread.getName()Thread-0Thread-currentThread.isAlive()truethis.getName()Thread-0 //this当前线程this.isAlive()trueThread-currentThread==thistrueCountOperate.run()//------------------------------------------------CountOperate.run()t1 Thread-currentThread.getName()t1 //Thread t1=new Thread(参数),Thread-currentThread.isAlive()true //t1是new的Thread，与传递的参数无关this.getName()Thread-0 //传过来的c对象参数，当执行t1.start(),this.isAlive()false //会调用c的run()方法Thread-currentThread==thisfalseCountOperate.run() 根据打印的Log可以知道调用CountOperate构造函数的是main线程，因此打印出 Thread.currentThread().getName()=mainThread.currentThread().isAlive()=true而此时还没有启动CountOperate子线程所以打印出this.getName=Thread-0this.isAlive()=false 此时this代表的是CountOperate对象实例，所以Thread.currentThread()==this :false 这里比较让人疑惑的是“this.getName() = Thread-0”，这个Thread-0是什么东西？？？通过查看Thread源码发现，在Thread类的构造方法中，会自动给name赋值，赋值代码： 123public Thread() &#123; init(null, null, &quot;Thread-&quot; + nextThreadNum(), 0); &#125; 然后执行到:Thread t1 = new Thread(c);System.out.println(“main begin t1 isAlive=” + t1.isAlive());t1.setName(“t1”);t1.start(); 打印：Thread-currentThread.getName()t1Thread-currentThread.isAlive()trueThread.currentThread()==this :falsethis.getName()=Thread-0this.isAlive()=false说明此时的this和Thread.currentThread()指向不是同一个线程实例 也就是说，this指向的还是new CountOperate()创建的那个线程实例，而不是new Thread(thread)创建的那个实例即t1。查看源代码可以知道 123public Thread(Runnable target) &#123; init(null, target, &quot;Thread-&quot; + nextThreadNum(), 0); &#125; 实际上new Thread(thread)会将thread应用的对象绑定到一个pravite变量target上，在t1被执行的时候即t1.run()被调用的时候，它会调用target.run()方法，也就是说它是直接调用thread对象的run方法，再确切的说，在run方法被执行的时候，this.getName()实际上返回的是target.getName()，而Thread.currentThread().getName()实际上是t1.getName()。]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java理解 子类成员变量与父类成员变量同名 方法的重写]]></title>
    <url>%2F2019%2F01%2F17%2F%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E7%9A%84%E5%90%8C%E5%90%8D%E5%92%8C%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99%2F</url>
    <content type="text"><![CDATA[1.子类父类成员变量同名1.子类的成员变量与父类成员变量同名时,在子类中父类成员变量被”隐藏”2.要想访问与父类的同名的成员变量, 两种方法 ①: 在子类中是用 super ②:将该变量强转成父类的类 3.对象是什么类型的(不是new的那个类型), 成员变量是什么类型. 2.子类对父类方法的重写子类的方法与父类的方法重名时(我们讲得是重写的情况, 方法名一致, 形参一致, 与返回值无关)叫做重写(覆盖), 顾名思义, 把父类的方法重写了. 所以怎么转换, 都是子类的方法.]]></content>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[String.split()分割字符串用法]]></title>
    <url>%2F2018%2F12%2F30%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%88%86%E5%89%B2split%2F</url>
    <content type="text"><![CDATA[split方法的参数是一个正则表达式，因此遇到正则表达式中的元字符需要进行转义，而java中的特殊字符也需要转义，因此，分隔的字符既是java特殊字符也是元字符就需要二次转义才能正确分割字符串。 1.public string[] split(string regex)这里的参数的名称是 regex ，也就是 regular expression （正则表达式）。这个参数并不是一个简单的分割用的字符，而是一个正则表达式，它对一些特殊的字符可能会出现你预想不到的结果，比如测试下面的代码： （1） 用竖线 | 分隔字符串，你将得不到预期的结果 ​ String[] aa = “aaa|bbb|ccc”.split(“|”); //String[] aa = “aaa|bbb|ccc”.split(“\\|”); 这样才能得到正确的结果 for (int i = 0 ; i &lt;aa.length ; i++ ) { System.out.println(“–”+aa); } （2）用竖 * 分隔字符串运行将抛出java.util.regex.PatternSyntaxException异常，用加号 + 也是如此。 ​ String[] aa = “aaabbbccc”.split(“*“); //String[] aa = “aaa|bbb|ccc”.split(“\\*”); 这样才能得到正确的结果 for (int i = 0 ; i &lt;aa.length ; i++ ) { System.out.println(“–”+aa);} （3）显然，+ 不是有效的模式匹配规则表达式，用”\\“ “\\+”转义后即可得到正确的结果。 （4） “|” 分隔串时虽然能够执行，但是却不是预期的目的，”\\|”转义后即可得到正确的结果。 （5）还有如果想在串中使用”\“字符，则也需要转义.首先要表达”aaaa\bbbb”这个串就应该用”aaaa\\bbbb”,如果要分隔就应该这样才能得到正确结果： String[] aa = “aaa\\bbb\\bccc”.split(“\\\\“); （6） 还有就是点号”.”，也要首先转义才能得到正确的结果。 2、public String[] split(String regex,int limit)​ 根据匹配给定的正则表达式来拆分此字符串。 此方法返回的数组包含此字符串的每个子字符串，这些子字符串由另一个匹配给定的表达式的子字符串终止或由字符串结束来终止。数组中的子字符串按它们在此字符串中的顺序排列。如果表达式不匹配输入的任何部分，则结果数组只具有一个元素，即此字符串。 3.”|”作为连字符的使用如果在一个字符串中有多个分隔符，可以用”|作为连字符，比如：”acount=? and uu =? or n=?”,把三个都分隔出来，可以用 “acount=? and uu =? or n=?”.split(“and|or”);]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[保存和获取cookie中的中文信息]]></title>
    <url>%2F2018%2F12%2F29%2F%E5%AF%B9cookie%E4%B8%AD%E7%9A%84%E4%B8%AD%E6%96%87%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[1.保存cookie问题： 出现500错误 解决：设置字符编码 Cookie cookie=new Cookie(“test”,URLEncoder.encode(“中文”,”utf-8”)); 2.获取cookie 问题：出现乱码 解决：设置字符解码 System.out.println(“cookie:”+cookies[i].getName()+”:”+URLDecoder.decode(cookies[i].getValue()))；]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>乱码</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[请求转发与重定向的理解]]></title>
    <url>%2F2018%2F12%2F28%2F%E8%AF%B7%E6%B1%82%E8%BD%AC%E5%8F%91%E4%B8%8E%E9%87%8D%E5%AE%9A%E5%90%91%2F</url>
    <content type="text"><![CDATA[1.forward（转发）是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,因为这个跳转过程实在服务器实现的，并不是在客户端实现的所以客户端并不知道这个跳转动作，所以它的地址栏还是原来的地址. 2.redirect（重定向）是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL. 区别：转发是服务器行为，重定向是客户端行为。 1 )请求转发只能将请求转发给同一个WEB应用中的组件，而重定向还可以重新定向到同一站点不同应用程序中的资源，甚至可以定向到一绝对的URL。 2)重定向可以看见目标页面的URL，转发只能看见第一次访问的页面URL，以后的工作都是有服 务器来做的。 3) 请求响应调用者和被调用者之间共享相同的request对象和response对象，重定向调用者和被调用者属于两个独立访问请求和响应过程。 4)请求重定向：不加/是相对于本servlet所在请求的目录，加“/”表示端口号后面的根目录 http：//localhost:8080/ 请求转发：不加/是相对于本servlet，加/表示web应用的根目录http：//localhost:8080/Test/ ———path”/“路径——— —–只要是需要通过浏览器发送请求的地方（比如html代码，sendRedirect方法等）“/“一般代表虚拟主机根目录，即相当于端口号之后的“/”，例：http：//localhost:8080/ ——服务器程序内部跳转，“/”一般代表本web应用的根目录，如请求转发。例：http：//localhost:8080/Test/]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[servlet的乱码问题]]></title>
    <url>%2F2018%2F12%2F28%2Fsevlet%E4%B8%AD%E7%9A%84%E4%B9%B1%E7%A0%81%2F</url>
    <content type="text"><![CDATA[1.post请求1）html、jsp等页面编码格式1pageEncoding=&quot;UTF-8&quot; 2）设置请求信息的的解码格式1req.setCharacterEncoding(&quot;utf-8&quot;); 3）设置响应信息的编码格式1resp.setCharacterEncoding(&quot;utf-8&quot;); 4）设置浏览器的解码格式1resp.setContentType(&quot;text/html;charset=utf-8&quot;); 2.get请求​ 同post请求所有要求再加上 1) 1） 配置tomcat的server.xml​ 在 &lt;Connector connectionTimeout=”20000” port=”8080” ​ protocol=”HTTP/1.1” redirectPort=”8443”/&gt; ​ 中加入 useBodyEncodingForURI=”true” ​ 加入后&lt;Connector connectionTimeout=”20000” port=”8080” ​ protocol=”HTTP/1.1” redirectPort=”8443” ​ useBodyEncodingForURI=”true”/&gt;]]></content>
      <categories>
        <category>Web开发</category>
      </categories>
      <tags>
        <tag>乱码</tag>
        <tag>Web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[change themes]]></title>
    <url>%2F2018%2F10%2F12%2F%E4%BF%AE%E6%94%B9%E4%B8%BB%E9%A2%98%2F</url>
    <content type="text"><![CDATA[1.获取主题cd themes 再将yilia主题clone至themes文件夹中 git clone https://github.com/litten/hexo-theme-yilia.git yilia 2.配置：修改hexo根目录下的_config.yml theme:yilia 3.更新:12cd themes/yiliagit pull 4.发布12hexo cleanhexo d -g]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>配置</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2018%2F10%2F11%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
